--liquibase formatted sql
--changeset ivg:database-tables-baseline

create schema AST;
GO
create schema COM;
GO
create schema CRM;
GO
create schema DCS;
GO
create schema FIN;
GO
create schema GEN;
GO
create schema IFC;
GO
create schema INKASSO;
GO
create schema LOG;
GO
create schema MIG;
GO
create schema MIS;
GO
create schema ORG;
GO
create schema PRT;
GO
create schema TMP;
GO

create sequence CRM.ContractNr_53_1
    minvalue 1
    maxvalue 1000000
go

create sequence CRM.ContractNr_53_2
    minvalue 1
    maxvalue 1000000
go

create sequence CRM.ContractNr_53_3
    minvalue 1
    maxvalue 1000000
go

create sequence CRM.ContractNr_54_1
    minvalue 1
    maxvalue 1000000
go

create sequence CRM.ContractNr_54_2
    minvalue 1
    maxvalue 1000000
go

create sequence CRM.ContractNr_54_3
    minvalue 1
    maxvalue 1000000
go

create sequence GEN.ContractTest
    minvalue 1
    maxvalue 1000000
go

create sequence IFC.CounterDebtNr
    start with 3000000000
go

create sequence GEN.EnvelopeID
    minvalue 1
    maxvalue 9999999999
go

create type GEN.NumericType as table
(
    ID int
)
go


--

-- =============================================
-- Author:		GURBAN
-- Create date:		2022.08.03
-- Description:
--  Returns the translation of the given @pCode
--    according to the language code @pLang.
--    Returns '--' if no data found.
-- =============================================

CREATE FUNCTION [GEN].[TranslateCode]
(
   @pCode NVARCHAR(200),
   @pLang NVARCHAR(5) = 'HU'

)
RETURNS NVARCHAR(200)

AS
BEGIN
	DECLARE @lCodeText NVARCHAR(200) = @pCode;

	IF COALESCE(@pCode, '') <> '' AND COALESCE(@pLang, '') <> ''
	BEGIN
		SELECT @lCodeText = GEN.Translation.Text
		FROM GEN.Translation
		WHERE GEN.Translation.CodeID = @pCode
		AND GEN.Translation.Language = @pLang;
	END;

	RETURN(@lCodeText) ;
END
go


-- =============================================
-- Author:		Gábor Tóth
-- Create date: 2022-11-11
-- Last modified date:
-- Description:	Get Debtor Name by EntityID
-- =============================================
CREATE   FUNCTION [PRT].[GetEntityName](@EntityID NUMERIC(16))
RETURNS Nvarchar(500)
AS
BEGIN
	Declare @l_name nvarchar(500);
	Set @l_name = '';

	If Isnull(@EntityID,0) <> 0
	BEGIN
		Set @l_name = (
			Select
			Isnull(
				Trim(Company.Name),
				Trim(Trim(Isnull(gen.translatecode(Person.Title,'HU'),'')) +  ' ' + Trim(Trim(Isnull(Person.LastName,'')) + ' ' + Trim(Trim(Isnull(Person.MiddleName,'')) + ' ' + Trim(Isnull(Person.FirstName,'')))))
			)
		From PRT.Entity
			left join PRT.Person on Person.EntityID = Entity.ID
			left join PRT.Company on Company.EntityID = Entity.ID
		Where Entity.ID = @EntityID)
	END;
	RETURN @l_name;
END;
go


-- =============================================
-- Author:		Aranyi Balázs
-- Create date: 2023.04.12.
-- Last modified date: 2023.04.12.
-- Description:	Return name of object.
-- =============================================
CREATE FUNCTION [GEN].[GetObjectName]
(
	-- Add the parameters for the function here
	@p_objectID NUMERIC(16)
)
RETURNS NVARCHAR(500)
AS
BEGIN
	-- Declare the return variable here
	DECLARE @l_result NVARCHAR(500) = NULL;
	DECLARE @l_objectTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_objectReferenceID NVARCHAR(200) = NULL;

	IF COALESCE(@p_objectID, 0) > 0
	BEGIN
		SELECT @l_objectTypeCode = [Object].[ObjectType]
		FROM [GEN].[Object]
		WHERE [Object].[ID] = @p_objectID;

		IF COALESCE(@l_objectTypeCode, '') <> ''
		BEGIN
			IF @l_objectTypeCode = 'OBJECT_TYPE_PRT_ENTITY'
			BEGIN
				SELECT @l_objectReferenceID = CAST([Entity].[ID] AS NVARCHAR(200))
				FROM [PRT].[Entity]
				WHERE [Entity].[ObjectID] = @p_objectID;

				IF COALESCE(@l_objectReferenceID, '') <> ''
					SELECT @l_result = [PRT].[GetEntityName](CAST(@l_objectReferenceID AS NUMERIC(16)));
			END
			ELSE IF @l_objectTypeCode = 'OBJECT_TYPE_DCS_DEBTCASE'
			BEGIN
				SELECT @l_objectReferenceID = CAST([DebtCase].[ID] AS NVARCHAR(200))
				FROM [DCS].[DebtCase]
				WHERE [DebtCase].[ObjectID] = @p_objectID;

				IF COALESCE(@l_objectReferenceID, '') <> ''
					SELECT @l_result = [DCS].[GetDebtCaseName](CAST(@l_objectReferenceID AS NUMERIC(16)));
			END



			ELSE IF @l_objectTypeCode = 'OBJECT_TYPE_DCS_DEBTOR'
			BEGIN
				SELECT @l_objectReferenceID = CAST([Debtor].[ID] AS NVARCHAR(200))
				FROM [DCS].[Debtor]
				WHERE [Debtor].[ObjectID] = @p_objectID;

				IF COALESCE(@l_objectReferenceID, '') <> ''
					SELECT @l_result = [DCS].[GetDebtorName](CAST(@l_objectReferenceID AS NUMERIC(16)));
			END





			ELSE
				SELECT @l_result = CAST(@p_objectID AS NVARCHAR(500));
		END;
	END;

	-- Return the result of the function
	RETURN @l_result;

END
go

--

create table dbo.ACT_GE_PROPERTY
(
    NAME_  nvarchar(64) not null
        primary key,
    VALUE_ nvarchar(300),
    REV_   int
)
go

create table dbo.ACT_GE_SCHEMA_LOG
(
    ID_        nvarchar(64) not null
        primary key,
    TIMESTAMP_ datetime2,
    VERSION_   nvarchar(255)
)
go

create table dbo.ACT_HI_ACTINST
(
    ID_                 nvarchar(64)  not null
        primary key,
    PARENT_ACT_INST_ID_ nvarchar(64),
    PROC_DEF_KEY_       nvarchar(255),
    PROC_DEF_ID_        nvarchar(64)  not null,
    ROOT_PROC_INST_ID_  nvarchar(64),
    PROC_INST_ID_       nvarchar(64)  not null,
    EXECUTION_ID_       nvarchar(64)  not null,
    ACT_ID_             nvarchar(255) not null,
    TASK_ID_            nvarchar(64),
    CALL_PROC_INST_ID_  nvarchar(64),
    CALL_CASE_INST_ID_  nvarchar(64),
    ACT_NAME_           nvarchar(255),
    ACT_TYPE_           nvarchar(255) not null,
    ASSIGNEE_           nvarchar(255),
    START_TIME_         datetime2     not null,
    END_TIME_           datetime2,
    DURATION_           numeric(19),
    ACT_INST_STATE_     tinyint,
    SEQUENCE_COUNTER_   numeric(19),
    TENANT_ID_          nvarchar(64),
    REMOVAL_TIME_       datetime2
)
go

create index ACT_IDX_HI_ACTINST_ROOT_PI
    on dbo.ACT_HI_ACTINST (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_ACT_INST_START_END
    on dbo.ACT_HI_ACTINST (START_TIME_, END_TIME_)
go

create index ACT_IDX_HI_ACT_INST_END
    on dbo.ACT_HI_ACTINST (END_TIME_)
go

create index ACT_IDX_HI_ACT_INST_PROCINST
    on dbo.ACT_HI_ACTINST (PROC_INST_ID_, ACT_ID_)
go

create index ACT_IDX_HI_ACT_INST_COMP
    on dbo.ACT_HI_ACTINST (EXECUTION_ID_, ACT_ID_, END_TIME_, ID_)
go

create index ACT_IDX_HI_ACT_INST_STATS
    on dbo.ACT_HI_ACTINST (PROC_DEF_ID_, PROC_INST_ID_, ACT_ID_, END_TIME_, ACT_INST_STATE_)
go

create index ACT_IDX_HI_ACT_INST_TENANT_ID
    on dbo.ACT_HI_ACTINST (TENANT_ID_)
go

create index ACT_IDX_HI_ACT_INST_PROC_DEF_KEY
    on dbo.ACT_HI_ACTINST (PROC_DEF_KEY_)
go

create index ACT_IDX_HI_AI_PDEFID_END_TIME
    on dbo.ACT_HI_ACTINST (PROC_DEF_ID_, END_TIME_)
go

create index ACT_IDX_HI_ACT_INST_RM_TIME
    on dbo.ACT_HI_ACTINST (REMOVAL_TIME_)
go

create table dbo.ACT_HI_ATTACHMENT
(
    ID_                nvarchar(64) not null
        primary key,
    REV_               int,
    USER_ID_           nvarchar(255),
    NAME_              nvarchar(255),
    DESCRIPTION_       nvarchar(4000),
    TYPE_              nvarchar(255),
    TASK_ID_           nvarchar(64),
    ROOT_PROC_INST_ID_ nvarchar(64),
    PROC_INST_ID_      nvarchar(64),
    URL_               nvarchar(4000),
    CONTENT_ID_        nvarchar(64),
    TENANT_ID_         nvarchar(64),
    CREATE_TIME_       datetime2,
    REMOVAL_TIME_      datetime2
)
go

create index ACT_IDX_HI_ATTACHMENT_CONTENT
    on dbo.ACT_HI_ATTACHMENT (CONTENT_ID_)
go

create index ACT_IDX_HI_ATTACHMENT_ROOT_PI
    on dbo.ACT_HI_ATTACHMENT (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_ATTACHMENT_PROCINST
    on dbo.ACT_HI_ATTACHMENT (PROC_INST_ID_)
go

create index ACT_IDX_HI_ATTACHMENT_TASK
    on dbo.ACT_HI_ATTACHMENT (TASK_ID_)
go

create index ACT_IDX_HI_ATTACHMENT_RM_TIME
    on dbo.ACT_HI_ATTACHMENT (REMOVAL_TIME_)
go

create table dbo.ACT_HI_BATCH
(
    ID_                  nvarchar(64) not null
        primary key,
    TYPE_                nvarchar(255),
    TOTAL_JOBS_          int,
    JOBS_PER_SEED_       int,
    INVOCATIONS_PER_JOB_ int,
    SEED_JOB_DEF_ID_     nvarchar(64),
    MONITOR_JOB_DEF_ID_  nvarchar(64),
    BATCH_JOB_DEF_ID_    nvarchar(64),
    TENANT_ID_           nvarchar(64),
    CREATE_USER_ID_      nvarchar(255),
    START_TIME_          datetime2    not null,
    END_TIME_            datetime2,
    REMOVAL_TIME_        datetime2
)
go

create index ACT_HI_BAT_RM_TIME
    on dbo.ACT_HI_BATCH (REMOVAL_TIME_)
go

create table dbo.ACT_HI_CASEACTINST
(
    ID_                 nvarchar(64)  not null
        primary key,
    PARENT_ACT_INST_ID_ nvarchar(64),
    CASE_DEF_ID_        nvarchar(64)  not null,
    CASE_INST_ID_       nvarchar(64)  not null,
    CASE_ACT_ID_        nvarchar(255) not null,
    TASK_ID_            nvarchar(64),
    CALL_PROC_INST_ID_  nvarchar(64),
    CALL_CASE_INST_ID_  nvarchar(64),
    CASE_ACT_NAME_      nvarchar(255),
    CASE_ACT_TYPE_      nvarchar(255),
    CREATE_TIME_        datetime2     not null,
    END_TIME_           datetime2,
    DURATION_           numeric(19),
    STATE_              tinyint,
    REQUIRED_           tinyint,
    TENANT_ID_          nvarchar(64)
)
go

create index ACT_IDX_HI_CAS_A_I_CREATE
    on dbo.ACT_HI_CASEACTINST (CREATE_TIME_)
go

create index ACT_IDX_HI_CAS_A_I_END
    on dbo.ACT_HI_CASEACTINST (END_TIME_)
go

create index ACT_IDX_HI_CAS_A_I_COMP
    on dbo.ACT_HI_CASEACTINST (CASE_ACT_ID_, END_TIME_, ID_)
go

create index ACT_IDX_HI_CAS_A_I_TENANT_ID
    on dbo.ACT_HI_CASEACTINST (TENANT_ID_)
go

create table dbo.ACT_HI_CASEINST
(
    ID_                        nvarchar(64) not null
        primary key,
    CASE_INST_ID_              nvarchar(64) not null
        unique,
    BUSINESS_KEY_              nvarchar(255),
    CASE_DEF_ID_               nvarchar(64) not null,
    CREATE_TIME_               datetime2    not null,
    CLOSE_TIME_                datetime2,
    DURATION_                  numeric(19),
    STATE_                     tinyint,
    CREATE_USER_ID_            nvarchar(255),
    SUPER_CASE_INSTANCE_ID_    nvarchar(64),
    SUPER_PROCESS_INSTANCE_ID_ nvarchar(64),
    TENANT_ID_                 nvarchar(64)
)
go

create index ACT_IDX_HI_CAS_I_CLOSE
    on dbo.ACT_HI_CASEINST (CLOSE_TIME_)
go

create index ACT_IDX_HI_CAS_I_BUSKEY
    on dbo.ACT_HI_CASEINST (BUSINESS_KEY_)
go

create index ACT_IDX_HI_CAS_I_TENANT_ID
    on dbo.ACT_HI_CASEINST (TENANT_ID_)
go

create table dbo.ACT_HI_COMMENT
(
    ID_                nvarchar(64) not null
        primary key,
    TYPE_              nvarchar(255),
    TIME_              datetime2    not null,
    USER_ID_           nvarchar(255),
    TASK_ID_           nvarchar(64),
    ROOT_PROC_INST_ID_ nvarchar(64),
    PROC_INST_ID_      nvarchar(64),
    ACTION_            nvarchar(255),
    MESSAGE_           nvarchar(4000),
    FULL_MSG_          image,
    TENANT_ID_         nvarchar(64),
    REMOVAL_TIME_      datetime2
)
go

create index ACT_IDX_HI_COMMENT_TASK
    on dbo.ACT_HI_COMMENT (TASK_ID_)
go

create index ACT_IDX_HI_COMMENT_ROOT_PI
    on dbo.ACT_HI_COMMENT (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_COMMENT_PROCINST
    on dbo.ACT_HI_COMMENT (PROC_INST_ID_)
go

create index ACT_IDX_HI_COMMENT_RM_TIME
    on dbo.ACT_HI_COMMENT (REMOVAL_TIME_)
go

create table dbo.ACT_HI_DECINST
(
    ID_                nvarchar(64)  not null
        primary key,
    DEC_DEF_ID_        nvarchar(64)  not null,
    DEC_DEF_KEY_       nvarchar(255) not null,
    DEC_DEF_NAME_      nvarchar(255),
    PROC_DEF_KEY_      nvarchar(255),
    PROC_DEF_ID_       nvarchar(64),
    PROC_INST_ID_      nvarchar(64),
    CASE_DEF_KEY_      nvarchar(255),
    CASE_DEF_ID_       nvarchar(64),
    CASE_INST_ID_      nvarchar(64),
    ACT_INST_ID_       nvarchar(64),
    ACT_ID_            nvarchar(255),
    EVAL_TIME_         datetime2     not null,
    REMOVAL_TIME_      datetime2,
    COLLECT_VALUE_     float,
    USER_ID_           nvarchar(255),
    ROOT_DEC_INST_ID_  nvarchar(64),
    ROOT_PROC_INST_ID_ nvarchar(64),
    DEC_REQ_ID_        nvarchar(64),
    DEC_REQ_KEY_       nvarchar(255),
    TENANT_ID_         nvarchar(64)
)
go

create index ACT_IDX_HI_DEC_INST_ID
    on dbo.ACT_HI_DECINST (DEC_DEF_ID_)
go

create index ACT_IDX_HI_DEC_INST_KEY
    on dbo.ACT_HI_DECINST (DEC_DEF_KEY_)
go

create index ACT_IDX_HI_DEC_INST_PI
    on dbo.ACT_HI_DECINST (PROC_INST_ID_)
go

create index ACT_IDX_HI_DEC_INST_CI
    on dbo.ACT_HI_DECINST (CASE_INST_ID_)
go

create index ACT_IDX_HI_DEC_INST_ACT
    on dbo.ACT_HI_DECINST (ACT_ID_)
go

create index ACT_IDX_HI_DEC_INST_ACT_INST
    on dbo.ACT_HI_DECINST (ACT_INST_ID_)
go

create index ACT_IDX_HI_DEC_INST_TIME
    on dbo.ACT_HI_DECINST (EVAL_TIME_)
go

create index ACT_IDX_HI_DEC_INST_TENANT_ID
    on dbo.ACT_HI_DECINST (TENANT_ID_)
go

create index ACT_IDX_HI_DEC_INST_ROOT_ID
    on dbo.ACT_HI_DECINST (ROOT_DEC_INST_ID_)
go

create index ACT_IDX_HI_DEC_INST_REQ_ID
    on dbo.ACT_HI_DECINST (DEC_REQ_ID_)
go

create index ACT_IDX_HI_DEC_INST_REQ_KEY
    on dbo.ACT_HI_DECINST (DEC_REQ_KEY_)
go

create index ACT_IDX_HI_DEC_INST_ROOT_PI
    on dbo.ACT_HI_DECINST (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_DEC_INST_RM_TIME
    on dbo.ACT_HI_DECINST (REMOVAL_TIME_)
go

create table dbo.ACT_HI_DEC_IN
(
    ID_                nvarchar(64) not null
        primary key,
    DEC_INST_ID_       nvarchar(64) not null,
    CLAUSE_ID_         nvarchar(64),
    CLAUSE_NAME_       nvarchar(255),
    VAR_TYPE_          nvarchar(100),
    BYTEARRAY_ID_      nvarchar(64),
    DOUBLE_            float,
    LONG_              numeric(19),
    TEXT_              nvarchar(4000),
    TEXT2_             nvarchar(4000),
    TENANT_ID_         nvarchar(64),
    CREATE_TIME_       datetime2,
    ROOT_PROC_INST_ID_ nvarchar(64),
    REMOVAL_TIME_      datetime2
)
go

create index ACT_IDX_HI_DEC_IN_INST
    on dbo.ACT_HI_DEC_IN (DEC_INST_ID_)
go

create index ACT_IDX_HI_DEC_IN_CLAUSE
    on dbo.ACT_HI_DEC_IN (DEC_INST_ID_, CLAUSE_ID_)
go

create index ACT_IDX_HI_DEC_IN_ROOT_PI
    on dbo.ACT_HI_DEC_IN (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_DEC_IN_RM_TIME
    on dbo.ACT_HI_DEC_IN (REMOVAL_TIME_)
go

create table dbo.ACT_HI_DEC_OUT
(
    ID_                nvarchar(64) not null
        primary key,
    DEC_INST_ID_       nvarchar(64) not null,
    CLAUSE_ID_         nvarchar(64),
    CLAUSE_NAME_       nvarchar(255),
    RULE_ID_           nvarchar(64),
    RULE_ORDER_        int,
    VAR_NAME_          nvarchar(255),
    VAR_TYPE_          nvarchar(100),
    BYTEARRAY_ID_      nvarchar(64),
    DOUBLE_            float,
    LONG_              numeric(19),
    TEXT_              nvarchar(4000),
    TEXT2_             nvarchar(4000),
    TENANT_ID_         nvarchar(64),
    CREATE_TIME_       datetime2,
    ROOT_PROC_INST_ID_ nvarchar(64),
    REMOVAL_TIME_      datetime2
)
go

create index ACT_IDX_HI_DEC_OUT_INST
    on dbo.ACT_HI_DEC_OUT (DEC_INST_ID_)
go

create index ACT_IDX_HI_DEC_OUT_RULE
    on dbo.ACT_HI_DEC_OUT (RULE_ORDER_, CLAUSE_ID_)
go

create index ACT_IDX_HI_DEC_OUT_ROOT_PI
    on dbo.ACT_HI_DEC_OUT (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_DEC_OUT_RM_TIME
    on dbo.ACT_HI_DEC_OUT (REMOVAL_TIME_)
go

create table dbo.ACT_HI_DETAIL
(
    ID_                nvarchar(64)  not null
        primary key,
    TYPE_              nvarchar(255) not null,
    PROC_DEF_KEY_      nvarchar(255),
    PROC_DEF_ID_       nvarchar(64),
    ROOT_PROC_INST_ID_ nvarchar(64),
    PROC_INST_ID_      nvarchar(64),
    EXECUTION_ID_      nvarchar(64),
    CASE_DEF_KEY_      nvarchar(255),
    CASE_DEF_ID_       nvarchar(64),
    CASE_INST_ID_      nvarchar(64),
    CASE_EXECUTION_ID_ nvarchar(64),
    TASK_ID_           nvarchar(64),
    ACT_INST_ID_       nvarchar(64),
    VAR_INST_ID_       nvarchar(64),
    NAME_              nvarchar(255) not null,
    VAR_TYPE_          nvarchar(255),
    REV_               int,
    TIME_              datetime2     not null,
    BYTEARRAY_ID_      nvarchar(64),
    DOUBLE_            float,
    LONG_              numeric(19),
    TEXT_              nvarchar(4000),
    TEXT2_             nvarchar(4000),
    SEQUENCE_COUNTER_  numeric(19),
    TENANT_ID_         nvarchar(64),
    OPERATION_ID_      nvarchar(64),
    REMOVAL_TIME_      datetime2,
    INITIAL_           bit
)
go

create index ACT_IDX_HI_DETAIL_ROOT_PI
    on dbo.ACT_HI_DETAIL (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_DETAIL_PROC_INST
    on dbo.ACT_HI_DETAIL (PROC_INST_ID_)
go

create index ACT_IDX_HI_DETAIL_ACT_INST
    on dbo.ACT_HI_DETAIL (ACT_INST_ID_)
go

create index ACT_IDX_HI_DETAIL_CASE_INST
    on dbo.ACT_HI_DETAIL (CASE_INST_ID_)
go

create index ACT_IDX_HI_DETAIL_CASE_EXEC
    on dbo.ACT_HI_DETAIL (CASE_EXECUTION_ID_)
go

create index ACT_IDX_HI_DETAIL_TIME
    on dbo.ACT_HI_DETAIL (TIME_)
go

create index ACT_IDX_HI_DETAIL_NAME
    on dbo.ACT_HI_DETAIL (NAME_)
go

create index ACT_IDX_HI_DETAIL_TASK_ID
    on dbo.ACT_HI_DETAIL (TASK_ID_)
go

create index ACT_IDX_HI_DETAIL_TENANT_ID
    on dbo.ACT_HI_DETAIL (TENANT_ID_)
go

create index ACT_IDX_HI_DETAIL_PROC_DEF_KEY
    on dbo.ACT_HI_DETAIL (PROC_DEF_KEY_)
go

create index ACT_IDX_HI_DETAIL_BYTEAR
    on dbo.ACT_HI_DETAIL (BYTEARRAY_ID_)
go

create index ACT_IDX_HI_DETAIL_RM_TIME
    on dbo.ACT_HI_DETAIL (REMOVAL_TIME_)
go

create index ACT_IDX_HI_DETAIL_TASK_BYTEAR
    on dbo.ACT_HI_DETAIL (BYTEARRAY_ID_, TASK_ID_)
go

create index ACT_IDX_HI_DETAIL_VAR_INST_ID
    on dbo.ACT_HI_DETAIL (VAR_INST_ID_)
go

create table dbo.ACT_HI_EXT_TASK_LOG
(
    ID_                nvarchar(64)          not null
        primary key,
    TIMESTAMP_         datetime2             not null,
    EXT_TASK_ID_       nvarchar(64)          not null,
    RETRIES_           int,
    TOPIC_NAME_        nvarchar(255),
    WORKER_ID_         nvarchar(255),
    PRIORITY_          numeric(19) default 0 not null,
    ERROR_MSG_         nvarchar(4000),
    ERROR_DETAILS_ID_  nvarchar(64),
    ACT_ID_            nvarchar(255),
    ACT_INST_ID_       nvarchar(64),
    EXECUTION_ID_      nvarchar(64),
    ROOT_PROC_INST_ID_ nvarchar(64),
    PROC_INST_ID_      nvarchar(64),
    PROC_DEF_ID_       nvarchar(64),
    PROC_DEF_KEY_      nvarchar(255),
    TENANT_ID_         nvarchar(64),
    STATE_             int,
    REMOVAL_TIME_      datetime2
)
go

create index ACT_HI_EXT_TASK_LOG_ROOT_PI
    on dbo.ACT_HI_EXT_TASK_LOG (ROOT_PROC_INST_ID_)
go

create index ACT_HI_EXT_TASK_LOG_PROCINST
    on dbo.ACT_HI_EXT_TASK_LOG (PROC_INST_ID_)
go

create index ACT_HI_EXT_TASK_LOG_PROCDEF
    on dbo.ACT_HI_EXT_TASK_LOG (PROC_DEF_ID_)
go

create index ACT_HI_EXT_TASK_LOG_PROC_DEF_KEY
    on dbo.ACT_HI_EXT_TASK_LOG (PROC_DEF_KEY_)
go

create index ACT_HI_EXT_TASK_LOG_TENANT_ID
    on dbo.ACT_HI_EXT_TASK_LOG (TENANT_ID_)
go

create index ACT_IDX_HI_EXTTASKLOG_ERRORDET
    on dbo.ACT_HI_EXT_TASK_LOG (ERROR_DETAILS_ID_)
go

create index ACT_HI_EXT_TASK_LOG_RM_TIME
    on dbo.ACT_HI_EXT_TASK_LOG (REMOVAL_TIME_)
go

create table dbo.ACT_HI_IDENTITYLINK
(
    ID_                nvarchar(64) not null
        primary key,
    TIMESTAMP_         datetime2    not null,
    TYPE_              nvarchar(255),
    USER_ID_           nvarchar(255),
    GROUP_ID_          nvarchar(255),
    TASK_ID_           nvarchar(64),
    ROOT_PROC_INST_ID_ nvarchar(64),
    PROC_DEF_ID_       nvarchar(64),
    OPERATION_TYPE_    nvarchar(64),
    ASSIGNER_ID_       nvarchar(64),
    PROC_DEF_KEY_      nvarchar(255),
    TENANT_ID_         nvarchar(64),
    REMOVAL_TIME_      datetime2
)
go

create index ACT_IDX_HI_IDENT_LNK_ROOT_PI
    on dbo.ACT_HI_IDENTITYLINK (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_IDENT_LNK_USER
    on dbo.ACT_HI_IDENTITYLINK (USER_ID_)
go

create index ACT_IDX_HI_IDENT_LNK_GROUP
    on dbo.ACT_HI_IDENTITYLINK (GROUP_ID_)
go

create index ACT_IDX_HI_IDENT_LNK_TENANT_ID
    on dbo.ACT_HI_IDENTITYLINK (TENANT_ID_)
go

create index ACT_IDX_HI_IDENT_LNK_PROC_DEF_KEY
    on dbo.ACT_HI_IDENTITYLINK (PROC_DEF_KEY_)
go

create index ACT_IDX_HI_IDENT_LINK_TASK
    on dbo.ACT_HI_IDENTITYLINK (TASK_ID_)
go

create index ACT_IDX_HI_IDENT_LINK_RM_TIME
    on dbo.ACT_HI_IDENTITYLINK (REMOVAL_TIME_)
go

create index ACT_IDX_HI_IDENT_LNK_TIMESTAMP
    on dbo.ACT_HI_IDENTITYLINK (TIMESTAMP_)
go

create table dbo.ACT_HI_INCIDENT
(
    ID_                     nvarchar(64)  not null
        primary key,
    PROC_DEF_KEY_           nvarchar(255),
    PROC_DEF_ID_            nvarchar(64),
    ROOT_PROC_INST_ID_      nvarchar(64),
    PROC_INST_ID_           nvarchar(64),
    EXECUTION_ID_           nvarchar(64),
    CREATE_TIME_            datetime2     not null,
    END_TIME_               datetime2,
    INCIDENT_MSG_           nvarchar(4000),
    INCIDENT_TYPE_          nvarchar(255) not null,
    ACTIVITY_ID_            nvarchar(255),
    FAILED_ACTIVITY_ID_     nvarchar(255),
    CAUSE_INCIDENT_ID_      nvarchar(64),
    ROOT_CAUSE_INCIDENT_ID_ nvarchar(64),
    CONFIGURATION_          nvarchar(255),
    HISTORY_CONFIGURATION_  nvarchar(255),
    INCIDENT_STATE_         int,
    TENANT_ID_              nvarchar(64),
    JOB_DEF_ID_             nvarchar(64),
    ANNOTATION_             nvarchar(4000),
    REMOVAL_TIME_           datetime2
)
go

create index ACT_IDX_HI_INCIDENT_TENANT_ID
    on dbo.ACT_HI_INCIDENT (TENANT_ID_)
go

create index ACT_IDX_HI_INCIDENT_PROC_DEF_KEY
    on dbo.ACT_HI_INCIDENT (PROC_DEF_KEY_)
go

create index ACT_IDX_HI_INCIDENT_ROOT_PI
    on dbo.ACT_HI_INCIDENT (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_INCIDENT_PROCINST
    on dbo.ACT_HI_INCIDENT (PROC_INST_ID_)
go

create index ACT_IDX_HI_INCIDENT_RM_TIME
    on dbo.ACT_HI_INCIDENT (REMOVAL_TIME_)
go

create index ACT_IDX_HI_INCIDENT_CREATE_TIME
    on dbo.ACT_HI_INCIDENT (CREATE_TIME_)
go

create index ACT_IDX_HI_INCIDENT_END_TIME
    on dbo.ACT_HI_INCIDENT (END_TIME_)
go

create table dbo.ACT_HI_JOB_LOG
(
    ID_                     nvarchar(64)          not null
        primary key,
    TIMESTAMP_              datetime2             not null,
    JOB_ID_                 nvarchar(64)          not null,
    JOB_DUEDATE_            datetime2,
    JOB_RETRIES_            int,
    JOB_PRIORITY_           numeric(19) default 0 not null,
    JOB_EXCEPTION_MSG_      nvarchar(4000),
    JOB_EXCEPTION_STACK_ID_ nvarchar(64),
    JOB_STATE_              int,
    JOB_DEF_ID_             nvarchar(64),
    JOB_DEF_TYPE_           nvarchar(255),
    JOB_DEF_CONFIGURATION_  nvarchar(255),
    ACT_ID_                 nvarchar(255),
    FAILED_ACT_ID_          nvarchar(255),
    EXECUTION_ID_           nvarchar(64),
    ROOT_PROC_INST_ID_      nvarchar(64),
    PROCESS_INSTANCE_ID_    nvarchar(64),
    PROCESS_DEF_ID_         nvarchar(64),
    PROCESS_DEF_KEY_        nvarchar(255),
    DEPLOYMENT_ID_          nvarchar(64),
    SEQUENCE_COUNTER_       numeric(19),
    TENANT_ID_              nvarchar(64),
    HOSTNAME_               nvarchar(255),
    REMOVAL_TIME_           datetime2
)
go

create index ACT_IDX_HI_JOB_LOG_ROOT_PI
    on dbo.ACT_HI_JOB_LOG (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_JOB_LOG_PROCINST
    on dbo.ACT_HI_JOB_LOG (PROCESS_INSTANCE_ID_)
go

create index ACT_IDX_HI_JOB_LOG_PROCDEF
    on dbo.ACT_HI_JOB_LOG (PROCESS_DEF_ID_)
go

create index ACT_IDX_HI_JOB_LOG_TENANT_ID
    on dbo.ACT_HI_JOB_LOG (TENANT_ID_)
go

create index ACT_IDX_HI_JOB_LOG_JOB_DEF_ID
    on dbo.ACT_HI_JOB_LOG (JOB_DEF_ID_)
go

create index ACT_IDX_HI_JOB_LOG_PROC_DEF_KEY
    on dbo.ACT_HI_JOB_LOG (PROCESS_DEF_KEY_)
go

create index ACT_IDX_HI_JOB_LOG_EX_STACK
    on dbo.ACT_HI_JOB_LOG (JOB_EXCEPTION_STACK_ID_)
go

create index ACT_IDX_HI_JOB_LOG_RM_TIME
    on dbo.ACT_HI_JOB_LOG (REMOVAL_TIME_)
go

create index ACT_IDX_HI_JOB_LOG_JOB_CONF
    on dbo.ACT_HI_JOB_LOG (JOB_DEF_CONFIGURATION_)
go

create table dbo.ACT_HI_OP_LOG
(
    ID_                nvarchar(64) not null
        primary key,
    DEPLOYMENT_ID_     nvarchar(64),
    PROC_DEF_ID_       nvarchar(64),
    PROC_DEF_KEY_      nvarchar(255),
    ROOT_PROC_INST_ID_ nvarchar(64),
    PROC_INST_ID_      nvarchar(64),
    EXECUTION_ID_      nvarchar(64),
    CASE_DEF_ID_       nvarchar(64),
    CASE_INST_ID_      nvarchar(64),
    CASE_EXECUTION_ID_ nvarchar(64),
    TASK_ID_           nvarchar(64),
    JOB_ID_            nvarchar(64),
    JOB_DEF_ID_        nvarchar(64),
    BATCH_ID_          nvarchar(64),
    USER_ID_           nvarchar(255),
    TIMESTAMP_         datetime2    not null,
    OPERATION_TYPE_    nvarchar(64),
    OPERATION_ID_      nvarchar(64),
    ENTITY_TYPE_       nvarchar(30),
    PROPERTY_          nvarchar(64),
    ORG_VALUE_         nvarchar(4000),
    NEW_VALUE_         nvarchar(4000),
    TENANT_ID_         nvarchar(64),
    REMOVAL_TIME_      datetime2,
    CATEGORY_          nvarchar(64),
    EXTERNAL_TASK_ID_  nvarchar(64),
    ANNOTATION_        nvarchar(4000)
)
go

create index ACT_IDX_HI_OP_LOG_ROOT_PI
    on dbo.ACT_HI_OP_LOG (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_OP_LOG_PROCINST
    on dbo.ACT_HI_OP_LOG (PROC_INST_ID_)
go

create index ACT_IDX_HI_OP_LOG_PROCDEF
    on dbo.ACT_HI_OP_LOG (PROC_DEF_ID_)
go

create index ACT_IDX_HI_OP_LOG_TASK
    on dbo.ACT_HI_OP_LOG (TASK_ID_)
go

create index ACT_IDX_HI_OP_LOG_RM_TIME
    on dbo.ACT_HI_OP_LOG (REMOVAL_TIME_)
go

create index ACT_IDX_HI_OP_LOG_TIMESTAMP
    on dbo.ACT_HI_OP_LOG (TIMESTAMP_)
go

create index ACT_IDX_HI_OP_LOG_USER_ID
    on dbo.ACT_HI_OP_LOG (USER_ID_)
go

create index ACT_IDX_HI_OP_LOG_OP_TYPE
    on dbo.ACT_HI_OP_LOG (OPERATION_TYPE_)
go

create index ACT_IDX_HI_OP_LOG_ENTITY_TYPE
    on dbo.ACT_HI_OP_LOG (ENTITY_TYPE_)
go

create table dbo.ACT_HI_PROCINST
(
    ID_                        nvarchar(64) not null
        primary key,
    PROC_INST_ID_              nvarchar(64) not null
        unique,
    BUSINESS_KEY_              nvarchar(255),
    PROC_DEF_KEY_              nvarchar(255),
    PROC_DEF_ID_               nvarchar(64) not null,
    START_TIME_                datetime2    not null,
    END_TIME_                  datetime2,
    REMOVAL_TIME_              datetime2,
    DURATION_                  numeric(19),
    START_USER_ID_             nvarchar(255),
    START_ACT_ID_              nvarchar(255),
    END_ACT_ID_                nvarchar(255),
    SUPER_PROCESS_INSTANCE_ID_ nvarchar(64),
    ROOT_PROC_INST_ID_         nvarchar(64),
    SUPER_CASE_INSTANCE_ID_    nvarchar(64),
    CASE_INST_ID_              nvarchar(64),
    DELETE_REASON_             nvarchar(4000),
    TENANT_ID_                 nvarchar(64),
    STATE_                     nvarchar(255)
)
go

create index ACT_IDX_HI_PRO_INST_END
    on dbo.ACT_HI_PROCINST (END_TIME_)
go

create index ACT_IDX_HI_PRO_I_BUSKEY
    on dbo.ACT_HI_PROCINST (BUSINESS_KEY_)
go

create index ACT_IDX_HI_PRO_INST_TENANT_ID
    on dbo.ACT_HI_PROCINST (TENANT_ID_)
go

create index ACT_IDX_HI_PRO_INST_PROC_DEF_KEY
    on dbo.ACT_HI_PROCINST (PROC_DEF_KEY_)
go

create index ACT_IDX_HI_PRO_INST_PROC_TIME
    on dbo.ACT_HI_PROCINST (START_TIME_, END_TIME_)
go

create index ACT_IDX_HI_PI_PDEFID_END_TIME
    on dbo.ACT_HI_PROCINST (PROC_DEF_ID_, END_TIME_)
go

create index ACT_IDX_HI_PRO_INST_ROOT_PI
    on dbo.ACT_HI_PROCINST (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_PRO_INST_RM_TIME
    on dbo.ACT_HI_PROCINST (REMOVAL_TIME_)
go

create table dbo.ACT_HI_TASKINST
(
    ID_                nvarchar(64) not null
        primary key,
    TASK_DEF_KEY_      nvarchar(255),
    PROC_DEF_KEY_      nvarchar(255),
    PROC_DEF_ID_       nvarchar(64),
    ROOT_PROC_INST_ID_ nvarchar(64),
    PROC_INST_ID_      nvarchar(64),
    EXECUTION_ID_      nvarchar(64),
    CASE_DEF_KEY_      nvarchar(255),
    CASE_DEF_ID_       nvarchar(64),
    CASE_INST_ID_      nvarchar(64),
    CASE_EXECUTION_ID_ nvarchar(64),
    ACT_INST_ID_       nvarchar(64),
    NAME_              nvarchar(255),
    PARENT_TASK_ID_    nvarchar(64),
    DESCRIPTION_       nvarchar(4000),
    OWNER_             nvarchar(255),
    ASSIGNEE_          nvarchar(255),
    START_TIME_        datetime2    not null,
    END_TIME_          datetime2,
    DURATION_          numeric(19),
    DELETE_REASON_     nvarchar(4000),
    PRIORITY_          int,
    DUE_DATE_          datetime2,
    FOLLOW_UP_DATE_    datetime2,
    TENANT_ID_         nvarchar(64),
    REMOVAL_TIME_      datetime2
)
go

create index ACT_IDX_HI_TASKINST_ROOT_PI
    on dbo.ACT_HI_TASKINST (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_TASK_INST_TENANT_ID
    on dbo.ACT_HI_TASKINST (TENANT_ID_)
go

create index ACT_IDX_HI_TASK_INST_PROC_DEF_KEY
    on dbo.ACT_HI_TASKINST (PROC_DEF_KEY_)
go

create index ACT_IDX_HI_TASKINST_PROCINST
    on dbo.ACT_HI_TASKINST (PROC_INST_ID_)
go

create index ACT_IDX_HI_TASKINSTID_PROCINST
    on dbo.ACT_HI_TASKINST (ID_, PROC_INST_ID_)
go

create index ACT_IDX_HI_TASK_INST_RM_TIME
    on dbo.ACT_HI_TASKINST (REMOVAL_TIME_)
go

create index ACT_IDX_HI_TASK_INST_START
    on dbo.ACT_HI_TASKINST (START_TIME_)
go

create index ACT_IDX_HI_TASK_INST_END
    on dbo.ACT_HI_TASKINST (END_TIME_)
go

create table dbo.ACT_HI_VARINST
(
    ID_                nvarchar(64)  not null
        primary key,
    PROC_DEF_KEY_      nvarchar(255),
    PROC_DEF_ID_       nvarchar(64),
    ROOT_PROC_INST_ID_ nvarchar(64),
    PROC_INST_ID_      nvarchar(64),
    EXECUTION_ID_      nvarchar(64),
    CASE_DEF_KEY_      nvarchar(255),
    CASE_DEF_ID_       nvarchar(64),
    CASE_INST_ID_      nvarchar(64),
    CASE_EXECUTION_ID_ nvarchar(64),
    ACT_INST_ID_       nvarchar(64),
    TASK_ID_           nvarchar(64),
    NAME_              nvarchar(255) not null,
    VAR_TYPE_          nvarchar(100),
    CREATE_TIME_       datetime2,
    REV_               int,
    BYTEARRAY_ID_      nvarchar(64),
    DOUBLE_            float,
    LONG_              numeric(19),
    TEXT_              nvarchar(4000),
    TEXT2_             nvarchar(4000),
    TENANT_ID_         nvarchar(64),
    STATE_             nvarchar(20),
    REMOVAL_TIME_      datetime2
)
go

create index ACT_IDX_HI_VARINST_ROOT_PI
    on dbo.ACT_HI_VARINST (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_HI_PROCVAR_PROC_INST
    on dbo.ACT_HI_VARINST (PROC_INST_ID_)
go

create index ACT_IDX_HI_PROCVAR_NAME_TYPE
    on dbo.ACT_HI_VARINST (NAME_, VAR_TYPE_)
go

create index ACT_IDX_HI_CASEVAR_CASE_INST
    on dbo.ACT_HI_VARINST (CASE_INST_ID_)
go

create index ACT_IDX_HI_VAR_INST_TENANT_ID
    on dbo.ACT_HI_VARINST (TENANT_ID_)
go

create index ACT_IDX_HI_VAR_INST_PROC_DEF_KEY
    on dbo.ACT_HI_VARINST (PROC_DEF_KEY_)
go

create index ACT_IDX_HI_VARINST_BYTEAR
    on dbo.ACT_HI_VARINST (BYTEARRAY_ID_)
go

create index ACT_IDX_HI_VARINST_RM_TIME
    on dbo.ACT_HI_VARINST (REMOVAL_TIME_)
go

create index ACT_IDX_HI_VAR_PI_NAME_TYPE
    on dbo.ACT_HI_VARINST (PROC_INST_ID_, NAME_, VAR_TYPE_)
go

create table dbo.ACT_ID_GROUP
(
    ID_   nvarchar(64) not null
        primary key,
    REV_  int,
    NAME_ nvarchar(255),
    TYPE_ nvarchar(255)
)
go

create table dbo.ACT_ID_INFO
(
    ID_        nvarchar(64) not null
        primary key,
    REV_       int,
    USER_ID_   nvarchar(64),
    TYPE_      nvarchar(64),
    KEY_       nvarchar(255),
    VALUE_     nvarchar(255),
    PASSWORD_  image,
    PARENT_ID_ nvarchar(255)
)
go

create table dbo.ACT_ID_TENANT
(
    ID_   nvarchar(64) not null
        primary key,
    REV_  int,
    NAME_ nvarchar(255)
)
go

create table dbo.ACT_ID_USER
(
    ID_            nvarchar(64) not null
        primary key,
    REV_           int,
    FIRST_         nvarchar(255),
    LAST_          nvarchar(255),
    EMAIL_         nvarchar(255),
    PWD_           nvarchar(255),
    SALT_          nvarchar(255),
    LOCK_EXP_TIME_ datetime2,
    ATTEMPTS_      int,
    PICTURE_ID_    nvarchar(64)
)
go

create table dbo.ACT_ID_MEMBERSHIP
(
    USER_ID_  nvarchar(64) not null
        constraint ACT_FK_MEMB_USER
            references dbo.ACT_ID_USER,
    GROUP_ID_ nvarchar(64) not null
        constraint ACT_FK_MEMB_GROUP
            references dbo.ACT_ID_GROUP,
    primary key (USER_ID_, GROUP_ID_)
)
go

create table dbo.ACT_ID_TENANT_MEMBER
(
    ID_        nvarchar(64) not null
        primary key,
    TENANT_ID_ nvarchar(64) not null
        constraint ACT_FK_TENANT_MEMB
            references dbo.ACT_ID_TENANT,
    USER_ID_   nvarchar(64)
        constraint ACT_FK_TENANT_MEMB_USER
            references dbo.ACT_ID_USER,
    GROUP_ID_  nvarchar(64)
        constraint ACT_FK_TENANT_MEMB_GROUP
            references dbo.ACT_ID_GROUP
)
go

create unique index ACT_UNIQ_TENANT_MEMB_USER
    on dbo.ACT_ID_TENANT_MEMBER (TENANT_ID_, USER_ID_)
    where [USER_ID_] IS NOT NULL
go

create unique index ACT_UNIQ_TENANT_MEMB_GROUP
    on dbo.ACT_ID_TENANT_MEMBER (TENANT_ID_, GROUP_ID_)
    where [GROUP_ID_] IS NOT NULL
go

create table dbo.ACT_RE_CAMFORMDEF
(
    ID_            nvarchar(64)  not null
        primary key,
    REV_           int,
    KEY_           nvarchar(255) not null,
    VERSION_       int           not null,
    DEPLOYMENT_ID_ nvarchar(64),
    RESOURCE_NAME_ nvarchar(4000),
    TENANT_ID_     nvarchar(64)
)
go

create table dbo.ACT_RE_CASE_DEF
(
    ID_                 nvarchar(64)  not null
        primary key,
    REV_                int,
    CATEGORY_           nvarchar(255),
    NAME_               nvarchar(255),
    KEY_                nvarchar(255) not null,
    VERSION_            int           not null,
    DEPLOYMENT_ID_      nvarchar(64),
    RESOURCE_NAME_      nvarchar(4000),
    DGRM_RESOURCE_NAME_ nvarchar(4000),
    TENANT_ID_          nvarchar(64),
    HISTORY_TTL_        int
)
go

create index ACT_IDX_CASE_DEF_TENANT_ID
    on dbo.ACT_RE_CASE_DEF (TENANT_ID_)
go

create table dbo.ACT_RE_DECISION_REQ_DEF
(
    ID_                 nvarchar(64)  not null
        primary key,
    REV_                int,
    CATEGORY_           nvarchar(255),
    NAME_               nvarchar(255),
    KEY_                nvarchar(255) not null,
    VERSION_            int           not null,
    DEPLOYMENT_ID_      nvarchar(64),
    RESOURCE_NAME_      nvarchar(4000),
    DGRM_RESOURCE_NAME_ nvarchar(4000),
    TENANT_ID_          nvarchar(64)
)
go

create table dbo.ACT_RE_DECISION_DEF
(
    ID_                 nvarchar(64)  not null
        primary key,
    REV_                int,
    CATEGORY_           nvarchar(255),
    NAME_               nvarchar(255),
    KEY_                nvarchar(255) not null,
    VERSION_            int           not null,
    DEPLOYMENT_ID_      nvarchar(64),
    RESOURCE_NAME_      nvarchar(4000),
    DGRM_RESOURCE_NAME_ nvarchar(4000),
    DEC_REQ_ID_         nvarchar(64)
        constraint ACT_FK_DEC_REQ
            references dbo.ACT_RE_DECISION_REQ_DEF,
    DEC_REQ_KEY_        nvarchar(255),
    TENANT_ID_          nvarchar(64),
    HISTORY_TTL_        int,
    VERSION_TAG_        nvarchar(64)
)
go

create index ACT_IDX_DEC_DEF_TENANT_ID
    on dbo.ACT_RE_DECISION_DEF (TENANT_ID_)
go

create index ACT_IDX_DEC_DEF_REQ_ID
    on dbo.ACT_RE_DECISION_DEF (DEC_REQ_ID_)
go

create index ACT_IDX_DEC_REQ_DEF_TENANT_ID
    on dbo.ACT_RE_DECISION_REQ_DEF (TENANT_ID_)
go

create table dbo.ACT_RE_DEPLOYMENT
(
    ID_          nvarchar(64) not null
        primary key,
    NAME_        nvarchar(255),
    DEPLOY_TIME_ datetime2,
    SOURCE_      nvarchar(255),
    TENANT_ID_   nvarchar(64)
)
go

create table dbo.ACT_GE_BYTEARRAY
(
    ID_                nvarchar(64) not null
        primary key,
    REV_               int,
    NAME_              nvarchar(255),
    DEPLOYMENT_ID_     nvarchar(64)
        constraint ACT_FK_BYTEARR_DEPL
            references dbo.ACT_RE_DEPLOYMENT,
    BYTES_             image,
    GENERATED_         tinyint,
    TENANT_ID_         nvarchar(64),
    TYPE_              int,
    CREATE_TIME_       datetime2,
    ROOT_PROC_INST_ID_ nvarchar(64),
    REMOVAL_TIME_      datetime2
)
go

create index ACT_IDX_BA_DEPLOYMENT
    on dbo.ACT_GE_BYTEARRAY (DEPLOYMENT_ID_)
go

create index ACT_IDX_BYTEARRAY_ROOT_PI
    on dbo.ACT_GE_BYTEARRAY (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_BYTEARRAY_RM_TIME
    on dbo.ACT_GE_BYTEARRAY (REMOVAL_TIME_)
go

create index ACT_IDX_BYTEARRAY_NAME
    on dbo.ACT_GE_BYTEARRAY (NAME_)
go

create index ACT_IDX_DEPLOYMENT_NAME
    on dbo.ACT_RE_DEPLOYMENT (NAME_)
go

create index ACT_IDX_DEPLOYMENT_TENANT_ID
    on dbo.ACT_RE_DEPLOYMENT (TENANT_ID_)
go

create table dbo.ACT_RE_PROCDEF
(
    ID_                 nvarchar(64)  not null
        primary key,
    REV_                int,
    CATEGORY_           nvarchar(255),
    NAME_               nvarchar(255),
    KEY_                nvarchar(255) not null,
    VERSION_            int           not null,
    DEPLOYMENT_ID_      nvarchar(64),
    RESOURCE_NAME_      nvarchar(4000),
    DGRM_RESOURCE_NAME_ nvarchar(4000),
    HAS_START_FORM_KEY_ tinyint,
    SUSPENSION_STATE_   tinyint,
    TENANT_ID_          nvarchar(64),
    VERSION_TAG_        nvarchar(64),
    HISTORY_TTL_        int,
    STARTABLE_          bit default 1 not null
)
go

create index ACT_IDX_PROCDEF_DEPLOYMENT_ID
    on dbo.ACT_RE_PROCDEF (DEPLOYMENT_ID_)
go

create index ACT_IDX_PROCDEF_TENANT_ID
    on dbo.ACT_RE_PROCDEF (TENANT_ID_)
go

create index ACT_IDX_PROCDEF_VER_TAG
    on dbo.ACT_RE_PROCDEF (VERSION_TAG_)
go

create table dbo.ACT_RU_AUTHORIZATION
(
    ID_                nvarchar(64) not null
        primary key,
    REV_               int,
    TYPE_              int          not null,
    GROUP_ID_          nvarchar(255),
    USER_ID_           nvarchar(255),
    RESOURCE_TYPE_     int          not null,
    RESOURCE_ID_       nvarchar(255),
    PERMS_             int,
    REMOVAL_TIME_      datetime2,
    ROOT_PROC_INST_ID_ nvarchar(64)
)
go

create unique index ACT_UNIQ_AUTH_USER
    on dbo.ACT_RU_AUTHORIZATION (TYPE_, USER_ID_, RESOURCE_TYPE_, RESOURCE_ID_)
    where [USER_ID_] IS NOT NULL
go

create unique index ACT_UNIQ_AUTH_GROUP
    on dbo.ACT_RU_AUTHORIZATION (TYPE_, GROUP_ID_, RESOURCE_TYPE_, RESOURCE_ID_)
    where [GROUP_ID_] IS NOT NULL
go

create index ACT_IDX_AUTH_GROUP_ID
    on dbo.ACT_RU_AUTHORIZATION (GROUP_ID_)
go

create index ACT_IDX_AUTH_RESOURCE_ID
    on dbo.ACT_RU_AUTHORIZATION (RESOURCE_ID_)
go

create index ACT_IDX_AUTH_ROOT_PI
    on dbo.ACT_RU_AUTHORIZATION (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_AUTH_RM_TIME
    on dbo.ACT_RU_AUTHORIZATION (REMOVAL_TIME_)
go

create table dbo.ACT_RU_CASE_EXECUTION
(
    ID_              nvarchar(64) not null
        primary key,
    REV_             int,
    CASE_INST_ID_    nvarchar(64)
        constraint ACT_FK_CASE_EXE_CASE_INST
            references dbo.ACT_RU_CASE_EXECUTION,
    SUPER_CASE_EXEC_ nvarchar(64),
    SUPER_EXEC_      nvarchar(64),
    BUSINESS_KEY_    nvarchar(255),
    PARENT_ID_       nvarchar(64)
        constraint ACT_FK_CASE_EXE_PARENT
            references dbo.ACT_RU_CASE_EXECUTION,
    CASE_DEF_ID_     nvarchar(64)
        constraint ACT_FK_CASE_EXE_CASE_DEF
            references dbo.ACT_RE_CASE_DEF,
    ACT_ID_          nvarchar(255),
    PREV_STATE_      int,
    CURRENT_STATE_   int,
    REQUIRED_        tinyint,
    TENANT_ID_       nvarchar(64)
)
go

create index ACT_IDX_CASE_EXEC_BUSKEY
    on dbo.ACT_RU_CASE_EXECUTION (BUSINESS_KEY_)
go

create index ACT_IDX_CASE_EXE_CASE_INST
    on dbo.ACT_RU_CASE_EXECUTION (CASE_INST_ID_)
go

create index ACT_IDX_CASE_EXEC_CASE
    on dbo.ACT_RU_CASE_EXECUTION (CASE_DEF_ID_)
go

create index ACT_IDX_CASE_EXEC_PARENT
    on dbo.ACT_RU_CASE_EXECUTION (PARENT_ID_)
go

create index ACT_IDX_CASE_EXEC_TENANT_ID
    on dbo.ACT_RU_CASE_EXECUTION (TENANT_ID_)
go

create table dbo.ACT_RU_CASE_SENTRY_PART
(
    ID_                  nvarchar(64) not null
        primary key,
    REV_                 int,
    CASE_INST_ID_        nvarchar(64)
        constraint ACT_FK_CASE_SENTRY_CASE_INST
            references dbo.ACT_RU_CASE_EXECUTION,
    CASE_EXEC_ID_        nvarchar(64)
        constraint ACT_FK_CASE_SENTRY_CASE_EXEC
            references dbo.ACT_RU_CASE_EXECUTION,
    SENTRY_ID_           nvarchar(255),
    TYPE_                nvarchar(255),
    SOURCE_CASE_EXEC_ID_ nvarchar(64),
    STANDARD_EVENT_      nvarchar(255),
    SOURCE_              nvarchar(255),
    VARIABLE_EVENT_      nvarchar(255),
    VARIABLE_NAME_       nvarchar(255),
    SATISFIED_           tinyint,
    TENANT_ID_           nvarchar(64)
)
go

create index ACT_IDX_CASE_SENTRY_CASE_INST
    on dbo.ACT_RU_CASE_SENTRY_PART (CASE_INST_ID_)
go

create index ACT_IDX_CASE_SENTRY_CASE_EXEC
    on dbo.ACT_RU_CASE_SENTRY_PART (CASE_EXEC_ID_)
go

create table dbo.ACT_RU_EXECUTION
(
    ID_                nvarchar(64) not null
        primary key,
    REV_               int,
    ROOT_PROC_INST_ID_ nvarchar(64),
    PROC_INST_ID_      nvarchar(64)
        constraint ACT_FK_EXE_PROCINST
            references dbo.ACT_RU_EXECUTION,
    BUSINESS_KEY_      nvarchar(255),
    PARENT_ID_         nvarchar(64)
        constraint ACT_FK_EXE_PARENT
            references dbo.ACT_RU_EXECUTION,
    PROC_DEF_ID_       nvarchar(64)
        constraint ACT_FK_EXE_PROCDEF
            references dbo.ACT_RE_PROCDEF,
    SUPER_EXEC_        nvarchar(64)
        constraint ACT_FK_EXE_SUPER
            references dbo.ACT_RU_EXECUTION,
    SUPER_CASE_EXEC_   nvarchar(64),
    CASE_INST_ID_      nvarchar(64),
    ACT_ID_            nvarchar(255),
    ACT_INST_ID_       nvarchar(64),
    IS_ACTIVE_         tinyint,
    IS_CONCURRENT_     tinyint,
    IS_SCOPE_          tinyint,
    IS_EVENT_SCOPE_    tinyint,
    SUSPENSION_STATE_  tinyint,
    CACHED_ENT_STATE_  int,
    SEQUENCE_COUNTER_  numeric(19),
    TENANT_ID_         nvarchar(64)
)
go

create table dbo.ACT_RU_EVENT_SUBSCR
(
    ID_            nvarchar(64)  not null
        primary key,
    REV_           int,
    EVENT_TYPE_    nvarchar(255) not null,
    EVENT_NAME_    nvarchar(255),
    EXECUTION_ID_  nvarchar(64)
        constraint ACT_FK_EVENT_EXEC
            references dbo.ACT_RU_EXECUTION,
    PROC_INST_ID_  nvarchar(64),
    ACTIVITY_ID_   nvarchar(255),
    CONFIGURATION_ nvarchar(255),
    CREATED_       datetime2     not null,
    TENANT_ID_     nvarchar(64)
)
go

create index ACT_IDX_EVENT_SUBSCR_CONFIG_
    on dbo.ACT_RU_EVENT_SUBSCR (CONFIGURATION_)
go

create index ACT_IDX_EVENT_SUBSCR_TENANT_ID
    on dbo.ACT_RU_EVENT_SUBSCR (TENANT_ID_)
go

create index ACT_IDX_EVENT_SUBSCR_EXEC
    on dbo.ACT_RU_EVENT_SUBSCR (EXECUTION_ID_)
go

create index ACT_IDX_EVENT_SUBSCR_EVT_NAME
    on dbo.ACT_RU_EVENT_SUBSCR (EVENT_NAME_)
go

create index ACT_IDX_EXEC_ROOT_PI
    on dbo.ACT_RU_EXECUTION (ROOT_PROC_INST_ID_)
go

create index ACT_IDX_EXEC_BUSKEY
    on dbo.ACT_RU_EXECUTION (BUSINESS_KEY_)
go

create index ACT_IDX_EXEC_TENANT_ID
    on dbo.ACT_RU_EXECUTION (TENANT_ID_)
go

create index ACT_IDX_EXECUTION_PROC
    on dbo.ACT_RU_EXECUTION (PROC_DEF_ID_)
go

create index ACT_IDX_EXECUTION_PARENT
    on dbo.ACT_RU_EXECUTION (PARENT_ID_)
go

create index ACT_IDX_EXECUTION_SUPER
    on dbo.ACT_RU_EXECUTION (SUPER_EXEC_)
go

create index ACT_IDX_EXECUTION_PROCINST
    on dbo.ACT_RU_EXECUTION (PROC_INST_ID_)
go

create table dbo.ACT_RU_EXT_TASK
(
    ID_               nvarchar(64)          not null
        primary key,
    REV_              int                   not null,
    WORKER_ID_        nvarchar(255),
    TOPIC_NAME_       nvarchar(255),
    RETRIES_          int,
    ERROR_MSG_        nvarchar(4000),
    ERROR_DETAILS_ID_ nvarchar(64)
        constraint ACT_FK_EXT_TASK_ERROR_DETAILS
            references dbo.ACT_GE_BYTEARRAY,
    LOCK_EXP_TIME_    datetime2,
    SUSPENSION_STATE_ tinyint,
    EXECUTION_ID_     nvarchar(64)
        constraint ACT_FK_EXT_TASK_EXE
            references dbo.ACT_RU_EXECUTION,
    PROC_INST_ID_     nvarchar(64),
    PROC_DEF_ID_      nvarchar(64),
    PROC_DEF_KEY_     nvarchar(255),
    ACT_ID_           nvarchar(255),
    ACT_INST_ID_      nvarchar(64),
    TENANT_ID_        nvarchar(64),
    PRIORITY_         numeric(19) default 0 not null
)
go

create index ACT_IDX_EXT_TASK_TOPIC
    on dbo.ACT_RU_EXT_TASK (TOPIC_NAME_)
go

create index ACT_IDX_EXT_TASK_TENANT_ID
    on dbo.ACT_RU_EXT_TASK (TENANT_ID_)
go

create index ACT_IDX_EXT_TASK_PRIORITY
    on dbo.ACT_RU_EXT_TASK (PRIORITY_)
go

create index ACT_IDX_EXT_TASK_ERR_DETAILS
    on dbo.ACT_RU_EXT_TASK (ERROR_DETAILS_ID_)
go

create index ACT_IDX_EXT_TASK_EXEC
    on dbo.ACT_RU_EXT_TASK (EXECUTION_ID_)
go

create table dbo.ACT_RU_FILTER
(
    ID_            nvarchar(64)  not null
        primary key,
    REV_           int           not null,
    RESOURCE_TYPE_ nvarchar(255) not null,
    NAME_          nvarchar(255) not null,
    OWNER_         nvarchar(255),
    QUERY_         nvarchar(max) not null,
    PROPERTIES_    nvarchar(max)
)
go

create table dbo.ACT_RU_JOB
(
    ID_                  nvarchar(64)          not null
        primary key,
    REV_                 int,
    TYPE_                nvarchar(255)         not null,
    LOCK_EXP_TIME_       datetime2,
    LOCK_OWNER_          nvarchar(255),
    EXCLUSIVE_           bit,
    EXECUTION_ID_        nvarchar(64),
    PROCESS_INSTANCE_ID_ nvarchar(64),
    PROCESS_DEF_ID_      nvarchar(64),
    PROCESS_DEF_KEY_     nvarchar(255),
    RETRIES_             int,
    EXCEPTION_STACK_ID_  nvarchar(64)
        constraint ACT_FK_JOB_EXCEPTION
            references dbo.ACT_GE_BYTEARRAY,
    EXCEPTION_MSG_       nvarchar(4000),
    FAILED_ACT_ID_       nvarchar(255),
    DUEDATE_             datetime2,
    REPEAT_              nvarchar(255),
    REPEAT_OFFSET_       numeric(19) default 0,
    HANDLER_TYPE_        nvarchar(255),
    HANDLER_CFG_         nvarchar(4000),
    DEPLOYMENT_ID_       nvarchar(64),
    SUSPENSION_STATE_    tinyint     default 1 not null,
    PRIORITY_            numeric(19) default 0 not null,
    JOB_DEF_ID_          nvarchar(64),
    SEQUENCE_COUNTER_    numeric(19),
    TENANT_ID_           nvarchar(64),
    CREATE_TIME_         datetime2
)
go

create index ACT_IDX_JOB_EXECUTION_ID
    on dbo.ACT_RU_JOB (EXECUTION_ID_)
go

create index ACT_IDX_JOB_PROCINST
    on dbo.ACT_RU_JOB (PROCESS_INSTANCE_ID_)
go

create index ACT_IDX_JOB_TENANT_ID
    on dbo.ACT_RU_JOB (TENANT_ID_)
go

create index ACT_IDX_JOB_JOB_DEF_ID
    on dbo.ACT_RU_JOB (JOB_DEF_ID_)
go

create index ACT_IDX_JOB_EXCEPTION_STACK
    on dbo.ACT_RU_JOB (EXCEPTION_STACK_ID_)
go

create index ACT_IDX_JOB_HANDLER_TYPE
    on dbo.ACT_RU_JOB (HANDLER_TYPE_)
go

create table dbo.ACT_RU_JOBDEF
(
    ID_                nvarchar(64)  not null
        primary key,
    REV_               int,
    PROC_DEF_ID_       nvarchar(64),
    PROC_DEF_KEY_      nvarchar(255),
    ACT_ID_            nvarchar(255),
    JOB_TYPE_          nvarchar(255) not null,
    JOB_CONFIGURATION_ nvarchar(255),
    SUSPENSION_STATE_  tinyint,
    JOB_PRIORITY_      numeric(19),
    TENANT_ID_         nvarchar(64),
    DEPLOYMENT_ID_     nvarchar(64)
)
go

create table dbo.ACT_RU_BATCH
(
    ID_                  nvarchar(64) not null
        primary key,
    REV_                 int          not null,
    TYPE_                nvarchar(255),
    TOTAL_JOBS_          int,
    JOBS_CREATED_        int,
    JOBS_PER_SEED_       int,
    INVOCATIONS_PER_JOB_ int,
    SEED_JOB_DEF_ID_     nvarchar(64)
        constraint ACT_FK_BATCH_SEED_JOB_DEF
            references dbo.ACT_RU_JOBDEF,
    BATCH_JOB_DEF_ID_    nvarchar(64)
        constraint ACT_FK_BATCH_JOB_DEF
            references dbo.ACT_RU_JOBDEF,
    MONITOR_JOB_DEF_ID_  nvarchar(64)
        constraint ACT_FK_BATCH_MONITOR_JOB_DEF
            references dbo.ACT_RU_JOBDEF,
    SUSPENSION_STATE_    tinyint,
    CONFIGURATION_       nvarchar(255),
    TENANT_ID_           nvarchar(64),
    CREATE_USER_ID_      nvarchar(255)
)
go

create index ACT_IDX_BATCH_SEED_JOB_DEF
    on dbo.ACT_RU_BATCH (SEED_JOB_DEF_ID_)
go

create index ACT_IDX_BATCH_MONITOR_JOB_DEF
    on dbo.ACT_RU_BATCH (MONITOR_JOB_DEF_ID_)
go

create index ACT_IDX_BATCH_JOB_DEF
    on dbo.ACT_RU_BATCH (BATCH_JOB_DEF_ID_)
go

create table dbo.ACT_RU_INCIDENT
(
    ID_                     nvarchar(64)  not null
        primary key,
    REV_                    int           not null,
    INCIDENT_TIMESTAMP_     datetime2     not null,
    INCIDENT_MSG_           nvarchar(4000),
    INCIDENT_TYPE_          nvarchar(255) not null,
    EXECUTION_ID_           nvarchar(64)
        constraint ACT_FK_INC_EXE
            references dbo.ACT_RU_EXECUTION,
    ACTIVITY_ID_            nvarchar(255),
    FAILED_ACTIVITY_ID_     nvarchar(255),
    PROC_INST_ID_           nvarchar(64)
        constraint ACT_FK_INC_PROCINST
            references dbo.ACT_RU_EXECUTION,
    PROC_DEF_ID_            nvarchar(64)
        constraint ACT_FK_INC_PROCDEF
            references dbo.ACT_RE_PROCDEF,
    CAUSE_INCIDENT_ID_      nvarchar(64)
        constraint ACT_FK_INC_CAUSE
            references dbo.ACT_RU_INCIDENT,
    ROOT_CAUSE_INCIDENT_ID_ nvarchar(64)
        constraint ACT_FK_INC_RCAUSE
            references dbo.ACT_RU_INCIDENT,
    CONFIGURATION_          nvarchar(255),
    TENANT_ID_              nvarchar(64),
    JOB_DEF_ID_             nvarchar(64)
        constraint ACT_FK_INC_JOB_DEF
            references dbo.ACT_RU_JOBDEF,
    ANNOTATION_             nvarchar(4000)
)
go

create index ACT_IDX_INC_CONFIGURATION
    on dbo.ACT_RU_INCIDENT (CONFIGURATION_)
go

create index ACT_IDX_INC_TENANT_ID
    on dbo.ACT_RU_INCIDENT (TENANT_ID_)
go

create index ACT_IDX_INCIDENT_JOB_DEF
    on dbo.ACT_RU_INCIDENT (JOB_DEF_ID_)
go

create index ACT_IDX_INCIDENT_EXEC
    on dbo.ACT_RU_INCIDENT (EXECUTION_ID_)
go

create index ACT_IDX_INCIDENT_PROCINST
    on dbo.ACT_RU_INCIDENT (PROC_INST_ID_)
go

create index ACT_IDX_INCIDENT_PROC_DEF_ID
    on dbo.ACT_RU_INCIDENT (PROC_DEF_ID_)
go

create index ACT_IDX_INCIDENT_CAUSE
    on dbo.ACT_RU_INCIDENT (CAUSE_INCIDENT_ID_)
go

create index ACT_IDX_INCIDENT_ROOT_CAUSE
    on dbo.ACT_RU_INCIDENT (ROOT_CAUSE_INCIDENT_ID_)
go

create index ACT_IDX_JOBDEF_TENANT_ID
    on dbo.ACT_RU_JOBDEF (TENANT_ID_)
go

create index ACT_IDX_JOBDEF_PROC_DEF_ID
    on dbo.ACT_RU_JOBDEF (PROC_DEF_ID_)
go

create table dbo.ACT_RU_METER_LOG
(
    ID_           nvarchar(64) not null
        primary key,
    NAME_         nvarchar(64) not null,
    REPORTER_     nvarchar(255),
    VALUE_        numeric(19),
    TIMESTAMP_    datetime2,
    MILLISECONDS_ numeric(19) default 0
)
go

create index ACT_IDX_METER_LOG_MS
    on dbo.ACT_RU_METER_LOG (MILLISECONDS_)
go

create index ACT_IDX_METER_LOG_NAME_MS
    on dbo.ACT_RU_METER_LOG (NAME_, MILLISECONDS_)
go

create index ACT_IDX_METER_LOG_REPORT
    on dbo.ACT_RU_METER_LOG (NAME_, REPORTER_, MILLISECONDS_)
go

create index ACT_IDX_METER_LOG_TIME
    on dbo.ACT_RU_METER_LOG (TIMESTAMP_)
go

create index ACT_IDX_METER_LOG
    on dbo.ACT_RU_METER_LOG (NAME_, TIMESTAMP_)
go

create table dbo.ACT_RU_TASK
(
    ID_                nvarchar(64) not null
        primary key,
    REV_               int,
    EXECUTION_ID_      nvarchar(64)
        constraint ACT_FK_TASK_EXE
            references dbo.ACT_RU_EXECUTION,
    PROC_INST_ID_      nvarchar(64)
        constraint ACT_FK_TASK_PROCINST
            references dbo.ACT_RU_EXECUTION,
    PROC_DEF_ID_       nvarchar(64)
        constraint ACT_FK_TASK_PROCDEF
            references dbo.ACT_RE_PROCDEF,
    CASE_EXECUTION_ID_ nvarchar(64)
        constraint ACT_FK_TASK_CASE_EXE
            references dbo.ACT_RU_CASE_EXECUTION,
    CASE_INST_ID_      nvarchar(64),
    CASE_DEF_ID_       nvarchar(64)
        constraint ACT_FK_TASK_CASE_DEF
            references dbo.ACT_RE_CASE_DEF,
    NAME_              nvarchar(255),
    PARENT_TASK_ID_    nvarchar(64),
    DESCRIPTION_       nvarchar(4000),
    TASK_DEF_KEY_      nvarchar(255),
    OWNER_             nvarchar(255),
    ASSIGNEE_          nvarchar(255),
    DELEGATION_        nvarchar(64),
    PRIORITY_          int,
    CREATE_TIME_       datetime2,
    DUE_DATE_          datetime2,
    FOLLOW_UP_DATE_    datetime2,
    SUSPENSION_STATE_  int,
    TENANT_ID_         nvarchar(64)
)
go

create table dbo.ACT_RU_IDENTITYLINK
(
    ID_          nvarchar(64) not null
        primary key,
    REV_         int,
    GROUP_ID_    nvarchar(255),
    TYPE_        nvarchar(255),
    USER_ID_     nvarchar(255),
    TASK_ID_     nvarchar(64)
        constraint ACT_FK_TSKASS_TASK
            references dbo.ACT_RU_TASK,
    PROC_DEF_ID_ nvarchar(64)
        constraint ACT_FK_ATHRZ_PROCEDEF
            references dbo.ACT_RE_PROCDEF,
    TENANT_ID_   nvarchar(64)
)
go

create index ACT_IDX_IDENT_LNK_USER
    on dbo.ACT_RU_IDENTITYLINK (USER_ID_)
go

create index ACT_IDX_IDENT_LNK_GROUP
    on dbo.ACT_RU_IDENTITYLINK (GROUP_ID_)
go

create index ACT_IDX_ATHRZ_PROCEDEF
    on dbo.ACT_RU_IDENTITYLINK (PROC_DEF_ID_)
go

create index ACT_IDX_IDENT_LNK_TASK
    on dbo.ACT_RU_IDENTITYLINK (TASK_ID_)
go

create index ACT_IDX_TASK_CREATE
    on dbo.ACT_RU_TASK (CREATE_TIME_)
go

create index ACT_IDX_TASK_ASSIGNEE
    on dbo.ACT_RU_TASK (ASSIGNEE_)
go

create index ACT_IDX_TASK_OWNER
    on dbo.ACT_RU_TASK (OWNER_)
go

create index ACT_IDX_TASK_TENANT_ID
    on dbo.ACT_RU_TASK (TENANT_ID_)
go

create index ACT_IDX_TASK_EXEC
    on dbo.ACT_RU_TASK (EXECUTION_ID_)
go

create index ACT_IDX_TASK_PROCINST
    on dbo.ACT_RU_TASK (PROC_INST_ID_)
go

create index ACT_IDX_TASK_PROC_DEF_ID
    on dbo.ACT_RU_TASK (PROC_DEF_ID_)
go

create index ACT_IDX_TASK_CASE_EXEC
    on dbo.ACT_RU_TASK (CASE_EXECUTION_ID_)
go

create index ACT_IDX_TASK_CASE_DEF_ID
    on dbo.ACT_RU_TASK (CASE_DEF_ID_)
go

create table dbo.ACT_RU_TASK_METER_LOG
(
    ID_            nvarchar(64) not null
        primary key,
    ASSIGNEE_HASH_ numeric(19),
    TIMESTAMP_     datetime2
)
go

create index ACT_IDX_TASK_METER_LOG_TIME
    on dbo.ACT_RU_TASK_METER_LOG (TIMESTAMP_)
go

create table dbo.ACT_RU_VARIABLE
(
    ID_                  nvarchar(64)  not null
        primary key,
    REV_                 int,
    TYPE_                nvarchar(255) not null,
    NAME_                nvarchar(255) not null,
    EXECUTION_ID_        nvarchar(64)
        constraint ACT_FK_VAR_EXE
            references dbo.ACT_RU_EXECUTION,
    PROC_INST_ID_        nvarchar(64)
        constraint ACT_FK_VAR_PROCINST
            references dbo.ACT_RU_EXECUTION,
    PROC_DEF_ID_         nvarchar(64),
    CASE_EXECUTION_ID_   nvarchar(64)
        constraint ACT_FK_VAR_CASE_EXE
            references dbo.ACT_RU_CASE_EXECUTION,
    CASE_INST_ID_        nvarchar(64)
        constraint ACT_FK_VAR_CASE_INST
            references dbo.ACT_RU_CASE_EXECUTION,
    TASK_ID_             nvarchar(64),
    BATCH_ID_            nvarchar(64)
        constraint ACT_FK_VAR_BATCH
            references dbo.ACT_RU_BATCH,
    BYTEARRAY_ID_        nvarchar(64)
        constraint ACT_FK_VAR_BYTEARRAY
            references dbo.ACT_GE_BYTEARRAY,
    DOUBLE_              float,
    LONG_                numeric(19),
    TEXT_                nvarchar(4000),
    TEXT2_               nvarchar(4000),
    VAR_SCOPE_           nvarchar(64)  not null,
    SEQUENCE_COUNTER_    numeric(19),
    IS_CONCURRENT_LOCAL_ tinyint,
    TENANT_ID_           nvarchar(64)
)
go

create index ACT_IDX_VARIABLE_TASK_ID
    on dbo.ACT_RU_VARIABLE (TASK_ID_)
go

create index ACT_IDX_VARIABLE_TENANT_ID
    on dbo.ACT_RU_VARIABLE (TENANT_ID_)
go

create index ACT_IDX_VARIABLE_TASK_NAME_TYPE
    on dbo.ACT_RU_VARIABLE (TASK_ID_, NAME_, TYPE_)
go

create unique index ACT_UNIQ_VARIABLE
    on dbo.ACT_RU_VARIABLE (VAR_SCOPE_, NAME_)
go

create index ACT_IDX_BATCH_ID
    on dbo.ACT_RU_VARIABLE (BATCH_ID_)
go

create index ACT_IDX_VARIABLE_BA
    on dbo.ACT_RU_VARIABLE (BYTEARRAY_ID_)
go

create index ACT_IDX_VARIABLE_EXEC
    on dbo.ACT_RU_VARIABLE (EXECUTION_ID_)
go

create index ACT_IDX_VARIABLE_PROCINST
    on dbo.ACT_RU_VARIABLE (PROC_INST_ID_)
go

create index ACT_IDX_VARIABLE_CASE_EXEC
    on dbo.ACT_RU_VARIABLE (CASE_EXECUTION_ID_)
go

create index ACT_IDX_VARIABLE_CASE_INST
    on dbo.ACT_RU_VARIABLE (CASE_INST_ID_)
go

create table GEN.Code
(
    OrderID              numeric(16) identity,
    ID                   nvarchar(200) not null
        constraint PK_Code
            primary key,
    ValueSetID           numeric(16)   not null,
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table FIN.AdjustmentDate
(
    ID                   numeric(16) identity
        constraint PK_AdjustmentDate
            primary key,
    Code                 nvarchar(200)
        constraint FK_AdjustmentDate_Code
            references GEN.Code,
    PeriodTypeCode       nvarchar(200)
        constraint FK_AdjustmentDate_Code_02
            references GEN.Code,
    DayOfPeriod          numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'FIN', 'TABLE', 'AdjustmentDate', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Adjustment date code -> value set ADJUSTMENT_DATE', 'SCHEMA', 'FIN',
     'TABLE', 'AdjustmentDate', 'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Adjustment period code -> value set PERIOD_TYPE', 'SCHEMA', 'FIN',
     'TABLE', 'AdjustmentDate', 'COLUMN', 'PeriodTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Day of the period (-1 means last day of the period)', 'SCHEMA', 'FIN',
     'TABLE', 'AdjustmentDate', 'COLUMN', 'DayOfPeriod'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'AdjustmentDate', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'AdjustmentDate', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'AdjustmentDate', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'AdjustmentDate', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'AdjustmentDate', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'AdjustmentDate', 'COLUMN', 'LastModifiedUserName'
go

create unique index IX_AdjustmentDate_Code_Unique
    on FIN.AdjustmentDate (Code)
go

create table FIN.CalculatedAdjustmentDate
(
    ID                   numeric(16) identity
        constraint PK_CalculatedAdjustmentDate
            primary key,
    AdjustmentDateID     numeric(16)
        constraint FK_CalculatedAdjustmentDate_AdjustmentDate
            references FIN.AdjustmentDate,
    CalculatedDate       date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'FIN', 'TABLE', 'CalculatedAdjustmentDate',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Adjustment date (set) identifier -> FIN.AdjustmentDate', 'SCHEMA', 'FIN',
     'TABLE', 'CalculatedAdjustmentDate', 'COLUMN', 'AdjustmentDateID'
go

exec sp_addextendedproperty 'MS_Description', 'Calculated date of the adjustment', 'SCHEMA', 'FIN', 'TABLE',
     'CalculatedAdjustmentDate', 'COLUMN', 'CalculatedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'CalculatedAdjustmentDate', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'CalculatedAdjustmentDate', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'CalculatedAdjustmentDate', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'CalculatedAdjustmentDate', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'CalculatedAdjustmentDate', 'COLUMN', 'LastModifiedTime'
go

create index IXFK_Code_ValueSet
    on GEN.Code (ValueSetID)
go

create table FIN.ConsolidatedProduct
(
    ID                   numeric(16) identity
        constraint PK_ConsolidatedProduct
            primary key,
    Code                 nvarchar(200) not null
        constraint FK_ConsolidatedProduct_Code
            references GEN.Code,
    CaseTypeCode         nvarchar(200)
        constraint FK_ConsolidatedProduct_Code_02
            references GEN.Code,
    EventTypeCode        nvarchar(200)
        constraint FK_ConsolidatedProduct_Code_03
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'FIN', 'TABLE', 'ConsolidatedProduct',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Consolidated product code -> value set CONSOLIDATED_PRODUCT', 'SCHEMA',
     'FIN', 'TABLE', 'ConsolidatedProduct', 'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Case type code -> value set CASE_TYPE', 'SCHEMA', 'FIN', 'TABLE',
     'ConsolidatedProduct', 'COLUMN', 'CaseTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Event type code -> value set EVENT_TYPE', 'SCHEMA', 'FIN', 'TABLE',
     'ConsolidatedProduct', 'COLUMN', 'EventTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'ConsolidatedProduct', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'ConsolidatedProduct', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'ConsolidatedProduct', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'ConsolidatedProduct', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'ConsolidatedProduct', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'ConsolidatedProduct', 'COLUMN', 'LastModifiedUserName'
go

create unique index IX_ConsolidatedProduct_Code
    on FIN.ConsolidatedProduct (Code)
go

create table FIN.ConstructionCode
(
    ID                    numeric(16) identity
        constraint PK_ConstructionCode
            primary key,
    Code                  nvarchar(200) not null,
    Level1                nvarchar(200),
    Level2                nvarchar(200),
    Level3                nvarchar(200),
    Level4                nvarchar(200),
    Level5                nvarchar(200),
    Level6                nvarchar(200),
    Level7                nvarchar(200),
    ConsolidatedProductID numeric(16),
    RbProd                nvarchar(200),
    IFRSProductCode       nvarchar(200),
    CurrencyCode          nvarchar(200)
        constraint FK_ConstructionCode_Code
            references GEN.Code,
    CreationDate          date,
    CreationTime          time,
    CreationUserName      nvarchar(200),
    LastModifiedDate      date,
    LastModifiedTime      time,
    LastModifiedUserName  nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'FIN', 'TABLE', 'ConstructionCode',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Construction code value', 'SCHEMA', 'FIN', 'TABLE', 'ConstructionCode',
     'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Level #1 field', 'SCHEMA', 'FIN', 'TABLE', 'ConstructionCode', 'COLUMN',
     'Level1'
go

exec sp_addextendedproperty 'MS_Description', 'Level #2 field', 'SCHEMA', 'FIN', 'TABLE', 'ConstructionCode', 'COLUMN',
     'Level2'
go

exec sp_addextendedproperty 'MS_Description', 'Level #3 field', 'SCHEMA', 'FIN', 'TABLE', 'ConstructionCode', 'COLUMN',
     'Level3'
go

exec sp_addextendedproperty 'MS_Description', 'Level #4 field', 'SCHEMA', 'FIN', 'TABLE', 'ConstructionCode', 'COLUMN',
     'Level4'
go

exec sp_addextendedproperty 'MS_Description', 'Level #5 field', 'SCHEMA', 'FIN', 'TABLE', 'ConstructionCode', 'COLUMN',
     'Level5'
go

exec sp_addextendedproperty 'MS_Description', 'Level #6 field', 'SCHEMA', 'FIN', 'TABLE', 'ConstructionCode', 'COLUMN',
     'Level6'
go

exec sp_addextendedproperty 'MS_Description', 'Level #7 field', 'SCHEMA', 'FIN', 'TABLE', 'ConstructionCode', 'COLUMN',
     'Level7'
go

exec sp_addextendedproperty 'MS_Description', 'Consolidated product identifier -> FIN.ConsolidatedProduct', 'SCHEMA',
     'FIN', 'TABLE', 'ConstructionCode', 'COLUMN', 'ConsolidatedProductID'
go

exec sp_addextendedproperty 'MS_Description', 'RbProd', 'SCHEMA', 'FIN', 'TABLE', 'ConstructionCode', 'COLUMN', 'RbProd'
go

exec sp_addextendedproperty 'MS_Description', 'IFRS product code', 'SCHEMA', 'FIN', 'TABLE', 'ConstructionCode',
     'COLUMN', 'IFRSProductCode'
go

exec sp_addextendedproperty 'MS_Description', 'Currency code -> value set CURRENCY', 'SCHEMA', 'FIN', 'TABLE',
     'ConstructionCode', 'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'ConstructionCode', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'ConstructionCode', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'ConstructionCode', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'ConstructionCode', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'ConstructionCode', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'ConstructionCode', 'COLUMN', 'LastModifiedUserName'
go

create unique index IX_ConstructionCode_Code
    on FIN.ConstructionCode (Code)
go

create table IFC.Contract
(
    ID                     numeric(16) identity
        constraint PK_Contract
            primary key,
    ObjectID               numeric(16),
    SellerName             nvarchar(200),
    SellerPartyID          numeric(16),
    BuyerName              nvarchar(200),
    BuyerPartyID           numeric(16),
    ReferencedContractNr   nvarchar(200),
    ReferencedContractID   numeric(16),
    ContractTypeCode       nvarchar(200),
    ContractTypeText       nvarchar(200),
    ContractPhaseCode      nvarchar(200),
    ContractPhaseText      nvarchar(200),
    StatusCode             nvarchar(200),
    StatusText             nvarchar(200),
    ContractNr             nvarchar(200),
    RegistrationNr         nvarchar(200),
    ExternalContractNr     nvarchar(200),
    DecisionNr             nvarchar(200),
    ValidFrom              date,
    ValidUntil             date,
    ContractDate           date,
    SourceID               nvarchar(200),
    SourceInterfaceType    nvarchar(200),
    InterfaceStatusCode    nvarchar(200),
    ErrorMessage           nvarchar(max),
    Operation              nvarchar(200),
    ImportTableID          numeric(16),
    CreationDate           date,
    CreationTime           time,
    CreationUserName       nvarchar(200),
    LastModifiedDate       date,
    LastModifiedTime       time,
    LastModifiedUserName   nvarchar(200),
    ContractID             numeric(16),
    FinancialMilestoneDate date
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'IFC', 'TABLE', 'Contract',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Seller party identifier -> PRT.Party', 'SCHEMA', 'IFC', 'TABLE',
     'Contract', 'COLUMN', 'SellerPartyID'
go

exec sp_addextendedproperty 'MS_Description', 'Buyer name', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN', 'BuyerName'
go

exec sp_addextendedproperty 'MS_Description', 'Buyer party identifier -> PRT.Party', 'SCHEMA', 'IFC', 'TABLE',
     'Contract', 'COLUMN', 'BuyerPartyID'
go

exec sp_addextendedproperty 'MS_Description', 'Referenced contract number', 'SCHEMA', 'IFC', 'TABLE', 'Contract',
     'COLUMN', 'ReferencedContractNr'
go

exec sp_addextendedproperty 'MS_Description', 'Referenced contract identifier -> CRM.Contract', 'SCHEMA', 'IFC',
     'TABLE', 'Contract', 'COLUMN', 'ReferencedContractID'
go

exec sp_addextendedproperty 'MS_Description', 'Contract type value set -> CONTRACT_TYPE', 'SCHEMA', 'IFC', 'TABLE',
     'Contract', 'COLUMN', 'ContractTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Contract type text', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN',
     'ContractTypeText'
go

exec sp_addextendedproperty 'MS_Description', 'Contract pahse value set -> CONTRACT_PHASE', 'SCHEMA', 'IFC', 'TABLE',
     'Contract', 'COLUMN', 'ContractPhaseCode'
go

exec sp_addextendedproperty 'MS_Description', 'Contract phase text', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN',
     'ContractPhaseText'
go

exec sp_addextendedproperty 'MS_Description', 'Contract status value set -> CONTRACT_STATUS', 'SCHEMA', 'IFC', 'TABLE',
     'Contract', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Status text', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN',
     'StatusText'
go

exec sp_addextendedproperty 'MS_Description', 'Contract number', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN',
     'ContractNr'
go

exec sp_addextendedproperty 'MS_Description', 'Registration number', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN',
     'RegistrationNr'
go

exec sp_addextendedproperty 'MS_Description', 'External contract number', 'SCHEMA', 'IFC', 'TABLE', 'Contract',
     'COLUMN', 'ExternalContractNr'
go

exec sp_addextendedproperty 'MS_Description', 'Decision number', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN',
     'DecisionNr'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Contract date', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN',
     'ContractDate'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier of the contract to be loaded', 'SCHEMA', 'IFC',
     'TABLE', 'Contract', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN',
     'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'Contract', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'Contract', 'COLUMN',
     'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Operation value set -> OPERATION', 'SCHEMA', 'IFC', 'TABLE', 'Contract',
     'COLUMN', 'Operation'
go

exec sp_addextendedproperty 'MS_Description', 'Import table identifier -> IFC.ImportTable', 'SCHEMA', 'IFC', 'TABLE',
     'Contract', 'COLUMN', 'ImportTableID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'Contract',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'Contract',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'Contract', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'Contract', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'Contract', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'Contract', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Financial milestone date', 'SCHEMA', 'IFC', 'TABLE', 'Contract',
     'COLUMN', 'FinancialMilestoneDate'
go

create table IFC.ContractPreparationItem
(
    ID                     numeric(16) identity
        constraint PK_ContractPreparationItem
            primary key,
    SequenceNr             numeric(16),
    DebtorName             nvarchar(250),
    AccountNr              nvarchar(200),
    GrossValue             money,
    CurrencyCode           nvarchar(200),
    DebtCapital            money,
    DebtTotal              money,
    DebtInterest           money,
    DebtPenaltyInterest    money,
    DebtCost               money,
    DebtCostLocalCurrency  money,
    ProductName            nvarchar(200),
    ContractNr             nvarchar(200),
    ContractDate           date,
    TerminationDate        date,
    DecisionNr             nvarchar(200),
    FinancialMilestoneDate date,
    SourceInterfaceType    nvarchar(200),
    InterfaceStatusCode    nvarchar(200),
    ErrorMessage           nvarchar(max),
    CreationDate           date,
    CreationTime           time,
    CreationUserName       nvarchar(200),
    LastModifiedDate       date,
    LastModifiedTime       time,
    LastModifiedUserName   nvarchar(200),
    GrossValueCurrencyCode nvarchar(200),
    ConstructionCode       nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Sequence number', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'SequenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Debtor name', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'DebtorName'
go

exec sp_addextendedproperty 'MS_Description', 'Account number', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'AccountNr'
go

exec sp_addextendedproperty 'MS_Description', 'Gross value', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'GrossValue'
go

exec sp_addextendedproperty 'MS_Description', 'Currency value set -> CURRENCY', 'SCHEMA', 'IFC', 'TABLE',
     'ContractPreparationItem', 'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Debt dapital', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'DebtCapital'
go

exec sp_addextendedproperty 'MS_Description', 'Debt total', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'DebtTotal'
go

exec sp_addextendedproperty 'MS_Description', 'Debt interest', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'DebtInterest'
go

exec sp_addextendedproperty 'MS_Description', 'Debt penalty interest', 'SCHEMA', 'IFC', 'TABLE',
     'ContractPreparationItem', 'COLUMN', 'DebtPenaltyInterest'
go

exec sp_addextendedproperty 'MS_Description', 'Debt cost', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'DebtCost'
go

exec sp_addextendedproperty 'MS_Description', 'Debt cost (local currency)', 'SCHEMA', 'IFC', 'TABLE',
     'ContractPreparationItem', 'COLUMN', 'DebtCostLocalCurrency'
go

exec sp_addextendedproperty 'MS_Description', 'Name of product', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'ProductName'
go

exec sp_addextendedproperty 'MS_Description', 'Contract date', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'ContractDate'
go

exec sp_addextendedproperty 'MS_Description', 'Termination date', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'TerminationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Decision number', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'DecisionNr'
go

exec sp_addextendedproperty 'MS_Description', 'Financial milestone date', 'SCHEMA', 'IFC', 'TABLE',
     'ContractPreparationItem', 'COLUMN', 'FinancialMilestoneDate'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'ContractPreparationItem', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'ContractPreparationItem',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'ContractPreparationItem', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'ContractPreparationItem', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'ContractPreparationItem', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'ContractPreparationItem', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'ContractPreparationItem', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'ContractPreparationItem', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.ContractTenderItem
(
    ID                    numeric(16) identity
        constraint PK_ContractTenderItem
            primary key,
    GrossValue            money,
    CurrencyCode          nvarchar(200),
    LegalActionCode       nvarchar(200),
    LegalActionText       nvarchar(200),
    DebtCapital           money,
    DebtTotal             money,
    DebtInterest          money,
    DebtPenaltyInterest   money,
    DebtCost              money,
    DebtCurrencyCode      nvarchar(200),
    DebtCostLocalCurrency money,
    DaysPastDue           numeric(10),
    ProductName           nvarchar(200),
    ContractNr            nvarchar(200),
    SourceInterfaceType   nvarchar(200),
    InterfaceStatusCode   nvarchar(200),
    ErrorMessage          nvarchar(max),
    CreationDate          date,
    CreationTime          time,
    CreationUserName      nvarchar(200),
    LastModifiedDate      date,
    LastModifiedTime      time,
    LastModifiedUserName  nvarchar(200),
    SequenceNr            numeric(16)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'ContractTenderItem',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Gross value', 'SCHEMA', 'IFC', 'TABLE', 'ContractTenderItem', 'COLUMN',
     'GrossValue'
go

exec sp_addextendedproperty 'MS_Description', 'Currency value set -> CURRENCY', 'SCHEMA', 'IFC', 'TABLE',
     'ContractTenderItem', 'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean value set -> BOOLEAN', 'SCHEMA', 'IFC', 'TABLE',
     'ContractTenderItem', 'COLUMN', 'LegalActionCode'
go

exec sp_addextendedproperty 'MS_Description', 'A value in the Boolean value set', 'SCHEMA', 'IFC', 'TABLE',
     'ContractTenderItem', 'COLUMN', 'LegalActionText'
go

exec sp_addextendedproperty 'MS_Description', 'Debt capital', 'SCHEMA', 'IFC', 'TABLE', 'ContractTenderItem', 'COLUMN',
     'DebtCapital'
go

exec sp_addextendedproperty 'MS_Description', 'Debt total', 'SCHEMA', 'IFC', 'TABLE', 'ContractTenderItem', 'COLUMN',
     'DebtTotal'
go

exec sp_addextendedproperty 'MS_Description', 'Debt interest', 'SCHEMA', 'IFC', 'TABLE', 'ContractTenderItem', 'COLUMN',
     'DebtInterest'
go

exec sp_addextendedproperty 'MS_Description', 'Debt penalty interest', 'SCHEMA', 'IFC', 'TABLE', 'ContractTenderItem',
     'COLUMN', 'DebtPenaltyInterest'
go

exec sp_addextendedproperty 'MS_Description', 'Debt cost', 'SCHEMA', 'IFC', 'TABLE', 'ContractTenderItem', 'COLUMN',
     'DebtCost'
go

exec sp_addextendedproperty 'MS_Description', 'Currency value set -> CURRENCY', 'SCHEMA', 'IFC', 'TABLE',
     'ContractTenderItem', 'COLUMN', 'DebtCurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Debt cost (local currency)', 'SCHEMA', 'IFC', 'TABLE',
     'ContractTenderItem', 'COLUMN', 'DebtCostLocalCurrency'
go

exec sp_addextendedproperty 'MS_Description', 'Days past due', 'SCHEMA', 'IFC', 'TABLE', 'ContractTenderItem', 'COLUMN',
     'DaysPastDue'
go

exec sp_addextendedproperty 'MS_Description', 'Contract number in the CRM.Contract', 'SCHEMA', 'IFC', 'TABLE',
     'ContractTenderItem', 'COLUMN', 'ContractNr'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'ContractTenderItem',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'ContractTenderItem', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'ContractTenderItem', 'COLUMN',
     'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'ContractTenderItem', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'ContractTenderItem', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'ContractTenderItem', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'ContractTenderItem', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'ContractTenderItem', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'ContractTenderItem', 'COLUMN', 'LastModifiedUserName'
go

create table GEN.Country
(
    ID                   numeric(16) identity
        constraint PK_Country
            primary key,
    CountryCode          nvarchar(200)
        constraint FK_Country_Code
            references GEN.Code,
    CountryClassCode     nvarchar(200)
        constraint FK_Country_Code_02
            references GEN.Code,
    PhoneCode            numeric(5),
    Alpha2Code           nvarchar(2),
    Alpha3Code           nvarchar(3),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'Country', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Country value set -> COUNTRY', 'SCHEMA', 'GEN', 'TABLE', 'Country',
     'COLUMN', 'CountryCode'
go

exec sp_addextendedproperty 'MS_Description', 'Country class value set -> COUNTRY_CLASS', 'SCHEMA', 'GEN', 'TABLE',
     'Country', 'COLUMN', 'CountryClassCode'
go

exec sp_addextendedproperty 'MS_Description', 'Phone country code', 'SCHEMA', 'GEN', 'TABLE', 'Country', 'COLUMN',
     'PhoneCode'
go

exec sp_addextendedproperty 'MS_Description', 'Country Alpha-2 code by ISO 3166-1', 'SCHEMA', 'GEN', 'TABLE', 'Country',
     'COLUMN', 'Alpha2Code'
go

exec sp_addextendedproperty 'MS_Description', 'Country Alpha-3 code by ISO 3166-1', 'SCHEMA', 'GEN', 'TABLE', 'Country',
     'COLUMN', 'Alpha3Code'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'Country',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'Country',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'Country',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'Country', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'Country', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'Country',
     'COLUMN', 'LastModifiedUserName'
go

create index IXFK_Country_Code
    on GEN.Country (CountryCode)
go

create index IXFK_Country_Code_02
    on GEN.Country (CountryClassCode)
go

create table FIN.Debt
(
    ID                   numeric(16) identity
        constraint [PK_FIN.Debt]
            primary key,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

create table FIN.ExchangeRate
(
    ID                     numeric(16) identity
        constraint PK_ExchangeRate
            primary key,
    ExchangeRateSystemCode nvarchar(200)
        constraint FK_ExchangeRate_Code
            references GEN.Code,
    ExchangeDate           date,
    SourceCurrencyCode     nvarchar(200)
        constraint FK_ExchangeRate_Code_02
            references GEN.Code,
    TargetCurrencyCode     nvarchar(200)
        constraint FK_ExchangeRate_Code_03
            references GEN.Code,
    Rate                   numeric(20, 4),
    CreationDate           date,
    CreationTime           time,
    CreationUserName       nvarchar(200),
    LastModifiedDate       date,
    LastModifiedTime       time,
    LastModifiedUserName   nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Exchange rate system -> value set EXCHANGE_RATE_SYSTEM', 'SCHEMA', 'FIN',
     'TABLE', 'ExchangeRate', 'COLUMN', 'ExchangeRateSystemCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date of the rate', 'SCHEMA', 'FIN', 'TABLE', 'ExchangeRate', 'COLUMN',
     'ExchangeDate'
go

exec sp_addextendedproperty 'MS_Description', 'Source currency code -> value set CURRENCY', 'SCHEMA', 'FIN', 'TABLE',
     'ExchangeRate', 'COLUMN', 'SourceCurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Target currency code -> value set CURRENCY', 'SCHEMA', 'FIN', 'TABLE',
     'ExchangeRate', 'COLUMN', 'TargetCurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Exchange rate', 'SCHEMA', 'FIN', 'TABLE', 'ExchangeRate', 'COLUMN',
     'Rate'
go

create index IXFK_ExchangeRate_Code
    on FIN.ExchangeRate (ExchangeRateSystemCode)
go

create index IXFK_ExchangeRate_Code_02
    on FIN.ExchangeRate (SourceCurrencyCode)
go

create index IXFK_ExchangeRate_Code_03
    on FIN.ExchangeRate (TargetCurrencyCode)
go

create table FIN.FeeList
(
    ID                   numeric(16) identity
        constraint PK_FeeList
            primary key,
    Code                 nvarchar(200)
        constraint FK_FeeList_Code
            references GEN.Code,
    Name                 nvarchar(200),
    UsageCode            nvarchar(200)
        constraint FK_FeeList_Code_02
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ValidFrom            date,
    ValidUntil           date,
    StatusCode           nvarchar(200)
        constraint FK_FeeList_Code_03
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'FIN', 'TABLE', 'FeeList', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Fee set code -> value set FEE_LIST', 'SCHEMA', 'FIN', 'TABLE', 'FeeList',
     'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Name of the fee list (not translated)', 'SCHEMA', 'FIN', 'TABLE',
     'FeeList', 'COLUMN', 'Name'
go

exec sp_addextendedproperty 'MS_Description', 'Usage of the fee list -> value set FEE_LIST_USAGE', 'SCHEMA', 'FIN',
     'TABLE', 'FeeList', 'COLUMN', 'UsageCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'FIN', 'TABLE', 'FeeList',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'FIN', 'TABLE', 'FeeList',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE', 'FeeList',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'FeeList', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'FeeList', 'COLUMN', 'LastModifiedTime'
go

create table GEN.[File]
(
    ID                   numeric(16) identity
        constraint PK_File
            primary key,
    ObjectID             numeric(16),
    CurrentStorageID     numeric(16),
    DebtCaseID           numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table GEN.ForeignKeyValueSet
(
    ID                        numeric(16) identity
        constraint PK_ForeignKeyValueSet
            primary key,
    SchemaName                nvarchar(200),
    TableName                 nvarchar(200),
    ColumnName                nvarchar(200),
    ValuesetCode              nvarchar(200)
        constraint FK_ForeignKeyValueSet_Code
            references GEN.Code,
    ExpandableCode            nvarchar(200)
        constraint FK_ForeignKeyValueSet_Code_02
            references GEN.Code,
    UpdateableCode            nvarchar(200)
        constraint FK_ForeignKeyValueSet_Code_03
            references GEN.Code,
    UpdateableTranslationCode nvarchar(200)
        constraint FK_ForeignKeyValueSet_Code_04
            references GEN.Code,
    CreationDate              date,
    CreationTime              time,
    CreationUserName          nvarchar(200),
    LastModifiedDate          date,
    LastModifiedTime          time,
    LastModifiedUserName      nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'ForeignKeyValueSet',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Name of the schema', 'SCHEMA', 'GEN', 'TABLE', 'ForeignKeyValueSet',
     'COLUMN', 'SchemaName'
go

exec sp_addextendedproperty 'MS_Description', 'Name of the database table', 'SCHEMA', 'GEN', 'TABLE',
     'ForeignKeyValueSet', 'COLUMN', 'TableName'
go

exec sp_addextendedproperty 'MS_Description', 'Name of the column', 'SCHEMA', 'GEN', 'TABLE', 'ForeignKeyValueSet',
     'COLUMN', 'ColumnName'
go

exec sp_addextendedproperty 'MS_Description', 'Value set code -> VALUESET', 'SCHEMA', 'GEN', 'TABLE',
     'ForeignKeyValueSet', 'COLUMN', 'ValuesetCode'
go

exec sp_addextendedproperty 'MS_Description',
     'Allowed to add new codes to the enumeration valueset. Value set -> BOOLEAN', 'SCHEMA', 'GEN', 'TABLE',
     'ForeignKeyValueSet', 'COLUMN', 'ExpandableCode'
go

exec sp_addextendedproperty 'MS_Description', 'Alllowed to update code -> value set BOOLEAN', 'SCHEMA', 'GEN', 'TABLE',
     'ForeignKeyValueSet', 'COLUMN', 'UpdateableCode'
go

exec sp_addextendedproperty 'MS_Description', 'Alllowed to update translations -> value set BOOLEAN', 'SCHEMA', 'GEN',
     'TABLE', 'ForeignKeyValueSet', 'COLUMN', 'UpdateableTranslationCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'ForeignKeyValueSet', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'ForeignKeyValueSet', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ForeignKeyValueSet', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ForeignKeyValueSet', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ForeignKeyValueSet', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ForeignKeyValueSet', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InterfaceError
(
    ID                   numeric(16) identity
        constraint PK_InterfaceError
            primary key,
    TableName            nvarchar(200),
    RecordID             numeric(16),
    FieldName            nvarchar(200),
    ErrorCode            nvarchar(200)
        constraint FK_InterfaceError_Code
            references GEN.Code,
    SeverityCode         nvarchar(200)
        constraint FK_InterfaceError_Code_02
            references GEN.Code,
    ModuleInstanceID     numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    StatusCode           nvarchar(200)
        constraint FK_InterfaceError_Code_2
            references GEN.Code,
    ErrorMessage         nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InterfaceError', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface table name', 'SCHEMA', 'IFC', 'TABLE', 'InterfaceError',
     'COLUMN', 'TableName'
go

exec sp_addextendedproperty 'MS_Description', 'The identifier of the table row specified in the TableName field',
     'SCHEMA', 'IFC', 'TABLE', 'InterfaceError', 'COLUMN', 'RecordID'
go

exec sp_addextendedproperty 'MS_Description', 'The name of the field containing the incorrect data', 'SCHEMA', 'IFC',
     'TABLE', 'InterfaceError', 'COLUMN', 'FieldName'
go

exec sp_addextendedproperty 'MS_Description', 'Error code -> value set ERR', 'SCHEMA', 'IFC', 'TABLE', 'InterfaceError',
     'COLUMN', 'ErrorCode'
go

exec sp_addextendedproperty 'MS_Description',
     'If the entry was created by an instantiated module, then its ID -> ORG.ModuleInstance', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceError', 'COLUMN', 'ModuleInstanceID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceError', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceError', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceError', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceError', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceError', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Interface error status -> value set INTERFACE_ERROR_STATUS', 'SCHEMA',
     'IFC', 'TABLE', 'InterfaceError', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InterfaceError', 'COLUMN',
     'ErrorMessage'
go

create table FIN.InvoiceDistribution
(
    ID                    numeric(16) identity
        constraint [PK_FIN.InvoiceDistribution]
            primary key,
    InvoiceID             numeric(16),
    InvoiceDistributionID numeric(16),
    CreationDate          date not null,
    CreationTime          time,
    CreationUserName      nvarchar(200),
    LastModifiedDate      date,
    LastModifiedTime      time,
    LastModifiedUserName  nvarchar(200),
    Comments              nvarchar(max)
)
go

create table IFC.Kishajo
(
    ID    int identity (0, 1),
    Name  varchar(100),
    RegNr varchar(100)
)
go

create table IFC.Mapping
(
    ID                   numeric(16) identity
        constraint PK_Mapping
            primary key,
    MappingCode          nvarchar(200)
        constraint FK_Mapping_Code
            references GEN.Code,
    Name                 nvarchar(200),
    AppUserID            numeric(16),
    FirstRow             numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'Mapping', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Value set MAPPING', 'SCHEMA', 'IFC', 'TABLE', 'Mapping', 'COLUMN',
     'MappingCode'
go

exec sp_addextendedproperty 'MS_Description', 'Name of the mapping', 'SCHEMA', 'IFC', 'TABLE', 'Mapping', 'COLUMN',
     'Name'
go

exec sp_addextendedproperty 'MS_Description', 'User identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE', 'Mapping',
     'COLUMN', 'AppUserID'
go

exec sp_addextendedproperty 'MS_Description', 'First row to load', 'SCHEMA', 'IFC', 'TABLE', 'Mapping', 'COLUMN',
     'FirstRow'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'Mapping',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'Mapping',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE', 'Mapping',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'Mapping', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'Mapping', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE', 'Mapping',
     'COLUMN', 'LastModifiedUserName'
go

create table IFC.MappingCode
(
    ID                   numeric(16) identity
        constraint PK_MappingCode
            primary key,
    MappingID            numeric(16)
        constraint FK_MappingCode_Mapping
            references IFC.Mapping,
    ValuesetCode         nvarchar(200),
    ExternalCode         nvarchar(200),
    Code                 nvarchar(200),
    DefaultValue         nvarchar(200),
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'MappingCode', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Mapping identifier -> IFC.Mapping', 'SCHEMA', 'IFC', 'TABLE',
     'MappingCode', 'COLUMN', 'MappingID'
go

exec sp_addextendedproperty 'MS_Description', 'Value set code', 'SCHEMA', 'IFC', 'TABLE', 'MappingCode', 'COLUMN',
     'ValuesetCode'
go

exec sp_addextendedproperty 'MS_Description', 'External Code', 'SCHEMA', 'IFC', 'TABLE', 'MappingCode', 'COLUMN',
     'ExternalCode'
go

exec sp_addextendedproperty 'MS_Description', 'Internal code (in ValueSet)', 'SCHEMA', 'IFC', 'TABLE', 'MappingCode',
     'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Default Value', 'SCHEMA', 'IFC', 'TABLE', 'MappingCode', 'COLUMN',
     'DefaultValue'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'IFC', 'TABLE', 'MappingCode', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'IFC', 'TABLE', 'MappingCode', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'MappingCode',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'MappingCode',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'MappingCode', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'MappingCode', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'MappingCode', 'COLUMN', 'LastModifiedTime'
go

create table IFC.MappingColumn
(
    ID                   numeric(16) identity
        constraint PK_MappingColumn
            primary key,
    MappingID            numeric(16)
        constraint FK_MappingColumn_Mapping
            references IFC.Mapping,
    TableName            nvarchar(200),
    ColumnName           nvarchar(200),
    ColumnNr             numeric(16),
    SheetNr              numeric(16),
    DefaultValue         nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Mapping identifier -> IFC.Mapping', 'SCHEMA', 'IFC', 'TABLE',
     'MappingColumn', 'COLUMN', 'MappingID'
go

exec sp_addextendedproperty 'MS_Description', 'Name of the table', 'SCHEMA', 'IFC', 'TABLE', 'MappingColumn', 'COLUMN',
     'TableName'
go

exec sp_addextendedproperty 'MS_Description', 'Name of the column', 'SCHEMA', 'IFC', 'TABLE', 'MappingColumn', 'COLUMN',
     'ColumnName'
go

exec sp_addextendedproperty 'MS_Description', 'Column position in the spreadsheet', 'SCHEMA', 'IFC', 'TABLE',
     'MappingColumn', 'COLUMN', 'ColumnNr'
go

exec sp_addextendedproperty 'MS_Description', 'Sheet number', 'SCHEMA', 'IFC', 'TABLE', 'MappingColumn', 'COLUMN',
     'SheetNr'
go

exec sp_addextendedproperty 'MS_Description', 'Default Value', 'SCHEMA', 'IFC', 'TABLE', 'MappingColumn', 'COLUMN',
     'DefaultValue'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'MappingColumn', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'MappingColumn', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'MappingColumn', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'MappingColumn', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'MappingColumn', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'MappingColumn', 'COLUMN', 'LastModifiedUserName'
go

create table COM.Meeting
(
    ID                   numeric(16) identity
        constraint PK_Meeting
            primary key,
    ObjectID             numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table COM.MeetingDebtCase
(
    ID                   numeric(16) identity
        constraint PK_MeetingDebtCase
            primary key,
    ObjectID             numeric(16),
    MeetingID            numeric(16),
    DebtCaseID           numeric(16),
    SolutionID           numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table COM.MeetingParticipant
(
    ID                   numeric(16) identity
        constraint PK_MeetingParticipant
            primary key,
    ObjectID             numeric(16),
    MeetingID            numeric(16),
    EntityID             numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table IFC.OTP_SRM_F
(
    ID                   numeric(16) identity
        constraint PK_OTP_SRM_F
            primary key,
    F1                   nvarchar(20),
    F2                   nvarchar(50),
    F3                   nvarchar(50),
    F4                   nvarchar(4),
    F5                   nvarchar(21),
    F6                   nvarchar(21),
    F7                   nvarchar(21),
    F8                   nvarchar(21),
    F9                   nvarchar(21),
    F10                  nvarchar(21),
    F11                  nvarchar(3),
    F12                  nvarchar(21),
    F13                  nvarchar(30),
    F14                  nvarchar(3),
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    InterfaceStatusCode  nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', N'SRM-Faktoring szerzĹ‘dĂ©sszĂˇm (pl: 8000-E00-20181220-J2)', 'SCHEMA',
     'IFC', 'TABLE', 'OTP_SRM_F', 'COLUMN', 'F1'
go

exec sp_addextendedproperty 'MS_Description', N'Az a dĂˇtum ameddig a bank a kamatot szĂˇmolta. ', 'SCHEMA', 'IFC',
     'TABLE', 'OTP_SRM_F', 'COLUMN', 'F2'
go

exec sp_addextendedproperty 'MS_Description',
     N'Az a dĂˇtum, amikor az SRM-ben a szerzĹ‘dĂ©s lezĂˇrĂˇsra kerĂĽl. Ez a dĂˇtum kerĂĽl a szerzĹ‘dĂ©s keltezĂ©se mezĹ‘be. (YYYYMMDD)',
     'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_F', 'COLUMN', 'F3'
go

exec sp_addextendedproperty 'MS_Description', N'Egy szerzĹ‘dĂ©sen belĂĽli tĂ©telszĂˇm', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_F', 'COLUMN', 'F4'
go

exec sp_addextendedproperty 'MS_Description', N'Egy szerzĹ‘dĂ©sen belĂĽli Ă¶sszesen tĹ‘ke Ă¶sszeg ', 'SCHEMA', 'IFC',
     'TABLE', 'OTP_SRM_F', 'COLUMN', 'F5'
go

exec sp_addextendedproperty 'MS_Description', N'Egy szerzĹ‘dĂ©sen belĂĽli Ă¶sszesen kĂ¶nyvelt ĂĽgyleti kamat Ă¶sszeg',
     'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_F', 'COLUMN', 'F6'
go

exec sp_addextendedproperty 'MS_Description', N'Egy szerzĹ‘dĂ©sen belĂĽli Ă¶sszesen kĂ¶nyvelt kĂ©sedelmi kamat Ă¶sszeg',
     'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_F', 'COLUMN', 'F7'
go

exec sp_addextendedproperty 'MS_Description', N'Egy szerzĹ‘dĂ©sen belĂĽli Ă¶sszesen kĂ¶nyvelt kĂ¶ltsĂ©g Ă¶sszeg',
     'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_F', 'COLUMN', 'F8'
go

exec sp_addextendedproperty 'MS_Description', N'Egy szerzĹ‘dĂ©s Ă¶sszesen vĂ©telĂˇra', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_F', 'COLUMN', 'F9'
go

exec sp_addextendedproperty 'MS_Description', N'Ă–sszes kĂ¶vetelĂ©s Ă©rtĂ©ke', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_F',
     'COLUMN', 'F10'
go

exec sp_addextendedproperty 'MS_Description', N'KĂ¶vetelĂ©s pĂ©nzneme', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_F', 'COLUMN',
     'F11'
go

exec sp_addextendedproperty 'MS_Description',
     N'Egy szerzĹ‘dĂ©sen belĂĽli Ă¶sszesen HUF-ban nyilvĂˇntartott KOLTSEG (deviza esetĂ©n)', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_F', 'COLUMN', 'F12'
go

exec sp_addextendedproperty 'MS_Description', N'WOB azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_F', 'COLUMN', 'F13'
go

exec sp_addextendedproperty 'MS_Description', N'VĂ©telĂˇr devizaneme', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_F', 'COLUMN',
     'F14'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_F', 'COLUMN',
     'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_F', 'COLUMN',
     'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'OTP_SRM_F', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_F',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_F', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_F', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_F', 'COLUMN', 'LastModifiedTime'
go

create table IFC.OTP_SRM_M
(
    ID                   numeric(16) identity
        constraint PK_OTP_SRM_M
            primary key,
    M2                   nvarchar(60),
    M3                   nvarchar(24),
    M4                   nvarchar(21),
    M5                   nvarchar(21),
    M6                   nvarchar(21),
    M7                   nvarchar(21),
    M8                   nvarchar(21),
    M9                   nvarchar(21),
    M10                  nvarchar(3),
    M11                  nvarchar(21),
    M12                  nvarchar(21),
    M13                  nvarchar(3),
    M14                  nvarchar(50),
    M15                  nvarchar(50),
    M16                  nvarchar(50),
    M17                  nvarchar(20),
    M18                  nvarchar(3),
    M19                  nvarchar(30),
    M20                  nvarchar(50),
    M21                  nvarchar(4),
    M22                  nvarchar(2),
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    InterfaceStatusCode  nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    M1                   nvarchar(4)
)
go

exec sp_addextendedproperty 'MS_Description', N'AdĂłs neve', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN', 'M2'
go

exec sp_addextendedproperty 'MS_Description', N'24 jegyĹ± girĂł azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M',
     'COLUMN', 'M3'
go

exec sp_addextendedproperty 'MS_Description', N'AktuĂˇlis tĹ‘ke Ă¶sszeg', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M',
     'COLUMN', 'M4'
go

exec sp_addextendedproperty 'MS_Description', N'KĂ¶nyvelt ĂĽgyleti kamat 
(Az ĂĽgyleti kamaton kĂ­vĂĽl a visszavont kamattĂˇmogatĂˇs Ă¶sszege is benne van)', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_M', 'COLUMN', 'M5'
go

exec sp_addextendedproperty 'MS_Description', N'KĂ¶nyvelt kĂ©sedelmi kamat', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M',
     'COLUMN', 'M6'
go

exec sp_addextendedproperty 'MS_Description', N'KĂ¶nyvelt KĂ¶ltsĂ©g (A behajtĂˇsi kĂ¶ltsĂ©get is tartalmazza)',
     'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN', 'M7'
go

exec sp_addextendedproperty 'MS_Description', N'EgyĂ©b kĂ¶ltsĂ©g', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN', 'M8'
go

exec sp_addextendedproperty 'MS_Description', N'Ă–sszes kĂ¶vetelĂ©s Ă©rtĂ©ke', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M',
     'COLUMN', 'M9'
go

exec sp_addextendedproperty 'MS_Description', N'KĂ¶vetelĂ©s pĂ©nzneme', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN',
     'M10'
go

exec sp_addextendedproperty 'MS_Description', N'HUF-ban nyilvĂˇntartott KOLTSEG (deviza esetĂ©n)', 'SCHEMA', 'IFC',
     'TABLE', 'OTP_SRM_M', 'COLUMN', 'M11'
go

exec sp_addextendedproperty 'MS_Description', N'VĂ©telĂˇr', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN', 'M12'
go

exec sp_addextendedproperty 'MS_Description', N'VĂ©telĂˇr devizaneme', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN',
     'M13'
go

exec sp_addextendedproperty 'MS_Description', N'SzerzĹ‘dĂ©skĂ¶tĂ©s dĂˇtuma (YYYYMMDD)', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_M', 'COLUMN', 'M14'
go

exec sp_addextendedproperty 'MS_Description', N'FelmondĂˇs dĂˇtuma (YYYYMMDD)', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M',
     'COLUMN', 'M15'
go

exec sp_addextendedproperty 'MS_Description', N'Az a dĂˇtum ameddig a bank a kamatot szĂˇmolta. ', 'SCHEMA', 'IFC',
     'TABLE', 'OTP_SRM_M', 'COLUMN', 'M16'
go

exec sp_addextendedproperty 'MS_Description', N'SRM-Faktoring szerzĹ‘dĂ©sszĂˇm (pl: 8000-E00-20181220-J2)', 'SCHEMA',
     'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN', 'M17'
go

exec sp_addextendedproperty 'MS_Description', N'EngedmĂ©nyezĹ‘ (OTP Bank Nyrt, OTP JZB Zrt, OTP LakĂˇstakarĂ©k Zrt)',
     'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN', 'M18'
go

exec sp_addextendedproperty 'MS_Description', N'WOB azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN', 'M19'
go

exec sp_addextendedproperty 'MS_Description',
     N'Az a dĂˇtum, amikor az SRM-ben a szerzĹ‘dĂ©s lezĂˇrĂˇsra kerĂĽl. Ez a dĂˇtum kerĂĽl a szerzĹ‘dĂ©s keltezĂ©se mezĹ‘be. (YYYYMMDD)',
     'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN', 'M20'
go

exec sp_addextendedproperty 'MS_Description', N'Egy szerzĹ‘dĂ©sen belĂĽli tĂ©telszĂˇm', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_M', 'COLUMN', 'M21'
go

exec sp_addextendedproperty 'MS_Description', N'HiteltĂ­pus', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN', 'M22'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN',
     'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M', 'COLUMN',
     'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'OTP_SRM_M', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'OTP_SRM_M',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_M', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_M', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_M', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_SRM_M', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.OTP_TA_FC
(
    ID                   numeric(22) identity
        constraint PK_OTP_TA_FC
            primary key,
    FC01                 nvarchar(30),
    FC02                 nvarchar(24),
    FC03                 nvarchar(3),
    FC04                 nvarchar(2),
    FC05                 nvarchar(20),
    FC06                 nvarchar(8),
    FC07                 nvarchar(2),
    FC08                 nvarchar(35),
    FC09                 nvarchar(35),
    FC10                 nvarchar(35),
    FC11                 nvarchar(15),
    FC12                 nvarchar(80),
    FC13                 nvarchar(50),
    FC14                 nvarchar(22),
    FC15                 nvarchar(22),
    FC16                 nvarchar(22),
    FC17                 nvarchar(2),
    FC18                 nvarchar(35),
    FC19                 nvarchar(4),
    FileName             nvarchar(500),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', N'FiĂłkkĂłd', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC', 'COLUMN', 'FC01'
go

exec sp_addextendedproperty 'MS_Description', N'HitelszĂˇmlaszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC', 'COLUMN',
     'FC02'
go

exec sp_addextendedproperty 'MS_Description', N'AlszĂˇmlaszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC', 'COLUMN', 'FC03'
go

exec sp_addextendedproperty 'MS_Description', N'ForrĂˇsrendszer azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC',
     'COLUMN', 'FC04'
go

exec sp_addextendedproperty 'MS_Description', N'SzerzĹ‘dĂ©sszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC', 'COLUMN',
     'FC05'
go

exec sp_addextendedproperty 'MS_Description', N'AdĂłs sorszĂˇma, GWB ĂĽgyfĂ©lszĂˇm', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FC', 'COLUMN', 'FC06'
go

exec sp_addextendedproperty 'MS_Description', N'CĂ­mptipus', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC', 'COLUMN', 'FC07'
go

exec sp_addextendedproperty 'MS_Description', N'IrĂˇnyĂ­tĂłszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC', 'COLUMN',
     'FC08'
go

exec sp_addextendedproperty 'MS_Description', N'VĂˇros', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC', 'COLUMN', 'FC09'
go

exec sp_addextendedproperty 'MS_Description', 'Utca', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC', 'COLUMN', 'FC10'
go

exec sp_addextendedproperty 'MS_Description', N'SzĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC', 'COLUMN', 'FC11'
go

exec sp_addextendedproperty 'MS_Description', N'Szabad szĂ¶veges cĂ­m', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC', 'COLUMN',
     'FC12'
go

exec sp_addextendedproperty 'MS_Description', N'CĂ­m Ă©rvĂ©nyessĂ©g kezdete', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC',
     'COLUMN', 'FC13'
go

exec sp_addextendedproperty 'MS_Description', N'Faktoring cĂ­m azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC',
     'COLUMN', 'FC14'
go

exec sp_addextendedproperty 'MS_Description', N'Faktoring ĂĽgyfĂ©l azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC',
     'COLUMN', 'FC15'
go

exec sp_addextendedproperty 'MS_Description', N'Faktoring kĂ¶vetelĂ©s azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FC', 'COLUMN', 'FC16'
go

exec sp_addextendedproperty 'MS_Description', N'MĂłdosĂ­tĂˇs sorszĂˇma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC',
     'COLUMN', 'FC17'
go

exec sp_addextendedproperty 'MS_Description', N'OszĂˇg nĂ©v', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC', 'COLUMN', 'FC18'
go

exec sp_addextendedproperty 'MS_Description', N'OrszĂˇg kĂłd', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FC', 'COLUMN', 'FC19'
go

create table IFC.OTP_TA_FF
(
    ID                   numeric(22) identity
        constraint PK_OTP_TA_FF
            primary key,
    FF01                 nvarchar(30),
    FF02                 nvarchar(24),
    FF03                 nvarchar(3),
    FF04                 nvarchar(2),
    FF05                 nvarchar(20),
    FF06                 nvarchar(30),
    FF07                 nvarchar(30),
    FF08                 nvarchar(5),
    FF09                 nvarchar(22),
    FF10                 nvarchar(30),
    FF11                 nvarchar(2),
    FF12                 nvarchar(2),
    FF13                 nvarchar(24),
    FF14                 nvarchar(24),
    FF15                 nvarchar(50),
    FF16                 nvarchar(50),
    FF17                 nvarchar(50),
    FF18                 nvarchar(35),
    FF19                 nvarchar(35),
    FF20                 nvarchar(35),
    FF21                 nvarchar(15),
    FF22                 nvarchar(80),
    FF23                 nvarchar(22),
    FF24                 nvarchar(22),
    FF25                 nvarchar(22),
    FF26                 nvarchar(22),
    FF27                 nvarchar(50),
    FF28                 nvarchar(8),
    FF29                 nvarchar(22),
    FF30                 nvarchar(22),
    FF31                 nvarchar(22),
    FF32                 nvarchar(2),
    FileName             nvarchar(500),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', N'FiĂłkkĂłd', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN', 'FF01'
go

exec sp_addextendedproperty 'MS_Description', N'HitelszĂˇmlaszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN',
     'FF02'
go

exec sp_addextendedproperty 'MS_Description', N'AlszĂˇmlaszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN', 'FF03'
go

exec sp_addextendedproperty 'MS_Description', N'ForrĂˇsrendszer azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF',
     'COLUMN', 'FF04'
go

exec sp_addextendedproperty 'MS_Description', N'SzerzĹ‘dĂ©sszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN',
     'FF05'
go

exec sp_addextendedproperty 'MS_Description', N'Fedezet azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN',
     'FF06'
go

exec sp_addextendedproperty 'MS_Description', N'TulajdonrĂ©sz azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF',
     'COLUMN', 'FF07'
go

exec sp_addextendedproperty 'MS_Description', N'Tulajdoni hĂˇnyad', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN',
     'FF08'
go

exec sp_addextendedproperty 'MS_Description', N'Tulajdoni hĂˇnyad %', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN',
     'FF09'
go

exec sp_addextendedproperty 'MS_Description', N'MegnevezĂ©s', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN', 'FF10'
go

exec sp_addextendedproperty 'MS_Description', 'Fedezet tipus', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN', 'FF11'
go

exec sp_addextendedproperty 'MS_Description', 'Fedezet jellege', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN', 'FF12'
go

exec sp_addextendedproperty 'MS_Description', N'Helyrajzi szĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN',
     'FF13'
go

exec sp_addextendedproperty 'MS_Description', N'JelzĂˇlog bejegyzĂ©s szĂˇma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF',
     'COLUMN', 'FF14'
go

exec sp_addextendedproperty 'MS_Description', 'Bejegyzes kelte', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN', 'FF15'
go

exec sp_addextendedproperty 'MS_Description', N'VH bejegyzĂ©s szĂˇma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN',
     'FF16'
go

exec sp_addextendedproperty 'MS_Description', N'VH bejegyzĂ©s kelte', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN',
     'FF17'
go

exec sp_addextendedproperty 'MS_Description', N'IrĂˇnyĂ­tĂłszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN',
     'FF18'
go

exec sp_addextendedproperty 'MS_Description', N'VĂˇros', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN', 'FF19'
go

exec sp_addextendedproperty 'MS_Description', 'Utca', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN', 'FF20'
go

exec sp_addextendedproperty 'MS_Description', N'HĂˇzszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN', 'FF21'
go

exec sp_addextendedproperty 'MS_Description', N'SzabadszĂ¶veges cĂ­m', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN',
     'FF22'
go

exec sp_addextendedproperty 'MS_Description', N'Ă‰rtĂ©k fedezetebe adĂˇskor', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF',
     'COLUMN', 'FF23'
go

exec sp_addextendedproperty 'MS_Description', N'MenekĂĽlĂ©si Ă©rtĂ©k', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN',
     'FF24'
go

exec sp_addextendedproperty 'MS_Description', N'ValĂłs piaci Ă©rtĂ©k', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF', 'COLUMN',
     'FF25'
go

exec sp_addextendedproperty 'MS_Description', N'ValĂłs menekĂĽlĂ©si Ă©rtĂ©k', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF',
     'COLUMN', 'FF26'
go

exec sp_addextendedproperty 'MS_Description', N'Ă‰rtĂ©kbecslĂ©s dĂˇtuma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF',
     'COLUMN', 'FF27'
go

exec sp_addextendedproperty 'MS_Description', N'Fedezet tulajdonosĂˇnak ĂĽgyfĂ©lkĂłdja', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FF', 'COLUMN', 'FF28'
go

exec sp_addextendedproperty 'MS_Description', N'Faktoring fedezeti azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF',
     'COLUMN', 'FF29'
go

exec sp_addextendedproperty 'MS_Description', N'Faktoring ĂĽgyfĂ©l azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF',
     'COLUMN', 'FF30'
go

exec sp_addextendedproperty 'MS_Description', N'Faktoring kĂ¶vetelĂ©sazonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FF', 'COLUMN', 'FF31'
go

exec sp_addextendedproperty 'MS_Description', N'MĂłdosĂ­tĂˇs sorszĂˇma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FF',
     'COLUMN', 'FF32'
go

create table IFC.OTP_TA_FK
(
    ID                   numeric(22) identity
        constraint PK_OTP_TA_FK
            primary key,
    FK01                 nvarchar(30),
    FK02                 nvarchar(24),
    FK03                 nvarchar(3),
    FK04                 nvarchar(2),
    FK05                 nvarchar(20),
    FK06                 nvarchar(30),
    FK07                 nvarchar(3),
    FK08                 nvarchar(3),
    FK09                 nvarchar(60),
    FK10                 nvarchar(22),
    FK11                 nvarchar(22),
    FK12                 nvarchar(22),
    FK13                 nvarchar(22),
    FK14                 nvarchar(3),
    FK15                 nvarchar(22),
    FK16                 nvarchar(22),
    FK17                 nvarchar(22),
    FK18                 nvarchar(22),
    FK19                 nvarchar(50),
    FK20                 nvarchar(50),
    FK21                 nvarchar(50),
    FK22                 nvarchar(2),
    FK23                 nvarchar(2),
    FK24                 nvarchar(2),
    FK25                 nvarchar(50),
    FK26                 nvarchar(22),
    FK27                 nvarchar(22),
    FK28                 nvarchar,
    FK29                 nvarchar,
    FK30                 nvarchar(50),
    FK31                 nvarchar(50),
    FK32                 nvarchar(50),
    FK33                 nvarchar(22),
    FK34                 nvarchar(30),
    FK35                 nvarchar(2),
    FK36                 nvarchar(2),
    FK37                 nvarchar(22),
    FK38                 nvarchar(22),
    FK39                 nvarchar,
    FK40                 nvarchar(50),
    FK41                 nvarchar(50),
    FK42                 nvarchar(50),
    FK43                 nvarchar(21),
    FK44                 nvarchar(18),
    FK45                 nvarchar(2),
    FK46                 nvarchar(3),
    FK47                 nvarchar(50),
    FK48                 nvarchar(50),
    FK49                 nvarchar(22),
    FK50                 nvarchar(22),
    FK51                 nvarchar(22),
    FK52                 nvarchar(2),
    FK53                 nvarchar,
    FK54                 nvarchar,
    FK55                 nvarchar(22),
    FK56                 nvarchar(240),
    FK57                 nvarchar(32),
    FK58                 nvarchar(50),
    FK59                 nvarchar(22),
    FK60                 nvarchar(22),
    FK61                 nvarchar,
    FK62                 nvarchar(22),
    FK63                 nvarchar(18),
    FileName             nvarchar(500),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    FK64                 nvarchar(230),
    FK65                 nvarchar(230),
    FK66                 nvarchar(230),
    FK67                 nvarchar(230),
    FK68                 nvarchar(230),
    FK69                 nvarchar(230),
    FK70                 nvarchar(230),
    FK71                 nvarchar(230),
    FK72                 nvarchar(230),
    FK73                 nvarchar(230),
    FK74                 nvarchar(230)
)
go

exec sp_addextendedproperty 'MS_Description', N'FiĂłkkĂłd', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK01'
go

exec sp_addextendedproperty 'MS_Description', N'HitelszĂˇmlaszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK02'
go

exec sp_addextendedproperty 'MS_Description', N'AlszĂˇmlaszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK03'
go

exec sp_addextendedproperty 'MS_Description', N'ForrĂˇsrendszer azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK04'
go

exec sp_addextendedproperty 'MS_Description', N'SzerzĹ‘dĂ©sszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK05'
go

exec sp_addextendedproperty 'MS_Description', N'Analitikus szĂˇmlaszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK06'
go

exec sp_addextendedproperty 'MS_Description', N'ĂśzletĂˇg', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK07'
go

exec sp_addextendedproperty 'MS_Description', N'HiteltĂ­pus', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK08'
go

exec sp_addextendedproperty 'MS_Description', N'AdĂłs neve', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK09'
go

exec sp_addextendedproperty 'MS_Description', N'AktuĂˇlis tĹ‘ke', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK10'
go

exec sp_addextendedproperty 'MS_Description', N'KĂ¶nyvelt ĂĽgyleti kamat', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK11'
go

exec sp_addextendedproperty 'MS_Description', N'KĂ¶nyvelt kĂ©sedelmi kamat', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK12'
go

exec sp_addextendedproperty 'MS_Description', N'KĂ¶nyvelt kĂ¶ltsĂ©g', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK13'
go

exec sp_addextendedproperty 'MS_Description', N'KĂ¶vetelĂ©s pĂ©nzneme', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK14'
go

exec sp_addextendedproperty 'MS_Description', N'Ă–sszes kĂ¶vetelĂ©s Ă©rtĂ©ke', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK15'
go

exec sp_addextendedproperty 'MS_Description', N'FelmondĂˇskori kamat %', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK16'
go

exec sp_addextendedproperty 'MS_Description', N'KĂ©sedelmi kamat %', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK17'
go

exec sp_addextendedproperty 'MS_Description', N'KĂ¶ltsĂ©g %', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK18'
go

exec sp_addextendedproperty 'MS_Description', N'FelmondĂˇs dĂˇtuma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK19'
go

exec sp_addextendedproperty 'MS_Description', N'SzerzĹ‘dĂ©skĂ¶tĂ©s dĂˇtuma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK20'
go

exec sp_addextendedproperty 'MS_Description', N'KĂ©sĂ©delembe esĂ©s dĂˇtuma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK21'
go

exec sp_addextendedproperty 'MS_Description', N'FizetĂ©si mĂłd', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK22'
go

exec sp_addextendedproperty 'MS_Description', N'FizetĂ©si hatĂˇridĹ‘', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK23'
go

exec sp_addextendedproperty 'MS_Description', N'ĂrkĂ©pzĂ©si mĂłd', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK24'
go

exec sp_addextendedproperty 'MS_Description', N'FordulĂłnap', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK25'
go

exec sp_addextendedproperty 'MS_Description', N'VĂ©telĂˇr', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK26'
go

exec sp_addextendedproperty 'MS_Description', N'RĂ©giĂł kĂłd', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK27'
go

exec sp_addextendedproperty 'MS_Description', N'ĂtadĂˇs tĂ­pusa', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK28'
go

exec sp_addextendedproperty 'MS_Description', N'StĂˇtusz', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK29'
go

exec sp_addextendedproperty 'MS_Description', N'SzerzĹ‘dĂ©s dĂˇtuma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK30'
go

exec sp_addextendedproperty 'MS_Description', N'KockĂˇzati pool azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK31'
go

exec sp_addextendedproperty 'MS_Description', N'Baseli termĂ©ktipus', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK32'
go

exec sp_addextendedproperty 'MS_Description', N'Faktoring kĂ¶vetelĂ©sazonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FK', 'COLUMN', 'FK33'
go

exec sp_addextendedproperty 'MS_Description', N'Faktoring Ăˇltal kapott OTP-s azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FK', 'COLUMN', 'FK34'
go

exec sp_addextendedproperty 'MS_Description', N'AktuĂˇlis mĂłdosĂ­tĂł ĂˇllomĂˇny sorszĂˇma', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FK', 'COLUMN', 'FK35'
go

exec sp_addextendedproperty 'MS_Description', N'A rekord melyik mĂłdosĂ­tĂˇsban mĂłdosult', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FK', 'COLUMN', 'FK36'
go

exec sp_addextendedproperty 'MS_Description', N'NettĂł tĂ©rĂĽlĂ©s %', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK37'
go

exec sp_addextendedproperty 'MS_Description', N'SzerzĹ‘dĂ©s Ă¶sszege', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK38'
go

exec sp_addextendedproperty 'MS_Description', N'A BAR-ba felkerĂĽlĂ©s lehetĹ‘sĂ©gĂ©t szerzĹ‘dĂ©sben elfogadta',
     'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK39'
go

exec sp_addextendedproperty 'MS_Description', N'Az ĂĽgylet 90 napos figyelĂ©sĂ©nek kezdĹ‘ dĂˇtuma', 'SCHEMA', 'IFC',
     'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK40'
go

exec sp_addextendedproperty 'MS_Description', N'Az ĂĽgyfĂ©lnek kĂĽldĂ¶tt figyelmeztetĹ‘ levĂ©l dĂˇtuma', 'SCHEMA',
     'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK41'
go

exec sp_addextendedproperty 'MS_Description', N'Amikor a forrĂˇsrendzser BAR-ba feladta', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FK', 'COLUMN', 'FK42'
go

exec sp_addextendedproperty 'MS_Description', N'KezelĂ©si kĂ¶ltsĂ©g minimuma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK43'
go

exec sp_addextendedproperty 'MS_Description', N'KezelĂ©si kĂ¶ltsĂ©g maximuma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK44'
go

exec sp_addextendedproperty 'MS_Description', N'BiztosĂ­tĂł tĂˇrsasĂˇg', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK45'
go

exec sp_addextendedproperty 'MS_Description', N'BiztosĂ­tĂˇs mĂłdozat', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK46'
go

exec sp_addextendedproperty 'MS_Description', N'BiztosĂ­tĂˇs kezdete', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK47'
go

exec sp_addextendedproperty 'MS_Description', N'BiztosĂ­tĂˇs vĂ©ge', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK48'
go

exec sp_addextendedproperty 'MS_Description', N'BiztosĂ­tĂˇs Ă¶sszege', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN',
     'FK49'
go

exec sp_addextendedproperty 'MS_Description', N'Ă–sszes esedĂ©kes biztosĂ­tĂˇsi dĂ­j', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FK', 'COLUMN', 'FK50'
go

exec sp_addextendedproperty 'MS_Description', N'Ă–sszes megfizetett biztosĂ­tĂˇsi dĂ­j', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FK', 'COLUMN', 'FK51'
go

exec sp_addextendedproperty 'MS_Description', N'TelepĂĽlĂ©s minĹ‘sĂ­tĂ©s kategĂłria', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FK', 'COLUMN', 'FK52'
go

exec sp_addextendedproperty 'MS_Description', N'HVP jelzĹ‘', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK53'
go

exec sp_addextendedproperty 'MS_Description', N'SpeciĂˇlis felmondott jelzĹ‘', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK54'
go

exec sp_addextendedproperty 'MS_Description', 'KONSTRUKCIO_ID', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK55'
go

exec sp_addextendedproperty 'MS_Description', 'KONSTRUKCIO_NEV', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK56'
go

exec sp_addextendedproperty 'MS_Description', 'KONSTR_FORRAS_RENDSZER_KOD', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK57'
go

exec sp_addextendedproperty 'MS_Description', N'HĂˇtralĂ©kba esĂ©s dĂˇtuma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK58'
go

exec sp_addextendedproperty 'MS_Description', N'Ă–sszeg, amelybĹ‘l az eladĂˇsi Ăˇrat szĂˇmoljĂˇk.', 'SCHEMA', 'IFC',
     'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK59'
go

exec sp_addextendedproperty 'MS_Description', N'DevizaszĂˇmla HUF dĂ­jegyenlege', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK60'
go

exec sp_addextendedproperty 'MS_Description', N'Hitelgarancia bevĂˇltĂˇs jelzĹ‘je', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FK', 'COLUMN', 'FK61'
go

exec sp_addextendedproperty 'MS_Description', N'Az ĂĽgyfĂ©l Ăˇltal a hitelre befizetett tĂ¶rlesztĂ©s teljes Ă¶sszege',
     'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK', 'COLUMN', 'FK62'
go

exec sp_addextendedproperty 'MS_Description', N'KHR szerzĹ‘dĂ©s azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FK',
     'COLUMN', 'FK63'
go

create table IFC.OTP_TA_FN
(
    ID                   numeric(22) identity
        constraint PK_OTP_TA_FN
            primary key,
    FN01                 nvarchar(3),
    FN02                 nvarchar(10),
    FN03                 nvarchar(25),
    FN04                 nvarchar(10),
    FileName             nvarchar(500),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', N'ForrĂˇsrendszer azonosĂ­tĂł (SRM, GWB)', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FN', 'COLUMN', 'FN01'
go

exec sp_addextendedproperty 'MS_Description', N'ElĹ‘ĂˇllĂ­tĂˇs napja (2000.01.01. Ăłta eltelt napok)', 'SCHEMA', 'IFC',
     'TABLE', 'OTP_TA_FN', 'COLUMN', 'FN02'
go

exec sp_addextendedproperty 'MS_Description', N'FilenĂ©v', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FN', 'COLUMN', 'FN03'
go

exec sp_addextendedproperty 'MS_Description', N'RekordszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FN', 'COLUMN', 'FN04'
go

create table IFC.OTP_TA_FU
(
    ID                   numeric(22) identity
        constraint PK_OTP_TA_FU
            primary key,
    FU01                 nvarchar(30),
    FU02                 nvarchar(24),
    FU03                 nvarchar(3),
    FU04                 nvarchar(2),
    FU05                 nvarchar(20),
    FU06                 nvarchar(8),
    FU07                 nvarchar(2),
    FU08                 nvarchar(30),
    FU09                 nvarchar(60),
    FU10                 nvarchar(30),
    FU11                 nvarchar(30),
    FU12                 nvarchar(30),
    FU13                 nvarchar(35),
    FU14                 nvarchar(35),
    FU15                 nvarchar(30),
    FU16                 nvarchar(50),
    FU17                 nvarchar(11),
    FU18                 nvarchar(10),
    FU19                 nvarchar(50),
    FU20                 nvarchar(30),
    FU21                 nvarchar(30),
    FU22                 nvarchar(15),
    FU23                 nvarchar(15),
    FU24                 nvarchar(24),
    FU25                 nvarchar(24),
    FU26                 nvarchar(24),
    FU27                 nvarchar(24),
    FU28                 nvarchar(15),
    FU29                 nvarchar(15),
    FU30                 nvarchar(15),
    FU31                 nvarchar,
    FU32                 nvarchar(22),
    FU33                 nvarchar(22),
    FU34                 nvarchar(2),
    FU35                 nvarchar(4),
    FU36                 nvarchar(30),
    FU37                 nvarchar,
    FU38                 nvarchar(22),
    FU39                 nvarchar(50),
    FU40                 nvarchar(4),
    FU41                 nvarchar(30),
    FU42                 nvarchar(24),
    FU43                 nvarchar(24),
    FU44                 nvarchar,
    FileName             nvarchar(500),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', N'FiĂłkkĂłd', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU01'
go

exec sp_addextendedproperty 'MS_Description', N'HitelszĂˇmlaszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU02'
go

exec sp_addextendedproperty 'MS_Description', N'AlszĂˇmlaszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU03'
go

exec sp_addextendedproperty 'MS_Description', N'ForrĂˇsrendszer azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU',
     'COLUMN', 'FU04'
go

exec sp_addextendedproperty 'MS_Description', N'SzerzĹ‘dĂ©sszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU05'
go

exec sp_addextendedproperty 'MS_Description', N'AdĂłs sorszĂˇma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU06'
go

exec sp_addextendedproperty 'MS_Description', 'Kapcsolat jellege', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU07'
go

exec sp_addextendedproperty 'MS_Description', N'Analitikus szĂˇmlaszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU',
     'COLUMN', 'FU08'
go

exec sp_addextendedproperty 'MS_Description', N'ĂśgyfĂ©l neve', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU09'
go

exec sp_addextendedproperty 'MS_Description', N'VezetĂ©knĂ©v', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU10'
go

exec sp_addextendedproperty 'MS_Description', N'UtĂłnĂ©v', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU11'
go

exec sp_addextendedproperty 'MS_Description', N'ElĹ‘zĹ‘ nĂ©v', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU12'
go

exec sp_addextendedproperty 'MS_Description', N'LeĂˇnykori nĂ©v', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU13'
go

exec sp_addextendedproperty 'MS_Description', 'Anyja neve', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU14'
go

exec sp_addextendedproperty 'MS_Description', N'SzĂĽletĂ©si hely', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU15'
go

exec sp_addextendedproperty 'MS_Description', N'SzĂĽletĂ©si dĂˇtum', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU16'
go

exec sp_addextendedproperty 'MS_Description', N'SzemĂ©lyi szĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU17'
go

exec sp_addextendedproperty 'MS_Description', N'AdĂłazonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU18'
go

exec sp_addextendedproperty 'MS_Description', N'HosszĂş nĂ©v', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU19'
go

exec sp_addextendedproperty 'MS_Description', N'RĂ¶vid nĂ©v', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU20'
go

exec sp_addextendedproperty 'MS_Description', N'CĂ©gforma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU21'
go

exec sp_addextendedproperty 'MS_Description', N'AdĂłszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU22'
go

exec sp_addextendedproperty 'MS_Description', N'CĂ©gjegyzĂ©kszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU23'
go

exec sp_addextendedproperty 'MS_Description', 'Telefon 1', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU24'
go

exec sp_addextendedproperty 'MS_Description', 'Telefon 2', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU25'
go

exec sp_addextendedproperty 'MS_Description', 'Mobil', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU26'
go

exec sp_addextendedproperty 'MS_Description', N'E-Mail cĂ­m', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU27'
go

exec sp_addextendedproperty 'MS_Description', N'SzemĂ©lyi ig. szĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU28'
go

exec sp_addextendedproperty 'MS_Description', N'ĂštlevelszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU29'
go

exec sp_addextendedproperty 'MS_Description', N'JogosĂ­tvĂˇny szĂˇma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU30'
go

exec sp_addextendedproperty 'MS_Description', N'AdatĂˇtadĂˇshoz hozzĂˇjĂˇrult', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU',
     'COLUMN', 'FU31'
go

exec sp_addextendedproperty 'MS_Description', N'Faktoring ĂĽgyfĂ©l azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU',
     'COLUMN', 'FU32'
go

exec sp_addextendedproperty 'MS_Description', N'Faktoring kĂ¶vetelĂ©s azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FU', 'COLUMN', 'FU33'
go

exec sp_addextendedproperty 'MS_Description', N'MĂłdosĂ­tĂˇs szĂˇma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU34'
go

exec sp_addextendedproperty 'MS_Description', N'ĂllampolgĂˇrsĂˇg (OrszĂˇgkĂłd)', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU',
     'COLUMN', 'FU35'
go

exec sp_addextendedproperty 'MS_Description', N'ĂśgyfĂ©l banki azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU',
     'COLUMN', 'FU36'
go

exec sp_addextendedproperty 'MS_Description', N'ĂśgyfĂ©l banki azonosĂ­tĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU',
     'COLUMN', 'FU37'
go

exec sp_addextendedproperty 'MS_Description', N'BAR mulasztĂˇs azonosĂ­tĂł (Aki mĂˇr BAR-ban van)', 'SCHEMA', 'IFC',
     'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU38'
go

exec sp_addextendedproperty 'MS_Description', N'AktuĂˇlis BAR stĂˇtusz dĂˇtuma', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU',
     'COLUMN', 'FU39'
go

exec sp_addextendedproperty 'MS_Description', N'MNB szektorkĂłd (vĂˇllalati ĂĽgyfeleknĂ©l)', 'SCHEMA', 'IFC', 'TABLE',
     'OTP_TA_FU', 'COLUMN', 'FU40'
go

exec sp_addextendedproperty 'MS_Description', N'KapcsolattartĂł', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN',
     'FU41'
go

exec sp_addextendedproperty 'MS_Description', N'1. legjobb telefonszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU',
     'COLUMN', 'FU42'
go

exec sp_addextendedproperty 'MS_Description', N'2. legjobb telefonszĂˇm', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU',
     'COLUMN', 'FU43'
go

exec sp_addextendedproperty 'MS_Description', 'Elhunyt-e', 'SCHEMA', 'IFC', 'TABLE', 'OTP_TA_FU', 'COLUMN', 'FU44'
go

create table GEN.ObjectType
(
    Code                 nvarchar(200) not null
        constraint PK_ObjectType
            primary key
        constraint FK_ObjectType_Code
            references GEN.Code,
    TableName            nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    CanBeGroupedCode     nvarchar(200)
        constraint FK_ObjectType_Code_02
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Object type code -> value set OBJECT_TYPE', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectType', 'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Table name', 'SCHEMA', 'GEN', 'TABLE', 'ObjectType', 'COLUMN',
     'TableName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'ObjectType',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'ObjectType',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'ObjectType',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectType', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectType', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'ObjectType',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Can be grouped -> value set BOOLEAN', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectType', 'COLUMN', 'CanBeGroupedCode'
go

create table GEN.Page
(
    ID                   numeric(16) identity
        constraint PK_Page
            primary key,
    Name                 nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table COM.Party
(
    ID                   numeric(16) not null
        constraint [PK_COM.Party]
            primary key,
    InteractionID        numeric(16),
    CreationDate         date        not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

create table GEN.Portfolio
(
    ID                   numeric(16) identity
        constraint PK_Portfolio
            primary key,
    Name                 nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    TreatmentTypeCode    nvarchar(200)
        constraint FK_Portfolio_Code
            references GEN.Code,
    Code                 nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'Portfolio', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Name of the portfolio', 'SCHEMA', 'GEN', 'TABLE', 'Portfolio', 'COLUMN',
     'Name'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'Portfolio',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'Portfolio',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'Portfolio', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'Portfolio', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'Portfolio', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Treatment method -> value set TREATMENT_TYPE', 'SCHEMA', 'GEN', 'TABLE',
     'Portfolio', 'COLUMN', 'TreatmentTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Code of the portfolio (used in AD)', 'SCHEMA', 'GEN', 'TABLE',
     'Portfolio', 'COLUMN', 'Code'
go

create table GEN.Object
(
    ID                   numeric(16) identity
        constraint [PK_GEN.Object]
            primary key,
    ObjectType           nvarchar(200)
        constraint FK_Object_ObjectType
            references GEN.ObjectType,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    PrevObjectID         numeric(16)
        constraint FK_Object_Object
            references GEN.Object,
    VersionNr            nvarchar(50),
    PortfolioID          numeric(16)
        constraint FK_Object_Portfolio
            references GEN.Portfolio
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'GEN', 'TABLE', 'Object', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Type of the specified object', 'SCHEMA', 'GEN', 'TABLE', 'Object',
     'COLUMN', 'ObjectType'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'GEN', 'TABLE', 'Object',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'GEN', 'TABLE', 'Object',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'GEN', 'TABLE', 'Object',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'GEN', 'TABLE',
     'Object', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'GEN', 'TABLE', 'Object',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'GEN', 'TABLE', 'Object',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'GEN', 'TABLE', 'Object', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Portfolio identifier -> GEN.Portfolio', 'SCHEMA', 'GEN', 'TABLE',
     'Object', 'COLUMN', 'PortfolioID'
go

create table ORG.Action
(
    ID                   numeric(16) identity
        constraint PK_Action
            primary key,
    ObjectID             numeric(16)
        constraint FK_Action_Object
            references GEN.Object,
    ActionCode           nvarchar(200)
        constraint FK_Action_Code
            references GEN.Code,
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'Action', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE', 'Action',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Action value set -> TASK_ACTION', 'SCHEMA', 'ORG', 'TABLE', 'Action',
     'COLUMN', 'ActionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'ORG', 'TABLE', 'Action', 'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'ORG', 'TABLE', 'Action', 'COLUMN', 'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'Action',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'Action',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'Action',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'Action', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'Action', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'Action',
     'COLUMN', 'LastModifiedUserName'
go

create index IXFK_Action_Code
    on ORG.Action (ActionCode)
go

create index IXFK_Action_Object
    on ORG.Action (ObjectID)
go

create table FIN.Calculation
(
    ID                   numeric(16) identity
        constraint PK_Calculation
            primary key,
    ObjectID             numeric(16)
        constraint FK_Calculation_Object
            references GEN.Object,
    RelationObjectID     numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    CalculationDate      date,
    FeeListID            numeric(16)
        constraint FK_Calculation_FeeList
            references FIN.FeeList
)
go

exec sp_addextendedproperty 'MS_Description', 'Date of the calculation', 'SCHEMA', 'FIN', 'TABLE', 'Calculation',
     'COLUMN', 'CalculationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Fee list identifier -> FIN.FeeList', 'SCHEMA', 'FIN', 'TABLE',
     'Calculation', 'COLUMN', 'FeeListID'
go

create table FIN.Account
(
    ID                   numeric(16) identity
        constraint PK_Account
            primary key,
    ObjectID             numeric(16)
        constraint FK_Account_Object
            references GEN.Object,
    CalculationID        numeric(16)
        constraint FK_Account_Calculation
            references FIN.Calculation,
    AccountTypeID        numeric(16),
    Balance              money,
    InvoiceLineID        numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    CurrencyCode         nvarchar(200)
        constraint FK_Account_Code
            references GEN.Code,
    InvoiceArrearsID     numeric(16)
)
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> CURRENCY', 'SCHEMA', 'FIN', 'TABLE', 'Account', 'COLUMN',
     'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Arrears line in the invoice -> FIN.InvoiceArrearsID', 'SCHEMA', 'FIN',
     'TABLE', 'Account', 'COLUMN', 'InvoiceArrearsID'
go

create index IXFK_Account_AccountType
    on FIN.Account (AccountTypeID)
go

create index IXFK_Account_Calculation
    on FIN.Account (CalculationID)
go

create index IXFK_Account_Object
    on FIN.Account (ObjectID)
go

create index IXFK_Account_Code
    on FIN.Account (CurrencyCode)
go

create index IXFK_Account_InvoiceArrears
    on FIN.Account (InvoiceArrearsID)
go

create table FIN.AccountType
(
    ID                   numeric(16) identity
        constraint PK_AccountType
            primary key,
    ObjectID             numeric(16)
        constraint FK_AccountType_Object
            references GEN.Object,
    Code                 nvarchar(200),
    MainClass            nvarchar(200),
    AccountNr            nvarchar(200),
    Pending              nvarchar(200)
        constraint FK_AccountType_Code
            references GEN.Code,
    AutoPending          nvarchar(200)
        constraint FK_AccountType_Code_02
            references GEN.Code,
    PendingAccountTypeID numeric(16)
        constraint FK_AccountType_AccountType
            references FIN.AccountType,
    PendingAccountID     numeric(16)
        constraint FK_AccountType_Account
            references FIN.Account,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    RelatedObjectType    nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Related object type -> OBJECT_TYPE', 'SCHEMA', 'FIN', 'TABLE',
     'AccountType', 'COLUMN', 'RelatedObjectType'
go

alter table FIN.Account
    add constraint FK_Account_AccountType
        foreign key (AccountTypeID) references FIN.AccountType
go

create index IXFK_AccountType_Account
    on FIN.AccountType (PendingAccountID)
go

create index IXFK_AccountType_AccountType
    on FIN.AccountType (PendingAccountTypeID)
go

create index IXFK_AccountType_Object
    on FIN.AccountType (ObjectID)
go

create index IXFK_Calculation_Object
    on FIN.Calculation (ObjectID)
go

create table GEN.City
(
    ID                   numeric(16) identity
        constraint PK_City
            primary key,
    ObjectID             numeric(16)
        constraint FK_City_Object
            references GEN.Object,
    CountryCode          nvarchar(200)
        constraint FK_City_Code
            references GEN.Code,
    ZipCode              nvarchar(10),
    City                 nvarchar(50),
    CityTypeCode         nvarchar(200)
        constraint FK_City_Code_02
            references GEN.Code,
    RegionCode           nvarchar(200)
        constraint FK_City_Code_03
            references GEN.Code,
    CountyCode           nvarchar(200)
        constraint FK_City_Code_04
            references GEN.Code,
    MicroRegionCode      nvarchar(200)
        constraint FK_City_Code_05
            references GEN.Code,
    Development          numeric(16),
    Inhabitants          numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE', 'City',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Country value set -> COUNTRY', 'SCHEMA', 'GEN', 'TABLE', 'City',
     'COLUMN', 'CountryCode'
go

exec sp_addextendedproperty 'MS_Description', 'Zip code', 'SCHEMA', 'GEN', 'TABLE', 'City', 'COLUMN', 'ZipCode'
go

exec sp_addextendedproperty 'MS_Description', 'City', 'SCHEMA', 'GEN', 'TABLE', 'City', 'COLUMN', 'City'
go

exec sp_addextendedproperty 'MS_Description', 'County value set -> COUNTY', 'SCHEMA', 'GEN', 'TABLE', 'City', 'COLUMN',
     'CountyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Micro region value set -> MICRO_REGION', 'SCHEMA', 'GEN', 'TABLE',
     'City', 'COLUMN', 'MicroRegionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'City',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'City',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE', 'City',
     'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE', 'City',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'City',
     'COLUMN', 'LastModifiedUserName'
go

create index IXFK_City_Code
    on GEN.City (CountryCode)
go

create index IXFK_City_Code_02
    on GEN.City (CityTypeCode)
go

create index IXFK_City_Code_03
    on GEN.City (RegionCode)
go

create index IXFK_City_Code_04
    on GEN.City (CountyCode)
go

create index IXFK_City_Code_05
    on GEN.City (MicroRegionCode)
go

create index IXFK_City_Object
    on GEN.City (ObjectID)
go

create table GEN.CityZipCode
(
    ID                   numeric(16) identity
        constraint PK_CityZipCode
            primary key,
    ObjectID             numeric(16)
        constraint FK_CityZipCode_Object
            references GEN.Object,
    CityID               numeric(16)
        constraint FK_CityZipCode_City
            references GEN.City,
    ZipCode              nvarchar(10),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'CityZipCode', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'CityZipCode', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'City identifier -> GEN.City', 'SCHEMA', 'GEN', 'TABLE', 'CityZipCode',
     'COLUMN', 'CityID'
go

exec sp_addextendedproperty 'MS_Description', 'Zip code', 'SCHEMA', 'GEN', 'TABLE', 'CityZipCode', 'COLUMN', 'ZipCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'CityZipCode',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'CityZipCode',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'CityZipCode', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'CityZipCode', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'CityZipCode', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'CityZipCode', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_CityZipCode_City
    on GEN.CityZipCode (CityID)
go

create index IXFK_CityZipCode_Object
    on GEN.CityZipCode (ObjectID)
go

create table ORG.ConditionSet
(
    ID                   numeric(16) identity
        constraint PK_ConditionSet
            primary key,
    ObjectID             numeric(16)
        constraint FK_ConditionSet_Object
            references GEN.Object,
    ConditionSetCode     nvarchar(200)
        constraint FK_ConditionSet_Code
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'ConditionSet', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ConditionSet', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Condition set code -> value set CONDITION_SET', 'SCHEMA', 'ORG', 'TABLE',
     'ConditionSet', 'COLUMN', 'ConditionSetCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ConditionSet', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ConditionSet', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ConditionSet', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ConditionSet', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ConditionSet', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ConditionSet', 'COLUMN', 'LastModifiedUserName'
go

create table PRT.Entity
(
    ID                   numeric(16) identity
        constraint [PK_CIS.Entity]
            primary key,
    ObjectID             numeric(16)
        constraint [FK_CIS.Entity_GEN.Object]
            references GEN.Object
            on delete cascade,
    EntityType           nvarchar(50),
    Status               nvarchar(200),
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    SourceID             nvarchar(200),
    SourceInterfaceType  nvarchar(200),
    OperatorUserName     nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Entity', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description',
     'Company / Person / Entrepreneur (Company + Person) / User (Person + User) / EntrepreneurUser (All three)',
     'SCHEMA', 'PRT', 'TABLE', 'Entity', 'COLUMN', 'EntityType'
go

exec sp_addextendedproperty 'MS_Description',
     N'N - NormA?l/aktA­v, D - technikailag tA¶rA¶lt, A - anonimizA?lt, X - megszL±nt/meghalt', 'SCHEMA', 'PRT',
     'TABLE', 'Entity', 'COLUMN', 'Status'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'PRT', 'TABLE', 'Entity',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Entity',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'PRT', 'TABLE', 'Entity',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'PRT', 'TABLE',
     'Entity', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Entity',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'PRT', 'TABLE', 'Entity',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'PRT', 'TABLE', 'Entity', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier (external system)', 'SCHEMA', 'PRT', 'TABLE', 'Entity',
     'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Operator user name -> PRT.AppUser', 'SCHEMA', 'PRT', 'TABLE', 'Entity',
     'COLUMN', 'OperatorUserName'
go

create table PRT.AppUser
(
    ID                   numeric(16) identity
        constraint [PK_CIS.User]
            primary key,
    UserName             nvarchar(50),
    EntityID             numeric(16)
        constraint [FK_CIS.User_CIS.Entity]
            references PRT.Entity,
    Language             nvarchar(50),
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    LanguageCode         nvarchar(200),
    DirectoryUserName    nvarchar(200),
    UserTypeCode         nvarchar(200)
        constraint FK_AppUser_Code
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'PRT', 'TABLE', 'AppUser', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'PRT', 'TABLE', 'AppUser',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'PRT', 'TABLE', 'AppUser',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'PRT', 'TABLE', 'AppUser',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'PRT', 'TABLE',
     'AppUser', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'PRT', 'TABLE', 'AppUser',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'PRT', 'TABLE', 'AppUser',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'PRT', 'TABLE', 'AppUser', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'User type code -> value set USER_TYPE', 'SCHEMA', 'PRT', 'TABLE',
     'AppUser', 'COLUMN', 'UserTypeCode'
go

create index [IXFK_CIS.User_CIS.Entity]
    on PRT.AppUser (ID)
go

create table AST.Asset
(
    ID                          numeric(16) identity
        constraint PK_Asset
            primary key,
    ObjectID                    numeric(16)
        constraint FK_Asset_Object
            references GEN.Object,
    AssetClassCode              nvarchar(200)
        constraint FK_Asset_Code
            references GEN.Code,
    AssetTypeCode               nvarchar(200)
        constraint FK_Asset_Code_02
            references GEN.Code,
    Name                        nvarchar(200),
    LandRegisterReference       nvarchar(200),
    StatusCode                  nvarchar(200)
        constraint FK_Asset_Code_03
            references GEN.Code,
    LandRegisterOfficeEntityID  numeric(16)
        constraint FK_Asset_Entity
            references PRT.Entity,
    CreationDate                date,
    CreationTime                time,
    CreationUserName            nvarchar(200),
    LastModifiedDate            date,
    LastModifiedTime            time,
    LastModifiedUserName        nvarchar(200),
    LandRegisterCity            nvarchar(100),
    ExternalReferenceNr         nvarchar(200),
    StructureSize               numeric(10, 4),
    LotSize                     numeric(10, 4),
    LotSizeUnitCode             nvarchar(200)
        constraint FK_Asset_Code_04
            references GEN.Code,
    InhabitedCode               nvarchar(200)
        constraint FK_Asset_Code_05
            references GEN.Code,
    RentedOutCode               nvarchar(200)
        constraint FK_Asset_Code_06
            references GEN.Code,
    UndividedCommonPropertyCode nvarchar(200)
        constraint FK_Asset_Code_07
            references GEN.Code,
    DataOriginCode              nvarchar(200)
        constraint FK_Asset_Code_08
            references GEN.Code,
    SourceInterfaceType         nvarchar(200),
    SourceID                    nvarchar(200),
    AssetNatureCode             nvarchar(200)
        constraint FK_Asset_Code_09
            references GEN.Code,
    OperatorUserName            nvarchar(200),
    SeparationReasonCode        nvarchar(200)
        constraint FK_Asset_Code_10
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'ASSET_CLASS ValuseSet', 'SCHEMA', 'AST', 'TABLE', 'Asset', 'COLUMN',
     'AssetClassCode'
go

exec sp_addextendedproperty 'MS_Description', 'ASSET_TYPE ValueSet', 'SCHEMA', 'AST', 'TABLE', 'Asset', 'COLUMN',
     'AssetTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'ASSET_STATUS ValueSet', 'SCHEMA', 'AST', 'TABLE', 'Asset', 'COLUMN',
     'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Lot size unit code -> ASSET_UNIT value set', 'SCHEMA', 'AST', 'TABLE',
     'Asset', 'COLUMN', 'LotSizeUnitCode'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean value set -> VALUESET_BOOLEAN', 'SCHEMA', 'AST', 'TABLE',
     'Asset', 'COLUMN', 'InhabitedCode'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean value set -> VALUESET_BOOLEAN', 'SCHEMA', 'AST', 'TABLE',
     'Asset', 'COLUMN', 'RentedOutCode'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean value set -> VALUESET_BOOLEAN', 'SCHEMA', 'AST', 'TABLE',
     'Asset', 'COLUMN', 'UndividedCommonPropertyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Data origin value set -> DATA_ORIGIN', 'SCHEMA', 'AST', 'TABLE', 'Asset',
     'COLUMN', 'DataOriginCode'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'AST', 'TABLE', 'Asset', 'COLUMN',
     'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier', 'SCHEMA', 'AST', 'TABLE', 'Asset', 'COLUMN',
     'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Asset nature -> value set ASSET_NATURE', 'SCHEMA', 'AST', 'TABLE',
     'Asset', 'COLUMN', 'AssetNatureCode'
go

exec sp_addextendedproperty 'MS_Description', 'Operator user name -> PRT.AppUser', 'SCHEMA', 'AST', 'TABLE', 'Asset',
     'COLUMN', 'OperatorUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Asset nature -> value set ASSET_DECOUPLING', 'SCHEMA', 'AST', 'TABLE',
     'Asset', 'COLUMN', 'SeparationReasonCode'
go

create index IXFK_Asset_Code
    on AST.Asset (AssetClassCode)
go

create index IXFK_Asset_Code_02
    on AST.Asset (AssetTypeCode)
go

create index IXFK_Asset_Code_03
    on AST.Asset (StatusCode)
go

create index IXFK_Asset_Entity
    on AST.Asset (LandRegisterOfficeEntityID)
go

create index IXFK_Asset_Object
    on AST.Asset (ObjectID)
go

create index IXFK_Asset_Code_04
    on AST.Asset (LotSizeUnitCode)
go

create index IXFK_Asset_Code_05
    on AST.Asset (InhabitedCode)
go

create index IXFK_Asset_Code_06
    on AST.Asset (RentedOutCode)
go

create index IXFK_Asset_Code_07
    on AST.Asset (UndividedCommonPropertyCode)
go

create index IXFK_Asset_Code_08
    on AST.Asset (DataOriginCode)
go

create table AST.AssetValuation
(
    ID                   numeric(16) identity
        constraint PK_AssetValuation
            primary key,
    ObjectID             numeric(16)
        constraint FK_AssetValuation_Object
            references GEN.Object,
    AssetID              numeric(16)
        constraint FK_AssetValuation_Asset
            references AST.Asset,
    ValuerEntityID       numeric(16)
        constraint FK_AssetValuation_Entity
            references PRT.Entity,
    ValuationDate        date,
    ValuationTypeCode    nvarchar(200)
        constraint FK_AssetValuation_Code
            references GEN.Code,
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    StatusCode           nvarchar(200)
        constraint FK_AssetValuation_Code_02
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'AST', 'TABLE', 'AssetValuation', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuation', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Asset identifier -> AST.Asset', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuation', 'COLUMN', 'AssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Valuer entity identifier -> PRT.Entity', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuation', 'COLUMN', 'ValuerEntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Valuation date', 'SCHEMA', 'AST', 'TABLE', 'AssetValuation', 'COLUMN',
     'ValuationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Valuation type -> ASSET_VALUATION_TYPE value set', 'SCHEMA', 'AST',
     'TABLE', 'AssetValuation', 'COLUMN', 'ValuationTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'AST', 'TABLE', 'AssetValuation', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'AST', 'TABLE', 'AssetValuation', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuation', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuation', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuation', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuation', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuation', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuation', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_AssetValuation_Asset
    on AST.AssetValuation (AssetID)
go

create index IXFK_AssetValuation_Code
    on AST.AssetValuation (ValuationTypeCode)
go

create index IXFK_AssetValuation_Entity
    on AST.AssetValuation (ValuerEntityID)
go

create index IXFK_AssetValuation_Object
    on AST.AssetValuation (ObjectID)
go

create table PRT.BankAccount
(
    ID                   numeric(16) identity
        constraint PK_BankAccount
            primary key,
    ObjectID             numeric(16)
        constraint FK_BankAccount_Object
            references GEN.Object,
    BankEntityID         numeric(16)
        constraint FK_BankAccount_Entity
            references PRT.Entity,
    EntityID             numeric(16)
        constraint FK_BankAccount_Entity_02
            references PRT.Entity,
    SequenceNr           numeric(3),
    AccountNumber        nvarchar(50),
    IBAN                 nvarchar(100),
    ValidFrom            date,
    ValidUntil           date,
    StatusCode           nvarchar(200)
        constraint FK_BankAccount_Code
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'PRT', 'TABLE',
     'BankAccount', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Bank entity identifier -> PRT.Entity', 'SCHEMA', 'PRT', 'TABLE',
     'BankAccount', 'COLUMN', 'BankEntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Entity identifier -> PRT.Entity', 'SCHEMA', 'PRT', 'TABLE',
     'BankAccount', 'COLUMN', 'EntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Order number in the bank account list', 'SCHEMA', 'PRT', 'TABLE',
     'BankAccount', 'COLUMN', 'SequenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Bank account number', 'SCHEMA', 'PRT', 'TABLE', 'BankAccount', 'COLUMN',
     'AccountNumber'
go

exec sp_addextendedproperty 'MS_Description', 'IBAN', 'SCHEMA', 'PRT', 'TABLE', 'BankAccount', 'COLUMN', 'IBAN'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'PRT', 'TABLE', 'BankAccount', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'PRT', 'TABLE', 'BankAccount', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Status value set -> VALUESET_STATUS', 'SCHEMA', 'PRT', 'TABLE',
     'BankAccount', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'PRT', 'TABLE', 'BankAccount',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'PRT', 'TABLE', 'BankAccount',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'PRT', 'TABLE',
     'BankAccount', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'PRT', 'TABLE',
     'BankAccount', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'PRT', 'TABLE',
     'BankAccount', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'PRT', 'TABLE',
     'BankAccount', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_BankAccount_Code
    on PRT.BankAccount (StatusCode)
go

create index IXFK_BankAccount_Entity
    on PRT.BankAccount (BankEntityID)
go

create index IXFK_BankAccount_Entity_02
    on PRT.BankAccount (EntityID)
go

create index IXFK_BankAccount_Object
    on PRT.BankAccount (ObjectID)
go

create table PRT.Company
(
    ID                   numeric(16) identity
        constraint [PK_CIS.Company]
            primary key,
    Name                 nvarchar(50),
    RegistrationNr       varchar(50),
    TaxNr                varchar(20),
    StatisticalNr        varchar(50),
    LegalFormCode        nvarchar(200)
        constraint FK_Company_Code
            references GEN.Code,
    LegalStatusCode      nvarchar(200),
    EntityID             numeric(16)
        constraint [FK_CIS.Company_CIS.Entity_02]
            references PRT.Entity
            on delete cascade,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    RegistrationDate     date,
    StatusCode           nvarchar(200)
        constraint FK_Company_Code_02
            references GEN.Code,
    CommissionedCode     nvarchar(200)
        constraint FK_Company_Code_03
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Company', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description',
     N'A¶sszhangban kellene tartani az Entity.Status-szal (kALlA¶nlegesek: felszA?molA?ssal megszL±nt, kA©nyszertA¶rlA©ssel megszL±nt)',
     'SCHEMA', 'PRT', 'TABLE', 'Company', 'COLUMN', 'LegalStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'PRT', 'TABLE', 'Company',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Company',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'PRT', 'TABLE', 'Company',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'PRT', 'TABLE',
     'Company', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Company',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'PRT', 'TABLE', 'Company',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'PRT', 'TABLE', 'Company', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'BOOLEAN valueset', 'SCHEMA', 'PRT', 'TABLE', 'Company', 'COLUMN',
     'CommissionedCode'
go

create table PRT.Balance
(
    ID                   numeric(16) identity
        constraint [PK_CIS.Balance]
            primary key,
    CompanyID            numeric(16)
        constraint [FK_CIS.Balance_CIS.Company_02]
            references PRT.Company,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    ObjectID             numeric(16)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Balance', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Company Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Balance', 'COLUMN',
     'CompanyID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'PRT', 'TABLE', 'Balance',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Balance',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'PRT', 'TABLE', 'Balance',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'PRT', 'TABLE',
     'Balance', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Balance',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'PRT', 'TABLE', 'Balance',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'PRT', 'TABLE', 'Balance', 'COLUMN', 'Comments'
go

create index [IXFK_CIS.Balance_CIS.Company]
    on PRT.Balance (ID)
go

create index [IXFK_CIS.Balance_CIS.Company_02]
    on PRT.Balance (CompanyID)
go

create index IXFK_Balance_Object
    on PRT.Balance (ObjectID)
go

create table PRT.BalanceRow
(
    ID                   numeric(16) identity
        constraint [PK_CIS.BalanceRow]
            primary key,
    BalanceRowID         numeric(16)
        constraint [FK_CIS.BalanceRow_CIS.Balance]
            references PRT.Balance,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    ObjectID             numeric(16)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'PRT', 'TABLE', 'BalanceRow', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Balancerow Identifier', 'SCHEMA', 'PRT', 'TABLE', 'BalanceRow', 'COLUMN',
     'BalanceRowID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'PRT', 'TABLE', 'BalanceRow',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'PRT', 'TABLE', 'BalanceRow',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'PRT', 'TABLE', 'BalanceRow',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'PRT', 'TABLE',
     'BalanceRow', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'PRT', 'TABLE',
     'BalanceRow', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'PRT', 'TABLE',
     'BalanceRow', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'PRT', 'TABLE', 'BalanceRow', 'COLUMN', 'Comments'
go

create index [IXFK_CIS.BalanceRow_CIS.Balance]
    on PRT.BalanceRow (BalanceRowID)
go

create index IXFK_BalanceRow_Object
    on PRT.BalanceRow (ObjectID)
go

create index [IXFK_CIS.Company_CIS.Entity]
    on PRT.Company (ID)
go

create index [IXFK_CIS.Company_CIS.Entity_02]
    on PRT.Company (ID)
go

create index IXFK_Company_Code
    on PRT.Company (LegalFormCode)
go

create index IXFK_Company_Code_02
    on PRT.Company (StatusCode)
go


create table PRT.Contact
(
    ID                   numeric(16) identity
        constraint [PK_CIS.Contanct]
            primary key,
    ContactType          nvarchar(200),
    Contact              nvarchar(150),
    ValidFrom            date,
    ValidUntil           date,
    EntityID             numeric(16)
        constraint FK_Contact_Entity
            references PRT.Entity,
    ObjectID             numeric(16)
        constraint FK_Contact_Object
            references GEN.Object,
    DataSourceCode       nvarchar(200)
        constraint FK_Contact_Code
            references GEN.Code,
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    StatusCode           nvarchar(200)
        constraint FK_Contact_Code_02
            references GEN.Code,
    DataOriginCode       nvarchar(200)
        constraint FK_Contact_Code_03
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Contact', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'GEN.Object Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Contact', 'COLUMN',
     'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Data source value set -> DATA_SOURCE', 'SCHEMA', 'PRT', 'TABLE',
     'Contact', 'COLUMN', 'DataSourceCode'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'PRT', 'TABLE', 'Contact', 'COLUMN',
     'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier (external system)', 'SCHEMA', 'PRT', 'TABLE',
     'Contact', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'PRT', 'TABLE', 'Contact',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Contact',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'PRT', 'TABLE', 'Contact',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'PRT', 'TABLE',
     'Contact', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Contact',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'PRT', 'TABLE', 'Contact',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'PRT', 'TABLE', 'Contact', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Contact status value set -> CONTACT_STATUS', 'SCHEMA', 'PRT', 'TABLE',
     'Contact', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Data origin value set -> DATA_ORIGIN', 'SCHEMA', 'PRT', 'TABLE',
     'Contact', 'COLUMN', 'DataOriginCode'
go

create index IXFK_Contact_Code
    on PRT.Contact (DataSourceCode)
go

create index IXFK_Contact_Entity
    on PRT.Contact (EntityID)
go

create index IXFK_Contact_Object
    on PRT.Contact (ObjectID)
go

create index IXFK_Contact_Code_02
    on PRT.Contact (StatusCode)
go

create table PRT.Customer
(
    ID                   numeric(16) identity
        constraint PK_Customer
            primary key,
    ObjectID             numeric(16)
        constraint FK_Customer_Object
            references GEN.Object,
    EntityID             numeric(16)
        constraint FK_Customer_Entity
            references PRT.Entity,
    CustomerNr           nvarchar(100),
    StatusCode           nvarchar(200)
        constraint FK_Customer_Code
            references GEN.Code,
    CustomerTypeCode     nvarchar(200)
        constraint FK_Customer_Code_02
            references GEN.Code,
    CustomerClassCode    nvarchar(200)
        constraint FK_Customer_Code_03
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'CUSTOMER_STATUS ValueSet', 'SCHEMA', 'PRT', 'TABLE', 'Customer',
     'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'CUSTOMER_TYPE ValueSet', 'SCHEMA', 'PRT', 'TABLE', 'Customer', 'COLUMN',
     'CustomerTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'CUSTOMER_CLASS ValueSet', 'SCHEMA', 'PRT', 'TABLE', 'Customer', 'COLUMN',
     'CustomerClassCode'
go

create index IXFK_Customer_Code
    on PRT.Customer (StatusCode)
go

create index IXFK_Customer_Code_02
    on PRT.Customer (CustomerTypeCode)
go

create index IXFK_Customer_Code_03
    on PRT.Customer (CustomerClassCode)
go

create index IXFK_Customer_Entity
    on PRT.Customer (EntityID)
go

create index IXFK_Customer_Object
    on PRT.Customer (ObjectID)
go

create table PRT.Employee
(
    ID                   numeric(16) identity
        constraint [PK_CIS.Employee]
            primary key,
    CompanyID            numeric(16)
        constraint [FK_CIS.Employee_CIS.Company]
            references PRT.Company,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    ObjectID             numeric(16)
        constraint FK_Employee_Object
            references GEN.Object,
    EmployeeDate         date,
    Employee             numeric(8)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Employee', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'PRT', 'TABLE', 'Employee',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Employee',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'PRT', 'TABLE', 'Employee',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'PRT', 'TABLE',
     'Employee', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Employee',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'PRT', 'TABLE', 'Employee',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'PRT', 'TABLE', 'Employee', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'PRT', 'TABLE', 'Employee',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was actual', 'SCHEMA', 'PRT', 'TABLE', 'Employee',
     'COLUMN', 'EmployeeDate'
go

exec sp_addextendedproperty 'MS_Description', 'Number of employees', 'SCHEMA', 'PRT', 'TABLE', 'Employee', 'COLUMN',
     'Employee'
go

create index [IXFK_CIS.Employee_CIS.Company]
    on PRT.Employee (CompanyID)
go

create index IXFK_Employee_Object
    on PRT.Employee (ObjectID)
go

create index [IXFK_CIS.Entity_GEN.Object]
    on PRT.Entity (ObjectID)
go

create table AST.EntityAsset
(
    ID                          numeric(16) identity
        constraint PK_EntityAsset
            primary key,
    ObjectID                    numeric(16)
        constraint FK_EntityAsset_Object
            references GEN.Object,
    EntityID                    numeric(16)
        constraint FK_EntityAsset_Entity
            references PRT.Entity,
    AssetID                     numeric(16)
        constraint FK_EntityAsset_Asset
            references AST.Asset,
    EntityAssetRelationTypeCode nvarchar(200)
        constraint FK_EntityAsset_Code
            references GEN.Code,
    SharePercent                numeric(10),
    ShareDividend               numeric(10),
    ShareDivisor                numeric(10),
    ExternalReferenceNr         nvarchar(200),
    DecisionNr                  nvarchar(200),
    ValidFrom                   date,
    ValidUntil                  date,
    StatusCode                  nvarchar(200)
        constraint FK_EntityAsset_Code_02
            references GEN.Code,
    CreationDate                date,
    CreationTime                time,
    CreationUserName            nvarchar(200),
    LastModifiedDate            date,
    LastModifiedTime            time,
    LastModifiedUserName        nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'AST', 'TABLE', 'EntityAsset', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'AST', 'TABLE',
     'EntityAsset', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Entity identifier -> PRT.Entity', 'SCHEMA', 'AST', 'TABLE',
     'EntityAsset', 'COLUMN', 'EntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Asset identifier -> AST.Asset', 'SCHEMA', 'AST', 'TABLE', 'EntityAsset',
     'COLUMN', 'AssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Entity-asset relation type -> value set ENTITY_ASSET_RELATION_TYPE',
     'SCHEMA', 'AST', 'TABLE', 'EntityAsset', 'COLUMN', 'EntityAssetRelationTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Share Percent', 'SCHEMA', 'AST', 'TABLE', 'EntityAsset', 'COLUMN',
     'SharePercent'
go

exec sp_addextendedproperty 'MS_Description', 'Share Dividend', 'SCHEMA', 'AST', 'TABLE', 'EntityAsset', 'COLUMN',
     'ShareDividend'
go

exec sp_addextendedproperty 'MS_Description', 'Share Divisor', 'SCHEMA', 'AST', 'TABLE', 'EntityAsset', 'COLUMN',
     'ShareDivisor'
go

exec sp_addextendedproperty 'MS_Description', 'External reference number', 'SCHEMA', 'AST', 'TABLE', 'EntityAsset',
     'COLUMN', 'ExternalReferenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Decision number', 'SCHEMA', 'AST', 'TABLE', 'EntityAsset', 'COLUMN',
     'DecisionNr'
go

exec sp_addextendedproperty 'MS_Description', 'Valid From', 'SCHEMA', 'AST', 'TABLE', 'EntityAsset', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid Until', 'SCHEMA', 'AST', 'TABLE', 'EntityAsset', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Status Code', 'SCHEMA', 'AST', 'TABLE', 'EntityAsset', 'COLUMN',
     'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'AST', 'TABLE', 'EntityAsset',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'AST', 'TABLE', 'EntityAsset',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'AST', 'TABLE',
     'EntityAsset', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'AST', 'TABLE',
     'EntityAsset', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'AST', 'TABLE',
     'EntityAsset', 'COLUMN', 'LastModifiedUserName'
go

create table PRT.EntityIdentifier
(
    ID                       numeric(16) identity
        constraint PK_EntityIdentifier
            primary key,
    ObjectID                 numeric(16)
        constraint FK_EntityIdentifier_Object
            references GEN.Object,
    EntityID                 numeric(16)
        constraint FK_EntityIdentifier_Entity
            references PRT.Entity,
    EntityIdentifierTypeCode nvarchar(200)
        constraint FK_EntityIdentifier_Code
            references GEN.Code,
    EntityIdentifier         nvarchar(100),
    ValidFrom                date,
    ValidUntil               date,
    StatusCode               nvarchar(200)
        constraint FK_EntityIdentifier_Code_02
            references GEN.Code,
    SourceInterfaceType      nvarchar(200),
    SourceID                 nvarchar(200),
    CreationDate             date,
    CreationTime             time,
    CreationUserName         nvarchar(200),
    LastModifiedDate         date,
    LastModifiedTime         time,
    LastModifiedUserName     nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'PRT', 'TABLE',
     'EntityIdentifier', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Entity identifier -> PRT.Entity', 'SCHEMA', 'PRT', 'TABLE',
     'EntityIdentifier', 'COLUMN', 'EntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Entity identifier type value set -> ENTITY_IDENTIFIER_TYPE', 'SCHEMA',
     'PRT', 'TABLE', 'EntityIdentifier', 'COLUMN', 'EntityIdentifierTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'PRT', 'TABLE', 'EntityIdentifier', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'PRT', 'TABLE', 'EntityIdentifier', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Entity identifier status value set -> STATUS_ENTITY_IDENTIFIER',
     'SCHEMA', 'PRT', 'TABLE', 'EntityIdentifier', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'PRT', 'TABLE', 'EntityIdentifier',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier (external system)', 'SCHEMA', 'PRT', 'TABLE',
     'EntityIdentifier', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'PRT', 'TABLE',
     'EntityIdentifier', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'PRT', 'TABLE',
     'EntityIdentifier', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_EntityIdentifier_Code
    on PRT.EntityIdentifier (EntityIdentifierTypeCode)
go

create index IXFK_EntityIdentifier_Code_02
    on PRT.EntityIdentifier (StatusCode)
go

create index IXFK_EntityIdentifier_Entity
    on PRT.EntityIdentifier (EntityID)
go

create index IXFK_EntityIdentifier_Object
    on PRT.EntityIdentifier (ObjectID)
go

create table PRT.EntityNegativeEvent
(
    ID                   numeric(16) identity
        constraint PK_EntityNegativeEvent
            primary key,
    ObjectID             numeric(16)
        constraint FK_EntityNegativeEvent_Object
            references GEN.Object,
    EntityID             numeric(16)
        constraint FK_EntityNegativeEvent_Entity
            references PRT.Entity,
    EventTypeCode        nvarchar(200)
        constraint FK_EntityNegativeEvent_Code
            references GEN.Code,
    ValidFrom            date,
    ValidUntil           date,
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'PRT', 'TABLE', 'EntityNegativeEvent',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'PRT', 'TABLE',
     'EntityNegativeEvent', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Entity identifier -> PRT.Entity', 'SCHEMA', 'PRT', 'TABLE',
     'EntityNegativeEvent', 'COLUMN', 'EntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Entity event type value set -> NEGATIVE_EVENT_TYPE', 'SCHEMA', 'PRT',
     'TABLE', 'EntityNegativeEvent', 'COLUMN', 'EventTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'PRT', 'TABLE', 'EntityNegativeEvent', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'PRT', 'TABLE', 'EntityNegativeEvent', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'PRT', 'TABLE', 'EntityNegativeEvent',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier (external system)', 'SCHEMA', 'PRT', 'TABLE',
     'EntityNegativeEvent', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'PRT', 'TABLE',
     'EntityNegativeEvent', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'PRT', 'TABLE',
     'EntityNegativeEvent', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'PRT', 'TABLE',
     'EntityNegativeEvent', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'PRT', 'TABLE',
     'EntityNegativeEvent', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'PRT', 'TABLE',
     'EntityNegativeEvent', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'PRT', 'TABLE',
     'EntityNegativeEvent', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_EntityNegativeEvent_Code
    on PRT.EntityNegativeEvent (EventTypeCode)
go

create index IXFK_EntityNegativeEvent_Entity
    on PRT.EntityNegativeEvent (EntityID)
go

create index IXFK_EntityNegativeEvent_Object
    on PRT.EntityNegativeEvent (ObjectID)
go

create table PRT.EntityRelation
(
    ID                   numeric(16) identity
        constraint PK_EntityRelation
            primary key,
    FromEntityID         numeric(16)
        constraint FK_EntityRelation_Entity
            references PRT.Entity,
    ToEntityID           numeric(16)
        constraint FK_EntityRelation_Entity_02
            references PRT.Entity,
    RelationTypeCode     nvarchar(200)
        constraint FK_EntityRelation_Code
            references GEN.Code,
    StatusCode           nvarchar(200)
        constraint FK_EntityRelation_Code_02
            references GEN.Code,
    OwnPercent           numeric(16, 10),
    OwnValue             money,
    CurrencyCode         nvarchar(200)
        constraint FK_EntityRelation_Code_03
            references GEN.Code,
    ValidFrom            date,
    ValidUntil           date,
    SequenceNr           numeric(3),
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ObjectID             numeric(16)
        constraint FK_EntityRelation_Object
            references GEN.Object,
    DispositionCode      nvarchar(200)
        constraint FK_EntityRelation_Code_04
            references GEN.Code,
    SignRightCode        nvarchar(200)
        constraint FK_EntityRelation_Code_05
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'PRT', 'TABLE', 'EntityRelation', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description',
     'First member of the relation (for example: the company which is owned by) -> PRT.Entity', 'SCHEMA', 'PRT',
     'TABLE', 'EntityRelation', 'COLUMN', 'FromEntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Second member of the relation (the leader or the owner) -> PRT.Entity',
     'SCHEMA', 'PRT', 'TABLE', 'EntityRelation', 'COLUMN', 'ToEntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Relation type value set -> ENTITY_RELATION_TYPE', 'SCHEMA', 'PRT',
     'TABLE', 'EntityRelation', 'COLUMN', 'RelationTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Status value set -> VALUESET_STATUS', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Owner''s property in percent', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'OwnPercent'
go

exec sp_addextendedproperty 'MS_Description', 'Owner''s property value in Currency', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'OwnValue'
go

exec sp_addextendedproperty 'MS_Description', 'Currency value set -> CURRENCY', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'PRT', 'TABLE', 'EntityRelation', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'PRT', 'TABLE', 'EntityRelation', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Order number in the relation list', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'SequenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'PRT', 'TABLE', 'EntityRelation',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier (external system)', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Disposition -> DISPOSITION value set', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'DispositionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Sign right -> RIGHT_TO_SIGN value set', 'SCHEMA', 'PRT', 'TABLE',
     'EntityRelation', 'COLUMN', 'SignRightCode'
go

create index IXFK_EntityRelation_Code
    on PRT.EntityRelation (RelationTypeCode)
go

create index IXFK_EntityRelation_Code_02
    on PRT.EntityRelation (StatusCode)
go

create index IXFK_EntityRelation_Code_03
    on PRT.EntityRelation (CurrencyCode)
go

create index IXFK_EntityRelation_Entity
    on PRT.EntityRelation (FromEntityID)
go

create index IXFK_EntityRelation_Entity_02
    on PRT.EntityRelation (ToEntityID)
go

create index IXFK_EntityRelation_Object
    on PRT.EntityRelation (ObjectID)
go

create table GEN.FlexibleFormTemplate
(
    ID                   numeric(16) identity
        constraint PK_FlexibleFormTemplate
            primary key,
    ObjectID             numeric(16)
        constraint FK_FlexibleFormTemplate_Object
            references GEN.Object,
    ObjectType           nvarchar(100),
    TemplateCode         nvarchar(200)
        constraint FK_FlexibleFormTemplate_Code
            references GEN.Code,
    ValidFrom            date,
    ValidUntil           date,
    StatusCode           nvarchar(200)
        constraint FK_FlexibleFormTemplate_Code_02
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormTemplate',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplate', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Object type to which the template belongs', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplate', 'COLUMN', 'ObjectType'
go

exec sp_addextendedproperty 'MS_Description', 'Flexible form template value set -> FLEXIBLE_FORM_TEMPLATE', 'SCHEMA',
     'GEN', 'TABLE', 'FlexibleFormTemplate', 'COLUMN', 'TemplateCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormTemplate', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormTemplate', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Status value set -> VALUESET_STATUS', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplate', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplate', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplate', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplate', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplate', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplate', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplate', 'COLUMN', 'LastModifiedUserName'
go

create table GEN.FlexibleForm
(
    ID                     numeric(16) identity
        constraint PK_FlexibleForm
            primary key,
    ObjectID               numeric(16)
        constraint FK_FlexibleForm_Object
            references GEN.Object,
    ReferencedObjectID     numeric(16)
        constraint FK_FlexibleForm_Object_02
            references GEN.Object,
    FlexibleFormTemplateID numeric(16)
        constraint FK_FlexibleForm_FlexibleFormTemplate
            references GEN.FlexibleFormTemplate,
    CreationDate           date,
    CreationTime           time,
    CreationUserName       nvarchar(200),
    LastModifiedDate       date,
    LastModifiedTime       time,
    LastModifiedUserName   nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleForm', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleForm', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier that the form instance belongs to -> GEN.Object',
     'SCHEMA', 'GEN', 'TABLE', 'FlexibleForm', 'COLUMN', 'ReferencedObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Flexible form template identifier -> GEN.FlexibleFormTemplate', 'SCHEMA',
     'GEN', 'TABLE', 'FlexibleForm', 'COLUMN', 'FlexibleFormTemplateID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleForm', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleForm', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleForm', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleForm', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleForm', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleForm', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_FlexibleForm_FlexibleFormTemplate
    on GEN.FlexibleForm (FlexibleFormTemplateID)
go

create index IXFK_FlexibleForm_Object
    on GEN.FlexibleForm (ObjectID)
go

create index IXFK_FlexibleForm_Object_02
    on GEN.FlexibleForm (ReferencedObjectID)
go

create unique index IX_FlexibleForm_Unique
    on GEN.FlexibleForm (ReferencedObjectID, FlexibleFormTemplateID)
go

create index IXFK_FlexibleFormTemplate_Code
    on GEN.FlexibleFormTemplate (TemplateCode)
go

create index IXFK_FlexibleFormTemplate_Code_02
    on GEN.FlexibleFormTemplate (StatusCode)
go

create index IXFK_FlexibleFormTemplate_Object
    on GEN.FlexibleFormTemplate (ObjectID)
go

create table FIN.InterestSet
(
    ID                   numeric(16) identity
        constraint PK_InterestSet
            primary key,
    ObjectID             numeric(16)
        constraint FK_InterestSet_Object
            references GEN.Object,
    Code                 nvarchar(200)
        constraint FK_InterestSet_Code
            references GEN.Code,
    AdjustmentDateID     numeric(16)
        constraint FK_InterestSet_AdjustmentDate
            references FIN.AdjustmentDate,
    BaseInterestSetID    numeric(16)
        constraint FK_InterestSet_InterestSet
            references FIN.InterestSet,
    TypeCode             nvarchar(200)
        constraint FK_InterestSet_Code_02
            references GEN.Code,
    Multiplier           numeric(10, 5),
    Surcharge            numeric(10, 5),
    Minimum              numeric(10, 5),
    Maximum              numeric(10, 5),
    MinimumValue         money,
    MaximumValue         money,
    StatusCode           nvarchar(200)
        constraint FK_InterestSet_Code_03
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'FIN', 'TABLE', 'InterestSet', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'FIN', 'TABLE',
     'InterestSet', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Code of the interest set -> value set INTEREST_SET', 'SCHEMA', 'FIN',
     'TABLE', 'InterestSet', 'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Adjustment date -> FIN.AdjustmentDate', 'SCHEMA', 'FIN', 'TABLE',
     'InterestSet', 'COLUMN', 'AdjustmentDateID'
go

exec sp_addextendedproperty 'MS_Description', 'Base interest set date -> FIN.InterestSet', 'SCHEMA', 'FIN', 'TABLE',
     'InterestSet', 'COLUMN', 'BaseInterestSetID'
go

exec sp_addextendedproperty 'MS_Description', 'Type of the interest set -> value set INTEREST_SET_TYPE', 'SCHEMA',
     'FIN', 'TABLE', 'InterestSet', 'COLUMN', 'TypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Multiplier of the base interest rate', 'SCHEMA', 'FIN', 'TABLE',
     'InterestSet', 'COLUMN', 'Multiplier'
go

exec sp_addextendedproperty 'MS_Description', 'Surcharge of the base interest rate', 'SCHEMA', 'FIN', 'TABLE',
     'InterestSet', 'COLUMN', 'Surcharge'
go

exec sp_addextendedproperty 'MS_Description', 'Minimum percent of the interest rate', 'SCHEMA', 'FIN', 'TABLE',
     'InterestSet', 'COLUMN', 'Minimum'
go

exec sp_addextendedproperty 'MS_Description', 'Maximum percent of the interest rate', 'SCHEMA', 'FIN', 'TABLE',
     'InterestSet', 'COLUMN', 'Maximum'
go

exec sp_addextendedproperty 'MS_Description', 'Minimum value of the interest rate', 'SCHEMA', 'FIN', 'TABLE',
     'InterestSet', 'COLUMN', 'MinimumValue'
go

exec sp_addextendedproperty 'MS_Description', 'Maximum value of the interest rate', 'SCHEMA', 'FIN', 'TABLE',
     'InterestSet', 'COLUMN', 'MaximumValue'
go

exec sp_addextendedproperty 'MS_Description', 'Status code -> value set STATUS', 'SCHEMA', 'FIN', 'TABLE',
     'InterestSet', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'FIN', 'TABLE', 'InterestSet',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'FIN', 'TABLE', 'InterestSet',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE', 'InterestSet',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'InterestSet', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'InterestSet', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE', 'InterestSet',
     'COLUMN', 'LastModifiedUserName'
go

create table FIN.InterestRate
(
    ID                   numeric(16) identity
        constraint PK_InterestRate
            primary key,
    InterestSetID        numeric(16)
        constraint FK_InterestRate_InterestSet
            references FIN.InterestSet,
    Rate                 numeric(10, 5),
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Interest set identifier -> FIN.InterestSet', 'SCHEMA', 'FIN', 'TABLE',
     'InterestRate', 'COLUMN', 'InterestSetID'
go

exec sp_addextendedproperty 'MS_Description',
     'Rate. Data is stored in normal format, so for example 20% is stored as 0.2', 'SCHEMA', 'FIN', 'TABLE',
     'InterestRate', 'COLUMN', 'Rate'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from date', 'SCHEMA', 'FIN', 'TABLE', 'InterestRate', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until date', 'SCHEMA', 'FIN', 'TABLE', 'InterestRate', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'InterestRate', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'InterestRate', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE', 'InterestRate',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'InterestRate', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'InterestRate', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE', 'InterestRate',
     'COLUMN', 'LastModifiedUserName'
go

create table IFC.Interface
(
    ID                       numeric(16) identity
        constraint PK_Interface
            primary key,
    ObjectID                 numeric(16)
        constraint FK_Interface_Object
            references GEN.Object,
    Code                     nvarchar(200)
        constraint FK_Interface_Code
            references GEN.Code,
    ChannelCode              nvarchar(200)
        constraint FK_Interface_Code_02
            references GEN.Code,
    TechnicalDirectionCode   nvarchar(200)
        constraint FK_Interface_Code_03
            references GEN.Code,
    LogicalDirectionCode     nvarchar(200)
        constraint FK_Interface_Code_04
            references GEN.Code,
    RemoteHost               nvarchar(200),
    RemotePort               numeric(16),
    RemoteFolderName         nvarchar(200),
    FileNamePattern          nvarchar(200),
    CreationDate             date,
    CreationTime             time,
    CreationUserName         nvarchar(200),
    LastModifiedDate         date,
    LastModifiedTime         time,
    LastModifiedUserName     nvarchar(200),
    AuthenticationMethodCode nvarchar(200)
        constraint FK_Interface_Code_05
            references GEN.Code,
    TriggerFileNamePattern   nvarchar(200),
    RemoteEndPoint           nvarchar(200),
    EnabledCode              nvarchar(200) not null
        constraint FK_Interface_EnabledCode_Code
            references GEN.Code,
    ValidFrom                date,
    ValidUntil               date
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'Interface', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'IFC', 'TABLE', 'Interface',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface code -> value set INTERFACE', 'SCHEMA', 'IFC', 'TABLE',
     'Interface', 'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Interface channel -> value set INTERFACE_CHANNEL', 'SCHEMA', 'IFC',
     'TABLE', 'Interface', 'COLUMN', 'ChannelCode'
go

exec sp_addextendedproperty 'MS_Description', 'Technical direction -> value set INTERFACE_DIRECTION', 'SCHEMA', 'IFC',
     'TABLE', 'Interface', 'COLUMN', 'TechnicalDirectionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Logical direction -> value set INTERFACE_DIRECTION', 'SCHEMA', 'IFC',
     'TABLE', 'Interface', 'COLUMN', 'LogicalDirectionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Remote Host', 'SCHEMA', 'IFC', 'TABLE', 'Interface', 'COLUMN',
     'RemoteHost'
go

exec sp_addextendedproperty 'MS_Description', 'Remote Port', 'SCHEMA', 'IFC', 'TABLE', 'Interface', 'COLUMN',
     'RemotePort'
go

exec sp_addextendedproperty 'MS_Description', 'Folder name on the remote side', 'SCHEMA', 'IFC', 'TABLE', 'Interface',
     'COLUMN', 'RemoteFolderName'
go

exec sp_addextendedproperty 'MS_Description', 'Pattern of the file names to search for', 'SCHEMA', 'IFC', 'TABLE',
     'Interface', 'COLUMN', 'FileNamePattern'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'Interface',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'Interface',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE', 'Interface',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'Interface', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'Interface', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE', 'Interface',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Authentication method -> value set AUTHENTICATION_METHOD', 'SCHEMA',
     'IFC', 'TABLE', 'Interface', 'COLUMN', 'AuthenticationMethodCode'
go

exec sp_addextendedproperty 'MS_Description', 'Trigger file name for batch downloads (last file)', 'SCHEMA', 'IFC',
     'TABLE', 'Interface', 'COLUMN', 'TriggerFileNamePattern'
go

exec sp_addextendedproperty 'MS_Description', 'Remote endpoint', 'SCHEMA', 'IFC', 'TABLE', 'Interface', 'COLUMN',
     'RemoteEndPoint'
go

exec sp_addextendedproperty 'MS_Description', 'Enabled? -> value set BOOLEAN', 'SCHEMA', 'IFC', 'TABLE', 'Interface',
     'COLUMN', 'EnabledCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from date', 'SCHEMA', 'IFC', 'TABLE', 'Interface', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until date', 'SCHEMA', 'IFC', 'TABLE', 'Interface', 'COLUMN',
     'ValidUntil'
go

create table IFC.InterfaceCatalog
(
    ID                   numeric(16) identity
        constraint PK_Folder
            primary key,
    ObjectID             numeric(16)
        constraint FK_InterfaceCatalog_Object
            references GEN.Object
            on update cascade,
    CodeID               nvarchar(50),
    FolderID             numeric(16),
    TableName            nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InterfaceCatalog',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCatalog', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Value set FOLDER', 'SCHEMA', 'IFC', 'TABLE', 'InterfaceCatalog',
     'COLUMN', 'CodeID'
go

exec sp_addextendedproperty 'MS_Description', 'Folder identifier -> GEN.Folder', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCatalog', 'COLUMN', 'FolderID'
go

exec sp_addextendedproperty 'MS_Description', 'Table name (example: IFC.Address)', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCatalog', 'COLUMN', 'TableName'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCatalog', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCatalog', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCatalog', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCatalog', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCatalog', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCatalog', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InterfaceCommunication
(
    ID                   numeric(16) identity
        constraint PK_InterfaceCommunication
            primary key,
    ObjectID             numeric(16)
        constraint FK_InterfaceCommunication_Object
            references GEN.Object,
    InterfaceID          numeric(16)
        constraint FK_InterfaceCommunication_Interface
            references IFC.Interface,
    DirectionCode        nvarchar(200)
        constraint FK_InterfaceCommunication_Code
            references GEN.Code,
    BeginDate            date,
    BeginTime            time,
    EndDate              date,
    EndTime              time,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InterfaceCommunication',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunication', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface identifier -> IFC.Interface', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunication', 'COLUMN', 'InterfaceID'
go

exec sp_addextendedproperty 'MS_Description', 'Direction -> value set INTERFACE_DIRECTION', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunication', 'COLUMN', 'DirectionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Begin Date', 'SCHEMA', 'IFC', 'TABLE', 'InterfaceCommunication',
     'COLUMN', 'BeginDate'
go

exec sp_addextendedproperty 'MS_Description', 'Begin Time', 'SCHEMA', 'IFC', 'TABLE', 'InterfaceCommunication',
     'COLUMN', 'BeginTime'
go

exec sp_addextendedproperty 'MS_Description', 'End Date', 'SCHEMA', 'IFC', 'TABLE', 'InterfaceCommunication', 'COLUMN',
     'EndDate'
go

exec sp_addextendedproperty 'MS_Description', 'End Time', 'SCHEMA', 'IFC', 'TABLE', 'InterfaceCommunication', 'COLUMN',
     'EndTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunication', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunication', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunication', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunication', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunication', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunication', 'COLUMN', 'LastModifiedUserName'
go

create table FIN.Invoice
(
    ID                   numeric(16) identity
        constraint [PK_FIN.Invoice]
            primary key,
    ObjectID             numeric(16)
        constraint FK_Invoice_Object
            references GEN.Object,
    InvoiceTypeCode      nvarchar(200),
    SellerPartyID        numeric(16),
    BuyerPartyID         numeric(16),
    ContractID           numeric(16),
    ReferencedInvoiceID  numeric(16),
    InvoiceNr            nvarchar(200),
    RegistrationNr       nvarchar(200),
    FulfillmentDate      date,
    IssueDate            date,
    DueDate              date,
    PaymentMethodCode    nvarchar(200),
    CurrencyCode         nvarchar(200),
    DebtCaseID           numeric(16),
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    ContractDate         date,
    TerminationDate      date
)
go

exec sp_addextendedproperty 'MS_Description', 'FolyAlszA?mla
Jelenlegi modellben ezzel ekvivalens: FIN.CashAccount, DCS.Invoice (?), FIN.Invoice, DCS.InvoiceDistribution', 'SCHEMA',
     'FIN', 'TABLE', 'Invoice'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'FIN', 'TABLE', 'Invoice', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'FIN', 'TABLE', 'Invoice',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'FIN', 'TABLE', 'Invoice',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'FIN', 'TABLE', 'Invoice',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'FIN', 'TABLE',
     'Invoice', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'FIN', 'TABLE', 'Invoice',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'FIN', 'TABLE', 'Invoice',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'FIN', 'TABLE', 'Invoice', 'COLUMN', 'Comments'
go

create table FIN.CalculationInvoice
(
    ID                   numeric(16) identity
        constraint PK_CalculationInvoice
            primary key,
    ObjectID             numeric(16),
    CalculationID        numeric(16)
        constraint FK_CalculationInvoice_Calculation
            references FIN.Calculation,
    InvoiceID            numeric(16)
        constraint FK_CalculationInvoice_Invoice
            references FIN.Invoice,
    InterestBeginDate    date,
    InterestEndDate      date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_CalculationInvoice_Calculation
    on FIN.CalculationInvoice (CalculationID)
go

create index IXFK_CalculationInvoice_Invoice
    on FIN.CalculationInvoice (InvoiceID)
go

create index IXFK_Invoice_Object
    on FIN.Invoice (ObjectID)
go

create table FIN.InvoiceArrears
(
    ID                   numeric(16) identity
        constraint PK_InvoiceArrears
            primary key,
    InvoiceID            numeric(16)
        constraint FK_InvoiceArrears_Invoice
            references FIN.Invoice,
    AccountTypeID        numeric(16)
        constraint FK_InvoiceArrears_AccountType
            references FIN.AccountType,
    Amount               money,
    CurrencyCode         nvarchar(200)
        constraint FK_InvoiceArrears_Code
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'FIN', 'TABLE', 'InvoiceArrears', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Invoice identifier -> FIN.Invoice', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceArrears', 'COLUMN', 'InvoiceID'
go

exec sp_addextendedproperty 'MS_Description', 'Account type -> FIN.AccountType', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceArrears', 'COLUMN', 'AccountTypeID'
go

exec sp_addextendedproperty 'MS_Description', 'Currency value set -> CURRENCY', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceArrears', 'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceArrears', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceArrears', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceArrears', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceArrears', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceArrears', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceArrears', 'COLUMN', 'LastModifiedUserName'
go

alter table FIN.Account
    add constraint FK_Account_InvoiceArrears
        foreign key (InvoiceArrearsID) references FIN.InvoiceArrears
go

create index IXFK_InvoiceArrears_AccountType
    on FIN.InvoiceArrears (AccountTypeID)
go

create index IXFK_InvoiceArrears_Code
    on FIN.InvoiceArrears (CurrencyCode)
go

create index IXFK_InvoiceArrears_Invoice
    on FIN.InvoiceArrears (InvoiceID)
go

create table FIN.InvoiceLine
(
    ID                   numeric(16) identity
        constraint PK_InvoiceLine
            primary key,
    ObjectID             numeric(16),
    InvoiceID            numeric(16)
        constraint FK_InvoiceLine_Invoice
            references FIN.Invoice,
    SequenceNr           numeric(16),
    ProductID            numeric(16),
    ProductName          nvarchar(200),
    UnitID               nvarchar(200),
    UnitPrice            money,
    VatID                numeric(16),
    Quantity             numeric(16, 2),
    NetValue             money,
    VatValue             money,
    GrossValue           money,
    ArrearsValue         money,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_InvoiceLine_Invoice
    on FIN.InvoiceLine (InvoiceID)
go

create table FIN.InvoiceTotal
(
    ID                   numeric(16) identity
        constraint PK_InvoiceTotal
            primary key,
    InvoiceID            numeric(16)
        constraint FK_InvoiceTotal_Invoice
            references FIN.Invoice,
    AmountTypeCode       nvarchar(200)
        constraint FK_InvoiceTotal_Code
            references GEN.Code,
    Amount               money,
    CurrencyCode         nvarchar(200)
        constraint FK_InvoiceTotal_Code_02
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'FIN', 'TABLE', 'InvoiceTotal', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Invoice identifier -> FIN.Invoice', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceTotal', 'COLUMN', 'InvoiceID'
go

exec sp_addextendedproperty 'MS_Description', 'Value set INVOICE_AMOUNT_TYPE', 'SCHEMA', 'FIN', 'TABLE', 'InvoiceTotal',
     'COLUMN', 'AmountTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Value of the invoice total', 'SCHEMA', 'FIN', 'TABLE', 'InvoiceTotal',
     'COLUMN', 'Amount'
go

exec sp_addextendedproperty 'MS_Description', 'Currency value set -> CURRENCY', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceTotal', 'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceTotal', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceTotal', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceTotal', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceTotal', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'InvoiceTotal', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_InvoiceTotal_Code
    on FIN.InvoiceTotal (AmountTypeCode)
go

create index IXFK_InvoiceTotal_Code_02
    on FIN.InvoiceTotal (CurrencyCode)
go

create index IXFK_InvoiceTotal_Invoice
    on FIN.InvoiceTotal (InvoiceID)
go

create table GEN.Language
(
    ID                   numeric(16) identity
        constraint PK_Language
            primary key,
    ObjectID             numeric(16)
        constraint FK_Language_Object
            references GEN.Object,
    ISOCode              nvarchar(5),
    LanguageCode         nvarchar(200)
        constraint FK_Language_Code
            references GEN.Code,
    StatusCode           nvarchar(200)
        constraint FK_Language_Code_02
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'Language', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE', 'Language',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'ISO 639-1 code of language', 'SCHEMA', 'GEN', 'TABLE', 'Language',
     'COLUMN', 'ISOCode'
go

exec sp_addextendedproperty 'MS_Description', 'Code of language -> value set LANGUAGE', 'SCHEMA', 'GEN', 'TABLE',
     'Language', 'COLUMN', 'LanguageCode'
go

exec sp_addextendedproperty 'MS_Description', 'Code of status -> value set STATUS', 'SCHEMA', 'GEN', 'TABLE',
     'Language', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'Language',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'Language',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'Language',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'Language', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'Language', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'Language',
     'COLUMN', 'LastModifiedUserName'
go

create table GEN.Menu
(
    ID                   numeric(16) identity
        constraint PK_Menu
            primary key,
    ObjectID             numeric(16)
        constraint FK_Menu_Object
            references GEN.Object,
    ParentMenuID         numeric(16)
        constraint FK_Menu_Menu
            references GEN.Menu,
    Code                 nvarchar(200)
        constraint FK_Menu_Code
            references GEN.Code,
    Action               nvarchar(500),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_Menu_Code
    on GEN.Menu (Code)
go

create index IXFK_Menu_Menu
    on GEN.Menu (ParentMenuID)
go

create index IXFK_Menu_Object
    on GEN.Menu (ObjectID)
go

create table GEN.MimeType
(
    ID                   numeric(16) identity
        constraint PK_MimeType
            primary key,
    ObjectID             numeric(16)
        constraint FK_MimeType_Object
            references GEN.Object,
    Code                 nvarchar(200)
        constraint FK_MimeType_Code
            references GEN.Code,
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'MimeType', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE', 'MimeType',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Mime type value set -> VALUESET_MIME_TYPE', 'SCHEMA', 'GEN', 'TABLE',
     'MimeType', 'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'GEN', 'TABLE', 'MimeType', 'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'GEN', 'TABLE', 'MimeType', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'MimeType',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'MimeType',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'MimeType', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'MimeType', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'MimeType', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'MimeType', 'COLUMN', 'LastModifiedUserName'
go

create table GEN.Document
(
    ID                   numeric(16) identity
        constraint PK_Document
            primary key,
    ObjectID             numeric(16)
        constraint FK_Document_Object
            references GEN.Object,
    StorageTypeCode      nvarchar(200)
        constraint FK_Document_Code
            references GEN.Code,
    FileName             nvarchar(250),
    MimeTypeID           numeric(16)
        constraint FK_Document_MimeType
            references GEN.MimeType,
    Size                 numeric(16),
    Comments             nvarchar(200),
    SourceInterfaceType  nvarchar(200),
    SourcePath           nvarchar(max),
    SourceID             nvarchar(200),
    HashCode             nvarchar(100),
    Pages                numeric(16),
    PreviewDocumentID    numeric(16)
        constraint FK_Document_Document
            references GEN.Document,
    DownloadDocumentID   numeric(16)
        constraint FK_Document_Document_02
            references GEN.Document,
    StatusCode           nvarchar(200)
        constraint FK_Document_Code_02
            references GEN.Code,
    ErrorMessage         nvarchar(max),
    ParentDocumentID     numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ExternalID           nvarchar(200),
    CheckSum             nvarchar(64)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier (and real file name in the file system)', 'SCHEMA',
     'GEN', 'TABLE', 'Document', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE', 'Document',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Storage type value set -> VALUESET_STORAGE_TYPE', 'SCHEMA', 'GEN',
     'TABLE', 'Document', 'COLUMN', 'StorageTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'File name of the original document', 'SCHEMA', 'GEN', 'TABLE',
     'Document', 'COLUMN', 'FileName'
go

exec sp_addextendedproperty 'MS_Description', 'Mime type identifier -> GEN.MimeType', 'SCHEMA', 'GEN', 'TABLE',
     'Document', 'COLUMN', 'MimeTypeID'
go

exec sp_addextendedproperty 'MS_Description', 'Size of the document in bytes', 'SCHEMA', 'GEN', 'TABLE', 'Document',
     'COLUMN', 'Size'
go

exec sp_addextendedproperty 'MS_Description', 'Short description for search and display', 'SCHEMA', 'GEN', 'TABLE',
     'Document', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'GEN', 'TABLE', 'Document', 'COLUMN',
     'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source URL or folder name', 'SCHEMA', 'GEN', 'TABLE', 'Document',
     'COLUMN', 'SourcePath'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier', 'SCHEMA', 'GEN', 'TABLE', 'Document', 'COLUMN',
     'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Hash code created for open web access', 'SCHEMA', 'GEN', 'TABLE',
     'Document', 'COLUMN', 'HashCode'
go

exec sp_addextendedproperty 'MS_Description', 'Number of pages in the document', 'SCHEMA', 'GEN', 'TABLE', 'Document',
     'COLUMN', 'Pages'
go

exec sp_addextendedproperty 'MS_Description', 'Preview (thumbnail) document of this document -> GEN.Document', 'SCHEMA',
     'GEN', 'TABLE', 'Document', 'COLUMN', 'PreviewDocumentID'
go

exec sp_addextendedproperty 'MS_Description', 'Download document of this document for web download -> GEN.Document',
     'SCHEMA', 'GEN', 'TABLE', 'Document', 'COLUMN', 'DownloadDocumentID'
go

exec sp_addextendedproperty 'MS_Description', 'Document status value set -> VALUESET_DOCUMENT_STATUS', 'SCHEMA', 'GEN',
     'TABLE', 'Document', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'GEN', 'TABLE', 'Document', 'COLUMN',
     'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Parent (container) document identifier (zip archive, es3 archive, etc.)',
     'SCHEMA', 'GEN', 'TABLE', 'Document', 'COLUMN', 'ParentDocumentID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'Document',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'Document',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'Document', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'Document', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'Document', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'Document', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Identifier for documents stored in external systems', 'SCHEMA', 'GEN',
     'TABLE', 'Document', 'COLUMN', 'ExternalID'
go

exec sp_addextendedproperty 'MS_Description', 'Result of checksum algoritm', 'SCHEMA', 'GEN', 'TABLE', 'Document',
     'COLUMN', 'CheckSum'
go

create table GEN.AppStatement
(
    ID                   numeric(16) identity
        constraint PK_AppStatement
            primary key,
    ObjectID             numeric(16)
        constraint FK_AppStatement_Object
            references GEN.Object,
    StatementCode        nvarchar(200)
        constraint FK_AppStatement_Code
            references GEN.Code,
    DocumentID           numeric(16)
        constraint FK_AppStatement_Document
            references GEN.Document,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'AppStatement', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatement', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Statement code -> value set STATEMENT', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatement', 'COLUMN', 'StatementCode'
go

exec sp_addextendedproperty 'MS_Description', 'Statement document identifier -> GEN.Document', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatement', 'COLUMN', 'DocumentID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatement', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatement', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'AppStatement',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatement', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatement', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'AppStatement',
     'COLUMN', 'LastModifiedUserName'
go

create table GEN.AppStatementOption
(
    ID                   numeric(16) identity
        constraint PK_AppStatementOption
            primary key,
    ObjectID             numeric(16)
        constraint FK_AppStatementOption_Object
            references GEN.Object,
    AppStatementID       numeric(16)
        constraint FK_AppStatementOption_AppStatement
            references GEN.AppStatement,
    StatementOptionCode  nvarchar(200)
        constraint FK_AppStatementOption_Code
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'AppStatementOption',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatementOption', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'App statement identifier -> GEN.AppStatement', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatementOption', 'COLUMN', 'AppStatementID'
go

exec sp_addextendedproperty 'MS_Description', 'Statement option code -> value set STATEMENT_OPTION', 'SCHEMA', 'GEN',
     'TABLE', 'AppStatementOption', 'COLUMN', 'StatementOptionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatementOption', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatementOption', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatementOption', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatementOption', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatementOption', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'AppStatementOption', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_Document_Code
    on GEN.Document (StorageTypeCode)
go

create index IXFK_Document_Code_02
    on GEN.Document (StatusCode)
go

create index IXFK_Document_Document
    on GEN.Document (PreviewDocumentID)
go

create index IXFK_Document_Document_02
    on GEN.Document (DownloadDocumentID)
go

create index IXFK_Document_Object
    on GEN.Document (ObjectID)
go

create index IXFK_Document_MimeType
    on GEN.Document (MimeTypeID)
go

create table GEN.MimeExtension
(
    ID                   numeric(16) identity
        constraint PK_MimeExtension
            primary key,
    ObjectID             numeric(16)
        constraint FK_MimeExtension_Object
            references GEN.Object,
    Extension            nvarchar(10),
    MimeTypeID           numeric(16)
        constraint FK_MimeExtension_MimeType
            references GEN.MimeType,
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'MimeExtension', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'File extension. Example: ''.docx''', 'SCHEMA', 'GEN', 'TABLE',
     'MimeExtension', 'COLUMN', 'Extension'
go

exec sp_addextendedproperty 'MS_Description', 'Mime type identifier -> GEN.MimeType', 'SCHEMA', 'GEN', 'TABLE',
     'MimeExtension', 'COLUMN', 'MimeTypeID'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'GEN', 'TABLE', 'MimeExtension', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'GEN', 'TABLE', 'MimeExtension', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'MimeExtension', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'MimeExtension', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'MimeExtension', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'MimeExtension', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'MimeExtension', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'MimeExtension', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_MimeExtension_MimeType
    on GEN.MimeExtension (MimeTypeID)
go

create index IXFK_MimeExtension_Object
    on GEN.MimeExtension (ObjectID)
go

create index IXFK_MimeType_Code
    on GEN.MimeType (Code)
go

create index IXFK_MimeType_Object
    on GEN.MimeType (ObjectID)
go

create table ORG.Module
(
    ID                   numeric(16) identity
        constraint PK_Module
            primary key,
    ObjectID             numeric(16)
        constraint FK_Module_Object
            references GEN.Object,
    ModuleCode           nvarchar(200)
        constraint FK_Module_Code
            references GEN.Code,
    ExecutionPath        nvarchar(200),
    MaxInstances         numeric(6),
    StopAllowedCode      nvarchar(200)
        constraint FK_Module_Code_02
            references GEN.Code,
    StatusCode           nvarchar(200)
        constraint FK_Module_Code_03
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    MessageQueueTopic    nvarchar(200),
    TechnicalUserName    nvarchar(200),
    InterfaceID          numeric(16)
        constraint FK_Module_Interface
            references IFC.Interface
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'Module', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE', 'Module',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Module code value set -> VALUESET_MODULE', 'SCHEMA', 'ORG', 'TABLE',
     'Module', 'COLUMN', 'ModuleCode'
go

exec sp_addextendedproperty 'MS_Description', 'Execution path', 'SCHEMA', 'ORG', 'TABLE', 'Module', 'COLUMN',
     'ExecutionPath'
go

exec sp_addextendedproperty 'MS_Description', 'Maximum instances', 'SCHEMA', 'ORG', 'TABLE', 'Module', 'COLUMN',
     'MaxInstances'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean value set -> VALUESET_BOOLEAN', 'SCHEMA', 'ORG', 'TABLE',
     'Module', 'COLUMN', 'StopAllowedCode'
go

exec sp_addextendedproperty 'MS_Description', 'Module status value set -> VALUESET_MODULE_STATUS', 'SCHEMA', 'ORG',
     'TABLE', 'Module', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'Module',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'Module',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'Module',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'Module', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'Module', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'Module',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'KAFKA topic', 'SCHEMA', 'ORG', 'TABLE', 'Module', 'COLUMN',
     'MessageQueueTopic'
go

exec sp_addextendedproperty 'MS_Description', 'Technical user of modul', 'SCHEMA', 'ORG', 'TABLE', 'Module', 'COLUMN',
     'TechnicalUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Interface identifier -> IFC.Interface', 'SCHEMA', 'ORG', 'TABLE',
     'Module', 'COLUMN', 'InterfaceID'
go

create index IXFK_Module_Code
    on ORG.Module (ModuleCode)
go

create index IXFK_Module_Code_02
    on ORG.Module (StopAllowedCode)
go

create index IXFK_Module_Code_03
    on ORG.Module (StatusCode)
go

create index IXFK_Module_Object
    on ORG.Module (ObjectID)
go

create table ORG.ModuleProcedure
(
    ID                   numeric(16) identity
        constraint PK_ModuleProcedure
            primary key,
    ModuleID             numeric(16)
        constraint FK_ModuleProcedure_Module
            references ORG.Module,
    SQLStatement         nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'ModuleProcedure',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Module identifier -> ORG.Module', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleProcedure', 'COLUMN', 'ModuleID'
go

exec sp_addextendedproperty 'MS_Description', 'SQL statement', 'SCHEMA', 'ORG', 'TABLE', 'ModuleProcedure', 'COLUMN',
     'SQLStatement'
go

create index IXFK_ModuleProcedure_Module
    on ORG.ModuleProcedure (ModuleID)
go

create table ORG.ModuleSchedule
(
    ID                   numeric(16) identity
        constraint PK_ModuleSchedule
            primary key,
    ObjectID             numeric(16)
        constraint FK_ModuleSchedule_Object
            references GEN.Object,
    ModuleID             numeric(16)
        constraint FK_ModuleSchedule_Module
            references ORG.Module,
    RepeatUnit           nvarchar(200)
        constraint FK_ModuleSchedule_Code_03
            references GEN.Code,
    RepeatPeriod         numeric(16),
    RepeatDaysOfWeek     nvarchar(7),
    RepeatErrorHandling  nvarchar(200)
        constraint FK_ModuleSchedule_Code
            references GEN.Code,
    BeginDate            date,
    BeginTime            time,
    EndDate              date,
    EndTime              time,
    Enabled              nvarchar(200)
        constraint FK_ModuleSchedule_Code_02
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ScheduleCreated      nvarchar(200)
        constraint FK_ModuleSchedule_Code_04
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'n', 'SCHEMA', 'ORG', 'TABLE', 'ModuleSchedule'
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'ModuleSchedule', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Module identifier -> ORG.Module', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'ModuleID'
go

exec sp_addextendedproperty 'MS_Description', 'Repeat unit value set -> VALUESET_REPEAT_UNIT', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'RepeatUnit'
go

exec sp_addextendedproperty 'MS_Description', 'Repeat period', 'SCHEMA', 'ORG', 'TABLE', 'ModuleSchedule', 'COLUMN',
     'RepeatPeriod'
go

exec sp_addextendedproperty 'MS_Description', 'Repeat error handling value set -> VALUESET_REPEAT_ERROR_HANDLING',
     'SCHEMA', 'ORG', 'TABLE', 'ModuleSchedule', 'COLUMN', 'RepeatErrorHandling'
go

exec sp_addextendedproperty 'MS_Description', 'Begin date of module scheduling', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'BeginDate'
go

exec sp_addextendedproperty 'MS_Description', 'Begin time of module scheduling', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'BeginTime'
go

exec sp_addextendedproperty 'MS_Description', 'End date of module scheduling', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'EndDate'
go

exec sp_addextendedproperty 'MS_Description', 'End time of module scheduling', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'EndTime'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean value set -> VALUESET_BOOLEAN', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'Enabled'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description',
     'Whether the the dynamic schedule has been created by microservice -> value set BOOLEAN', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleSchedule', 'COLUMN', 'ScheduleCreated'
go

create table ORG.ModuleInstance
(
    ID                   numeric(16) identity
        constraint PK_ModuleInstance
            primary key,
    ObjectID             numeric(16)
        constraint FK_ModuleInstance_Object
            references GEN.Object,
    ModuleID             numeric(16)
        constraint FK_ModuleInstance_Module
            references ORG.Module,
    StatusCode           nvarchar(200)
        constraint FK_ModuleInstance_Code
            references GEN.Code,
    CorrelationID        nvarchar(200),
    BeginDate            date,
    BeginTime            time,
    EndDate              date,
    EndTime              time,
    Progress             numeric(6, 3),
    ErrorMessage         nvarchar(max),
    MessageQueueTopic    nvarchar(200),
    LastHeartbeatDate    date,
    LastHeartbeatTime    time,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ScheduleDate         date,
    ScheduleTime         time,
    ModuleScheduleID     numeric(16)
        constraint FK_ModuleInstance_ModuleSchedule_04
            references ORG.ModuleSchedule
)
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstance', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Module identifier -> ORG.Module', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstance', 'COLUMN', 'ModuleID'
go

exec sp_addextendedproperty 'MS_Description', 'Module instance status value set -> VALUESET_MODULE_INSTANCE_STATUS',
     'SCHEMA', 'ORG', 'TABLE', 'ModuleInstance', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Correlation (session) ID', 'SCHEMA', 'ORG', 'TABLE', 'ModuleInstance',
     'COLUMN', 'CorrelationID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when processing the module instance has started', 'SCHEMA', 'ORG',
     'TABLE', 'ModuleInstance', 'COLUMN', 'BeginDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when processing the module instance has started', 'SCHEMA', 'ORG',
     'TABLE', 'ModuleInstance', 'COLUMN', 'BeginTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when processing the module instance has finished', 'SCHEMA', 'ORG',
     'TABLE', 'ModuleInstance', 'COLUMN', 'EndDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when processing the module instance has finished', 'SCHEMA', 'ORG',
     'TABLE', 'ModuleInstance', 'COLUMN', 'EndTime'
go

exec sp_addextendedproperty 'MS_Description', 'Progress % of the process 0-100', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstance', 'COLUMN', 'Progress'
go

exec sp_addextendedproperty 'MS_Description', 'Short error message (details are in log)', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstance', 'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Message queue / Kafka topic', 'SCHEMA', 'ORG', 'TABLE', 'ModuleInstance',
     'COLUMN', 'MessageQueueTopic'
go

exec sp_addextendedproperty 'MS_Description', 'Date of the last heartbeat', 'SCHEMA', 'ORG', 'TABLE', 'ModuleInstance',
     'COLUMN', 'LastHeartbeatDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time of the last heartbeat', 'SCHEMA', 'ORG', 'TABLE', 'ModuleInstance',
     'COLUMN', 'LastHeartbeatTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstance', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstance', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstance', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstance', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstance', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstance', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Single schedule date (for manually initiated module instances)',
     'SCHEMA', 'ORG', 'TABLE', 'ModuleInstance', 'COLUMN', 'ScheduleDate'
go

exec sp_addextendedproperty 'MS_Description', 'Single schedule time (manual scheduling)', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstance', 'COLUMN', 'ScheduleTime'
go

exec sp_addextendedproperty 'MS_Description',
     'The ID of the module schedule, if the moduleInstance was automatically created based on a schedule (null for manually initiated module instances) --> ORG.ModuleSchedule',
     'SCHEMA', 'ORG', 'TABLE', 'ModuleInstance', 'COLUMN', 'ModuleScheduleID'
go

create index IXFK_ModuleInstance_Code
    on ORG.ModuleInstance (StatusCode)
go

create index IXFK_ModuleInstance_Module
    on ORG.ModuleInstance (ModuleID)
go

create index IXFK_ModuleInstance_Object
    on ORG.ModuleInstance (ObjectID)
go

create table ORG.ModuleInstanceParameter
(
    ID                   numeric(16) identity
        constraint PK_ModuleInstanceParameter
            primary key,
    ObjectID             numeric(16)
        constraint FK_ModuleInstanceParameter_Object
            references GEN.Object,
    ModuleInstanceID     numeric(16)
        constraint FK_ModuleInstanceParameter_ModuleInstance
            references ORG.ModuleInstance,
    ParameterCode        nvarchar(200)
        constraint FK_ModuleInstanceParameter_Code
            references GEN.Code,
    ParameterID          numeric(16),
    ParameterValue       nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'ModuleInstanceParameter',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstanceParameter', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Module instance identifier -> ORG.ModuleInstance', 'SCHEMA', 'ORG',
     'TABLE', 'ModuleInstanceParameter', 'COLUMN', 'ModuleInstanceID'
go

exec sp_addextendedproperty 'MS_Description', 'Module parameter value set -> VALUESET_MODULE_PARAMETER', 'SCHEMA',
     'ORG', 'TABLE', 'ModuleInstanceParameter', 'COLUMN', 'ParameterCode'
go

exec sp_addextendedproperty 'MS_Description', 'Parameter value, if the parameter is a numeric identifier', 'SCHEMA',
     'ORG', 'TABLE', 'ModuleInstanceParameter', 'COLUMN', 'ParameterID'
go

exec sp_addextendedproperty 'MS_Description', 'Parameter value, if the parameter is an alphanumeric value', 'SCHEMA',
     'ORG', 'TABLE', 'ModuleInstanceParameter', 'COLUMN', 'ParameterValue'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstanceParameter', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstanceParameter', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstanceParameter', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstanceParameter', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleInstanceParameter', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_ModuleInstanceParameter_Code
    on ORG.ModuleInstanceParameter (ParameterCode)
go

create index IXFK_ModuleInstanceParameter_ModuleInstance
    on ORG.ModuleInstanceParameter (ModuleInstanceID)
go

create index IXFK_ModuleInstanceParameter_Object
    on ORG.ModuleInstanceParameter (ObjectID)
go

create index IXFK_ModuleSchedule_Code
    on ORG.ModuleSchedule (RepeatErrorHandling)
go

create index IXFK_ModuleSchedule_Code_02
    on ORG.ModuleSchedule (Enabled)
go

create index IXFK_ModuleSchedule_Code_03
    on ORG.ModuleSchedule (RepeatUnit)
go

create index IXFK_ModuleSchedule_Module
    on ORG.ModuleSchedule (ModuleID)
go

create index IXFK_ModuleSchedule_Object
    on ORG.ModuleSchedule (ObjectID)
go

create table ORG.ModuleScheduleParameter
(
    ID                   numeric(16) identity
        constraint PK_ModuleScheduleParameter
            primary key,
    ObjectID             numeric(16)
        constraint FK_ModuleScheduleParameter_Object
            references GEN.Object,
    ModuleScheduleID     numeric(16)
        constraint FK_ModuleScheduleParameter_ModuleSchedule
            references ORG.ModuleSchedule,
    ParameterCode        nvarchar(200)
        constraint FK_ModuleScheduleParameter_Code
            references GEN.Code,
    ParameterID          numeric(16),
    ParameterValue       nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'ModuleScheduleParameter',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleScheduleParameter', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Module schedule identifier -> ORG.ModuleSchedule', 'SCHEMA', 'ORG',
     'TABLE', 'ModuleScheduleParameter', 'COLUMN', 'ModuleScheduleID'
go

exec sp_addextendedproperty 'MS_Description', 'Module parameter value set -> VALUESET_MODULE_PARAMETER', 'SCHEMA',
     'ORG', 'TABLE', 'ModuleScheduleParameter', 'COLUMN', 'ParameterCode'
go

exec sp_addextendedproperty 'MS_Description', 'Parameter value, if the parameter is a numeric identifier', 'SCHEMA',
     'ORG', 'TABLE', 'ModuleScheduleParameter', 'COLUMN', 'ParameterID'
go

exec sp_addextendedproperty 'MS_Description', 'Parameter value, if the parameter is an alphanumeric value', 'SCHEMA',
     'ORG', 'TABLE', 'ModuleScheduleParameter', 'COLUMN', 'ParameterValue'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleScheduleParameter', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleScheduleParameter', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleScheduleParameter', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleScheduleParameter', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleScheduleParameter', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleScheduleParameter', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_ModuleScheduleParameter_Code
    on ORG.ModuleScheduleParameter (ParameterCode)
go

create index IXFK_ModuleScheduleParameter_ModuleSchedule
    on ORG.ModuleScheduleParameter (ModuleScheduleID)
go

create index IXFK_ModuleScheduleParameter_Object
    on ORG.ModuleScheduleParameter (ObjectID)
go

create table PRT.Name
(
    ID                   numeric(16) identity
        constraint PK_Name
            primary key,
    ObjectID             numeric(16)
        constraint FK_Name_Object
            references GEN.Object,
    EntityID             numeric(16)
        constraint FK_Name_Entity
            references PRT.Entity,
    NameTypeCode         nvarchar(200)
        constraint FK_Name_Code
            references GEN.Code,
    Name                 nvarchar(200),
    ValidFrom            date,
    ValidUntil           date,
    StatusCode           nvarchar(200)
        constraint FK_Name_Code_02
            references GEN.Code,
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    DataOriginCode       nvarchar(200)
        constraint FK_Name_Code_03
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'PRT', 'TABLE', 'Name',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Entity identifier -> PRT.Entity', 'SCHEMA', 'PRT', 'TABLE', 'Name',
     'COLUMN', 'EntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Name type value set -> NAME_TYPE', 'SCHEMA', 'PRT', 'TABLE', 'Name',
     'COLUMN', 'NameTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'PRT', 'TABLE', 'Name', 'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'valid until', 'SCHEMA', 'PRT', 'TABLE', 'Name', 'COLUMN', 'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Name status value set -> STATUS_NAME', 'SCHEMA', 'PRT', 'TABLE', 'Name',
     'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'PRT', 'TABLE', 'Name', 'COLUMN',
     'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier (external system)', 'SCHEMA', 'PRT', 'TABLE', 'Name',
     'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'PRT', 'TABLE', 'Name',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'PRT', 'TABLE', 'Name',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Data origin value set -> DATA_ORIGIN', 'SCHEMA', 'PRT', 'TABLE', 'Name',
     'COLUMN', 'DataOriginCode'
go

create index IXFK_Name_Code
    on PRT.Name (NameTypeCode)
go

create index IXFK_Name_Code_02
    on PRT.Name (StatusCode)
go

create index IXFK_Name_Entity
    on PRT.Name (EntityID)
go

create index IXFK_Name_Object
    on PRT.Name (ObjectID)
go

create index IXFK_Object_Object
    on GEN.Object (PrevObjectID)
go

create index IXFK_Object_Portfolio
    on GEN.Object (PortfolioID)
go

create table GEN.ObjectGroup
(
    ID                   numeric(16) identity
        constraint PK_ObjectGroup
            primary key,
    ObjectID             numeric(16)
        constraint FK_ObjectGroup_Object
            references GEN.Object,
    ObjectTypeCode       nvarchar(200)
        constraint FK_ObjectGroup_Code
            references GEN.Code,
    Name                 nvarchar(200)
        unique,
    PrivateGroupCode     nvarchar(200)
        constraint FK_ObjectGroup_Code_02
            references GEN.Code,
    MembersProtectedCode nvarchar(200)
        constraint FK_ObjectGroup_Code_03
            references GEN.Code,
    AppUserName          nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'ObjectGroup', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroup', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Object type -> value set OBJECT_TYPE', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroup', 'COLUMN', 'ObjectTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Name of the group', 'SCHEMA', 'GEN', 'TABLE', 'ObjectGroup', 'COLUMN',
     'Name'
go

exec sp_addextendedproperty 'MS_Description', 'Private group? -> value set BOOLEAN', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroup', 'COLUMN', 'PrivateGroupCode'
go

exec sp_addextendedproperty 'MS_Description', 'Members protected? -> value set BOOLEAN', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroup', 'COLUMN', 'MembersProtectedCode'
go

exec sp_addextendedproperty 'MS_Description', 'Owner of the group -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroup', 'COLUMN', 'AppUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'ObjectGroup',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'ObjectGroup',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroup', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroup', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroup', 'COLUMN', 'LastModifiedUserName'
go

create table GEN.ObjectGroupMember
(
    ID                   numeric(16) identity
        constraint PK_ObjectGroupMember
            primary key,
    ObjectGroupID        numeric(16)
        constraint FK_ObjectGroupMember_ObjectGroup
            references GEN.ObjectGroup,
    ReferencedObjectID   numeric(16)
        constraint FK_ObjectGroupMember_Object
            references GEN.Object,
    StatusCode           nvarchar(200)
        constraint FK_ObjectGroupMember_Code
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'ObjectGroupMember',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object group identifier -> GEN.ObjectGroup', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'ObjectGroupID'
go

exec sp_addextendedproperty 'MS_Description', 'Member object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'ReferencedObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Status code -> value set OBJECT_GROUP_MEMBER_STATUS', 'SCHEMA', 'GEN',
     'TABLE', 'ObjectGroupMember', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'LastModifiedUserName'
go

create table GEN.ObjectIdentifier
(
    ID                   numeric(16) identity
        constraint PK_ObjectIdentifier
            primary key,
    ReferencedObjectID   numeric(16)
        constraint FK_ObjectIdentifier_Object
            references GEN.Object
            on delete cascade,
    IdentifierTypeCode   nvarchar(200)
        constraint FK_ObjectIdentifier_Code
            references GEN.Code,
    Identifier           nvarchar(100),
    ValidFrom            date,
    ValidUntil           date,
    StatusCode           nvarchar(200)
        constraint FK_ObjectIdentifier_Code_02
            references GEN.Code,
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    DataOriginCode       nvarchar(200)
        constraint FK_ObjectIdentifier_Code_03
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'ObjectIdentifier',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Referenced object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'ReferencedObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Identifier type -> value set IDENTIFIER_TYPE', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'IdentifierTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'The identifier', 'SCHEMA', 'GEN', 'TABLE', 'ObjectIdentifier', 'COLUMN',
     'Identifier'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'GEN', 'TABLE', 'ObjectIdentifier', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'GEN', 'TABLE', 'ObjectIdentifier', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Status code -> value set IDENTIFIER_STATUS', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'GEN', 'TABLE', 'ObjectIdentifier',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier', 'SCHEMA', 'GEN', 'TABLE', 'ObjectIdentifier',
     'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered ', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Data origin value set -> DATA_ORIGIN', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'DataOriginCode'
go

create index IXFK_ObjectIdentifier_Code
    on GEN.ObjectIdentifier (IdentifierTypeCode)
go

create index IXFK_ObjectIdentifier_Code_02
    on GEN.ObjectIdentifier (StatusCode)
go

create index IXFK_ObjectIdentifier_Object
    on GEN.ObjectIdentifier (ReferencedObjectID)
go

create table COM.ObjectTask
(
    ID                   numeric(16) identity
        constraint PK_ObjectTask
            primary key,
    ObjectID             numeric(16)
        constraint FK_ObjectTask_Object
            references GEN.Object,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_ObjectTask_Object
    on COM.ObjectTask (ObjectID)
go

create table DCS.Package
(
    ID                   numeric(16) identity
        constraint PK_Package
            primary key,
    ObjectID             numeric(16)
        constraint FK_Package_Object
            references GEN.Object,
    Name                 nvarchar(200),
    PortfolioID          numeric(16)
        constraint FK_Package_Portfolio
            references GEN.Portfolio,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'DCS', 'TABLE', 'Package', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'DCS', 'TABLE', 'Package',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Name of the package', 'SCHEMA', 'DCS', 'TABLE', 'Package', 'COLUMN',
     'Name'
go

exec sp_addextendedproperty 'MS_Description', 'Portfolio identifier -> GEN.Portfolio', 'SCHEMA', 'DCS', 'TABLE',
     'Package', 'COLUMN', 'PortfolioID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'DCS', 'TABLE', 'Package',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'DCS', 'TABLE', 'Package',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'DCS', 'TABLE',
     'Package', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'DCS', 'TABLE',
     'Package', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'DCS', 'TABLE', 'Package',
     'COLUMN', 'LastModifiedUserName'
go

create table PRT.Party
(
    ID                    numeric(16) identity
        constraint PK_Party
            primary key,
    ObjectID              numeric(16),
    EntityID              numeric(16)
        constraint FK_Party_Entity
            references PRT.Entity,
    ClientNr              nvarchar(200),
    Status                nvarchar(200),
    CreationDate          date,
    CreationTime          time,
    CreationUserName      nvarchar(200),
    LastModifiedDate      date,
    LastModifiedTime      time,
    LastModifiedUserName  nvarchar(200),
    PartyTypeCode         nvarchar(200)
        constraint FK_Party_Code
            references GEN.Code,
    PartyClassCode        nvarchar(200)
        constraint FK_Party_Code_02
            references GEN.Code,
    StatusCode            nvarchar(200)
        constraint FK_Party_Code_03
            references GEN.Code,
    OfficeEntityID        numeric(16)
        constraint FK_Party_Entity_02
            references PRT.Entity,
    SupplierAccountTypeID numeric(16)
        constraint FK_Party_AccountType
            references FIN.AccountType,
    BuyerAccountTypeID    numeric(16)
        constraint FK_Party_AccountType_02
            references FIN.AccountType
)
go

exec sp_addextendedproperty 'MS_Description', 'Party type value set -> PARTY_TYPE', 'SCHEMA', 'PRT', 'TABLE', 'Party',
     'COLUMN', 'PartyTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Party class value set -> PARTY_CLASS', 'SCHEMA', 'PRT', 'TABLE', 'Party',
     'COLUMN', 'PartyClassCode'
go

exec sp_addextendedproperty 'MS_Description', 'Status value set -> PARTY_STATUS', 'SCHEMA', 'PRT', 'TABLE', 'Party',
     'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Office entity identifier -> PRT.Entity', 'SCHEMA', 'PRT', 'TABLE',
     'Party', 'COLUMN', 'OfficeEntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Account type for supplier accounting -> FIN.AccountType', 'SCHEMA',
     'PRT', 'TABLE', 'Party', 'COLUMN', 'SupplierAccountTypeID'
go

exec sp_addextendedproperty 'MS_Description', 'Account type for buyer accounting -> FIN.AccountType', 'SCHEMA', 'PRT',
     'TABLE', 'Party', 'COLUMN', 'BuyerAccountTypeID'
go

create table IFC.AccountingSystem
(
    ID                           numeric(16) identity
        constraint PK_AccountingSystem
            primary key,
    Code                         nvarchar(200)
        constraint FK_AccountingSystem_Code
            references GEN.Code,
    EntityID                     numeric(16)
        constraint FK_AccountingSystem_EntityID
            references PRT.Entity,
    PartyID                      numeric(16)
        constraint FK_AccountingSystem_PartyID
            references PRT.Party,
    RepaymentAccountRequiredCode nvarchar(200)
        constraint FK_AccountingSystem_RepaymentAccountRequiredCode
            references GEN.Code,
    CreationDate                 date,
    CreationTime                 time,
    CreationUserName             nvarchar(200),
    LastModifiedDate             date,
    LastModifiedTime             time,
    LastModifiedUserName         nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'AccountingSystem',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Code of the accounting system -> value set ACCOUNTING_SYSTEM', 'SCHEMA',
     'IFC', 'TABLE', 'AccountingSystem', 'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', '(Creditor) entity identifier -> PRT.Entity', 'SCHEMA', 'IFC', 'TABLE',
     'AccountingSystem', 'COLUMN', 'EntityID'
go

exec sp_addextendedproperty 'MS_Description', '(Creditor) party identifier -> PRT.Party', 'SCHEMA', 'IFC', 'TABLE',
     'AccountingSystem', 'COLUMN', 'PartyID'
go

exec sp_addextendedproperty 'MS_Description', 'The repayment account is required? -> value set BOOLEAN', 'SCHEMA',
     'IFC', 'TABLE', 'AccountingSystem', 'COLUMN', 'RepaymentAccountRequiredCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'AccountingSystem', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'AccountingSystem', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'AccountingSystem', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'AccountingSystem', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'AccountingSystem', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'AccountingSystem', 'COLUMN', 'LastModifiedUserName'
go

create table CRM.Contract
(
    ID                     numeric(16) identity
        constraint PK_Contract
            primary key,
    ObjectID               numeric(16)
        constraint FK_Contract_Object
            references GEN.Object,
    SellerName             nvarchar(200),
    SellerPartyID          numeric(16)
        constraint FK_Contract_Party
            references PRT.Party,
    BuyerName              nvarchar(200),
    BuyerPartyID           numeric(16)
        constraint FK_Contract_Party_02
            references PRT.Party,
    ReferencedContractID   numeric(16),
    ContractTypeCode       nvarchar(200),
    ContractPhaseCode      nvarchar(200),
    StatusCode             nvarchar(200),
    ContractNr             nvarchar(200),
    RegistrationNr         nvarchar(200),
    ExternalContractNr     nvarchar(200),
    ValidFrom              date,
    ValidUntil             date,
    CreationDate           date,
    CreationTime           time,
    CreationUserName       nvarchar(200),
    LastModifiedDate       date,
    LastModifiedTime       time,
    LastModifiedUserName   nvarchar(200),
    DecisionNr             nvarchar(200),
    ContractDate           date,
    DataOriginCode         nvarchar(200)
        constraint FK_Contract_Code
            references GEN.Code,
    SourceInterfaceType    nvarchar(200),
    SourceID               nvarchar(200),
    FinancialMilestoneDate date
)
go

exec sp_addextendedproperty 'MS_Description', 'Data origin value set -> DATA_ORIGIN', 'SCHEMA', 'CRM', 'TABLE',
     'Contract', 'COLUMN', 'DataOriginCode'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'CRM', 'TABLE', 'Contract', 'COLUMN',
     'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source Identifier', 'SCHEMA', 'CRM', 'TABLE', 'Contract', 'COLUMN',
     'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Financial milestone date', 'SCHEMA', 'CRM', 'TABLE', 'Contract',
     'COLUMN', 'FinancialMilestoneDate'
go

create table CRM.CollectionContractSummary
(
    ID                        numeric(16) identity
        constraint PK_CollectionContractSummary
            primary key,
    ObjectID                  numeric(16)
        constraint FK_CollectionContractSummary_Object
            references GEN.Object,
    ContractID                numeric(16)
        constraint FK_CollectionContractSummary_Contract
            references CRM.Contract,
    ItemCount                 numeric(16),
    DebtCapital               money,
    DebtInterest              money,
    DebtCost                  money,
    DebtCostLocalCurrency     money,
    DebtTotal                 money,
    CreationDate              date,
    CreationTime              time,
    CreationUserName          nvarchar(200),
    LastModifiedDate          date,
    LastModifiedTime          time,
    LastModifiedUserName      nvarchar(200),
    CurrencyCode              nvarchar(200)
        constraint FK_CollectionContractSummary_Code
            references GEN.Code,
    DebtPenaltyInterest       money,
    PurchasePrice             money,
    PurchasePriceCurrencyCode nvarchar(200)
        constraint FK_CollectionContractSummary_Code_02
            references GEN.Code
)
go

create index IXFK_CollectionContractSummary_Contract
    on CRM.CollectionContractSummary (ContractID)
go

create index IXFK_CollectionContractSummary_Code
    on CRM.CollectionContractSummary (CurrencyCode)
go

create index IXFK_CollectionContractSummary_Code_02
    on CRM.CollectionContractSummary (PurchasePriceCurrencyCode)
go

create index IXFK_CollectionContractSummary_Object
    on CRM.CollectionContractSummary (ObjectID)
go

create index IXFK_Contract_Party
    on CRM.Contract (SellerPartyID)
go

create index IXFK_Contract_Party_02
    on CRM.Contract (BuyerPartyID)
go

create index IXFK_Contract_CollectionContractSummary
    on CRM.Contract (ObjectID)
go

create index IXFK_Contract_Object
    on CRM.Contract (ObjectID)
go

create table CRM.ContractItem
(
    ID                       numeric(16) identity
        constraint PK_ContractItem
            primary key,
    ObjectID                 numeric(16),
    ContractID               numeric(16)
        constraint FK_ContractItem_Contract
            references CRM.Contract,
    ReferencedContractItemID numeric(16)
        constraint FK_ContractItem_ContractItem
            references CRM.ContractItem,
    SequenceNr               numeric(16),
    ReferenceNr              nvarchar(200),
    NetValue                 money,
    VATValue                 money,
    GrossValue               money,
    CurrencyID               nvarchar(200),
    ProductID                nvarchar(50),
    Description              nvarchar(max),
    Status                   nvarchar(200),
    CreationDate             date,
    CreationTime             time,
    CreationUserName         nvarchar(200),
    LastModifiedDate         date,
    LastModifiedTime         time,
    LastModifiedUserName     nvarchar(200)
)
go

create index IXFK_ContractItem_Contract
    on CRM.ContractItem (ContractID)
go

create index IXFK_ContractItem_ContractItem
    on CRM.ContractItem (ReferencedContractItemID)
go

create table CRM.ContractSigner
(
    ID                   numeric(16) identity
        constraint PK_ContractSigner
            primary key,
    ObjectID             numeric(16),
    ContractID           numeric(16)
        constraint FK_ContractSigner_Contract
            references CRM.Contract,
    PartyID              numeric(16)
        constraint FK_ContractSigner_Party
            references PRT.Party,
    EntityID             numeric(16),
    SignMethod           nvarchar(50),
    RejectDate           date,
    RejectTime           time,
    SignDate             date,
    SignTime             time,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_ContractSigner_Contract
    on CRM.ContractSigner (ContractID)
go

create index IXFK_ContractSigner_Party
    on CRM.ContractSigner (PartyID)
go

create table IFC.InterfacePackage
(
    ID                   numeric(16) identity
        constraint PK_ImportPackage
            primary key,
    ObjectID             numeric(16)
        constraint FK_InterfacePackage_Object
            references GEN.Object,
    SourceInterfaceType  nvarchar(200),
    CostumerID           numeric(16),
    CreditorCode         nvarchar(200),
    ImportDate           date,
    Status               nvarchar(200),
    ImportType           nvarchar(10),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    PartyID              numeric(16)
        constraint FK_InterfacePackage_Party
            references PRT.Party,
    ContractID           numeric(16)
        constraint FK_InterfacePackage_Contract
            references CRM.Contract,
    ContractNr           nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Party identifier -> PRT.Party', 'SCHEMA', 'IFC', 'TABLE',
     'InterfacePackage', 'COLUMN', 'PartyID'
go

exec sp_addextendedproperty 'MS_Description', 'Contract identifier -> CRM.Contract', 'SCHEMA', 'IFC', 'TABLE',
     'InterfacePackage', 'COLUMN', 'ContractID'
go

exec sp_addextendedproperty 'MS_Description', 'Contract number', 'SCHEMA', 'IFC', 'TABLE', 'InterfacePackage', 'COLUMN',
     'ContractNr'
go

create index IXFK_InterfacePackage_Object
    on IFC.InterfacePackage (ObjectID)
go

create index IXFK_InterfacePackage_Contract
    on IFC.InterfacePackage (ContractID)
go

create index IXFK_InterfacePackage_Party
    on IFC.InterfacePackage (PartyID)
go

create index IXFK_Party_Entity
    on PRT.Party (EntityID)
go

create index IXFK_Party_Code
    on PRT.Party (PartyTypeCode)
go

create index IXFK_Party_Code_02
    on PRT.Party (PartyClassCode)
go

create index IXFK_Party_Code_03
    on PRT.Party (StatusCode)
go

create index IXFK_Party_Entity_02
    on PRT.Party (OfficeEntityID)
go

create table FIN.Period
(
    ID                   numeric(16) identity
        constraint PK_Period
            primary key,
    ObjectID             numeric(16)
        constraint FK_Period_Object
            references GEN.Object,
    BeginDate            date,
    EndDate              date,
    StatusCode           nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Name                 nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Name of the period', 'SCHEMA', 'FIN', 'TABLE', 'Period', 'COLUMN', 'Name'
go

create index IXFK_Period_Object
    on FIN.Period (ObjectID)
go

create table PRT.Person
(
    ID                         numeric(16) identity
        constraint [PK_CIS.Person]
            primary key,
    LastName                   nvarchar(150),
    MiddleName                 nvarchar(150),
    FirstName                  nvarchar(150),
    Title                      nvarchar(200)
        constraint FK_Person_Code_06
            references GEN.Code,
    MotherLastName             nvarchar(150),
    MotherFirstName            nvarchar(150),
    BirthPlace                 nvarchar(150),
    BirthDate                  date,
    Sex                        nvarchar(500),
    MaidenLastName             varchar(150),
    MaidenFirstName            nvarchar(150),
    FathersName                nvarchar(150),
    EntityID                   numeric(16)
        constraint FK_Person_Entity
            references PRT.Entity
            on delete cascade,
    CreationDate               date,
    CreationTime               time,
    CreationUserName           nvarchar(200),
    LastModifiedDate           date,
    LastModifiedTime           time,
    LastModifiedUserName       nvarchar(200),
    NationalityCode            nvarchar(200)
        constraint FK_Person_Code_02
            references GEN.Code,
    BirthCountryCode           nvarchar(200)
        constraint FK_Person_Code
            references GEN.Code,
    DeathDate                  date,
    DeathCountryCode           nvarchar(200)
        constraint FK_Person_Code_03
            references GEN.Code,
    DeathZipCode               nvarchar(200),
    DeathPlace                 nvarchar(200),
    StatusCode                 nvarchar(200)
        constraint FK_Person_Code_04
            references GEN.Code,
    LegacyAssetCode            nvarchar(200)
        constraint FK_Person_Code_05
            references GEN.Code,
    LegacyProcessCompletedCode nvarchar(200)
        constraint FK_Person_Code_07
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Person', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'PRT', 'TABLE', 'Person',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Person',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'PRT', 'TABLE', 'Person',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'PRT', 'TABLE',
     'Person', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Person',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'PRT', 'TABLE', 'Person',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Nationality value set -> NATIONALITY', 'SCHEMA', 'PRT', 'TABLE',
     'Person', 'COLUMN', 'NationalityCode'
go

exec sp_addextendedproperty 'MS_Description', 'Country value set -> COUNTRY', 'SCHEMA', 'PRT', 'TABLE', 'Person',
     'COLUMN', 'BirthCountryCode'
go

exec sp_addextendedproperty 'MS_Description', 'Legacy asset -> value set BOOLEAN', 'SCHEMA', 'PRT', 'TABLE', 'Person',
     'COLUMN', 'LegacyAssetCode'
go

exec sp_addextendedproperty 'MS_Description', 'Legacy process completed? -> value set BOOLEAN', 'SCHEMA', 'PRT',
     'TABLE', 'Person', 'COLUMN', 'LegacyProcessCompletedCode'
go

create index [IXFK_CIS.Person_CIS.Entity]
    on PRT.Person (ID)
go

create index IXFK_Person_Code
    on PRT.Person (BirthCountryCode)
go

create index IXFK_Person_Code_02
    on PRT.Person (NationalityCode)
go

create index IXFK_Person_Code_03
    on PRT.Person (DeathCountryCode)
go

create index IXFK_Person_Code_04
    on PRT.Person (StatusCode)
go

create index IXFK_Person_Entity
    on PRT.Person (EntityID)
go

create table GEN.PortfolioAppUser
(
    ID                   numeric(16) identity
        constraint PK_PortfolioAppUser
            primary key,
    PortfolioID          numeric(16)
        constraint FK_PortfolioAppUser_Portfolio
            references GEN.Portfolio,
    AppUserID            numeric(16),
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'PortfolioAppUser',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Portfolio identifier -> GEN.Portfolio', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioAppUser', 'COLUMN', 'PortfolioID'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioAppUser', 'COLUMN', 'AppUserID'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'GEN', 'TABLE', 'PortfolioAppUser', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'GEN', 'TABLE', 'PortfolioAppUser', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioAppUser', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioAppUser', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioAppUser', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioAppUser', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioAppUser', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioAppUser', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_PortfolioAppUser_Portfolio
    on GEN.PortfolioAppUser (PortfolioID)
go

create table FIN.Pretense
(
    ID                   numeric(16) identity
        constraint PK_Pretense
            primary key,
    ObjectID             numeric(16)
        constraint FK_Pretense_Object
            references GEN.Object,
    Code                 nvarchar(200)
        constraint FK_Pretense_Code
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ValidFrom            date,
    ValidUntil           date,
    StatusCode           nvarchar(200)
        constraint FK_Pretense_Code_02
            references GEN.Code
            on update cascade on delete set null
)
go

exec sp_addextendedproperty 'MS_Description', 'Valid from date', 'SCHEMA', 'FIN', 'TABLE', 'Pretense', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until date', 'SCHEMA', 'FIN', 'TABLE', 'Pretense', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Status of the accounting -> value set STATUS', 'SCHEMA', 'FIN', 'TABLE',
     'Pretense', 'COLUMN', 'StatusCode'
go

create table FIN.Carry
(
    ID                   numeric(16) identity
        constraint PK_Carry
            primary key,
    ObjectID             numeric(16)
        constraint FK_Carry_Object
            references GEN.Object,
    BankJournalDate      date,
    BankValueDate        date,
    ValueDate            date,
    AccountingDate       date,
    ExchangeDate         date,
    Amount               money,
    PretenseID           numeric(16)
        constraint FK_Carry_Pretense
            references FIN.Pretense,
    CreditAccountID      numeric(16)
        constraint FK_Carry_Account
            references FIN.Account,
    DebitAccountID       numeric(16)
        constraint FK_Carry_Account_02
            references FIN.Account,
    StatusCode           nvarchar(200),
    PeriodID             numeric(16)
        constraint FK_Carry_Period
            references FIN.Period,
    DebiTransactionID    numeric(16),
    CreditTransactionID  numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_Carry_Account
    on FIN.Carry (CreditAccountID)
go

create index IXFK_Carry_Account_02
    on FIN.Carry (DebitAccountID)
go

create index IXFK_Carry_Object
    on FIN.Carry (ObjectID)
go

create index IXFK_Carry_Period
    on FIN.Carry (PeriodID)
go

create index IXFK_Carry_Pretense
    on FIN.Carry (PretenseID)
go

create table FIN.Fee
(
    ID                   numeric(16) identity
        constraint PK_Fee
            primary key,
    FeeListID            numeric(16)
        constraint FK_Fee_FeeList
            references FIN.FeeList,
    Code                 nvarchar(200)
        constraint FK_Fee_Code
            references GEN.Code,
    TypeCode             nvarchar(200)
        constraint FK_Fee_Code_02
            references GEN.Code,
    PretenseID           numeric(16)
        constraint FK_Fee_Pretense
            references FIN.Pretense,
    InterestSetID        numeric(16)
        constraint FK_Fee_InterestSet
            references FIN.InterestSet,
    FeeRate              numeric(10, 5),
    FeeValue             numeric(19),
    CurrencyCode         nvarchar(200)
        constraint FK_Fee_Code_03
            references GEN.Code,
    AdjustmentDateID     numeric(16)
        constraint FK_Fee_AdjustmentDate
            references FIN.AdjustmentDate,
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    PeriodTypeCode       nvarchar(200)
        constraint FK_Fee_PeriodTypeCode
            references GEN.Code,
    PeriodMinimumValue   money,
    PeriodMaximumValue   money
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'FIN', 'TABLE', 'Fee', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Fee list identifier -> FIN.FeeList', 'SCHEMA', 'FIN', 'TABLE', 'Fee',
     'COLUMN', 'FeeListID'
go

exec sp_addextendedproperty 'MS_Description', 'Code of the fee -> value set FEE', 'SCHEMA', 'FIN', 'TABLE', 'Fee',
     'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Type of the fee -> value set FEE_TYPE', 'SCHEMA', 'FIN', 'TABLE', 'Fee',
     'COLUMN', 'TypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Pretense identifier -> FIN.Pretense', 'SCHEMA', 'FIN', 'TABLE', 'Fee',
     'COLUMN', 'PretenseID'
go

exec sp_addextendedproperty 'MS_Description', 'Interest set identifier -> FIN.InterestSet', 'SCHEMA', 'FIN', 'TABLE',
     'Fee', 'COLUMN', 'InterestSetID'
go

exec sp_addextendedproperty 'MS_Description',
     'Fee rate (if it is not an interest set). Data is stored in normal format, so for example 20% is stored as 0.2',
     'SCHEMA', 'FIN', 'TABLE', 'Fee', 'COLUMN', 'FeeRate'
go

exec sp_addextendedproperty 'MS_Description', 'Fee value', 'SCHEMA', 'FIN', 'TABLE', 'Fee', 'COLUMN', 'FeeValue'
go

exec sp_addextendedproperty 'MS_Description', 'Currency code -> value set CURRENCY', 'SCHEMA', 'FIN', 'TABLE', 'Fee',
     'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Adjustment date (used for costs) -> FIN.AdjustmentDate', 'SCHEMA', 'FIN',
     'TABLE', 'Fee', 'COLUMN', 'AdjustmentDateID'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from date', 'SCHEMA', 'FIN', 'TABLE', 'Fee', 'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until date', 'SCHEMA', 'FIN', 'TABLE', 'Fee', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'FIN', 'TABLE', 'Fee',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'FIN', 'TABLE', 'Fee',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE', 'Fee', 'COLUMN',
     'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'FIN', 'TABLE', 'Fee',
     'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'FIN', 'TABLE', 'Fee',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE', 'Fee', 'COLUMN',
     'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Period type for the period value limitations -> value set PERIOD_TYPE',
     'SCHEMA', 'FIN', 'TABLE', 'Fee', 'COLUMN', 'PeriodTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Minimum value for the period', 'SCHEMA', 'FIN', 'TABLE', 'Fee', 'COLUMN',
     'PeriodMinimumValue'
go

exec sp_addextendedproperty 'MS_Description', 'Maximum value for the period', 'SCHEMA', 'FIN', 'TABLE', 'Fee', 'COLUMN',
     'PeriodMaximumValue'
go

create index IXFK_Pretense_Code
    on FIN.Pretense (Code)
go

create index IXFK_Pretense_Object
    on FIN.Pretense (ObjectID)
go

create table FIN.PretenseAccounting
(
    ID                   numeric(16) identity
        constraint PK_PretenseAccounting
            primary key,
    ObjectID             numeric(16)
        constraint FK_PretenseAccounting_Object
            references GEN.Object,
    PretenseID           numeric(16)
        constraint FK_PretenseAccounting_Pretense
            references FIN.Pretense,
    DebitAccountTypeID   numeric(16)
        constraint FK_PretenseAccounting_AccountType
            references FIN.AccountType,
    CreditAccountTypeID  numeric(16)
        constraint FK_PretenseAccounting_AccountType_02
            references FIN.AccountType,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ValidFrom            date,
    ValidUntil           date,
    StatusCode           nvarchar(200)
        constraint FK_PretenseAccounting_Code
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Valid from date', 'SCHEMA', 'FIN', 'TABLE', 'PretenseAccounting',
     'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until date', 'SCHEMA', 'FIN', 'TABLE', 'PretenseAccounting',
     'COLUMN', 'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Status of the accounting -> value set STATUS', 'SCHEMA', 'FIN', 'TABLE',
     'PretenseAccounting', 'COLUMN', 'StatusCode'
go

create index IXFK_PretenseAccounting_AccountType
    on FIN.PretenseAccounting (DebitAccountTypeID)
go

create index IXFK_PretenseAccounting_AccountType_02
    on FIN.PretenseAccounting (CreditAccountTypeID)
go

create index IXFK_PretenseAccounting_Object
    on FIN.PretenseAccounting (ObjectID)
go

create index IXFK_PretenseAccounting_Pretense
    on FIN.PretenseAccounting (PretenseID)
go

create table DCS.Property
(
    ID                   numeric(16) identity
        constraint [PK_DCS.Property]
            primary key,
    AccountID            numeric(16),
    CreationDate         date not null,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    CreationTime         time
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'DCS', 'TABLE', 'Property', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'FIN.Accounting Identifier', 'SCHEMA', 'DCS', 'TABLE', 'Property',
     'COLUMN', 'AccountID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'DCS', 'TABLE', 'Property',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'DCS', 'TABLE', 'Property',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'Property', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'DCS', 'TABLE', 'Property',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'DCS', 'TABLE', 'Property',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'DCS', 'TABLE', 'Property', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'DCS', 'TABLE', 'Property',
     'COLUMN', 'CreationTime'
go

create table PRT.Address
(
    ID                    numeric(16) identity
        constraint [PK_CIS/DCS.Address]
            primary key,
    AddressType           nvarchar(50),
    AddressStructure      nvarchar(200)
        constraint FK_AddressCode_04
            references GEN.Code,
    CountryID             nvarchar(200)
        constraint FK_AddressCode_05
            references GEN.Code,
    ZipCode               nvarchar(10),
    Settlement            nvarchar(50),
    District              nvarchar(50),
    PublicPlaceName       nvarchar(50),
    PublicPlaceType       nvarchar(50),
    HouseNr               nvarchar(8),
    LandRegisterReference nvarchar(20),
    Staircase             nvarchar(10),
    Building              nvarchar(50),
    Floor                 nvarchar(10),
    Door                  nvarchar(10),
    ValidFrom             date,
    ValidUntil            date,
    EntityID              numeric(16)
        constraint FK_Address_Entity
            references PRT.Entity,
    ObjectID              numeric(16)
        constraint [FK_CIS/DCS.Address_GEN.Object]
            references GEN.Object
            on delete cascade,
    PropertyID            numeric(16)
        constraint FK_Address_Property
            references DCS.Property,
    CreationDate          date not null,
    CreationTime          time,
    CreationUserName      nvarchar(200),
    LastModifiedDate      date,
    LastModifiedTime      time,
    LastModifiedUserName  nvarchar(200),
    Comments              nvarchar(max),
    AssetID               numeric(16)
        constraint FK_Address_Asset
            references AST.Asset,
    CountryClassCode      nvarchar(200)
        constraint FK_Address_Code
            references GEN.Code,
    DataSource            nvarchar(200),
    SourceInterfaceType   nvarchar(200),
    SourceID              nvarchar(200),
    StatusCode            nvarchar(200)
        constraint FK_Address_Code_02
            references GEN.Code,
    DataOriginCode        nvarchar(200)
        constraint FK_Address_Code_03
            references GEN.Code,
    PublicPlaceTypeOther  nvarchar(100)
)
go

exec sp_addextendedproperty 'MS_Description', 'egyA?ltalA?n CIS?', 'SCHEMA', 'PRT', 'TABLE', 'Address'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Address', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'GEN.Object Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Address', 'COLUMN',
     'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'DCS.Property Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Address', 'COLUMN',
     'PropertyID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'PRT', 'TABLE', 'Address',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Address',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'PRT', 'TABLE', 'Address',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'PRT', 'TABLE',
     'Address', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Address',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'PRT', 'TABLE', 'Address',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'PRT', 'TABLE', 'Address', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Country class value set -> COUNTRY_CLASS', 'SCHEMA', 'PRT', 'TABLE',
     'Address', 'COLUMN', 'CountryClassCode'
go

exec sp_addextendedproperty 'MS_Description', 'Data source value set -> DATA_SOURCE', 'SCHEMA', 'PRT', 'TABLE',
     'Address', 'COLUMN', 'DataSource'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'PRT', 'TABLE', 'Address', 'COLUMN',
     'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier (external system)', 'SCHEMA', 'PRT', 'TABLE',
     'Address', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Data origin value set -> DATA_ORIGIN', 'SCHEMA', 'PRT', 'TABLE',
     'Address', 'COLUMN', 'DataOriginCode'
go

create index IXFK_Address_Entity
    on PRT.Address (EntityID)
go

create index [IXFK_CIS/DCS.Address_DCS.Property]
    on PRT.Address (PropertyID)
go

create index [IXFK_CIS/DCS.Address_GEN.Object]
    on PRT.Address (ObjectID)
go

create index IXFK_Address_Asset
    on PRT.Address (AssetID)
go

create index IXFK_Address_Code_02
    on PRT.Address (StatusCode)
go

create index IXFK_Address_Code
    on PRT.Address (CountryClassCode)
go


create table DCS.PropertyAuction
(
    ID                   numeric(16) identity
        constraint [PK_DCS.PropertyAuction]
            primary key,
    NetValue             money,
    GrossValue           money,
    VATValue             varchar(5),
    ValidFrom            date,
    PropertyID           numeric(16)
        constraint [FK_DCS.PropertyAuction_DCS.Property]
            references DCS.Property,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', N'A?rverA©s', 'SCHEMA', 'DCS', 'TABLE', 'PropertyAuction'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'DCS', 'TABLE', 'PropertyAuction',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Net value of auction', 'SCHEMA', 'DCS', 'TABLE', 'PropertyAuction',
     'COLUMN', 'NetValue'
go

exec sp_addextendedproperty 'MS_Description', 'Gross value of auction', 'SCHEMA', 'DCS', 'TABLE', 'PropertyAuction',
     'COLUMN', 'GrossValue'
go

exec sp_addextendedproperty 'MS_Description', 'Value Added Tax value', 'SCHEMA', 'DCS', 'TABLE', 'PropertyAuction',
     'COLUMN', 'VATValue'
go

exec sp_addextendedproperty 'MS_Description', 'Date of Auction', 'SCHEMA', 'DCS', 'TABLE', 'PropertyAuction', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'DCS.Property Identifier', 'SCHEMA', 'DCS', 'TABLE', 'PropertyAuction',
     'COLUMN', 'PropertyID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyAuction', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyAuction', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyAuction', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyAuction', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyAuction', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyAuction', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'DCS', 'TABLE', 'PropertyAuction', 'COLUMN',
     'Comments'
go

create index [IXFK_DCS.PropertyAuction_DCS.Property]
    on DCS.PropertyAuction (PropertyID)
go

create table DCS.PropertyRegistrationNr
(
    ID                   numeric(16) identity
        constraint [PK_DCS.PropertyRegistrationNr]
            primary key,
    PropertyID           numeric(16)
        constraint [FK_DCS.PropertyRegistrationNr_DCS.Property]
            references DCS.Property,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', N'ez kALlA¶n tA?blA?ba kell?', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRegistrationNr'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRegistrationNr',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'DCS.Property Identifier', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRegistrationNr', 'COLUMN', 'PropertyID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRegistrationNr', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRegistrationNr', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRegistrationNr', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRegistrationNr', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRegistrationNr', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRegistrationNr', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRegistrationNr', 'COLUMN',
     'Comments'
go

create index [IXFK_DCS.PropertyRegistrationNr_DCS.Property]
    on DCS.PropertyRegistrationNr (PropertyID)
go

create table DCS.PropertyRelation
(
    ID                   numeric(16) identity
        constraint [PK_DCS.PropertyRelation]
            primary key,
    PropertyID           numeric(16) not null
        constraint [FK_DCS.PropertyRelation_DCS.Property]
            references DCS.Property,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', N'tulajdonosok A©s bA©rlL‘k', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRelation'
go

exec sp_addextendedproperty 'MS_Description', 'DCS.Property Identifier', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRelation',
     'COLUMN', 'PropertyID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRelation', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRelation', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRelation', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRelation', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRelation', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRelation', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRelation', 'COLUMN',
     'Comments'
go

create index [IXFK_DCS.PropertyRelation_DCS.Property]
    on DCS.PropertyRelation (PropertyID)
go

create table DCS.PropertyRight
(
    ID                   numeric(16) identity
        constraint [PK_DCS.PropertyRight]
            primary key,
    NetValue             money,
    GrossValue           money,
    VATValue             varchar(5),
    ValidFrom            date,
    PropertyID           numeric(16)
        constraint [FK_DCS.PropertyRight_DCS.Property]
            references DCS.Property,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', 'jogok', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRight'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRight', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Net value of auction', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRight',
     'COLUMN', 'NetValue'
go

exec sp_addextendedproperty 'MS_Description', 'Gross value of auction', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRight',
     'COLUMN', 'GrossValue'
go

exec sp_addextendedproperty 'MS_Description', 'Value Added Tax value', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRight',
     'COLUMN', 'VATValue'
go

exec sp_addextendedproperty 'MS_Description', 'Date of Valuation', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRight', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'DCS.Property Identifier', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRight',
     'COLUMN', 'PropertyID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRight',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRight',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRight',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRight', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRight', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'DCS', 'TABLE',
     'PropertyRight', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'DCS', 'TABLE', 'PropertyRight', 'COLUMN',
     'Comments'
go

create index [IXFK_DCS.PropertyRight_DCS.Property]
    on DCS.PropertyRight (PropertyID)
go

create table DCS.PropertySuperstructure
(
    ID                   numeric(16) identity
        constraint [PK_DCS.PropertySuperstructure]
            primary key,
    PropertyID           numeric(16)
        constraint [FK_DCS.PropertySuperstructure_DCS.Property]
            references DCS.Property,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', N'A©pALletek', 'SCHEMA', 'DCS', 'TABLE', 'PropertySuperstructure'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'DCS', 'TABLE', 'PropertySuperstructure',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'DCS.Property Identifier', 'SCHEMA', 'DCS', 'TABLE',
     'PropertySuperstructure', 'COLUMN', 'PropertyID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertySuperstructure', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertySuperstructure', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertySuperstructure', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertySuperstructure', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'DCS', 'TABLE',
     'PropertySuperstructure', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'DCS', 'TABLE',
     'PropertySuperstructure', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'DCS', 'TABLE', 'PropertySuperstructure', 'COLUMN',
     'Comments'
go

create index [IXFK_DCS.PropertySuperstructure_DCS.Property]
    on DCS.PropertySuperstructure (PropertyID)
go

create table PRT.PropertyValuation
(
    ID                   numeric(16) identity
        constraint [PK_DCS.PropertyValuation]
            primary key,
    ValidFrom            date,
    PropertyID           numeric(16)
        constraint [FK_DCS.PropertyValuation_DCS.Property]
            references DCS.Property,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    InhabitedValue       money,
    ValuationDate        date,
    ValuationType        nvarchar(20),
    AvailableValue       money,
    LiqvidationValue     money,
    EscapeValue          money,
    MarketValue          money,
    ValidUntil           date,
    ValuatorEntityID     numeric(16)
)
go

exec sp_addextendedproperty 'MS_Description', N'A©rtA©kbecslA©s', 'SCHEMA', 'PRT', 'TABLE', 'PropertyValuation'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'PRT', 'TABLE', 'PropertyValuation',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Date of Valuation', 'SCHEMA', 'PRT', 'TABLE', 'PropertyValuation',
     'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'DCS.Property Identifier', 'SCHEMA', 'PRT', 'TABLE', 'PropertyValuation',
     'COLUMN', 'PropertyID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'PRT', 'TABLE',
     'PropertyValuation', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'PRT', 'TABLE',
     'PropertyValuation', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'PRT', 'TABLE',
     'PropertyValuation', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'PRT', 'TABLE',
     'PropertyValuation', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'PRT', 'TABLE',
     'PropertyValuation', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'PRT', 'TABLE',
     'PropertyValuation', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'PRT', 'TABLE', 'PropertyValuation', 'COLUMN',
     'Comments'
go

create index [IXFK_DCS.PropertyValuation_DCS.Property]
    on PRT.PropertyValuation (PropertyID)
go

create table PRT.Relation
(
    ID                   numeric(16) identity
        constraint [PK_CIS.Relation]
            primary key,
    EntityFromID         numeric(16)
        constraint FK_Relation_Entity
            references PRT.Entity,
    EntityToID           numeric(16)
        constraint FK_Relation_Entity_02
            references PRT.Entity,
    RelationTypeCode     nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Relation', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Referenced Company', 'SCHEMA', 'PRT', 'TABLE', 'Relation', 'COLUMN',
     'EntityFromID'
go

exec sp_addextendedproperty 'MS_Description', 'Person Identifier', 'SCHEMA', 'PRT', 'TABLE', 'Relation', 'COLUMN',
     'EntityToID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'PRT', 'TABLE', 'Relation',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Relation',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'PRT', 'TABLE', 'Relation',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'PRT', 'TABLE',
     'Relation', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'PRT', 'TABLE', 'Relation',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'PRT', 'TABLE', 'Relation',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'PRT', 'TABLE', 'Relation', 'COLUMN', 'Comments'
go

create index IXFK_Relation_Entity
    on PRT.Relation (EntityFromID)
go

create index IXFK_Relation_Entity_02
    on PRT.Relation (EntityToID)
go

create table GEN.Responsibility
(
    ID                   numeric(16) identity
        constraint PK_Responsibility
            primary key,
    ObjectID             numeric(16)
        constraint FK_Responsibility_Object
            references GEN.Object,
    Name                 nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Code                 nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Code of the responsibility group (AD). Value set -> RESPONSIBILITY',
     'SCHEMA', 'GEN', 'TABLE', 'Responsibility', 'COLUMN', 'Code'
go

create index IXFK_Responsibility_Object
    on GEN.Responsibility (ObjectID)
go

create index IXFK_Responsibility_Code
    on GEN.Responsibility (Code)
go

create table GEN.ResponsibilityAppUser
(
    ID                   numeric(16) identity
        constraint PK_ResponsibilityAppUser
            primary key,
    ResponsibilityID     numeric(16)
        constraint FK_ResponsibilityAppUser_Responsibility
            references GEN.Responsibility,
    AppUserID            numeric(16),
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'ResponsibilityAppUser',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Responsibility ID -> GEN.Responsibility', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityAppUser', 'COLUMN', 'ResponsibilityID'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityAppUser', 'COLUMN', 'AppUserID'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'GEN', 'TABLE', 'ResponsibilityAppUser', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'GEN', 'TABLE', 'ResponsibilityAppUser',
     'COLUMN', 'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityAppUser', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityAppUser', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityAppUser', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityAppUser', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityAppUser', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_ResponsibilityAppUser_Responsibility
    on GEN.ResponsibilityAppUser (ResponsibilityID)
go

create table GEN.ResponsibilityObject
(
    ID                   numeric(16) identity
        constraint PK_ResponsibilityObject
            primary key,
    ResponsibilityID     numeric(16)
        constraint FK_ResponsibilityObject_Responsibility
            references GEN.Responsibility,
    ObjectID             numeric(16)
        constraint FK_ResponsibilityObject_Object
            references GEN.Object,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ResponsibilityCode   nvarchar(200)
        constraint FK_ResponsibilityObject_Code
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Responsibility value set -> RESPONSIBILITY', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityObject', 'COLUMN', 'ResponsibilityCode'
go

create index IXFK_ResponsibilityObject_Object
    on GEN.ResponsibilityObject (ObjectID)
go

create index IXFK_ResponsibilityObject_Responsibility
    on GEN.ResponsibilityObject (ResponsibilityID)
go

create index IXFK_ResponsibilityObject_Code
    on GEN.ResponsibilityObject (ResponsibilityCode)
go

create table GEN.ResponsibilityUser
(
    ID                   numeric(16) identity
        constraint PK_ResponsibilityUser
            primary key,
    ResponsibilityID     numeric(16)
        constraint FK_ResponsibilityUser_Responsibility
            references GEN.Responsibility,
    UserID               numeric(16)
        constraint FK_ResponsibilityUser_AppUser
            references PRT.AppUser,
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_ResponsibilityUser_AppUser
    on GEN.ResponsibilityUser (UserID)
go

create index IXFK_ResponsibilityUser_Responsibility
    on GEN.ResponsibilityUser (ResponsibilityID)
go

create table GEN.RootFolder
(
    ID                   numeric(16) identity
        constraint PK_RootFolder
            primary key,
    ObjectID             numeric(16)
        constraint FK_RootFolder_Object
            references GEN.Object,
    TableName            nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ReferenceObjectID    numeric(16)
        constraint FK_RootFolder_Object_02
            references GEN.Object
)
go

create table GEN.Folder
(
    ID                   numeric(16) identity
        constraint PK_Folder
            primary key,
    ObjectID             numeric(16)
        constraint FK_Folder_Object
            references GEN.Object,
    ParentFolderID       numeric(16)
        constraint FK_Folder_Folder
            references GEN.Folder,
    Code                 nvarchar(200)
        constraint FK_Folder_Code
            references GEN.Code
            on update cascade on delete set null,
    IconName             nvarchar(50),
    Name                 nvarchar(150),
    RootFolderID         numeric(16)
        constraint FK_Folder_RootFolder
            references GEN.RootFolder,
    PageID               numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_Folder_Code
    on GEN.Folder (Code)
go

create index IXFK_Folder_Folder
    on GEN.Folder (ParentFolderID)
go

create index IXFK_Folder_Object
    on GEN.Folder (ObjectID)
go

create index IXFK_Folder_RootFolder
    on GEN.Folder (RootFolderID)
go

create table MIS.Form
(
    ID                   numeric(16) identity
        constraint PK_Form
            primary key,
    ObjectID             numeric(16)
        constraint FK_Form_Object
            references GEN.Object
            on update cascade on delete cascade,
    CodeID               nvarchar(200)
        constraint FK_Form_Code
            references GEN.Code
            on update cascade,
    FolderID             numeric(16)
        constraint FK_Form_Folder
            references GEN.Folder,
    RootFilterFolderID   numeric(16)
        constraint FK_Form_RootFolder
            references GEN.RootFolder,
    Modal                nvarchar,
    FormStyle            nvarchar,
    SQLText              nvarchar(max),
    IconName             nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table GEN.DataSource
(
    ID                   numeric(16) identity
        constraint PK_DataSource
            primary key,
    ObjectID             numeric(16)
        constraint FK_DataSource_Object
            references GEN.Object,
    FolderID             numeric(16)
        constraint FK_DataSource_Folder
            references GEN.Folder,
    DataCode             nvarchar(200)
        unique
        constraint FK_DataSource_Code
            references GEN.Code,
    ValidFrom            date,
    ValidUntil           date,
    VersionNr            nvarchar(100),
    SourceTypeCode       nvarchar(200)
        constraint FK_DataSource_Code_02
            references GEN.Code,
    SQLExpression        nvarchar(max),
    FormID               numeric(16)
        constraint FK_DataSource_Form
            references MIS.Form,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'DataSource', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE', 'DataSource',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Data source value set -> DATA', 'SCHEMA', 'GEN', 'TABLE', 'DataSource',
     'COLUMN', 'DataCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'GEN', 'TABLE', 'DataSource', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'GEN', 'TABLE', 'DataSource', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Version number', 'SCHEMA', 'GEN', 'TABLE', 'DataSource', 'COLUMN',
     'VersionNr'
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> DATA_SOURCE_TYPE', 'SCHEMA', 'GEN', 'TABLE', 'DataSource',
     'COLUMN', 'SourceTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'SQL expression to evaluate the data source', 'SCHEMA', 'GEN', 'TABLE',
     'DataSource', 'COLUMN', 'SQLExpression'
go

exec sp_addextendedproperty 'MS_Description', 'MIS form identifier -> MIS.Form', 'SCHEMA', 'GEN', 'TABLE', 'DataSource',
     'COLUMN', 'FormID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'DataSource',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'DataSource',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'DataSource', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'DataSource', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'DataSource', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'DataSource', 'COLUMN', 'LastModifiedUserName'
go

create table ORG.Condition
(
    ID                   numeric(16) identity
        constraint PK_Condition
            primary key,
    ObjectID             numeric(16)
        constraint FK_Condition_Object
            references GEN.Object,
    ConditionSetID       numeric(16)
        constraint FK_Condition_ConditionSet
            references ORG.ConditionSet,
    DataSourceID         numeric(16)
        constraint FK_Condition_DataSource
            references GEN.DataSource,
    ConditionCode        nvarchar(200)
        constraint FK_Condition_Code
            references GEN.Code,
    ConditionResultCode  nvarchar(200)
        constraint FK_Condition_Code_02
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'Condition', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE', 'Condition',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Condition set identifier -> ORG.ConditionSet', 'SCHEMA', 'ORG', 'TABLE',
     'Condition', 'COLUMN', 'ConditionSetID'
go

exec sp_addextendedproperty 'MS_Description', 'Data source identifier -> GEN.DataSource', 'SCHEMA', 'ORG', 'TABLE',
     'Condition', 'COLUMN', 'DataSourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Code of the condition -> value set CONDITION', 'SCHEMA', 'ORG', 'TABLE',
     'Condition', 'COLUMN', 'ConditionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Result of the condition -> value set CONDITION_RESULT', 'SCHEMA', 'ORG',
     'TABLE', 'Condition', 'COLUMN', 'ConditionResultCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'Condition',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'Condition',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'Condition', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'Condition', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'Condition', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'Condition', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_DataSource_Code
    on GEN.DataSource (DataCode)
go

create index IXFK_DataSource_Code_02
    on GEN.DataSource (SourceTypeCode)
go

create index IXFK_DataSource_Folder
    on GEN.DataSource (FolderID)
go

create index IXFK_DataSource_Form
    on GEN.DataSource (FormID)
go

create index IXFK_DataSource_Object
    on GEN.DataSource (ObjectID)
go

create table GEN.DocumentTemplate
(
    ID                          numeric(16) identity
        constraint PK_DocumentTemplate
            primary key,
    ObjectID                    numeric(16)
        constraint FK_DocumentTemplate_Object
            references GEN.Object,
    FolderID                    numeric(16)
        constraint FK_DocumentTemplate_Folder
            references GEN.Folder,
    TemplateCode                nvarchar(200)
        constraint FK_DocumentTemplate_Code
            references GEN.Code,
    DocumentID                  numeric(16)
        constraint FK_DocumentTemplate_Document
            references GEN.Document,
    ValidFrom                   date,
    ValidUntil                  date,
    VersionNr                   nvarchar(100),
    CreationDate                date,
    CreationTime                time,
    CreationUserName            nvarchar(200),
    LastModifiedDate            date,
    LastModifiedTime            time,
    LastModifiedUserName        nvarchar(200),
    StatusCode                  nvarchar(200)
        constraint FK_DocumentTemplate_Code_02
            references GEN.Code,
    PriorityCode                nvarchar(200)
        constraint FK_DocumentTemplate_Code_03
            references GEN.Code,
    ChannelCode                 nvarchar(200)
        constraint FK_DocumentTemplate_Code_04
            references GEN.Code,
    MassUsageCode               nvarchar(200)
        constraint FK_DocumentTemplate_Code_05
            references GEN.Code,
    EnablingConditionSetID      numeric(16)
        constraint FK_DocumentTemplate_ConditionSet
            references ORG.ConditionSet,
    AnswerRequired              nvarchar(200)
        constraint FK_DocumentTemplate_Code_06
            references GEN.Code,
    AnswerInDays                numeric(16),
    TypeCode                    nvarchar(200)
        constraint FK_DocumentTemplate_Code_07
            references GEN.Code,
    MockCode                    nvarchar(200)
        constraint FK_DocumentTemplate_Code_08
            references GEN.Code,
    VariantSelectorDataSourceID numeric(16)
        constraint FK_DocumentTemplate_DataSource
            references GEN.DataSource,
    DataSourceID                numeric(16)
        constraint FK_DocumentTemplate_DataSource_02
            references GEN.DataSource,
    MimeTypeID                  numeric(16)
        constraint FK_DocumentTemplate_MimeType
            references GEN.MimeType
            on update cascade on delete set null
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplate',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplate', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Folder identifier -> GEN.Folder', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplate', 'COLUMN', 'FolderID'
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> DOCUMENT_TEMPLATE', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplate', 'COLUMN', 'TemplateCode'
go

exec sp_addextendedproperty 'MS_Description', 'Document identifier -> GEN.Document', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplate', 'COLUMN', 'DocumentID'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplate', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplate', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Version number', 'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplate', 'COLUMN',
     'VersionNr'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplate', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplate', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplate', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplate', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplate', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplate', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> DOCUMENT_TEMPLATE_STATUS', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplate', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> PRIORITY', 'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplate',
     'COLUMN', 'PriorityCode'
go

exec sp_addextendedproperty 'MS_Description', 'Channel restriction (optional). Value set -> CHANNEL', 'SCHEMA', 'GEN',
     'TABLE', 'DocumentTemplate', 'COLUMN', 'ChannelCode'
go

exec sp_addextendedproperty 'MS_Description', 'Document designed for mass usage? Value set -> BOOLEAN', 'SCHEMA', 'GEN',
     'TABLE', 'DocumentTemplate', 'COLUMN', 'MassUsageCode'
go

exec sp_addextendedproperty 'MS_Description', 'Usage of the document is allowed? -> ORG.ConditionSet', 'SCHEMA', 'GEN',
     'TABLE', 'DocumentTemplate', 'COLUMN', 'EnablingConditionSetID'
go

exec sp_addextendedproperty 'MS_Description', 'Value set ->  BOOLEAN', 'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplate',
     'COLUMN', 'AnswerRequired'
go

exec sp_addextendedproperty 'MS_Description', 'Answer required in days', 'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplate',
     'COLUMN', 'AnswerInDays'
go

exec sp_addextendedproperty 'MS_Description', 'Template type -> value set DOCUMENT_TEMPLATE_TYPE', 'SCHEMA', 'GEN',
     'TABLE', 'DocumentTemplate', 'COLUMN', 'TypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Mocked document (generated in an external system) -> value set BOOLEAN',
     'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplate', 'COLUMN', 'MockCode'
go

exec sp_addextendedproperty 'MS_Description', 'Variant selector data source -> GEN.DataSource', 'SCHEMA', 'GEN',
     'TABLE', 'DocumentTemplate', 'COLUMN', 'VariantSelectorDataSourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Data source for the mass generated documents -> GEN.DataSource',
     'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplate', 'COLUMN', 'DataSourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Mime type identifier -> GEN.MimeType', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplate', 'COLUMN', 'MimeTypeID'
go

create index IXFK_DocumentTemplate_Code
    on GEN.DocumentTemplate (TemplateCode)
go

create index IXFK_DocumentTemplate_Document
    on GEN.DocumentTemplate (DocumentID)
go

create index IXFK_DocumentTemplate_Folder
    on GEN.DocumentTemplate (FolderID)
go

create index IXFK_DocumentTemplate_Object
    on GEN.DocumentTemplate (ObjectID)
go

create index IXFK_DocumentTemplate_Code_02
    on GEN.DocumentTemplate (StatusCode)
go

create index IXFK_DocumentTemplate_Code_03
    on GEN.DocumentTemplate (PriorityCode)
go

create table GEN.DocumentTemplateVariant
(
    ID                   numeric(16) identity
        constraint PK_DocumentTemplateVariant
            primary key,
    ObjectID             numeric(16)
        constraint FK_DocumentTemplateVariant_Object
            references GEN.Object,
    DocumentTemplateID   numeric(16)
        constraint FK_DocumentTemplateVariant_DocumentTemplate
            references GEN.DocumentTemplate,
    LanguageCode         nvarchar(200)
        constraint FK_DocumentTemplateVariant_Code
            references GEN.Code,
    ExternalCode         nvarchar(200),
    VariantCode          nvarchar(200),
    FormID               numeric(16)
        constraint FK_DocumentTemplateVariant_Form
            references MIS.Form,
    DocumentID           numeric(16)
        constraint FK_DocumentTemplateVariant_Document
            references GEN.Document,
    VersionNr            nvarchar(100),
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    StatusCode           nvarchar(200)
        constraint FK_DocumentTemplateVariant_Code_02
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplateVariant',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplateVariant', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Document template -> GEN.DocumentTemplate', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplateVariant', 'COLUMN', 'DocumentTemplateID'
go

exec sp_addextendedproperty 'MS_Description', 'Language code ->  value set LANGUAGE', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplateVariant', 'COLUMN', 'LanguageCode'
go

exec sp_addextendedproperty 'MS_Description', 'External code of the document in a remote system', 'SCHEMA', 'GEN',
     'TABLE', 'DocumentTemplateVariant', 'COLUMN', 'ExternalCode'
go

exec sp_addextendedproperty 'MS_Description', 'Variant code (no value set defined)', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplateVariant', 'COLUMN', 'VariantCode'
go

exec sp_addextendedproperty 'MS_Description', 'MIS form identifier (to retrieve document data fields) -> MIS.Form',
     'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplateVariant', 'COLUMN', 'FormID'
go

exec sp_addextendedproperty 'MS_Description', 'Document identifier -> GEN.Document', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplateVariant', 'COLUMN', 'DocumentID'
go

exec sp_addextendedproperty 'MS_Description', 'Version number', 'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplateVariant',
     'COLUMN', 'VersionNr'
go

exec sp_addextendedproperty 'MS_Description', 'Valid From', 'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplateVariant',
     'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid Until', 'SCHEMA', 'GEN', 'TABLE', 'DocumentTemplateVariant',
     'COLUMN', 'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplateVariant', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplateVariant', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplateVariant', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplateVariant', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplateVariant', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'DocumentTemplateVariant', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Status of the template variant -> value set STATUS', 'SCHEMA', 'GEN',
     'TABLE', 'DocumentTemplateVariant', 'COLUMN', 'StatusCode'
go

create index IXFK_Form_Code
    on MIS.Form (CodeID)
go

create index IXFK_Form_Folder
    on MIS.Form (FolderID)
go

create index IXFK_Form_Object
    on MIS.Form (ObjectID)
go

create index IXFK_Form_RootFolder
    on MIS.Form (RootFilterFolderID)
go

create table MIS.FormAction
(
    ID                   numeric(16) identity
        constraint PK_FormAction
            primary key,
    ObjectID             numeric(16)
        constraint FK_FormAction_Object
            references GEN.Object,
    FormID               numeric(16)
        constraint FK_FormAction_Form
            references MIS.Form
            on update cascade on delete cascade,
    FunctionType         nvarchar(50),
    FunctionName         nvarchar(50),
    DefaultAction        nvarchar(50),
    ColumnName           nvarchar(50),
    FunctionTitle        nvarchar(50),
    ActionFormID         numeric(16)
        constraint FK_FormAction_Form_02
            references MIS.Form,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    FunctionTitleCode    nvarchar(200)
        constraint FK_FormAction_Code
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Function title code -> value set MIS_FORM_ACTION', 'SCHEMA', 'MIS',
     'TABLE', 'FormAction', 'COLUMN', 'FunctionTitleCode'
go

create index IXFK_FormAction_Form
    on MIS.FormAction (FormID)
go

create index IXFK_FormAction_Form_02
    on MIS.FormAction (ActionFormID)
go

create index IXFK_FormAction_Object
    on MIS.FormAction (ObjectID)
go

create table MIS.FormListingMode
(
    ID                     numeric(16) identity
        constraint PK_FormListingMode
            primary key,
    ObjectID               numeric(16)
        constraint FK_FormListingMode_Object
            references GEN.Object,
    FormID                 numeric(16)
        constraint FK_FormListingMode_Form
            references MIS.Form,
    SQLText                nvarchar(max),
    ListingModeCode        nvarchar(200)
        constraint FK_FormListingMode_Code
            references GEN.Code,
    DefaultListingModeCode nvarchar(200)
        constraint FK_FormListingMode_Code_02
            references GEN.Code,
    StatusCode             nvarchar(200)
        constraint FK_FormListingMode_Code_03
            references GEN.Code,
    CreationDate           date,
    CreationTime           time,
    CreationUserName       nvarchar(200),
    LastModifiedDate       date,
    LastModifiedTime       time,
    LastModifiedUserName   nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'MIS', 'TABLE', 'FormListingMode',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'MIS', 'TABLE',
     'FormListingMode', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Form identifier -> MIS.Form', 'SCHEMA', 'MIS', 'TABLE',
     'FormListingMode', 'COLUMN', 'FormID'
go

exec sp_addextendedproperty 'MS_Description', 'SQL statement', 'SCHEMA', 'MIS', 'TABLE', 'FormListingMode', 'COLUMN',
     'SQLText'
go

exec sp_addextendedproperty 'MS_Description', 'Listing mode -> value set FORM_LISTING_MODE', 'SCHEMA', 'MIS', 'TABLE',
     'FormListingMode', 'COLUMN', 'ListingModeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Default listing mode -> value set BOOLEAN', 'SCHEMA', 'MIS', 'TABLE',
     'FormListingMode', 'COLUMN', 'DefaultListingModeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Status -> value set STATUS', 'SCHEMA', 'MIS', 'TABLE', 'FormListingMode',
     'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'MIS', 'TABLE',
     'FormListingMode', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'MIS', 'TABLE',
     'FormListingMode', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'MIS', 'TABLE',
     'FormListingMode', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'MIS', 'TABLE',
     'FormListingMode', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'MIS', 'TABLE',
     'FormListingMode', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'MIS', 'TABLE',
     'FormListingMode', 'COLUMN', 'LastModifiedUserName'
go

create table MIS.FormView
(
    ID                   numeric(16) identity
        constraint PK_FormView
            primary key,
    ObjectID             numeric(16)
        constraint FK_FormView_Object
            references GEN.Object,
    FormID               numeric(16)
        constraint FK_FormView_Form
            references MIS.Form,
    UserName             nvarchar(200),
    Name                 nvarchar(250),
    Description          nvarchar(max),
    SystemView           nvarchar(200)
        constraint FK_FormView_Code
            references GEN.Code,
    FilterSet            nvarchar(max),
    ColumnSet            nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'MIS', 'TABLE', 'FormView', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'MIS', 'TABLE', 'FormView',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Form identifier -> MIS.Form', 'SCHEMA', 'MIS', 'TABLE', 'FormView',
     'COLUMN', 'FormID'
go

exec sp_addextendedproperty 'MS_Description', 'User who owns the view', 'SCHEMA', 'MIS', 'TABLE', 'FormView', 'COLUMN',
     'UserName'
go

exec sp_addextendedproperty 'MS_Description', 'Name of view', 'SCHEMA', 'MIS', 'TABLE', 'FormView', 'COLUMN', 'Name'
go

exec sp_addextendedproperty 'MS_Description', 'Description', 'SCHEMA', 'MIS', 'TABLE', 'FormView', 'COLUMN',
     'Description'
go

exec sp_addextendedproperty 'MS_Description', 'System view -> value set BOOLEAN', 'SCHEMA', 'MIS', 'TABLE', 'FormView',
     'COLUMN', 'SystemView'
go

exec sp_addextendedproperty 'MS_Description', 'Filter set, stored in JSON', 'SCHEMA', 'MIS', 'TABLE', 'FormView',
     'COLUMN', 'FilterSet'
go

exec sp_addextendedproperty 'MS_Description', 'Column set, stored in JSON', 'SCHEMA', 'MIS', 'TABLE', 'FormView',
     'COLUMN', 'ColumnSet'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'MIS', 'TABLE', 'FormView',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'MIS', 'TABLE', 'FormView',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'MIS', 'TABLE', 'FormView',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'MIS', 'TABLE',
     'FormView', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'MIS', 'TABLE',
     'FormView', 'COLUMN', 'LastModifiedTime'
go

create table IFC.InterfaceCommunicationFile
(
    ID                       numeric(16) identity
        constraint PK_InterfaceCommunicationFile
            primary key,
    ObjectID                 numeric(16)
        constraint FK_InterfaceCommunicationFile_Object
            references GEN.Object,
    InterfaceCommunicationID numeric(16)
        constraint FK_InterfaceCommunicationFile_InterfaceCommunication
            references IFC.InterfaceCommunication,
    FormID                   numeric(16)
        constraint FK_InterfaceCommunicationFile_Form
            references MIS.Form,
    DocumentID               numeric(16)
        constraint FK_InterfaceCommunicationFile_Document
            references GEN.Document,
    FileName                 nvarchar(200),
    FileSize                 numeric(16),
    CreationDate             date,
    CreationTime             time,
    CreationUserName         nvarchar(200),
    LastModifiedDate         date,
    LastModifiedTime         time,
    LastModifiedUserName     nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunicationFile', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunicationFile', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface communication identifier -> IFC.InterfaceCommunication',
     'SCHEMA', 'IFC', 'TABLE', 'InterfaceCommunicationFile', 'COLUMN', 'InterfaceCommunicationID'
go

exec sp_addextendedproperty 'MS_Description', 'Form identifier -> MIS.Form', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunicationFile', 'COLUMN', 'FormID'
go

exec sp_addextendedproperty 'MS_Description', 'Document identifier -> GEN.Document', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunicationFile', 'COLUMN', 'DocumentID'
go

exec sp_addextendedproperty 'MS_Description', 'File name', 'SCHEMA', 'IFC', 'TABLE', 'InterfaceCommunicationFile',
     'COLUMN', 'FileName'
go

exec sp_addextendedproperty 'MS_Description', 'Size of the file in the bytes', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunicationFile', 'COLUMN', 'FileSize'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunicationFile', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunicationFile', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunicationFile', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunicationFile', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InterfaceCommunicationFile', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InterfaceTable
(
    ID                   numeric(16) identity
        constraint PK_ImportTable
            primary key,
    ObjectID             numeric(16)
        constraint FK_InterfaceTable_Object
            references GEN.Object,
    InterfacePackageID   numeric(16)
        constraint FK_InterfaceTable_InterfacePackage
            references IFC.InterfacePackage,
    InterfaceTableName   nvarchar(200),
    DocumentID           numeric(16),
    SheetNr              numeric(16),
    FolderID             numeric(16)
        constraint FK_InterfaceTable_Folder
            references GEN.Folder,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table IFC.Address
(
    ID                    numeric(16) identity
        constraint PK_Address
            primary key,
    ObjectID              numeric(16)
        constraint FK_Address_Object
            references GEN.Object,
    SourceInterfaceType   nvarchar(200),
    SourceID              nvarchar(200),
    SourceCompanyID       nvarchar(200),
    SourcePersonID        nvarchar(200),
    RegistrationNr        nvarchar(30),
    TaxNr                 nvarchar(30),
    StatisticalNr         nvarchar(30),
    AddressType           nvarchar(200),
    Country               nvarchar(250),
    CountryCode           nvarchar(200),
    CountryID             nvarchar(200),
    ZipCode               nvarchar(250),
    City                  nvarchar(250),
    Street                nvarchar(250),
    HouseNr               nvarchar(250),
    FullAddress           nvarchar(250),
    Description           nvarchar(250),
    ValidFrom             date,
    ValidUntil            date,
    Field1                nvarchar(250),
    Field2                nvarchar(250),
    Field3                nvarchar(250),
    Field4                nvarchar(250),
    Field5                nvarchar(250),
    CrefoID               numeric(16),
    InterfaceStatusCode   nvarchar(200),
    ErrorMessage          nvarchar(max),
    ActualisationDate     date,
    Operation             nvarchar,
    InterfaceTableID      numeric(16)
        constraint FK_Address_InterfaceTable
            references IFC.InterfaceTable,
    MainAddress           nvarchar,
    CreationDate          date,
    CreationTime          time,
    CreationUserName      nvarchar(200),
    LastModifiedDate      date,
    LastModifiedTime      time,
    LastModifiedUserName  nvarchar(200),
    SourceAssetID         nvarchar(200),
    AddressStructure      nvarchar(200),
    District              nvarchar(250),
    PublicPlaceName       nvarchar(50),
    PublicPlaceType       nvarchar(200),
    PublicPlaceTypeText   nvarchar(200),
    LandRegisterReference nvarchar(20),
    Staircase             nvarchar(10),
    Building              nvarchar(50),
    Floor                 nvarchar(10),
    Door                  nvarchar(10)
)
go

exec sp_addextendedproperty 'MS_Description', 'Country value set -> COUNTRY', 'SCHEMA', 'IFC', 'TABLE', 'Address',
     'COLUMN', 'CountryCode'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status code value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'Address', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Special address structure value set -> SPECIAL_ADDRESS_STRUCTURE',
     'SCHEMA', 'IFC', 'TABLE', 'Address', 'COLUMN', 'AddressStructure'
go

exec sp_addextendedproperty 'MS_Description', 'Public place name', 'SCHEMA', 'IFC', 'TABLE', 'Address', 'COLUMN',
     'PublicPlaceName'
go

exec sp_addextendedproperty 'MS_Description', 'Public place type value set -> PUBLIC_PLACE_TYPE', 'SCHEMA', 'IFC',
     'TABLE', 'Address', 'COLUMN', 'PublicPlaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Public place type text', 'SCHEMA', 'IFC', 'TABLE', 'Address', 'COLUMN',
     'PublicPlaceTypeText'
go

exec sp_addextendedproperty 'MS_Description', 'Land register reference', 'SCHEMA', 'IFC', 'TABLE', 'Address', 'COLUMN',
     'LandRegisterReference'
go

exec sp_addextendedproperty 'MS_Description', 'Staircase', 'SCHEMA', 'IFC', 'TABLE', 'Address', 'COLUMN', 'Staircase'
go

exec sp_addextendedproperty 'MS_Description', 'Building', 'SCHEMA', 'IFC', 'TABLE', 'Address', 'COLUMN', 'Building'
go

exec sp_addextendedproperty 'MS_Description', 'Floor', 'SCHEMA', 'IFC', 'TABLE', 'Address', 'COLUMN', 'Floor'
go

exec sp_addextendedproperty 'MS_Description', 'Door', 'SCHEMA', 'IFC', 'TABLE', 'Address', 'COLUMN', 'Door'
go

create index IXFK_Address_InterfaceTable
    on IFC.Address (InterfaceTableID)
go

create index IXFK_Address_Object
    on IFC.Address (ObjectID)
go

create table IFC.Asset
(
    ID                          numeric(16) identity
        constraint PK_Asset
            primary key,
    AssetClass                  nvarchar(200),
    AssetClassText              nvarchar(200),
    AssetType                   nvarchar(200),
    AssetTypeText               varchar(200),
    Name                        nvarchar(200),
    LandRegisterCity            nvarchar(100),
    LandRegisterReference       nvarchar(200),
    Status                      nvarchar(200),
    StatusText                  nvarchar(200),
    LandRegisterOfficeEntityID  numeric(16),
    ExternalReferenceNr         nvarchar(200),
    StructureSize               numeric(10, 4),
    LotSize                     numeric(10, 4),
    LotSizeUnitCode             nvarchar(200),
    LotSizeUnitText             nvarchar(200),
    InhabitedCode               nvarchar(200),
    InhabitedText               nvarchar(200),
    RentedOutCode               nvarchar(200),
    RentedOutText               nvarchar(200),
    UndividedCommonPropertyCode nvarchar(200),
    UndividedCommonPropertyText nvarchar(200),
    DataOriginCode              nvarchar(200),
    DataOriginText              nvarchar(200),
    AssetID                     numeric(16),
    SourceInterfaceType         nvarchar(200),
    SourceID                    nvarchar(200),
    InterfaceStatusCode         nvarchar(200),
    ErrorMessage                nvarchar(max),
    InterfaceTableID            numeric(16)
        constraint FK_Asset_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate                date,
    CreationTime                time,
    CreationUserName            nvarchar(200),
    LastModifiedDate            date,
    LastModifiedTime            time,
    LastModifiedUserName        nvarchar(200),
    PortfolioName               nvarchar(200),
    PortfolioID                 numeric(16),
    AssetNatureCode             nvarchar(200),
    AssetNatureText             nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Asset class value set -> ASSET_CLASS', 'SCHEMA', 'IFC', 'TABLE', 'Asset',
     'COLUMN', 'AssetClass'
go

exec sp_addextendedproperty 'MS_Description', 'Asset class text', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'AssetClassText'
go

exec sp_addextendedproperty 'MS_Description', 'Asset type value set -> ASSET_TYPE', 'SCHEMA', 'IFC', 'TABLE', 'Asset',
     'COLUMN', 'AssetType'
go

exec sp_addextendedproperty 'MS_Description', 'Asset type', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN', 'AssetTypeText'
go

exec sp_addextendedproperty 'MS_Description', 'Name', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN', 'Name'
go

exec sp_addextendedproperty 'MS_Description', 'Land register city', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'LandRegisterCity'
go

exec sp_addextendedproperty 'MS_Description', 'Land register reference', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'LandRegisterReference'
go

exec sp_addextendedproperty 'MS_Description', 'Status value set -> STATUS', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'Status'
go

exec sp_addextendedproperty 'MS_Description', 'Status text', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN', 'StatusText'
go

exec sp_addextendedproperty 'MS_Description', 'Externaal reference number', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'ExternalReferenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Structure Size', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'StructureSize'
go

exec sp_addextendedproperty 'MS_Description', 'Lot Size', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN', 'LotSize'
go

exec sp_addextendedproperty 'MS_Description', 'Lot size unit value set -> ASSET_UNIT', 'SCHEMA', 'IFC', 'TABLE',
     'Asset', 'COLUMN', 'LotSizeUnitCode'
go

exec sp_addextendedproperty 'MS_Description', 'Lot size unit text', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'LotSizeUnitText'
go

exec sp_addextendedproperty 'MS_Description', 'Inhabited -> BOOLEAN value set', 'SCHEMA', 'IFC', 'TABLE', 'Asset',
     'COLUMN', 'InhabitedCode'
go

exec sp_addextendedproperty 'MS_Description', 'Rented out -> BOOLEAN value set', 'SCHEMA', 'IFC', 'TABLE', 'Asset',
     'COLUMN', 'RentedOutCode'
go

exec sp_addextendedproperty 'MS_Description', 'Rented out text', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'RentedOutText'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean value set -> BOOLEAN', 'SCHEMA', 'IFC', 'TABLE', 'Asset',
     'COLUMN', 'UndividedCommonPropertyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean text', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'UndividedCommonPropertyText'
go

exec sp_addextendedproperty 'MS_Description', 'Data origin value set -> DATA_ORIGIN', 'SCHEMA', 'IFC', 'TABLE', 'Asset',
     'COLUMN', 'DataOriginCode'
go

exec sp_addextendedproperty 'MS_Description', 'Data origin text', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'DataOriginText'
go

exec sp_addextendedproperty 'MS_Description', 'Asset identifier -> AST.Asset', 'SCHEMA', 'IFC', 'TABLE', 'Asset',
     'COLUMN', 'AssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'Asset', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Interface table identifier -> IFC.InterfaceTable', 'SCHEMA', 'IFC',
     'TABLE', 'Asset', 'COLUMN', 'InterfaceTableID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'Asset',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'Asset',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE', 'Asset',
     'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE', 'Asset',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE', 'Asset',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Name of the portfolio', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'PortfolioName'
go

exec sp_addextendedproperty 'MS_Description', 'Portfolio identifier -> GEN.Portfolio', 'SCHEMA', 'IFC', 'TABLE',
     'Asset', 'COLUMN', 'PortfolioID'
go

exec sp_addextendedproperty 'MS_Description', 'Asset nature -> value set ASSET_NATURE', 'SCHEMA', 'IFC', 'TABLE',
     'Asset', 'COLUMN', 'AssetNatureCode'
go

exec sp_addextendedproperty 'MS_Description', 'Asset nature', 'SCHEMA', 'IFC', 'TABLE', 'Asset', 'COLUMN',
     'AssetNatureText'
go

create index IXFK_Asset_InterfaceTable
    on IFC.Asset (InterfaceTableID)
go

create table IFC.AssetValuation
(
    ID                   numeric(16) identity
        constraint PK_AssetValuation
            primary key,
    ValuerEntityID       numeric(16),
    ValuationDate        date,
    ValuationTypeCode    nvarchar(200),
    ValuationTypeText    nvarchar(200),
    ValidFrom            date,
    ValidUntil           date,
    AssetValuationID     numeric(16),
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    SourceAssetID        nvarchar(200),
    SourceCompanyID      nvarchar(200),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    InterfaceTableID     numeric(16)
        constraint FK_AssetValuation_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    StatusCode           nvarchar(200),
    StatusText           nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuation', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Valuer entity identifier -> PRT.Entity', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuation', 'COLUMN', 'ValuerEntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Valuation Date', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuation', 'COLUMN',
     'ValuationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Valuation type -> ASSET_VALUATION_TYPE value set', 'SCHEMA', 'IFC',
     'TABLE', 'AssetValuation', 'COLUMN', 'ValuationTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valuation type text', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuation',
     'COLUMN', 'ValuationTypeText'
go

exec sp_addextendedproperty 'MS_Description', 'Valid From', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuation', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid Until', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuation', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Asset valuation identifier -> AST.AssetValuation', 'SCHEMA', 'IFC',
     'TABLE', 'AssetValuation', 'COLUMN', 'AssetValuationID'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuation',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuation', 'COLUMN',
     'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Source asset identifier -> IFC.Asset', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuation', 'COLUMN', 'SourceAssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Source company identifier -> IFC.Company', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuation', 'COLUMN', 'SourceCompanyID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'AssetValuation', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuation', 'COLUMN',
     'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Interface table identifier -> IFC.InterfaceTable', 'SCHEMA', 'IFC',
     'TABLE', 'AssetValuation', 'COLUMN', 'InterfaceTableID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuation', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuation', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuation', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuation', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuation', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuation', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Status value set -> STATUS', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuation',
     'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Status text', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuation', 'COLUMN',
     'StatusText'
go

create index IXFK_AssetValuation_InterfaceTable
    on IFC.AssetValuation (InterfaceTableID)
go

create table IFC.AssetValuationValue
(
    ID                     numeric(16) identity
        constraint PK_AssetValuationValue
            primary key,
    ValueTypeCode          nvarchar(200),
    ValueTypeText          nvarchar(200),
    NetValue               money,
    VatRate                numeric(10, 4),
    VatValue               money,
    GrossValue             money,
    ValueCurrencyCode      nvarchar(200),
    ValueCurrencyText      nvarchar(200),
    AssetValuationValueID  numeric(16),
    AssetValuationID       numeric(16),
    SourceInterfaceType    nvarchar(200),
    SourceID               nvarchar(200),
    SourceAssetValuationID nvarchar(200),
    InterfaceStatusCode    nvarchar(200),
    ErrorMessage           nvarchar(max),
    InterfaceTableID       numeric(16)
        constraint FK_AssetValuationValue_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate           date,
    CreationTime           time,
    CreationUserName       nvarchar(200),
    LastModifiedDate       date,
    LastModifiedTime       time,
    LastModifiedUserName   nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Asset valuation value type -> ASSET_VALUATION_VALUE_TYPE', 'SCHEMA',
     'IFC', 'TABLE', 'AssetValuationValue', 'COLUMN', 'ValueTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Asset valuation value type text', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'ValueTypeText'
go

exec sp_addextendedproperty 'MS_Description', 'Net Value', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuationValue', 'COLUMN',
     'NetValue'
go

exec sp_addextendedproperty 'MS_Description', 'Vat rate', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuationValue', 'COLUMN',
     'VatRate'
go

exec sp_addextendedproperty 'MS_Description', 'Vat Value', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuationValue', 'COLUMN',
     'VatValue'
go

exec sp_addextendedproperty 'MS_Description', 'Gross Value', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuationValue', 'COLUMN',
     'GrossValue'
go

exec sp_addextendedproperty 'MS_Description', 'Value currency -> CURRENCY value set', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'ValueCurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Value currency text', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuationValue',
     'COLUMN', 'ValueCurrencyText'
go

exec sp_addextendedproperty 'MS_Description', 'Asset valuation value identifier -> AST.AssetValuationValue', 'SCHEMA',
     'IFC', 'TABLE', 'AssetValuationValue', 'COLUMN', 'AssetValuationValueID'
go

exec sp_addextendedproperty 'MS_Description', 'Asset valuation identifier -> AST.AssetValuation', 'SCHEMA', 'IFC',
     'TABLE', 'AssetValuationValue', 'COLUMN', 'AssetValuationID'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuationValue',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuationValue',
     'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Source asset valuation identifier -> IFC.AssetValuation', 'SCHEMA',
     'IFC', 'TABLE', 'AssetValuationValue', 'COLUMN', 'SourceAssetValuationID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'AssetValuationValue', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error Message', 'SCHEMA', 'IFC', 'TABLE', 'AssetValuationValue',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Interface table identifier -> IFC.InterfaceTable', 'SCHEMA', 'IFC',
     'TABLE', 'AssetValuationValue', 'COLUMN', 'InterfaceTableID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_AssetValuationValue_InterfaceTable
    on IFC.AssetValuationValue (InterfaceTableID)
go

create table IFC.CollectionContractItem
(
    ID                       numeric(16) identity
        constraint PK_CollectionContractItem
            primary key,
    ObjectID                 numeric(16),
    CurrencyCode             nvarchar(200),
    DebtCapital              money,
    DebtInterest             money,
    DebtPenaltyInterest      money,
    DebtCost                 money,
    DebtCostLocalCurrency    money,
    DebtTotal                money,
    ConstructionCode         nvarchar(200),
    DebtorName               nvarchar(200),
    PricingMethodCode        nvarchar(200),
    PricingMethodText        nvarchar(200),
    BusinessPercent          numeric(10),
    BusinessPrice            money,
    ContractNr               nvarchar(200),
    DecisionNr               nvarchar(200),
    AccountNr                nvarchar(200),
    ContractDate             date,
    TerminationDate          date,
    FinancialMilestoneDate   date,
    LegalActionCode          nvarchar(200),
    LegalActionText          nvarchar(200),
    CollectionContractItemID numeric(16),
    SourceID                 nvarchar(200),
    SourceContractItemID     nvarchar(200),
    SourceInterfaceType      varchar(200),
    InterfaceStatusCode      nvarchar(200),
    ErrorMessage             nvarchar(max),
    OperationCode            nvarchar(200),
    ImportTableID            numeric(16)
        constraint FK_CollectionContractItem_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate             date,
    CreationTime             time,
    CreationUserName         nvarchar(200),
    LastModifiedDate         date,
    LastModifiedTime         time,
    LastModifiedUserName     nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Currency value set -> CURRENCY', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Capital part of debt', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'DebtCapital'
go

exec sp_addextendedproperty 'MS_Description', 'Normal interest part of debt', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'DebtInterest'
go

exec sp_addextendedproperty 'MS_Description', 'Penalty interest part of debt', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'DebtPenaltyInterest'
go

exec sp_addextendedproperty 'MS_Description', 'Cost part of debt', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'DebtCost'
go

exec sp_addextendedproperty 'MS_Description', 'Cost part of debt in currency', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'DebtCostLocalCurrency'
go

exec sp_addextendedproperty 'MS_Description', 'Total debt', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'DebtTotal'
go

exec sp_addextendedproperty 'MS_Description', 'Construction code value set -> CONSTRUCTION_CODE', 'SCHEMA', 'IFC',
     'TABLE', 'CollectionContractItem', 'COLUMN', 'ConstructionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Name of debtor', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'DebtorName'
go

exec sp_addextendedproperty 'MS_Description', 'Pricing method value set -> PRICING_METHOD', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'PricingMethodCode'
go

exec sp_addextendedproperty 'MS_Description', 'Pricing method text', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'PricingMethodText'
go

exec sp_addextendedproperty 'MS_Description', 'Business percent', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'BusinessPercent'
go

exec sp_addextendedproperty 'MS_Description', 'Business price', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'BusinessPrice'
go

exec sp_addextendedproperty 'MS_Description', 'Contract number', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'ContractNr'
go

exec sp_addextendedproperty 'MS_Description', 'Decison number', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'DecisionNr'
go

exec sp_addextendedproperty 'MS_Description', 'Account number', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'AccountNr'
go

exec sp_addextendedproperty 'MS_Description', 'Contract date', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'ContractDate'
go

exec sp_addextendedproperty 'MS_Description', 'Termination date', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'TerminationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Financial milestone date', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'FinancialMilestoneDate'
go

exec sp_addextendedproperty 'MS_Description', 'Legal action value set -> LEGAL_ACTION', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'LegalActionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Legal action text', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'LegalActionText'
go

exec sp_addextendedproperty 'MS_Description',
     'The identifier of the loaded collection contract item -> CRM.CollectionContractItem', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'CollectionContractItemID'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier of the collection contract item to be loaded',
     'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Contract item identifier -> IFC.ContractItem.SourceID', 'SCHEMA', 'IFC',
     'TABLE', 'CollectionContractItem', 'COLUMN', 'SourceContractItemID'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'CollectionContractItem', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Operation value set -> OPERATION', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'OperationCode'
go

exec sp_addextendedproperty 'MS_Description', 'Import table identifier -> IFC.ImportTable', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'ImportTableID'
go

create index IXFK_CollectionContractItem_InterfaceTable
    on IFC.CollectionContractItem (ImportTableID)
go

create table IFC.CollectionContractSummary
(
    ID                          numeric(16) identity
        constraint PK_CollectionContractSummary
            primary key,
    ObjectID                    numeric(16),
    CurrencyCode                nvarchar(200),
    ItemCount                   numeric(16),
    DebtCapital                 money,
    DebtInterest                money,
    DebtPenaltyInterest         money,
    DebtCost                    money,
    DebtCostLocalCurrency       money,
    DebtTotal                   money,
    PurchasePrice               money,
    PurchasePriceCurrencyCode   nvarchar(200),
    CollectionContractSummaryID numeric,
    SourceID                    nvarchar(200),
    SourceContractID            nvarchar(200),
    SourceInterfaceType         nvarchar(200),
    InterfaceStatusCode         nvarchar(200),
    ErrorMessage                nvarchar(max),
    OperationCode               nvarchar(200),
    ImportTableID               numeric(16)
        constraint FK_CollectionContractSummary_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate                date,
    CreationTime                time,
    CreationUserName            nvarchar(200),
    LastModifiedDate            date,
    LastModifiedTime            time,
    LastModifiedUserName        nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Currency value set -> CURRENCY', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Number of items in contract', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'ItemCount'
go

exec sp_addextendedproperty 'MS_Description', 'Capital part of debt in currency', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'DebtCapital'
go

exec sp_addextendedproperty 'MS_Description', 'Normal interest part of debt in currency', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'DebtInterest'
go

exec sp_addextendedproperty 'MS_Description', 'Penalty interest part of debt in currency', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'DebtPenaltyInterest'
go

exec sp_addextendedproperty 'MS_Description', 'Cost part of debt in currency', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'DebtCost'
go

exec sp_addextendedproperty 'MS_Description', 'Cost part of debt in local currency', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'DebtCostLocalCurrency'
go

exec sp_addextendedproperty 'MS_Description', 'Total debt in currency', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'DebtTotal'
go

exec sp_addextendedproperty 'MS_Description', 'Purchase price in purchase price currency', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'PurchasePrice'
go

exec sp_addextendedproperty 'MS_Description', 'Currency value set -> CURRENCY', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'PurchasePriceCurrencyCode'
go

exec sp_addextendedproperty 'MS_Description',
     'The identifier of the loaded collection contract summary -> CRM.CollectionContractSummary', 'SCHEMA', 'IFC',
     'TABLE', 'CollectionContractSummary', 'COLUMN', 'CollectionContractSummaryID'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier of the collection contract summary to be loaded',
     'SCHEMA', 'IFC', 'TABLE', 'CollectionContractSummary', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Contract identifier -> IFC.Contract.SourceID', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'SourceContractID'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'CollectionContractSummary', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'CollectionContractSummary',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Operation value set -> OPERATION', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'OperationCode'
go

exec sp_addextendedproperty 'MS_Description', 'Import table identifier -> IFC.ImportTable', 'SCHEMA', 'IFC', 'TABLE',
     'CollectionContractSummary', 'COLUMN', 'ImportTableID'
go

create index IXFK_CollectionContractSummary_InterfaceTable
    on IFC.CollectionContractSummary (ImportTableID)
go

create table IFC.Company
(
    ID                   numeric(16) identity
        constraint PK_Company
            primary key,
    ObjectID             numeric(16)
        constraint FK_Company_Object
            references GEN.Object,
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    RegistrationNr       nvarchar(30),
    RegistrationDate     date,
    TaxNr                nvarchar(30),
    StatisticalNr        nvarchar(30),
    LegalForm            nvarchar(200),
    LegalFormID          nvarchar(200),
    Name                 nvarchar(250),
    ZipCode              nvarchar(250),
    City                 nvarchar(250),
    Street               nvarchar(250),
    MainActivityCode     nvarchar(16),
    LegalStatus          nvarchar(200),
    LegalStatusID        nvarchar(200),
    Field1               nvarchar(250),
    Field2               nvarchar(250),
    Field3               nvarchar(250),
    Field4               nvarchar(250),
    Field5               nvarchar(250),
    CrefoID              numeric(16),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    ParentStatisticalNr  nvarchar(100),
    ValidFrom            date,
    UpdateDate           date,
    ValidUntil           date,
    ActualisationDate    date,
    InternationalTaxNr   nvarchar(50),
    IndustryCode         nvarchar(200),
    EntrepreneurNr       nvarchar(100),
    TaxResidence         nvarchar,
    Operation            nvarchar,
    InterfaceTableID     numeric(16)
        constraint FK_Company_InterfaceTable
            references IFC.InterfaceTable,
    CountryID            nvarchar(200),
    Country              nvarchar(16),
    OrganizationUnitCode nvarchar(200),
    OrganizationUnitID   nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    CompanyID            numeric(16),
    PortfolioName        nvarchar(200),
    PortfolioID          numeric(16),
    LegalFormCode        nvarchar(200),
    LegalStatusCode      nvarchar(200)
)
go

create index IXFK_Company_InterfaceTable
    on IFC.Company (InterfaceTableID)
go

create index IXFK_Company_Object
    on IFC.Company (ObjectID)
go

create table IFC.Contact
(
    ID                   numeric(16) identity
        constraint PK_Contact
            primary key,
    ObjectID             numeric(16)
        constraint FK_Contact_Object
            references GEN.Object,
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    SourcePersonID       nvarchar(200),
    SourceCompanyID      nvarchar(200),
    RegistrationNr       nvarchar(30),
    TaxNr                nvarchar(30),
    StatisticalNr        nvarchar(30),
    ContactType          nvarchar(200),
    ContactTypeID        numeric(16),
    Contact              nvarchar(250),
    MainContact          nvarchar,
    Description          nvarchar(250),
    CrefoID              numeric(16),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    ActualisationDate    date,
    ContactID            numeric(16),
    Operation            nvarchar,
    InterfaceTableID     numeric(16)
        constraint FK_Contact_InterfaceTable
            references IFC.InterfaceTable,
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ContactTypeCode      nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Contact type -> value set CONTACT_TYPE', 'SCHEMA', 'IFC', 'TABLE',
     'Contact', 'COLUMN', 'ContactTypeCode'
go

create index IXFK_Contact_InterfaceTable
    on IFC.Contact (InterfaceTableID)
go

create index IXFK_Contact_Object
    on IFC.Contact (ObjectID)
go

create table IFC.ContractItem
(
    ID                   numeric(16) identity
        constraint PK_ContractItem
            primary key,
    ObjectID             numeric(16),
    SequenceNr           numeric(16),
    ReferenceNr          nvarchar(200),
    NetValue             money,
    VATValue             money,
    GrossValue           money,
    CurrencyCode         nvarchar(200),
    ProductID            nvarchar(50),
    ProductName          nvarchar(200),
    Description          nvarchar(max),
    StatusCode           nvarchar(200),
    StatusText           nvarchar(200),
    ContractItemID       numeric(16),
    SourceID             nvarchar(200),
    SourceContractID     nvarchar(200),
    SourceContractNr     nvarchar(200),
    SourceInterfaceType  nvarchar(200),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    OperationCode        nvarchar(200),
    ImportTableID        numeric(16)
        constraint FK_ContractItem_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'ContractItem', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'IFC', 'TABLE',
     'ContractItem', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Sequence number', 'SCHEMA', 'IFC', 'TABLE', 'ContractItem', 'COLUMN',
     'SequenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Reference number', 'SCHEMA', 'IFC', 'TABLE', 'ContractItem', 'COLUMN',
     'ReferenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Net value', 'SCHEMA', 'IFC', 'TABLE', 'ContractItem', 'COLUMN',
     'NetValue'
go

exec sp_addextendedproperty 'MS_Description', 'VAT value', 'SCHEMA', 'IFC', 'TABLE', 'ContractItem', 'COLUMN',
     'VATValue'
go

exec sp_addextendedproperty 'MS_Description', 'Gross value', 'SCHEMA', 'IFC', 'TABLE', 'ContractItem', 'COLUMN',
     'GrossValue'
go

exec sp_addextendedproperty 'MS_Description', 'Currency value set -> CURRENCY', 'SCHEMA', 'IFC', 'TABLE',
     'ContractItem', 'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Name of product', 'SCHEMA', 'IFC', 'TABLE', 'ContractItem', 'COLUMN',
     'ProductName'
go

exec sp_addextendedproperty 'MS_Description', 'Description', 'SCHEMA', 'IFC', 'TABLE', 'ContractItem', 'COLUMN',
     'Description'
go

exec sp_addextendedproperty 'MS_Description', 'Status value set -> STATUS', 'SCHEMA', 'IFC', 'TABLE', 'ContractItem',
     'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Status text', 'SCHEMA', 'IFC', 'TABLE', 'ContractItem', 'COLUMN',
     'StatusText'
go

exec sp_addextendedproperty 'MS_Description', 'The identifier of the loaded contract item -> CRM.ContractItem',
     'SCHEMA', 'IFC', 'TABLE', 'ContractItem', 'COLUMN', 'ContractItemID'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier of the contract item to be loaded', 'SCHEMA', 'IFC',
     'TABLE', 'ContractItem', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Contract identifier -> IFC.Contract.SourceID', 'SCHEMA', 'IFC', 'TABLE',
     'ContractItem', 'COLUMN', 'SourceContractID'
go

exec sp_addextendedproperty 'MS_Description', 'Contract number -> IFC.Contract.ContractNr', 'SCHEMA', 'IFC', 'TABLE',
     'ContractItem', 'COLUMN', 'SourceContractNr'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'ContractItem',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'ContractItem', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'ContractItem', 'COLUMN',
     'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Operation value set -> OPERATION', 'SCHEMA', 'IFC', 'TABLE',
     'ContractItem', 'COLUMN', 'OperationCode'
go

exec sp_addextendedproperty 'MS_Description', 'Import table identifier -> IFC.ImportTable', 'SCHEMA', 'IFC', 'TABLE',
     'ContractItem', 'COLUMN', 'ImportTableID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'ContractItem', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'ContractItem', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'ContractItem', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'ContractItem', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'ContractItem', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'ContractItem', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_ContractItem_InterfaceTable
    on IFC.ContractItem (ImportTableID)
go

create table IFC.DebtCase
(
    ID                        numeric(16) identity
        constraint PK_DebtCase
            primary key,
    SourceInterfaceType       nvarchar(200),
    SourceID                  nvarchar(200),
    PackageName               nvarchar(200),
    PackageCode               nvarchar(200),
    PackageID                 numeric(16),
    DebtNr                    nvarchar(200),
    PartyName                 nvarchar(200),
    PartyID                   numeric(16),
    PartyBankAccountNr        nvarchar(50),
    CreditorName              nvarchar(200),
    CreditorEntityID          numeric(16),
    OwnProperty               nvarchar(200),
    PurchasePrice             money,
    PurchasePriceCurrency     nvarchar(200),
    PurchasePriceCurrencyCode nvarchar(200),
    PurchaseDate              date,
    SalesUserID               nvarchar(50),
    UserID                    nvarchar(50),
    TaskMainStatusCode        nvarchar(200),
    TaskStatusCode            nvarchar(200),
    Currency                  nvarchar(200),
    CurrencyCode              nvarchar(200),
    Comments                  nvarchar(250),
    Field1                    nvarchar(200),
    Field2                    nvarchar(200),
    Field3                    nvarchar(200),
    Field4                    nvarchar(200),
    Field5                    nvarchar(200),
    OperationCode             nvarchar(200),
    DebtCaseID                numeric(16),
    InterfaceStatusCode       nvarchar(200),
    ErrorMessage              nvarchar(max),
    InterfaceTableID          numeric(16)
        constraint FK_DebtCase_InterfaceTable
            references IFC.InterfaceTable,
    MainDebtorID              numeric(16),
    Section                   nvarchar(200),
    SectionCode               nvarchar(200),
    Phase                     nvarchar(200),
    PhaseCode                 nvarchar(200),
    CloseReason               nvarchar(200),
    CloseDate                 date,
    OfficeID                  numeric(16),
    Office                    nvarchar(200),
    ClientNr                  nvarchar(200),
    CreationDate              date,
    CreationTime              time,
    CreationUserName          nvarchar(200),
    LastModifiedDate          date,
    LastModifiedTime          time,
    LastModifiedUserName      nvarchar(200),
    DepartmentType            nvarchar(200),
    DepartmentTypeCode        nvarchar(200),
    CreditType                nvarchar(200),
    CreditTypeCode            nvarchar(200),
    PortfolioName             nvarchar(200),
    PortfolioID               numeric(16),
    BankAccountNumber         nvarchar(200),
    RepaymentBankAccountNr    nvarchar(200),
    CaseTypeCode              nvarchar(200)
        constraint FK_Object_Code_08
            references GEN.Code,
    LoanGuaranteedCode        nvarchar(200)
        constraint FK_Object_Code_09
            references GEN.Code,
    ConstructionCode          nvarchar(200),
    AccountingSystem          nvarchar(200),
    AccountingSystemCode      nvarchar(200),
    Level1                    nvarchar(200),
    Level2                    nvarchar(200),
    Level3                    nvarchar(200),
    Level4                    nvarchar(200),
    Level5                    nvarchar(200),
    Level6                    nvarchar(200),
    Level7                    nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Name of the portfolio', 'SCHEMA', 'IFC', 'TABLE', 'DebtCase', 'COLUMN',
     'PortfolioName'
go

exec sp_addextendedproperty 'MS_Description', 'Portfolio identifier -> GEN.Portfolio', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCase', 'COLUMN', 'PortfolioID'
go

exec sp_addextendedproperty 'MS_Description', 'Repayment bank account number', 'SCHEMA', 'IFC', 'TABLE', 'DebtCase',
     'COLUMN', 'RepaymentBankAccountNr'
go

exec sp_addextendedproperty 'MS_Description', 'Case type code -> value set CASE_TYPE', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCase', 'COLUMN', 'CaseTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'This case is secured with loan guarantee? -> value set BOOLEAN',
     'SCHEMA', 'IFC', 'TABLE', 'DebtCase', 'COLUMN', 'LoanGuaranteedCode'
go

exec sp_addextendedproperty 'MS_Description', 'Construction code value', 'SCHEMA', 'IFC', 'TABLE', 'DebtCase', 'COLUMN',
     'ConstructionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Original accounting system''s name', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCase', 'COLUMN', 'AccountingSystem'
go

exec sp_addextendedproperty 'MS_Description', 'Original accounting system''s code', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCase', 'COLUMN', 'AccountingSystemCode'
go

exec sp_addextendedproperty 'MS_Description', 'Level1', 'SCHEMA', 'IFC', 'TABLE', 'DebtCase', 'COLUMN', 'Level1'
go

exec sp_addextendedproperty 'MS_Description', 'Level2', 'SCHEMA', 'IFC', 'TABLE', 'DebtCase', 'COLUMN', 'Level2'
go

exec sp_addextendedproperty 'MS_Description', 'Level3', 'SCHEMA', 'IFC', 'TABLE', 'DebtCase', 'COLUMN', 'Level3'
go

exec sp_addextendedproperty 'MS_Description', 'Level4', 'SCHEMA', 'IFC', 'TABLE', 'DebtCase', 'COLUMN', 'Level4'
go

exec sp_addextendedproperty 'MS_Description', 'Level5', 'SCHEMA', 'IFC', 'TABLE', 'DebtCase', 'COLUMN', 'Level5'
go

exec sp_addextendedproperty 'MS_Description', 'Level6', 'SCHEMA', 'IFC', 'TABLE', 'DebtCase', 'COLUMN', 'Level6'
go

exec sp_addextendedproperty 'MS_Description', 'Level7', 'SCHEMA', 'IFC', 'TABLE', 'DebtCase', 'COLUMN', 'Level7'
go

create index IXFK_DebtCase_InterfaceTable
    on IFC.DebtCase (InterfaceTableID)
go

create table IFC.DebtCaseAsset
(
    ID                   numeric(16) identity
        constraint PK_DebtCaseAsset
            primary key,
    StatusCode           nvarchar(200),
    StatusText           nvarchar(200),
    TypeCode             nvarchar(200),
    TypeText             nvarchar(200),
    DecisionNr           nvarchar(200),
    ValidFrom            date,
    ValidUntil           date,
    DebtCaseAssetID      numeric(16),
    AssetID              numeric(16),
    DebtCaseID           numeric(16),
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    SourceAssetID        nvarchar(200),
    SourceDebtCaseID     nvarchar(200),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    InterfaceTableID     numeric(16)
        constraint FK_DebtCaseAsset_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'DebtCaseAsset', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Debt case asset status value set -> STATUS', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Debt case asset status text', 'SCHEMA', 'IFC', 'TABLE', 'DebtCaseAsset',
     'COLUMN', 'StatusText'
go

exec sp_addextendedproperty 'MS_Description', 'Type of the debt case-asset connection -> ASSET_RELATION_TYPE', 'SCHEMA',
     'IFC', 'TABLE', 'DebtCaseAsset', 'COLUMN', 'TypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Type of the debt case-asset connection text', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'TypeText'
go

exec sp_addextendedproperty 'MS_Description', 'Decision number', 'SCHEMA', 'IFC', 'TABLE', 'DebtCaseAsset', 'COLUMN',
     'DecisionNr'
go

exec sp_addextendedproperty 'MS_Description', 'Valid From', 'SCHEMA', 'IFC', 'TABLE', 'DebtCaseAsset', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'IFC', 'TABLE', 'DebtCaseAsset', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Debt case asset identifier -> AST.DebtCaseAsset', 'SCHEMA', 'IFC',
     'TABLE', 'DebtCaseAsset', 'COLUMN', 'DebtCaseAssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Asset identifier -> AST.Asset', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'AssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Debt case identifier -> DCS.DebtCase', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'DebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'DebtCaseAsset',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier', 'SCHEMA', 'IFC', 'TABLE', 'DebtCaseAsset', 'COLUMN',
     'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Source asset identifier -> IFC.Asset', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'SourceAssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Source debt case identifier -> IFC.DebtCase', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'SourceDebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'DebtCaseAsset', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error Message', 'SCHEMA', 'IFC', 'TABLE', 'DebtCaseAsset', 'COLUMN',
     'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Interface table identifier -> IFC.InterfaceTable', 'SCHEMA', 'IFC',
     'TABLE', 'DebtCaseAsset', 'COLUMN', 'InterfaceTableID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_DebtCaseAsset_InterfaceTable
    on IFC.DebtCaseAsset (InterfaceTableID)
go

create table IFC.Debtor
(
    ID                   numeric(16) identity
        constraint PK_Debtor
            primary key,
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    SourceDebtCaseID     nvarchar(200),
    SourcePersonID       nvarchar(200),
    SourceCompanyID      nvarchar(200),
    RoleText             nvarchar(200),
    RoleCode             nvarchar(200),
    DebtorID             numeric(16),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    OperationCode        nvarchar(200),
    InterfaceTableID     numeric(16)
        constraint FK_Debtor_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_Debtor_InterfaceTable
    on IFC.Debtor (InterfaceTableID)
go

create table IFC.DebtorAsset
(
    ID                          numeric(16) identity
        constraint PK_DebtorAsset
            primary key,
    AssetDebtorRelationTypeCode nvarchar(200),
    AssetDebtorRelationTypeText nvarchar(200),
    OwnPercent                  numeric(10, 4),
    SharePercent                numeric(10, 4),
    ShareDividend               numeric(10, 4),
    ShareDivisor                numeric(10, 4),
    ValidFrom                   date,
    ValidUntil                  date,
    StatusCode                  nvarchar(200),
    Status                      nvarchar(200),
    DebtorAssetID               numeric(16),
    AssetID                     numeric(16),
    DebtorID                    numeric(16),
    SourceInterfaceType         nvarchar(200),
    SourceID                    nvarchar(200),
    SourceAssetID               nvarchar(200),
    SourceDebtorID              nvarchar(200),
    InterfaceStatusCode         nvarchar(200),
    ErrorMessage                nvarchar(200),
    InterfaceTableID            numeric(16)
        constraint FK_DebtorAsset_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate                date,
    CreationTime                time,
    CreationUserName            nvarchar(200),
    LastModifiedDate            date,
    LastModifiedTime            time,
    LastModifiedUserName        nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description',
     'Type of the asset-debtor relation -> value set ASSET_DEBTOR_RELATION_TYPE', 'SCHEMA', 'IFC', 'TABLE',
     'DebtorAsset', 'COLUMN', 'AssetDebtorRelationTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Type of the asset-debtor relation text', 'SCHEMA', 'IFC', 'TABLE',
     'DebtorAsset', 'COLUMN', 'AssetDebtorRelationTypeText'
go

exec sp_addextendedproperty 'MS_Description', 'Own percent', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset', 'COLUMN',
     'OwnPercent'
go

exec sp_addextendedproperty 'MS_Description', 'Share in percent', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset', 'COLUMN',
     'SharePercent'
go

exec sp_addextendedproperty 'MS_Description', 'Share dividend', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset', 'COLUMN',
     'ShareDividend'
go

exec sp_addextendedproperty 'MS_Description', 'Share divisor', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset', 'COLUMN',
     'ShareDivisor'
go

exec sp_addextendedproperty 'MS_Description', 'Valid From', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid Until', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Debtor asset status value set -> STATUS', 'SCHEMA', 'IFC', 'TABLE',
     'DebtorAsset', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Debtor asset status text', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset',
     'COLUMN', 'Status'
go

exec sp_addextendedproperty 'MS_Description', 'Debtor asset identifier -> AST.DebtorAsset', 'SCHEMA', 'IFC', 'TABLE',
     'DebtorAsset', 'COLUMN', 'DebtorAssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Asset identifier -> AST.Asset', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset',
     'COLUMN', 'AssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Debtor identifier -> DCS.Debtor', 'SCHEMA', 'IFC', 'TABLE',
     'DebtorAsset', 'COLUMN', 'DebtorID'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset', 'COLUMN',
     'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Source asset identifier -> IFC.Aasset', 'SCHEMA', 'IFC', 'TABLE',
     'DebtorAsset', 'COLUMN', 'SourceAssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Source debtor identifier -> IFC.Debtor', 'SCHEMA', 'IFC', 'TABLE',
     'DebtorAsset', 'COLUMN', 'SourceDebtorID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'DebtorAsset', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error Message', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset', 'COLUMN',
     'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Interface table identifier -> IFC.InterfaceTable', 'SCHEMA', 'IFC',
     'TABLE', 'DebtorAsset', 'COLUMN', 'InterfaceTableID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'DebtorAsset',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'DebtorAsset', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'DebtorAsset', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'DebtorAsset', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'DebtorAsset', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_DebtorAsset_InterfaceTable
    on IFC.DebtorAsset (InterfaceTableID)
go

create table IFC.EntityAsset
(
    ID                          numeric(16) identity
        constraint PK_EntityAsset
            primary key,
    EntityAssetRelationTypeCode nvarchar(200),
    EntityAssetRelationTypeText nvarchar(200),
    SharePercent                numeric(10),
    ShareDividend               numeric(10),
    ShareDivisor                numeric(10),
    ExternalReferenceNr         nvarchar(200),
    DecisionNr                  nvarchar(200),
    ValidFrom                   date,
    ValidUntil                  date,
    StatusCode                  nvarchar(200),
    StatusText                  nvarchar(200),
    EntityAssetID               numeric(16),
    AssetID                     numeric(16),
    EntityID                    numeric(16),
    SourceInterfaceType         nvarchar(200),
    SourceID                    nvarchar(200),
    SourceAssetID               nvarchar(200),
    SourceEntityID              nvarchar(200),
    InterfaceStatusCode         nvarchar(200),
    ErrorMessage                nvarchar(max),
    InterfaceTableID            numeric(16)
        constraint FK_EntityAsset_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate                date,
    CreationTime                time,
    CreationUserName            nvarchar(200),
    LastModifiedDate            date,
    LastModifiedTime            time,
    LastModifiedUserName        nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description',
     'Type of the asset-entity relation -> value set ENTITY_ASSET_RELATION_TYPE', 'SCHEMA', 'IFC', 'TABLE',
     'EntityAsset', 'COLUMN', 'EntityAssetRelationTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Type of the asset-entity relation text', 'SCHEMA', 'IFC', 'TABLE',
     'EntityAsset', 'COLUMN', 'EntityAssetRelationTypeText'
go

exec sp_addextendedproperty 'MS_Description', 'Share in percent', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset', 'COLUMN',
     'SharePercent'
go

exec sp_addextendedproperty 'MS_Description', 'Share Dividend', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset', 'COLUMN',
     'ShareDividend'
go

exec sp_addextendedproperty 'MS_Description', 'Share Divisor', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset', 'COLUMN',
     'ShareDivisor'
go

exec sp_addextendedproperty 'MS_Description', 'Decision number', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset', 'COLUMN',
     'DecisionNr'
go

exec sp_addextendedproperty 'MS_Description', 'Valid From', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid Until', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Debtor asset status value set -> STATUS', 'SCHEMA', 'IFC', 'TABLE',
     'EntityAsset', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Debtor asset status text', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset',
     'COLUMN', 'StatusText'
go

exec sp_addextendedproperty 'MS_Description', 'Entriy-asset identifier -> AST.EntityAsset', 'SCHEMA', 'IFC', 'TABLE',
     'EntityAsset', 'COLUMN', 'EntityAssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Asset identifier -> AST.Asset', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset',
     'COLUMN', 'AssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Entity identifier -> PRT.Entity', 'SCHEMA', 'IFC', 'TABLE',
     'EntityAsset', 'COLUMN', 'EntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset', 'COLUMN',
     'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Source asset identifier -> IFC.Asset', 'SCHEMA', 'IFC', 'TABLE',
     'EntityAsset', 'COLUMN', 'SourceAssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Source debtor identifier -> IFC.Debtor', 'SCHEMA', 'IFC', 'TABLE',
     'EntityAsset', 'COLUMN', 'SourceEntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'EntityAsset', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error Message', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset', 'COLUMN',
     'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Interface table identifier -> IFC.InterfaceTable', 'SCHEMA', 'IFC',
     'TABLE', 'EntityAsset', 'COLUMN', 'InterfaceTableID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE', 'EntityAsset',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'EntityAsset', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'EntityAsset', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'EntityAsset', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'EntityAsset', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_ImportTable_ImportPackage
    on IFC.InterfaceTable (InterfacePackageID)
go

create index IXFK_InterfaceTable_Folder
    on IFC.InterfaceTable (FolderID)
go

create index IXFK_InterfaceTable_InterfacePackage
    on IFC.InterfaceTable (InterfacePackageID)
go

create index IXFK_InterfaceTable_Object
    on IFC.InterfaceTable (ObjectID)
go

create table IFC.Invoice
(
    ID                       numeric(16) identity,
    ObjectID                 numeric(16),
    InvoiceTypeText          nvarchar(200),
    InvoiceTypeCode          nvarchar(200),
    SellerPartyID            numeric(16),
    BuyerPartyID             numeric(16),
    InvoiceNr                nvarchar(200),
    RegistrationNr           nvarchar(200),
    CreditTypeCode           nvarchar(200),
    CreditTypeText           nvarchar(200),
    ProductCode              nvarchar(200),
    ProductText              nvarchar(200),
    ContractDate             date,
    FulfillmentDate          date,
    IssueDate                date,
    DueDate                  date,
    TerminationDate          date,
    PaymentMethodCode        nvarchar(200),
    PaymentMethodText        nvarchar(200),
    CurrencyCode             nvarchar(200),
    CurrencyText             nvarchar(200),
    TotalNetAmount           money,
    TotalVATAmount           money,
    TotalGrossAmount         money,
    TotalCredit              money,
    TotalInstalment          money,
    ArrearsCapital           money,
    ArrearsInterest          money,
    ArrearsPenaltyInterest   money,
    ArrearsCost              money,
    ArrearsCostLocalCurrency money,
    InterestRate             numeric(10, 5),
    PenaltyInterestRate      numeric(10, 5),
    InvoiceID                numeric(16),
    SourceID                 nvarchar(200),
    SourceDebtCaseID         nvarchar(200),
    SourceContractID         nvarchar(200),
    SourceInterfaceType      nvarchar(200),
    InterfaceStatusCode      nvarchar(200),
    ErrorMessage             nvarchar(max),
    OperationCode            nvarchar(200),
    ImportTableID            numeric(16)
        constraint FK_Invoice_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate             date,
    CreationTime             time,
    CreationUserName         nvarchar(200),
    LastModifiedDate         date,
    LastModifiedTime         time,
    LastModifiedUserName     nvarchar(200),
    SellerPartyName          nvarchar(200),
    BuyerPartyName           nvarchar(200),
    CostRate                 numeric(10, 5),
    PeriodMinimumValue       money,
    PeriodMaximumValue       money
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'Invoice', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'IFC', 'TABLE', 'Invoice',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Period minimum value', 'SCHEMA', 'IFC', 'TABLE', 'Invoice', 'COLUMN',
     'PeriodMinimumValue'
go

exec sp_addextendedproperty 'MS_Description', 'Period maximum value', 'SCHEMA', 'IFC', 'TABLE', 'Invoice', 'COLUMN',
     'PeriodMaximumValue'
go

create index IXFK_Invoice_InterfaceTable
    on IFC.Invoice (ImportTableID)
go

create table COM.Notification
(
    ID                   numeric(16) identity
        constraint PK_Notification
            primary key,
    NotificationCode     nvarchar(200)
        constraint FK_Notification_Code
            references GEN.Code,
    Subject              nvarchar(200),
    DocumentTemplateID   numeric(16)
        constraint FK_Notification_DocumentTemplate
            references GEN.DocumentTemplate,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'COM', 'TABLE', 'Notification', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Code of the notification -> value set NOTIFICATION', 'SCHEMA', 'COM',
     'TABLE', 'Notification', 'COLUMN', 'NotificationCode'
go

exec sp_addextendedproperty 'MS_Description', 'Subject of the notification', 'SCHEMA', 'COM', 'TABLE', 'Notification',
     'COLUMN', 'Subject'
go

exec sp_addextendedproperty 'MS_Description', 'Document template identifier -> GEN.DocumentTemplate', 'SCHEMA', 'COM',
     'TABLE', 'Notification', 'COLUMN', 'DocumentTemplateID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'COM', 'TABLE',
     'Notification', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'COM', 'TABLE',
     'Notification', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'COM', 'TABLE', 'Notification',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'COM', 'TABLE',
     'Notification', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'COM', 'TABLE',
     'Notification', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'COM', 'TABLE', 'Notification',
     'COLUMN', 'LastModifiedUserName'
go

create table ORG.EventType
(
    ID                   numeric(16) identity
        constraint PK_EventType
            primary key,
    Code                 nvarchar(200)
        constraint FK_EventType_Code
            references GEN.Code,
    NotificationID       numeric(16)
        constraint FK_EventType_Notification
            references COM.Notification,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'EventType', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Event type code -> value set EVENT_TYPE', 'SCHEMA', 'ORG', 'TABLE',
     'EventType', 'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Notification for the event ->  COM.Notification', 'SCHEMA', 'ORG',
     'TABLE', 'EventType', 'COLUMN', 'NotificationID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'EventType',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'EventType',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'EventType',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'EventType', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'EventType', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'EventType',
     'COLUMN', 'LastModifiedUserName'
go

create table COM.NotificationSubscription
(
    ID                   numeric(16) identity
        constraint PK_NotificationSubscription
            primary key,
    NotificationID       numeric(16)
        constraint FK_NotificationSubscription_Notification
            references COM.Notification,
    AppUserName          nvarchar(200),
    ChannelCode          nvarchar(200)
        constraint FK_NotificationSubscription_Code_02
            references GEN.Code,
    SuspendedCode        nvarchar(200)
        constraint FK_NotificationSubscription_Code
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    LanguageCode         nvarchar(200)
        constraint FK_NotificationSubscription_Code_03
            references GEN.Code,
    StatusCode           nvarchar(200)
        constraint FK_NotificationSubscription_Code_04
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'COM', 'TABLE', 'NotificationSubscription',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Notification identifier -> COM.Notification', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscription', 'COLUMN', 'NotificationID'
go

exec sp_addextendedproperty 'MS_Description', 'Subscriber user name -> PRT.AppUser', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscription', 'COLUMN', 'AppUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Channel of the notiification -> value set CHANNEL', 'SCHEMA', 'COM',
     'TABLE', 'NotificationSubscription', 'COLUMN', 'ChannelCode'
go

exec sp_addextendedproperty 'MS_Description', 'Suspended? -> value set BOOLEAN', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscription', 'COLUMN', 'SuspendedCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscription', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscription', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscription', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscription', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscription', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Language code -> value set LANGUAGE', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscription', 'COLUMN', 'LanguageCode'
go

exec sp_addextendedproperty 'MS_Description', 'Status code -> value set STATUS', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscription', 'COLUMN', 'StatusCode'
go

create table IFC.ObjectGroupMember
(
    ID                   numeric(16) identity
        constraint PK_ObjectGroupMember
            primary key,
    InterfaceTableID     numeric(16)
        constraint FK_ObjectGroupMember_InterfaceTable
            references IFC.InterfaceTable,
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    ObjectGroupID        numeric(16),
    DataSourceID         numeric(16),
    ReferencedObjectID   numeric(16),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    ObjectGroupMemberID  numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    IdentifierID         nvarchar(250)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'ObjectGroupMember',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface table identifier -> IFC.InterfaceTable', 'SCHEMA', 'IFC',
     'TABLE', 'ObjectGroupMember', 'COLUMN', 'InterfaceTableID'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'ObjectGroupMember',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier (external system)', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Object group identifier -> GEN.ObjectGroup', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'ObjectGroupID'
go

exec sp_addextendedproperty 'MS_Description', 'Data source identifier -> GEN.DataSource', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'DataSourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Referenced object identifier -> GEN.Object', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'ReferencedObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'ObjectGroupMember', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'ObjectGroupMember', 'COLUMN',
     'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Object group member identifier -> GEN.ObjectGroupMember', 'SCHEMA',
     'IFC', 'TABLE', 'ObjectGroupMember', 'COLUMN', 'ObjectGroupMemberID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectGroupMember', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Identifier', 'SCHEMA', 'IFC', 'TABLE', 'ObjectGroupMember', 'COLUMN',
     'IdentifierID'
go

create table IFC.ObjectIdentifier
(
    ID                      numeric(16) identity
        constraint PK_ObjectIdentifier
            primary key,
    IdentifierTypeText      nvarchar(200),
    IdentifierTypeCode      nvarchar(200),
    Identifier              nvarchar(200),
    ValidFrom               date,
    ValidUntil              date,
    ObjectIdentifierID      numeric(16),
    SourceInterfaceType     nvarchar(200),
    SourceID                nvarchar(200),
    SourceRelatedObjectID   nvarchar(200),
    InterfaceStatusCode     nvarchar(200),
    ErrorMessage            nvarchar(max),
    InterfaceTableID        numeric(16)
        constraint FK_ObjectIdentifier_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate            date,
    CreationTime            time,
    CreationUserName        nvarchar(200),
    LastModifiedDate        date,
    LastModifiedTime        time,
    LastModifiedUserName    nvarchar(200),
    SourceRelatedObjectType nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'ObjectIdentifier',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Identifier type (value)', 'SCHEMA', 'IFC', 'TABLE', 'ObjectIdentifier',
     'COLUMN', 'IdentifierTypeText'
go

exec sp_addextendedproperty 'MS_Description', 'Identifier type -> value set IDENTIFIER_TYPE', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'IdentifierTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Identifier', 'SCHEMA', 'IFC', 'TABLE', 'ObjectIdentifier', 'COLUMN',
     'Identifier'
go

exec sp_addextendedproperty 'MS_Description', 'Valid From', 'SCHEMA', 'IFC', 'TABLE', 'ObjectIdentifier', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid Until', 'SCHEMA', 'IFC', 'TABLE', 'ObjectIdentifier', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.ObjectIdentifier', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'ObjectIdentifierID'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'IFC', 'TABLE', 'ObjectIdentifier',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier', 'SCHEMA', 'IFC', 'TABLE', 'ObjectIdentifier',
     'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'The object''s source identifier', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'SourceRelatedObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'ObjectIdentifier', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error Message', 'SCHEMA', 'IFC', 'TABLE', 'ObjectIdentifier', 'COLUMN',
     'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Interface table identifier -> IFC.InterfaceTable', 'SCHEMA', 'IFC',
     'TABLE', 'ObjectIdentifier', 'COLUMN', 'InterfaceTableID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'ObjectIdentifier', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'The object''s type', 'SCHEMA', 'IFC', 'TABLE', 'ObjectIdentifier',
     'COLUMN', 'SourceRelatedObjectType'
go

create table IFC.Person
(
    ID                   numeric(16) identity
        constraint PK_Person
            primary key,
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    PortfolioName        nvarchar(200),
    PortfolioID          numeric(16),
    RegistrationNr       nvarchar(200),
    TaxNr                nvarchar(200),
    StatisticalNr        nvarchar(200),
    Title                nvarchar(100),
    LastName             nvarchar(250),
    MiddleName           nvarchar(250),
    FirstName            nvarchar(250),
    FullName             nvarchar(250),
    NationalityName      nvarchar(200),
    NationalityCode      nvarchar(200),
    BirthCountryName     nvarchar(200),
    BirthCountryCode     nvarchar(200),
    BirthPlace           nvarchar(250),
    BirthDate            date,
    MaidenLastName       nvarchar(250),
    MaidenFirstName      nvarchar(250),
    MothersLastName      nvarchar(250),
    MothersFirstName     nvarchar(250),
    PhoneNr              nvarchar(250),
    FaxNr                nvarchar(250),
    EMail                nvarchar(250),
    Web                  nvarchar(250),
    IdentityCardNr       nvarchar(250),
    PensionerNr          nvarchar(250),
    GenderName           nvarchar(200),
    GenderCode           nvarchar(200),
    DeceasedCode         nvarchar(200),
    CountryName          nvarchar(200),
    CountryCode          nvarchar(200),
    OrganizationUnitCode nvarchar(200),
    OrganizationUnitID   numeric(16),
    FathersName          nvarchar(50),
    DeathDate            date,
    DeathCountryName     nvarchar(200),
    DeathCountryCode     nvarchar(200),
    DeathZipCode         nvarchar(50),
    DeathCity            nvarchar(200),
    Field1               nvarchar(250),
    Field2               nvarchar(250),
    Field3               nvarchar(250),
    Field4               nvarchar(250),
    Field5               nvarchar(250),
    PersonID             numeric(16),
    InterfaceStatusCode  nvarchar(200),
    ErrorMessage         nvarchar(max),
    ActualisationDate    date,
    Operation            nvarchar(200),
    InterfaceTableID     numeric(16)
        constraint FK_Person_InterfaceTable
            references IFC.InterfaceTable,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    CrefoID              numeric(16),
    LegacyAssetCode      nvarchar(200)
)
go

create index IXFK_Person_InterfaceTable
    on IFC.Person (InterfaceTableID)
go

create table ORG.ProcessDefinition
(
    ID                               numeric(16) identity
        constraint PK_ProcessDefinition
            primary key,
    ObjectID                         numeric(16)
        constraint FK_ProcessDefinition_Object
            references GEN.Object,
    ProcessCode                      nvarchar(200)
        constraint FK_ProcessDefinition_Code
            references GEN.Code,
    StatusCode                       nvarchar(200)
        constraint FK_ProcessDefinition_Code_02
            references GEN.Code,
    ValidFrom                        date,
    ValidUntil                       date,
    FlowChartDocumentID              numeric(16)
        constraint FK_ProcessDefinition_Document
            references GEN.Document,
    ExternalProcessID                nvarchar(250),
    ExternalProcessDefinitionID      nvarchar(250),
    ReferencedObjectType             nvarchar(200),
    InconsistentCode                 nvarchar(200)
        constraint FK_ProcessDefinition_Code_03
            references GEN.Code,
    CreationDate                     date,
    CreationTime                     time,
    CreationUserName                 nvarchar(200),
    LastModifiedDate                 date,
    LastModifiedTime                 time,
    LastModifiedUserName             nvarchar(200),
    MassEntryCriteriaDataSourceID    numeric(16)
        constraint FK_ProcessDefinition_DataSource
            references GEN.DataSource,
    EntryAndExitCriteriaDataSourceID numeric(16)
        constraint FK_ProcessDefinition_DataSource_02
            references GEN.DataSource,
    EntryCriteriaDataSourceID        numeric(16)
        constraint FK_ProcessDefinition_DataSource_03
            references GEN.DataSource,
    ExitCriteriaDataSourceID         numeric(16)
        constraint FK_ProcessDefinition_DataSource_04
            references GEN.DataSource
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'ProcessDefinition',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinition', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Process value set -> WORKFLOW', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinition', 'COLUMN', 'ProcessCode'
go

exec sp_addextendedproperty 'MS_Description', 'Status value set -> STATUS', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinition', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid From', 'SCHEMA', 'ORG', 'TABLE', 'ProcessDefinition', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid Until', 'SCHEMA', 'ORG', 'TABLE', 'ProcessDefinition', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Flow chart document identifier -> GEN.Document', 'SCHEMA', 'ORG',
     'TABLE', 'ProcessDefinition', 'COLUMN', 'FlowChartDocumentID'
go

exec sp_addextendedproperty 'MS_Description', 'Process identifier (external system)', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinition', 'COLUMN', 'ExternalProcessID'
go

exec sp_addextendedproperty 'MS_Description', 'Process difinition identifier (external system)', 'SCHEMA', 'ORG',
     'TABLE', 'ProcessDefinition', 'COLUMN', 'ExternalProcessDefinitionID'
go

exec sp_addextendedproperty 'MS_Description', 'Referenced object type', 'SCHEMA', 'ORG', 'TABLE', 'ProcessDefinition',
     'COLUMN', 'ReferencedObjectType'
go

exec sp_addextendedproperty 'MS_Description', 'Inconsistent -> BOOLEAN value set', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinition', 'COLUMN', 'InconsistentCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinition', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinition', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinition', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinition', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinition', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinition', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Mass entry criteria data source identifier -> GEN.DataSource', 'SCHEMA',
     'ORG', 'TABLE', 'ProcessDefinition', 'COLUMN', 'MassEntryCriteriaDataSourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Entry and exit criteria data source identifier -> GEN.DataSource',
     'SCHEMA', 'ORG', 'TABLE', 'ProcessDefinition', 'COLUMN', 'EntryAndExitCriteriaDataSourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Entry criteria data source identifier -> GEN.DataSource', 'SCHEMA',
     'ORG', 'TABLE', 'ProcessDefinition', 'COLUMN', 'EntryCriteriaDataSourceID'
go

create table ORG.Process
(
    ID                   numeric(16) identity
        constraint PK_Process
            primary key
        constraint FK_Process_Code_01
            references ORG.Process,
    ObjectID             numeric(16)
        constraint FK_Process_Object
            references GEN.Object,
    ProcessDefinitionID  numeric(16)
        constraint FK_Process_ProcessDefinition
            references ORG.ProcessDefinition,
    ReferencedObjectID   numeric(16)
        constraint FK_Process_Object_02
            references GEN.Object,
    StatusCode           nvarchar(200)
        constraint FK_Process_Code
            references GEN.Code,
    BeginDate            date,
    BeginTime            time,
    EndDate              date,
    EndTime              time,
    ExternalProcessID    nvarchar(250),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    StartupTypeCode      nvarchar(200)
        constraint FK_Process_Code_02
            references GEN.Code,
    DetailedStatusCode   nvarchar(200)
        constraint FK_Process_Code_03
            references GEN.Code,
    ParentProcessID      numeric(16)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'Process', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE', 'Process',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Process identifier -> ORG.ProcessDefinition', 'SCHEMA', 'ORG', 'TABLE',
     'Process', 'COLUMN', 'ProcessDefinitionID'
go

exec sp_addextendedproperty 'MS_Description', 'Referenced object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'Process', 'COLUMN', 'ReferencedObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Process instance status value set -> PROCESS_INSTANCE_STATUS', 'SCHEMA',
     'ORG', 'TABLE', 'Process', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Process instance begin date', 'SCHEMA', 'ORG', 'TABLE', 'Process',
     'COLUMN', 'BeginDate'
go

exec sp_addextendedproperty 'MS_Description', 'Process instance begin time', 'SCHEMA', 'ORG', 'TABLE', 'Process',
     'COLUMN', 'BeginTime'
go

exec sp_addextendedproperty 'MS_Description', 'Process instance end date', 'SCHEMA', 'ORG', 'TABLE', 'Process',
     'COLUMN', 'EndDate'
go

exec sp_addextendedproperty 'MS_Description', 'Process instance end time', 'SCHEMA', 'ORG', 'TABLE', 'Process',
     'COLUMN', 'EndTime'
go

exec sp_addextendedproperty 'MS_Description', 'Process instance identifier (external system)', 'SCHEMA', 'ORG', 'TABLE',
     'Process', 'COLUMN', 'ExternalProcessID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'Process',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'Process',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'Process', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'Process', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'Process',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Type of process startup -> valuse set PROCESS_INSTANCE_STARTUP_TYPE',
     'SCHEMA', 'ORG', 'TABLE', 'Process', 'COLUMN', 'StartupTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Process instance detailed status', 'SCHEMA', 'ORG', 'TABLE', 'Process',
     'COLUMN', 'DetailedStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Parent process identifier -> ORG.Process', 'SCHEMA', 'ORG', 'TABLE',
     'Process', 'COLUMN', 'ParentProcessID'
go

create table IFC.AddressRegister
(
    ID                        numeric(16) identity
        constraint PK_AddressRegister
            primary key,
    SequenceNr                numeric(16),
    ObjectID                  numeric(16),
    Gender                    nvarchar(200),
    LastName                  nvarchar(200),
    MiddleName                nvarchar(200),
    FirstName                 nvarchar(200),
    MothersLastName           nvarchar(200),
    MothersFirstName          nvarchar(200),
    MaidenLastName            nvarchar(200),
    MaidenMiddleName          nvarchar(200),
    MaidenFirstName           nvarchar(200),
    BirthDate                 date,
    BirthPlace                nvarchar(200),
    DeregistrationReason      nvarchar(200),
    DeregistrationDate        date,
    PZipCode                  nvarchar(200),
    PCity                     nvarchar(200),
    PPublicPlaceName          nvarchar(200),
    PPublicPlaceType          nvarchar(200),
    PHouseNr                  nvarchar(200),
    PBuilding                 nvarchar(200),
    PStaircase                nvarchar(200),
    PFloor                    nvarchar(200),
    PDoor                     nvarchar(200),
    PRegistrationDate         date,
    PLevel                    nvarchar(200),
    TZipCode                  nvarchar(200),
    TCity                     nvarchar(200),
    TPublicPlaceName          nvarchar(200),
    TPublicPlaceType          nvarchar(200),
    THouseNr                  nvarchar(200),
    TBuilding                 nvarchar(200),
    TStaircase                nvarchar(200),
    TFloor                    nvarchar(200),
    TDoor                     nvarchar(200),
    TRegistrationDate         date,
    FCountry                  nvarchar(200),
    FZipCode                  nvarchar(200),
    FState                    nvarchar(200),
    FCity                     nvarchar(200),
    FAddress                  nvarchar(200),
    StatusCode                nvarchar(200)
        constraint FK_AddressRegister_Code
            references GEN.Code,
    CreationDate              date,
    CreationTime              time,
    CreationUserName          nvarchar(200),
    LastModifiedDate          date,
    LastModifiedTime          time,
    LastModifiedUserName      nvarchar(200),
    ExportImportCode          nvarchar(200)
        constraint FK_AddressRegister_Code_02
            references GEN.Code,
    ReturnedAddressRegisterID numeric(16),
    SourceInterfaceType       nvarchar(200),
    ValidationRecordCode      nvarchar(200),
    ProcessID                 numeric(16)
        constraint FK_AddressRegister_Process
            references ORG.Process
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Sequence number in a list', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'SequenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'The person''s object identifier -> GEN.Object', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Gender (HU: F / N)', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'Gender'
go

exec sp_addextendedproperty 'MS_Description', 'Last Name', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister', 'COLUMN',
     'LastName'
go

exec sp_addextendedproperty 'MS_Description', 'Middle Name', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister', 'COLUMN',
     'MiddleName'
go

exec sp_addextendedproperty 'MS_Description', 'First Name', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister', 'COLUMN',
     'FirstName'
go

exec sp_addextendedproperty 'MS_Description', 'Mother''s last name', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'MothersLastName'
go

exec sp_addextendedproperty 'MS_Description', 'Mother''s first name', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'MothersFirstName'
go

exec sp_addextendedproperty 'MS_Description', 'Last name at birth', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'MaidenLastName'
go

exec sp_addextendedproperty 'MS_Description', 'Middle name at birth', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'MaidenMiddleName'
go

exec sp_addextendedproperty 'MS_Description', 'First name at birth', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'MaidenFirstName'
go

exec sp_addextendedproperty 'MS_Description', 'Date of birth', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister', 'COLUMN',
     'BirthDate'
go

exec sp_addextendedproperty 'MS_Description', 'City of birth', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister', 'COLUMN',
     'BirthPlace'
go

exec sp_addextendedproperty 'MS_Description', 'Reason of deregistration', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'DeregistrationReason'
go

exec sp_addextendedproperty 'MS_Description', 'Date of deregistration', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'DeregistrationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Permanent address zip code', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'PZipCode'
go

exec sp_addextendedproperty 'MS_Description', 'Permanent address city', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'PCity'
go

exec sp_addextendedproperty 'MS_Description', 'Permanent address public place name', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'PPublicPlaceName'
go

exec sp_addextendedproperty 'MS_Description', 'Perpanent address public place type', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'PPublicPlaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Permanent address house number', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'PHouseNr'
go

exec sp_addextendedproperty 'MS_Description', 'Permanent address house number', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'PBuilding'
go

exec sp_addextendedproperty 'MS_Description', 'Permanent address staircase', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'PStaircase'
go

exec sp_addextendedproperty 'MS_Description', 'Permanent address floor', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'PFloor'
go

exec sp_addextendedproperty 'MS_Description', 'Permanent address door', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'PDoor'
go

exec sp_addextendedproperty 'MS_Description', 'Permanent address registration date', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'PRegistrationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Permanent address validity level (example: city)', 'SCHEMA', 'IFC',
     'TABLE', 'AddressRegister', 'COLUMN', 'PLevel'
go

exec sp_addextendedproperty 'MS_Description', 'Temporary address postal code', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'TZipCode'
go

exec sp_addextendedproperty 'MS_Description', 'Temporary address city', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'TCity'
go

exec sp_addextendedproperty 'MS_Description', 'Temporary address public place name', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'TPublicPlaceName'
go

exec sp_addextendedproperty 'MS_Description', 'Temporary address public place type', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'TPublicPlaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Temporary address house number', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'THouseNr'
go

exec sp_addextendedproperty 'MS_Description', 'Temporary address building', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'TBuilding'
go

exec sp_addextendedproperty 'MS_Description', 'Temporary address staircase', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'TStaircase'
go

exec sp_addextendedproperty 'MS_Description', 'Temporary address floor', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'TFloor'
go

exec sp_addextendedproperty 'MS_Description', 'Temporary address registration date', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'TRegistrationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Foreign address country', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'FCountry'
go

exec sp_addextendedproperty 'MS_Description', 'Foreign address zip code', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'FZipCode'
go

exec sp_addextendedproperty 'MS_Description', 'Foreign address state', 'SCHEMA', 'IFC', 'TABLE', 'AddressRegister',
     'COLUMN', 'FState'
go

exec sp_addextendedproperty 'MS_Description', 'Foreign address street and house number', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'FAddress'
go

exec sp_addextendedproperty 'MS_Description', 'Status of the address search -> value set ADDRESS_REGISTER_STATUS',
     'SCHEMA', 'IFC', 'TABLE', 'AddressRegister', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Export/Import code -> EXPORT_IMPORT', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'ExportImportCode'
go

exec sp_addextendedproperty 'MS_Description', 'Returned address register identifier -> IFC.AddressRegister', 'SCHEMA',
     'IFC', 'TABLE', 'AddressRegister', 'COLUMN', 'ReturnedAddressRegisterID'
go

exec sp_addextendedproperty 'MS_Description', 'Validation record -> value set BOOLEAN', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'ValidationRecordCode'
go

exec sp_addextendedproperty 'MS_Description', 'Process identifier -> ORG.Process', 'SCHEMA', 'IFC', 'TABLE',
     'AddressRegister', 'COLUMN', 'ProcessID'
go

create table ORG.ProcessDefinitionModule
(
    ID                   numeric(16) identity
        constraint PK_ProcessDefinitionModule
            primary key,
    ObjectID             numeric(16)
        constraint FK_ProcessDefinitionModule_Object
            references GEN.Object,
    ProcessDefinitionID  numeric(16)
        constraint FK_ProcessDefinitionModule_ProcessDefinition
            references ORG.ProcessDefinition,
    ModuleID             numeric(16)
        constraint FK_ProcessDefinitionModule_Module
            references ORG.Module,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    InconsistentCode     nvarchar(200)
        constraint FK_ProcessDefinitionModule_Code
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'ProcessDefinitionModule',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionModule', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Process identifier -> ORG.ProcessDefinition', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionModule', 'COLUMN', 'ProcessDefinitionID'
go

exec sp_addextendedproperty 'MS_Description', 'Module identifier -> ORG.Module', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionModule', 'COLUMN', 'ModuleID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionModule', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionModule', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionModule', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionModule', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionModule', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'Inconsistent -> value set BOOLEAN', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionModule', 'COLUMN', 'InconsistentCode'
go

create table ORG.ProcessDefinitionTerminalEventType
(
    ID                   numeric(16) identity
        constraint PK_ProcessDefinitionTerminalEventType
            primary key,
    ProcessDefinitionID  numeric(16)   not null
        constraint FK_ProcessDefinitionTerminalEventType_ProcessDefinition
            references ORG.ProcessDefinition
            on delete cascade,
    EventTypeCode        nvarchar(200) not null
        constraint FK_ProcessDefinitionTerminalEventType_Code
            references GEN.Code,
    CreationDate         date          not null,
    CreationTime         time          not null,
    CreationUserName     nvarchar(200) not null,
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTerminalEventType', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Process definition identifier -> ORG.ProcessDefinition', 'SCHEMA', 'ORG',
     'TABLE', 'ProcessDefinitionTerminalEventType', 'COLUMN', 'ProcessDefinitionID'
go

exec sp_addextendedproperty 'MS_Description', 'Event type code -> value set EVENT_TYPE', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTerminalEventType', 'COLUMN', 'EventTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTerminalEventType', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTerminalEventType', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTerminalEventType', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTerminalEventType', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTerminalEventType', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTerminalEventType', 'COLUMN', 'LastModifiedUserName'
go

create unique index IX_ProcessDefinitionTerminalEventType_Unique
    on ORG.ProcessDefinitionTerminalEventType (ProcessDefinitionID, EventTypeCode)
go

create index IXFK_RootFolder_Object
    on GEN.RootFolder (ObjectID)
go

create index IXFK_RootFolder_Object_02
    on GEN.RootFolder (ReferenceObjectID)
go

create table GEN.Sequence
(
    ID                   numeric(16) identity
        constraint PK_Sequence
            primary key,
    ObjectID             numeric(16)
        constraint FK_Sequence_Object
            references GEN.Object,
    Code                 nvarchar(200)
        constraint FK_Sequence_Code
            references GEN.Code,
    StatusCode           nvarchar(200)
        constraint FK_Sequence_Code_02
            references GEN.Code,
    LockedCode           nvarchar(200)
        constraint FK_Sequence_Code_03
            references GEN.Code,
    MaskValue            nvarchar(200),
    Description          nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    SequenceName         nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'Sequence', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE', 'Sequence',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Sequence code -> value set SEQUENCE', 'SCHEMA', 'GEN', 'TABLE',
     'Sequence', 'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Status code -> value set STATUS', 'SCHEMA', 'GEN', 'TABLE', 'Sequence',
     'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Locked code -> value set BOOLEAN', 'SCHEMA', 'GEN', 'TABLE', 'Sequence',
     'COLUMN', 'LockedCode'
go

exec sp_addextendedproperty 'MS_Description', 'Mask value', 'SCHEMA', 'GEN', 'TABLE', 'Sequence', 'COLUMN', 'MaskValue'
go

exec sp_addextendedproperty 'MS_Description', 'Description', 'SCHEMA', 'GEN', 'TABLE', 'Sequence', 'COLUMN',
     'Description'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'Sequence',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'Sequence',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'Sequence',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'Sequence', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'Sequence', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'Sequence',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Name of sequence', 'SCHEMA', 'GEN', 'TABLE', 'Sequence', 'COLUMN',
     'SequenceName'
go

create table GEN.SequenceValue
(
    ID                   numeric(16) identity
        constraint PK_SequenceValue
            primary key,
    ObjectID             numeric(16)
        constraint FK_SequenceValue_Object
            references GEN.Object,
    SequenceID           numeric(16)
        constraint FK_SequenceValue_Sequence
            references GEN.Sequence,
    Value                numeric(16),
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'SequenceValue', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'SequenceValue', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Sequence identifier -> GEN.Sequence', 'SCHEMA', 'GEN', 'TABLE',
     'SequenceValue', 'COLUMN', 'SequenceID'
go

exec sp_addextendedproperty 'MS_Description', 'Last value of sequence', 'SCHEMA', 'GEN', 'TABLE', 'SequenceValue',
     'COLUMN', 'Value'
go

exec sp_addextendedproperty 'MS_Description', 'Valid From', 'SCHEMA', 'GEN', 'TABLE', 'SequenceValue', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid Until', 'SCHEMA', 'GEN', 'TABLE', 'SequenceValue', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'SequenceValue', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'SequenceValue', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'SequenceValue',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'SequenceValue', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'SequenceValue', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'SequenceValue',
     'COLUMN', 'LastModifiedUserName'
go

create table DCS.Solution
(
    ID                   numeric(16) identity
        constraint PK_Solution
            primary key,
    ObjectID             numeric(16),
    SolutionTypeID       numeric(16),
    DebtCaseID           numeric(16),
    PropertyID           numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table DCS.SolutionType
(
    ID                   numeric(16) identity
        constraint PK_SolutionType
            primary key,
    ObjectID             numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table GEN.Storage
(
    ID                   numeric(16) identity
        constraint PK_Storage
            primary key,
    ObjectID             numeric(16),
    Name                 nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table DCS.StrategyType
(
    ID                   numeric(16) identity
        constraint PK_StrategyType
            primary key,
    ObjectID             numeric(16),
    Code                 nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table DCS.DebtCase
(
    ID                           numeric(16) identity
        constraint [PK_DCS.DebtCase]
            primary key,
    ObjectID                     numeric(16)
        constraint FK_DebtCase_Object
            references GEN.Object,
    DebtNr                       nvarchar(50),
    PackageID                    numeric(16),
    MainDebtorID                 numeric(16),
    PhaseID                      nvarchar(200),
    CustomerID                   numeric(16),
    OfficeID                     numeric(16),
    SourceInterfaceType          nvarchar(200),
    SourceID                     nvarchar(200),
    OwnProperty                  nvarchar(200),
    PurchaseDate                 date,
    CutOffDate                   date,
    CloseDate                    date,
    AccountID                    numeric(16)
        constraint FK_DebtCase_Account
            references FIN.Account,
    MainCalculationID            numeric(16)
        constraint FK_DebtCase_Calculation
            references FIN.Calculation,
    StrategyTypeID               numeric(16)
        constraint FK_DebtCase_StrategyType
            references DCS.StrategyType,
    CreationDate                 date not null,
    CreationTime                 time,
    CreationUserName             nvarchar(200),
    LastModifiedDate             date,
    LastModifiedTime             time,
    LastModifiedUserName         nvarchar(200),
    Comments                     nvarchar(max),
    CurrencyCode                 nvarchar(200)
        constraint FK_DebtCase_Code
            references GEN.Code,
    SectionCode                  nvarchar(200)
        constraint FK_DebtCase_Code_02
            references GEN.Code,
    PartyID                      numeric(16)
        constraint FK_DebtCase_Party
            references PRT.Party,
    OriginalCreditorEntityID     numeric(16)
        constraint FK_DebtCase_Entity
            references PRT.Entity,
    DepartmentTypeCode           nvarchar(200)
        constraint FK_DebtCase_Code_03
            references GEN.Code,
    CreditTypeCode               nvarchar(200)
        constraint FK_DebtCase_Code_04
            references GEN.Code,
    BankAccountNumber            nvarchar(200),
    OperatorUserName             nvarchar(200),
    MainStatusCode               nvarchar(200)
        constraint FK_DebtCase_Code_05
            references GEN.Code,
    SubOperatorUserName          nvarchar(200),
    DetailedStatusCode           nvarchar(200)
        constraint FK_DebtCase_Code_06
            references GEN.Code,
    BranchEntityID               numeric(16)
        constraint FK_DebtCase_Code_07
            references PRT.Entity,
    RepaymentBankAccountNr       nvarchar(200),
    CaseTypeCode                 nvarchar(200)
        constraint FK_Object_Code_08
            references GEN.Code,
    LoanGuaranteedCode           nvarchar(200)
        constraint FK_Object_Code_09
            references GEN.Code,
    ConsolidatedProductCode      nvarchar(200)
        constraint FK_DebtCase_Code_08
            references GEN.Code,
    OriginalAccountingSystemCode nvarchar(200)
        constraint FK_DebtCase_Code_09
            references GEN.Code,
    ConstructionCode             nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', N'Task-ot Ă©s DebtCase-t olvasszuk Ă¶ssze', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCase'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Date of purchase', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase', 'COLUMN',
     'PurchaseDate'
go

exec sp_addextendedproperty 'MS_Description', 'Date of cut-off', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase', 'COLUMN',
     'CutOffDate'
go

exec sp_addextendedproperty 'MS_Description', 'Date of task closing', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase', 'COLUMN',
     'CloseDate'
go

exec sp_addextendedproperty 'MS_Description', 'FIN.Account Identifier', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase', 'COLUMN',
     'AccountID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCase', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Debt case currency value set -> CURRENCY', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCase', 'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Debt case section value set -> CASE_SECTION', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCase', 'COLUMN', 'SectionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Party identifier -> PRT.Party', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase',
     'COLUMN', 'PartyID'
go

exec sp_addextendedproperty 'MS_Description', 'Original creditor entity identifier -> PRT.Entity', 'SCHEMA', 'DCS',
     'TABLE', 'DebtCase', 'COLUMN', 'OriginalCreditorEntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Department type -> value set DEPARTMNET_TYPE', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCase', 'COLUMN', 'DepartmentTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Credit type -> value set CREDIT_TYPE', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCase', 'COLUMN', 'CreditTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Operator user identifier -> PRT.AppUser', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCase', 'COLUMN', 'OperatorUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Main status of the case -> value set CASE_MAIN_STATUS', 'SCHEMA', 'DCS',
     'TABLE', 'DebtCase', 'COLUMN', 'MainStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Sub operator user identifier -> PRT.AppUser', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCase', 'COLUMN', 'SubOperatorUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Detailed status -> value set CASE_DETAILED_STATUS', 'SCHEMA', 'DCS',
     'TABLE', 'DebtCase', 'COLUMN', 'DetailedStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Repayment bank account number', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase',
     'COLUMN', 'RepaymentBankAccountNr'
go

exec sp_addextendedproperty 'MS_Description', 'Case type code -> value set CASE_TYPE', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCase', 'COLUMN', 'CaseTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'This case is secured with loan guarantee? -> value set BOOLEAN',
     'SCHEMA', 'DCS', 'TABLE', 'DebtCase', 'COLUMN', 'LoanGuaranteedCode'
go

exec sp_addextendedproperty 'MS_Description', 'Consolidated product code -> value set CONSOLIDATED_PRODUCT', 'SCHEMA',
     'DCS', 'TABLE', 'DebtCase', 'COLUMN', 'ConsolidatedProductCode'
go

exec sp_addextendedproperty 'MS_Description', 'Original accounting system''s code -> value set ACCOUNTING_SYSTEM',
     'SCHEMA', 'DCS', 'TABLE', 'DebtCase', 'COLUMN', 'OriginalAccountingSystemCode'
go

exec sp_addextendedproperty 'MS_Description', 'Construction code value', 'SCHEMA', 'DCS', 'TABLE', 'DebtCase', 'COLUMN',
     'ConstructionCode'
go

create table DCS.Agreement
(
    ID                          numeric(16) identity
        constraint PK_Agreement
            primary key,
    ObjectID                    numeric(16)
        constraint FK_Agreement_Object
            references GEN.Object,
    DebtCaseID                  numeric(16)
        constraint FK_Agreement_DebtCase
            references DCS.DebtCase,
    DebtorOriginalCalculationID numeric(16),
    ValidCalculationID          numeric(16)
        constraint FK_Agreement_Calculation
            references FIN.Calculation,
    CreationDate                date,
    CreationTime                time,
    CreationUserName            nvarchar(200),
    LastModifiedDate            date,
    LastModifiedTime            time,
    LastModifiedUserName        nvarchar(200)
)
go

create index IXFK_Agreement_Calculation
    on DCS.Agreement (ValidCalculationID)
go

create index IXFK_Agreement_DebtCase
    on DCS.Agreement (DebtCaseID)
go

create index IXFK_Agreement_Object
    on DCS.Agreement (ObjectID)
go

create table DCS.AgreementCalculation
(
    ID                   numeric(16) identity
        constraint PK_AgreementCalculation
            primary key,
    ObjectID             numeric(16)
        constraint FK_AgreementCalculation_Object
            references GEN.Object,
    AgreementID          numeric(16)
        constraint FK_AgreementCalculation_Agreement
            references DCS.Agreement,
    CalculationID        numeric(16)
        constraint FK_AgreementCalculation_Calculation
            references FIN.Calculation,
    CalculationTypeCode  nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDated    date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_AgreementCalculation_Agreement
    on DCS.AgreementCalculation (AgreementID)
go

create index IXFK_AgreementCalculation_Calculation
    on DCS.AgreementCalculation (CalculationID)
go

create index IXFK_AgreementCalculation_Object
    on DCS.AgreementCalculation (ObjectID)
go

create table CRM.CollectionContractItem
(
    ID                     numeric(16) identity
        constraint PK_CollectionContractItem
            primary key,
    ObjectID               numeric(16)
        constraint FK_CollectionContractItem_Object
            references GEN.Object,
    ContractItemID         numeric(16)
        constraint FK_CollectionContractItem_ContractItem
            references CRM.ContractItem,
    DebtCaseID             numeric(16)
        constraint FK_CollectionContractItem_DebtCase
            references DCS.DebtCase,
    DebtCapital            money,
    DebtInterest           money,
    DebtCost               money,
    DebtCostLocalCurrency  money,
    DebtTotal              money,
    ConstructionCode       nvarchar(200),
    DebtorName             nvarchar(200),
    PricingMethodID        nvarchar(200),
    BusinessPercent        numeric(10, 2),
    BusinessPrice          money,
    ContractNr             nvarchar(50),
    DecisionNr             varchar(200),
    AccountNr              varchar(200),
    ContractDate           date,
    TerminationDate        date,
    FinancialMilestoneDate date,
    CreationDate           date,
    CreationTime           time,
    CreationUserName       nvarchar(200),
    LastModifiedDate       date,
    LastModifiedTime       time,
    LastModifiedUserName   nvarchar(200),
    CurrencyCode           nvarchar(200)
        constraint FK_CollectionContractItem_Code
            references GEN.Code,
    DebtPenaltyInterest    money,
    LegalActionCode        nvarchar(200)
        constraint FK_CollectionContractItem_Code_02
            references GEN.Code,
    SourceInterfaceType    nvarchar(200),
    SourceID               nvarchar(200),
    DaysPastDue            numeric(10)
)
go

exec sp_addextendedproperty 'MS_Description', 'VALUESET_CURRENCY', 'SCHEMA', 'CRM', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'VALUESET_BOOLEAN', 'SCHEMA', 'CRM', 'TABLE', 'CollectionContractItem',
     'COLUMN', 'LegalActionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'CRM', 'TABLE',
     'CollectionContractItem', 'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier of the collection contract item to be loaded',
     'SCHEMA', 'CRM', 'TABLE', 'CollectionContractItem', 'COLUMN', 'SourceID'
go

create index IXFK_CollectionContractItem_ContractItem
    on CRM.CollectionContractItem (ContractItemID)
go

create index IXFK_CollectionContractItem_DebtCase
    on CRM.CollectionContractItem (DebtCaseID)
go

create index IXFK_CollectionContractItem_Code
    on CRM.CollectionContractItem (CurrencyCode)
go

create index IXFK_CollectionContractItem_Code_02
    on CRM.CollectionContractItem (LegalActionCode)
go

create index IXFK_CollectionContractItem_Object
    on CRM.CollectionContractItem (ObjectID)
go

create index IXFK_DebtCase_Account
    on DCS.DebtCase (AccountID)
go

create index IXFK_DebtCase_Calculation
    on DCS.DebtCase (MainCalculationID)
go

create index IXFK_DebtCase_Debtor
    on DCS.DebtCase (MainDebtorID)
go

create index IXFK_DebtCase_Object
    on DCS.DebtCase (ObjectID)
go

create index IXFK_DebtCase_StrategyType
    on DCS.DebtCase (StrategyTypeID)
go

create index IXFK_DebtCase_Code
    on DCS.DebtCase (CurrencyCode)
go

create index IXFK_DebtCase_Code_02
    on DCS.DebtCase (SectionCode)
go

create index IXFK_DebtCase_Entity
    on DCS.DebtCase (OriginalCreditorEntityID)
go

create index IXFK_DebtCase_Party
    on DCS.DebtCase (PartyID)
go

create index IXFK_DebtCase_Code_03
    on DCS.DebtCase (DepartmentTypeCode)
go

create index IXFK_DebtCase_Code_04
    on DCS.DebtCase (CreditTypeCode)
go

create table AST.DebtCaseAsset
(
    ID                   numeric(16) identity
        constraint PK_DebtCaseAsset
            primary key,
    ObjectID             numeric(16)
        constraint FK_DebtCaseAsset_Object
            references GEN.Object,
    AssetID              numeric(16)
        constraint FK_DebtCaseAsset_Asset
            references AST.Asset,
    DebtCaseID           numeric(16)
        constraint FK_DebtCaseAsset_DebtCase
            references DCS.DebtCase,
    StatusCode           nvarchar(200)
        constraint FK_DebtCaseAsset_Code
            references GEN.Code,
    TypeCode             nvarchar(200)
        constraint FK_DebtCaseAsset_Code_02
            references GEN.Code,
    DecisionNr           nvarchar(200),
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'AST', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Asset identifier -> AST.Asset', 'SCHEMA', 'AST', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'AssetID'
go

exec sp_addextendedproperty 'MS_Description', 'Debt case identifier -> DCS.DebtCase', 'SCHEMA', 'AST', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'DebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', 'Debt case asset status value set -> STATUS', 'SCHEMA', 'AST', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Type of the debt case-asset connection -> ASSET_RELATION_TYPE', 'SCHEMA',
     'AST', 'TABLE', 'DebtCaseAsset', 'COLUMN', 'TypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Decision number', 'SCHEMA', 'AST', 'TABLE', 'DebtCaseAsset', 'COLUMN',
     'DecisionNr'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'AST', 'TABLE', 'DebtCaseAsset', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'ValidUntil', 'SCHEMA', 'AST', 'TABLE', 'DebtCaseAsset', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'AST', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'AST', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'AST', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'AST', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'AST', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'AST', 'TABLE',
     'DebtCaseAsset', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_DebtCaseAsset_Asset
    on AST.DebtCaseAsset (AssetID)
go

create index IXFK_DebtCaseAsset_Code
    on AST.DebtCaseAsset (StatusCode)
go

create index IXFK_DebtCaseAsset_Code_02
    on AST.DebtCaseAsset (TypeCode)
go

create index IXFK_DebtCaseAsset_DebtCase
    on AST.DebtCaseAsset (DebtCaseID)
go

create index IXFK_DebtCaseAsset_Object
    on AST.DebtCaseAsset (ObjectID)
go

create table DCS.DebtCaseProperty
(
    ID                       numeric(16) identity
        constraint [PK_DCS.DebtCaseProperty]
            primary key,
    StatusCode               nvarchar(200),
    AccountablePropertyValue money,
    BeginDate                date,
    EndDate                  date,
    DebtCaseID               numeric(16)
        constraint [FK_DCS.DebtCaseProperty_DCS.DebtCase]
            references DCS.DebtCase,
    PropertyID               numeric(16)
        constraint [FK_DCS.DebtCaseProperty_DCS.Property]
            references DCS.Property,
    StatusID                 numeric(16),
    CreationDate             date not null,
    CreationTime             time,
    CreationUserName         nvarchar(200),
    LastModifiedDate         date,
    LastModifiedTime         time,
    LastModifiedUserName     nvarchar(200),
    Comments                 nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description',
     N'DebtCaseProperty (1 ingatlan A©s 1 ALgy kA¶zA¶tt csak 1 ilyen aktA­v rekord lehet)', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCaseProperty'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'DCS', 'TABLE', 'DebtCaseProperty',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Status of DebtorProperty', 'SCHEMA', 'DCS', 'TABLE', 'DebtCaseProperty',
     'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Accountable Property Value', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCaseProperty', 'COLUMN', 'AccountablePropertyValue'
go

exec sp_addextendedproperty 'MS_Description', 'Valid period begin date', 'SCHEMA', 'DCS', 'TABLE', 'DebtCaseProperty',
     'COLUMN', 'BeginDate'
go

exec sp_addextendedproperty 'MS_Description', 'Valid period end date', 'SCHEMA', 'DCS', 'TABLE', 'DebtCaseProperty',
     'COLUMN', 'EndDate'
go

exec sp_addextendedproperty 'MS_Description', 'DCS.DebtCase Identifier', 'SCHEMA', 'DCS', 'TABLE', 'DebtCaseProperty',
     'COLUMN', 'DebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', 'DCS.Property Identifier', 'SCHEMA', 'DCS', 'TABLE', 'DebtCaseProperty',
     'COLUMN', 'PropertyID'
go

exec sp_addextendedproperty 'MS_Description', 'Status Identifier of DebtorProperty', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCaseProperty', 'COLUMN', 'StatusID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCaseProperty', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCaseProperty', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCaseProperty', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCaseProperty', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCaseProperty', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'DCS', 'TABLE',
     'DebtCaseProperty', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'DCS', 'TABLE', 'DebtCaseProperty', 'COLUMN',
     'Comments'
go

create index [IXFK_DCS.DebtCaseProperty_DCS.DebtCase]
    on DCS.DebtCaseProperty (DebtCaseID)
go

create index [IXFK_DCS.DebtCaseProperty_DCS.Property]
    on DCS.DebtCaseProperty (PropertyID)
go

create table DCS.Debtor
(
    ID                   numeric(16) identity
        constraint [PK_DCS.Debtor]
            primary key,
    RoleCode             nvarchar(200),
    StatusCode           nvarchar(200),
    DebtCaseID           numeric(16)
        constraint [FK_DCS.Debtor_DCS.DebtCase]
            references DCS.DebtCase,
    EntityID             numeric(16)
        constraint [FK_DCS.Debtor_CIS.Entity]
            references PRT.Entity,
    StatusID             numeric(16),
    AccountID            numeric(16)
        constraint FK_Debtor_Account
            references FIN.Account,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    ParentDebtorID       numeric(16)
        constraint FK_Debtor_Debtor
            references DCS.Debtor,
    ObjectID             numeric(16)
        constraint FK_Debtor_Object
            references GEN.Object,
    OperatorUserID       numeric(16),
    ValidFrom            date,
    ValidUntil           date,
    OperatorUserName     nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description',
     N'Debtor.Status -> DebtCase.Status    hogyan hatĂˇrozza meg az adĂłsonkĂ©nti stĂˇtusz az ĂĽgy "fĹ‘" stĂˇtuszĂˇt',
     'SCHEMA', 'DCS', 'TABLE', 'Debtor'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'DCS', 'TABLE', 'Debtor', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Debtor Type', 'SCHEMA', 'DCS', 'TABLE', 'Debtor', 'COLUMN', 'RoleCode'
go

exec sp_addextendedproperty 'MS_Description', 'Status of Debtor', 'SCHEMA', 'DCS', 'TABLE', 'Debtor', 'COLUMN',
     'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'DCS.DebtCase Identifier', 'SCHEMA', 'DCS', 'TABLE', 'Debtor', 'COLUMN',
     'DebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', 'CIS.Entity Identifier', 'SCHEMA', 'DCS', 'TABLE', 'Debtor', 'COLUMN',
     'EntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Status Identifier of Debtor', 'SCHEMA', 'DCS', 'TABLE', 'Debtor',
     'COLUMN', 'StatusID'
go

exec sp_addextendedproperty 'MS_Description', 'FIN.Account Identifier', 'SCHEMA', 'DCS', 'TABLE', 'Debtor', 'COLUMN',
     'AccountID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'DCS', 'TABLE', 'Debtor',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'DCS', 'TABLE', 'Debtor',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'DCS', 'TABLE', 'Debtor',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'Debtor', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'DCS', 'TABLE', 'Debtor',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'DCS', 'TABLE', 'Debtor',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'DCS', 'TABLE', 'Debtor', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'DCS', 'TABLE', 'Debtor',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Operator user identifier -> PRT.AppUser', 'SCHEMA', 'DCS', 'TABLE',
     'Debtor', 'COLUMN', 'OperatorUserID'
go

exec sp_addextendedproperty 'MS_Description', 'Valid From', 'SCHEMA', 'DCS', 'TABLE', 'Debtor', 'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid Until', 'SCHEMA', 'DCS', 'TABLE', 'Debtor', 'COLUMN', 'ValidUntil'
go

alter table DCS.DebtCase
    add constraint FK_DebtCase_Debtor
        foreign key (MainDebtorID) references DCS.Debtor
go

create index [IXFK_DCS.Debtor_CIS.Entity]
    on DCS.Debtor (EntityID)
go

create index [IXFK_DCS.Debtor_DCS.DebtCase]
    on DCS.Debtor (DebtCaseID)
go

create index IXFK_Debtor_Account
    on DCS.Debtor (AccountID)
go

create index IXFK_Debtor_Debtor
    on DCS.Debtor (ParentDebtorID)
go

create index IXFK_Debtor_Object
    on DCS.Debtor (ObjectID)
go

create table DCS.DebtorProperty
(
    ID                   numeric(16) identity
        constraint [PK_DCS.DebtorProperty]
            primary key,
    DebtorID             numeric(16)
        constraint [FK_DCS.DebtorProperty_DCS.Debtor]
            references DCS.Debtor,
    PropertyID           numeric(16)
        constraint [FK_DCS.DebtorProperty_DCS.Property]
            references DCS.Property,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', N'DebtorProperty, PropertyRelation valAlszA­nL±leg marad', 'SCHEMA',
     'DCS', 'TABLE', 'DebtorProperty'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'DCS', 'TABLE', 'DebtorProperty', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'DCS.Debtor Identifier', 'SCHEMA', 'DCS', 'TABLE', 'DebtorProperty',
     'COLUMN', 'DebtorID'
go

exec sp_addextendedproperty 'MS_Description', 'DCS.Property Identifier', 'SCHEMA', 'DCS', 'TABLE', 'DebtorProperty',
     'COLUMN', 'PropertyID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'DCS', 'TABLE', 'DebtorProperty',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'DCS', 'TABLE', 'DebtorProperty',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'DCS', 'TABLE', 'DebtorProperty',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorProperty', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorProperty', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorProperty', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'DCS', 'TABLE', 'DebtorProperty', 'COLUMN',
     'Comments'
go

create index [IXFK_DCS.DebtorProperty_DCS.Debtor]
    on DCS.DebtorProperty (DebtorID)
go

create index [IXFK_DCS.DebtorProperty_DCS.Property]
    on DCS.DebtorProperty (PropertyID)
go

create table DCS.DebtorRelation
(
    ID                   numeric(16) identity
        constraint PK_DebtorRelation
            primary key,
    FromDebtorID         numeric(16)
        constraint FK_DebtorRelation_Debtor
            references DCS.Debtor,
    ToDebtorID           numeric(16)
        constraint FK_DebtorRelation_Debtor_02
            references DCS.Debtor,
    RelationTypeCode     nvarchar(200)
        constraint FK_DebtorRelation_Code_02
            references GEN.Code,
    StatusCode           nvarchar(200)
        constraint FK_DebtorRelation_Code
            references GEN.Code,
    ValidFrom            date,
    ValidUntil           date,
    SourceInterfaceType  nvarchar(200),
    SourceID             nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'DCS', 'TABLE', 'DebtorRelation', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'From part of the relation -> DCS.Debtor', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorRelation', 'COLUMN', 'FromDebtorID'
go

exec sp_addextendedproperty 'MS_Description', 'Topart of the relation -> DCS.Debtor', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorRelation', 'COLUMN', 'ToDebtorID'
go

exec sp_addextendedproperty 'MS_Description', 'Relation type value set -> DEBTOR_RELATION_TYPE', 'SCHEMA', 'DCS',
     'TABLE', 'DebtorRelation', 'COLUMN', 'RelationTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Status value set -> VALUESET_STATUS', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorRelation', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'DCS', 'TABLE', 'DebtorRelation', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'DCS', 'TABLE', 'DebtorRelation', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'DCS', 'TABLE', 'DebtorRelation',
     'COLUMN', 'SourceInterfaceType'
go

exec sp_addextendedproperty 'MS_Description', 'Source identifier (external system)', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorRelation', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorRelation', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorRelation', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorRelation', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorRelation', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorRelation', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'DCS', 'TABLE',
     'DebtorRelation', 'COLUMN', 'LastModifiedUserName'
go

create table GEN.SystemObject
(
    ID                   numeric(16) identity
        constraint PK_SystemObject
            primary key,
    Code                 nvarchar(200)
        constraint FK_SystemObject_Code
            references GEN.Code,
    ParentSystemObjectID numeric(16)
        constraint FK_SystemObject_SystemObject
            references GEN.SystemObject,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ObjectPath           nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> SYSOBJECT', 'SCHEMA', 'GEN', 'TABLE', 'SystemObject',
     'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Parent object -> GEN.SystemObject', 'SCHEMA', 'GEN', 'TABLE',
     'SystemObject', 'COLUMN', 'ParentSystemObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Object path (endpoint, DOM object, etc.)', 'SCHEMA', 'GEN', 'TABLE',
     'SystemObject', 'COLUMN', 'ObjectPath'
go

create table GEN.PortfolioSystemObject
(
    ID                   numeric(16) identity
        constraint PK_PortfolioSystemObject
            primary key,
    SystemObjectID       numeric(16)
        constraint FK_PortfolioSystemObject_SystemObject
            references GEN.SystemObject,
    PortfolioID          numeric(16)
        constraint FK_PortfolioSystemObject_Portfolio
            references GEN.Portfolio,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'PortfolioSystemObject',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'System object identifier -> GEN.SystemObject', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioSystemObject', 'COLUMN', 'SystemObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Portfolio identifier -> GEN.Portfolio', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioSystemObject', 'COLUMN', 'PortfolioID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioSystemObject', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time part of CreationDate', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioSystemObject', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creator user''s identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioSystemObject', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioSystemObject', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'PortfolioSystemObject', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User who changed the data last time -> PRT.AppUser', 'SCHEMA', 'GEN',
     'TABLE', 'PortfolioSystemObject', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_PortfolioSystemObject_Portfolio
    on GEN.PortfolioSystemObject (PortfolioID)
go

create index IXFK_PortfolioSystemObject_SystemObject
    on GEN.PortfolioSystemObject (SystemObjectID)
go

create table GEN.ResponsibilitySystemObject
(
    ID                   numeric(16) identity
        constraint PK_ResponsibilitySystemObject
            primary key,
    ResponsibilityID     numeric(16)
        constraint FK_ResponsibilitySystemObject_Responsibility
            references GEN.Responsibility,
    SystemObjectID       numeric(16)
        constraint FK_ResponsibilitySystemObject_SystemObject
            references GEN.SystemObject,
    PermissionCode       nvarchar(200)
        constraint FK_ResponsibilitySystemObject_Code
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Responsibility (AD group) identifier -> GEN.Responsibility', 'SCHEMA',
     'GEN', 'TABLE', 'ResponsibilitySystemObject', 'COLUMN', 'ResponsibilityID'
go

exec sp_addextendedproperty 'MS_Description', 'System object identifier -> GEN.SystemObject', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObject', 'COLUMN', 'SystemObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Permission. Value set -> PERMISSION', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObject', 'COLUMN', 'PermissionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObject', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time part of CreationDate', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObject', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creator user''s identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObject', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObject', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObject', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User who changed the data last time -> PRT.AppUser', 'SCHEMA', 'GEN',
     'TABLE', 'ResponsibilitySystemObject', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_ResponsibilitySystemObject_Code
    on GEN.ResponsibilitySystemObject (PermissionCode)
go

create index IXFK_ResponsibilitySystemObject_Responsibility
    on GEN.ResponsibilitySystemObject (ResponsibilityID)
go

create index IXFK_ResponsibilitySystemObject_SystemObject
    on GEN.ResponsibilitySystemObject (SystemObjectID)
go

create index IXFK_SystemObject_Code
    on GEN.SystemObject (Code)
go

create index IXFK_SystemObject_SystemObject
    on GEN.SystemObject (ParentSystemObjectID)
go

create table COM.Tag
(
    ID                   numeric(16) not null
        constraint [PK_COM.Tag]
            primary key,
    EventID              numeric(16),
    ObjectID             numeric(16),
    CreationDate         date        not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

create table COM.Task
(
    ID                   numeric(16) not null
        constraint [PK_COM.Task]
            primary key,
    EventID              numeric(16),
    ObjectID             numeric(16),
    CreationDate         date        not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

create table ORG.TaskGroupOperationSet
(
    ID                   numeric(16) identity
        constraint PK_TaskGroupOperationSet
            primary key,
    ObjectID             numeric(16)
        constraint FK_TaskGroupOperationSet_Object
            references GEN.Object,
    Name                 nvarchar(200),
    ScheduleDate         date,
    ScheduleTime         time,
    StatusCode           nvarchar(200)
        constraint FK_TaskGroupOperationSet_Code
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'TaskGroupOperationSet',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSet', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Name of task group operation set', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSet', 'COLUMN', 'Name'
go

exec sp_addextendedproperty 'MS_Description', 'Schedule Date', 'SCHEMA', 'ORG', 'TABLE', 'TaskGroupOperationSet',
     'COLUMN', 'ScheduleDate'
go

exec sp_addextendedproperty 'MS_Description', 'ScheduleTime', 'SCHEMA', 'ORG', 'TABLE', 'TaskGroupOperationSet',
     'COLUMN', 'ScheduleTime'
go

exec sp_addextendedproperty 'MS_Description', 'Status code -> value set TASK_GROUP_OPERATION_SET_STATUS', 'SCHEMA',
     'ORG', 'TABLE', 'TaskGroupOperationSet', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSet', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSet', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSet', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSet', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSet', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSet', 'COLUMN', 'LastModifiedUserName'
go

create table ORG.TaskGroupOperationSetObject
(
    ID                      numeric(16) identity
        constraint PK_TaskGroupOperationSetObject
            primary key,
    ObjectID                numeric(16)
        constraint FK_TaskGroupOperationSetObject_Object
            references GEN.Object,
    TaskGroupOperationSetID numeric(16)
        constraint FK_TaskGroupOperationSetObject_TaskGroupOperationSet
            references ORG.TaskGroupOperationSet,
    RelatedObjectID         numeric(16)
        constraint FK_TaskGroupOperationSetObject_Object_02
            references GEN.Object,
    CreationDate            date,
    CreationTime            time,
    CreationUserName        nvarchar(200),
    LastModifiedDate        date,
    LastModifiedTime        time,
    LastModifiedUserName    nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSetObject', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSetObject', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task group operation set identifier -> ORG.TaskGroupOpertionSet',
     'SCHEMA', 'ORG', 'TABLE', 'TaskGroupOperationSetObject', 'COLUMN', 'TaskGroupOperationSetID'
go

exec sp_addextendedproperty 'MS_Description', 'Related object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSetObject', 'COLUMN', 'RelatedObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSetObject', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSetObject', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSetObject', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSetObject', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationSetObject', 'COLUMN', 'LastModifiedUserName'
go

create table ORG.TaskListType
(
    ID                        nvarchar(200) not null
        constraint PK_TaskListType
            primary key,
    ObjectID                  numeric(16)
        constraint FK_TaskListType_Object
            references GEN.Object,
    LayoutFormID              numeric(16)
        constraint FK_TaskListType_Form
            references MIS.Form,
    StatusCode                nvarchar(200)
        constraint FK_TaskListType_Code
            references GEN.Code,
    ValidFrom                 date,
    ValidUntil                date,
    SelectionRuleDataSourceID numeric(16)
        constraint FK_TaskListType_DataSource
            references GEN.DataSource,
    SubjectDataSourceID       numeric(16)
        constraint FK_TaskListType_DataSource_02
            references GEN.DataSource,
    CreationDate              date,
    CreationTime              time,
    CreationUserName          nvarchar(200),
    LastModifiedDate          date,
    LastModifiedTime          time,
    LastModifiedUserName      nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier based on the TASK_LIST_TYPE', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListType', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListType', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Layout form identifier -> MIS.Form', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListType', 'COLUMN', 'LayoutFormID'
go

exec sp_addextendedproperty 'MS_Description', 'Status code -> value set STATUS', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListType', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid From', 'SCHEMA', 'ORG', 'TABLE', 'TaskListType', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid Until', 'SCHEMA', 'ORG', 'TABLE', 'TaskListType', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Selection rule data source identifier -> GEN.DataSource', 'SCHEMA',
     'ORG', 'TABLE', 'TaskListType', 'COLUMN', 'SelectionRuleDataSourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Subject data source identifier -> GEN.DataSource', 'SCHEMA', 'ORG',
     'TABLE', 'TaskListType', 'COLUMN', 'SubjectDataSourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListType', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListType', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'TaskListType',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListType', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListType', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'TaskListType',
     'COLUMN', 'LastModifiedUserName'
go

create table ORG.TaskList
(
    ID                   numeric(16) identity
        constraint PK_TaskList
            primary key,
    ObjectID             numeric(16)
        constraint FK_TaskList_Object
            references GEN.Object,
    TaskListTypeID       nvarchar(200)
        constraint FK_TaskList_TaskListType
            references ORG.TaskListType,
    StatusCode           nvarchar(200)
        constraint FK_TaskList_Code
            references GEN.Code,
    Subject              nvarchar(250),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'TaskList', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE', 'TaskList',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task list type identifier -> ORG.TaskListType', 'SCHEMA', 'ORG', 'TABLE',
     'TaskList', 'COLUMN', 'TaskListTypeID'
go

exec sp_addextendedproperty 'MS_Description', 'Task list main status code -> TASK_LIST_MAIN_STATUS', 'SCHEMA', 'ORG',
     'TABLE', 'TaskList', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Name of task list', 'SCHEMA', 'ORG', 'TABLE', 'TaskList', 'COLUMN',
     'Subject'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'TaskList',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'TaskList',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'TaskList',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskList', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskList', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'TaskList',
     'COLUMN', 'LastModifiedUserName'
go

create table ORG.TaskListUser
(
    ID                   numeric(16) identity
        constraint PK_TaskListUser
            primary key,
    ObjectID             numeric(16)
        constraint FK_TaskListUser_Object
            references GEN.Object,
    TaskListID           numeric(16)
        constraint FK_TaskListUser_TaskList
            references ORG.TaskList,
    UserName             nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'TaskListUser', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListUser', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task list identifier -> ORG.TaskList', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListUser', 'COLUMN', 'TaskListID'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'TaskListUser',
     'COLUMN', 'UserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListUser', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListUser', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'TaskListUser',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListUser', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskListUser', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'TaskListUser',
     'COLUMN', 'LastModifiedUserName'
go

create table ORG.TaskType
(
    ID                       nvarchar(200) not null
        constraint PK_TaskType
            primary key
        constraint FK_TaskType_Code
            references GEN.Code,
    ObjectID                 numeric(16)
        constraint FK_TaskType_Object
            references GEN.Object,
    DeadlineDayTypeCode      nvarchar(200)
        constraint FK_TaskType_Code_02
            references GEN.Code,
    DeadlineDay              numeric(5),
    StatusCode               nvarchar(200)
        constraint FK_TaskType_Code_03
            references GEN.Code,
    ValidFrom                date,
    ValidUntil               date,
    CreationDate             date,
    CreationTime             time,
    CreationUserName         nvarchar(200),
    LastModifiedDate         date,
    LastModifiedTime         time,
    LastModifiedUserName     nvarchar(200),
    TaskListTypeID           nvarchar(200)
        constraint FK_TaskType_TaskListType
            references ORG.TaskListType,
    UserDataSourceID         numeric(16)
        constraint FK_TaskType_DataSource
            references GEN.DataSource,
    SubjectDataSourceID      numeric(16)
        constraint FK_TaskType_DataSource_02
            references GEN.DataSource,
    PriorityCode             nvarchar(200)
        constraint FK_TaskType_Code_04
            references GEN.Code,
    ReferencedObjectTypeCode nvarchar(200)
        constraint FK_TaskType_ObjectType
            references GEN.ObjectType,
    ResultObjectTypeCode     nvarchar(200)
        constraint FK_TaskType_ObjectType_02
            references GEN.ObjectType
)
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE', 'TaskType',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Deadline day type value set -> VALUESET_DAY_TYPE', 'SCHEMA', 'ORG',
     'TABLE', 'TaskType', 'COLUMN', 'DeadlineDayTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Number of days required to complete a task', 'SCHEMA', 'ORG', 'TABLE',
     'TaskType', 'COLUMN', 'DeadlineDay'
go

exec sp_addextendedproperty 'MS_Description', 'Status value set -> VALUESET_STATUS', 'SCHEMA', 'ORG', 'TABLE',
     'TaskType', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'ORG', 'TABLE', 'TaskType', 'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'ORG', 'TABLE', 'TaskType', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'TaskType',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'TaskType',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskType', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskType', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskType', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskType', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Task list type identifier -> ORG.TaskListType', 'SCHEMA', 'ORG', 'TABLE',
     'TaskType', 'COLUMN', 'TaskListTypeID'
go

exec sp_addextendedproperty 'MS_Description', 'User data source identifier -> GEN.DataSource', 'SCHEMA', 'ORG', 'TABLE',
     'TaskType', 'COLUMN', 'UserDataSourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Subject data source identifier -> GEN.DataSource', 'SCHEMA', 'ORG',
     'TABLE', 'TaskType', 'COLUMN', 'SubjectDataSourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Priority value set -> PRIORITY', 'SCHEMA', 'ORG', 'TABLE', 'TaskType',
     'COLUMN', 'PriorityCode'
go

exec sp_addextendedproperty 'MS_Description', 'Related object type -> GEN.ObjectType', 'SCHEMA', 'ORG', 'TABLE',
     'TaskType', 'COLUMN', 'ReferencedObjectTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Result object type -> GEN.ObjectType', 'SCHEMA', 'ORG', 'TABLE',
     'TaskType', 'COLUMN', 'ResultObjectTypeCode'
go

create table ORG.ProcessDefinitionTask
(
    ID                   numeric(16) identity
        constraint PK_ProcessDefinitionTask
            primary key,
    ObjectID             numeric(16)
        constraint FK_ProcessDefinitionTask_Object
            references GEN.Object,
    ProcessDefinitionID  numeric(16)
        constraint FK_ProcessDefinitionTask_ProcessDefinition
            references ORG.ProcessDefinition,
    TaskTypeID           nvarchar(200)
        constraint FK_ProcessDefinitionTask_TaskType
            references ORG.TaskType,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    TaskTypeCode         nvarchar(200)
        constraint FK_ProcessDefinitionTask_TaskType_02
            references ORG.TaskType,
    ServiceTaskCode      nvarchar(200)
        constraint FK_ProcessDefinitionTask_Code
            references GEN.Code,
    InconsistentCode     nvarchar(200)
        constraint FK_ProcessDefinitionTask_Code_02
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'ProcessDefinitionTask',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTask', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Process identifier -> ORG.ProcessDefinition', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTask', 'COLUMN', 'ProcessDefinitionID'
go

exec sp_addextendedproperty 'MS_Description', 'Task type identifier -> ORG.TaskType', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTask', 'COLUMN', 'TaskTypeID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTask', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTask', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTask', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTask', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTask', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'Task type identifier', 'SCHEMA', 'ORG', 'TABLE', 'ProcessDefinitionTask',
     'COLUMN', 'TaskTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Service task -> value set BOOLEAN', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTask', 'COLUMN', 'ServiceTaskCode'
go

exec sp_addextendedproperty 'MS_Description', 'Inconsistent -> value set BOOLEAN', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionTask', 'COLUMN', 'InconsistentCode'
go

create table ORG.TaskGroupOperationDefinition
(
    ID                   numeric(16) identity
        constraint PK_TaskGroupOperationDefinition
            primary key,
    ObjectID             numeric(16)
        constraint FK_TaskGroupOperationDefinition_Object
            references GEN.Object,
    TaskTypeID           nvarchar(200)
        constraint FK_TaskGroupOperationDefinition_TaskType
            references ORG.TaskType,
    StatusCode           nvarchar(200)
        constraint FK_TaskGroupOperationDefinition_Code
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinition', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinition', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task type identifier -> ORG.TaskType', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinition', 'COLUMN', 'TaskTypeID'
go

exec sp_addextendedproperty 'MS_Description', 'Status code -> value set STATUS', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinition', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinition', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinition', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinition', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinition', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinition', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinition', 'COLUMN', 'LastModifiedUserName'
go

create table ORG.TaskGroupOperation
(
    ID                             numeric(16) identity
        constraint PK_TaskGroupOperation
            primary key,
    ObjectID                       numeric(16)
        constraint FK_TaskGroupOperation_Object
            references GEN.Object,
    TaskGroupOperationSetID        numeric(16)
        constraint FK_TaskGroupOperation_TaskGroupOperationSet
            references ORG.TaskGroupOperationSet,
    TaskGroupOperationDefinitionID numeric(16)
        constraint FK_TaskGroupOperation_TaskGroupOperationDefinition
            references ORG.TaskGroupOperationDefinition,
    SequenceNr                     numeric(5),
    WaitingForTaskGroupOperationID numeric(16)
        constraint FK_TaskGroupOperation_TaskGroupOperation
            references ORG.TaskGroupOperation,
    StatusCode                     nvarchar(200)
        constraint FK_TaskGroupOperation_Code
            references GEN.Code,
    CreationDate                   date,
    CreationTime                   time,
    CreationUserName               nvarchar(200),
    LastModifiedDate               date,
    LastModifiedTime               time,
    LastModifiedUserName           nvarchar(200),
    ScheduleDate                   date,
    ScheduleTime                   time
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'TaskGroupOperation',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperation', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task group operation set identifier -> ORG.TaskGroupOpertionSet',
     'SCHEMA', 'ORG', 'TABLE', 'TaskGroupOperation', 'COLUMN', 'TaskGroupOperationSetID'
go

exec sp_addextendedproperty 'MS_Description',
     'Task group operation definition identifier -> ORG.TaskGroupOperationDefinition', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperation', 'COLUMN', 'TaskGroupOperationDefinitionID'
go

exec sp_addextendedproperty 'MS_Description', 'Sequence number in a operation list', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperation', 'COLUMN', 'SequenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Task group operation identifier -> ORG.TaskGroupOperation', 'SCHEMA',
     'ORG', 'TABLE', 'TaskGroupOperation', 'COLUMN', 'WaitingForTaskGroupOperationID'
go

exec sp_addextendedproperty 'MS_Description', 'Status code -> value set TASK_GROUP_OPERATION_STATUS', 'SCHEMA', 'ORG',
     'TABLE', 'TaskGroupOperation', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperation', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperation', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperation', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperation', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'Schedule Date', 'SCHEMA', 'ORG', 'TABLE', 'TaskGroupOperation', 'COLUMN',
     'ScheduleDate'
go

exec sp_addextendedproperty 'MS_Description', 'Schedule Time', 'SCHEMA', 'ORG', 'TABLE', 'TaskGroupOperation', 'COLUMN',
     'ScheduleTime'
go

create table ORG.Task
(
    ID                       numeric(16) identity
        constraint [PK_GEN.Task]
            primary key,
    ObjectID                 numeric(16)
        constraint FK_Task_Object
            references GEN.Object,
    TaskTypeID               nvarchar(200),
    UserID                   nvarchar(200),
    StatusCode               nvarchar(200),
    DetailsStatusCode        nvarchar(200),
    BeginDate                date,
    BeginTime                time,
    EndDate                  date,
    EndTime                  time,
    DeadlineDate             date,
    DeadlineTime             time,
    Subject                  nvarchar(200),
    ParentTaskID             numeric(16)
        constraint FK_Task_Task
            references ORG.Task,
    Priority                 nvarchar(50),
    ProcessID                numeric(16),
    CreationDate             date not null,
    CreationTime             time,
    CreationUserName         nvarchar(200),
    LastModifiedDate         date,
    LastModifiedTime         time,
    LastModifiedUserName     nvarchar(200),
    Comments                 nvarchar(max),
    ReferencedObjectID       numeric(16)
        constraint FK_GEN_Object
            references GEN.Object,
    TaskListID               numeric(16)
        constraint FK_Task_TaskList
            references ORG.TaskList,
    ReferencedObjectTypeCode nvarchar(200)
        constraint FK_Task_ObjectType
            references GEN.ObjectType,
    PriorityCode             nvarchar(200)
        constraint FK_Task_Code
            references GEN.Code,
    ResultObjectTypeCode     nvarchar(200)
        constraint FK_Task_ObjectType_02
            references GEN.ObjectType,
    ResultObjectID           numeric(16)
        constraint FK_Task_Object_03
            references GEN.Object,
    WaitingForTaskID         numeric(16)
        constraint FK_Task_Task_02
            references ORG.Task,
    ScheduleDate             date,
    ScheduleTime             time,
    ExternalTaskID           nvarchar(200),
    TaskGroupOperationID     numeric(16)
        constraint FK_Task_TaskGroupOperation
            references ORG.TaskGroupOperation,
    ImmediateExecutionCode   nvarchar(200)
        constraint FK_Task_Code_02
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description',
     N'ObjectID (csak 1 objektumra utalhat, ez egy egyszerĹ±sĂ­tĂ©s, de szĂĽksĂ©ges)', 'SCHEMA', 'ORG', 'TABLE', 'Task'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'ORG', 'TABLE', 'Task', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'GEN.Object Identifier', 'SCHEMA', 'ORG', 'TABLE', 'Task', 'COLUMN',
     'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'ORG', 'TABLE', 'Task', 'COLUMN',
     'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'ORG', 'TABLE', 'Task', 'COLUMN',
     'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'ORG', 'TABLE', 'Task', 'COLUMN',
     'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'ORG', 'TABLE', 'Task',
     'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'ORG', 'TABLE', 'Task',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'ORG', 'TABLE', 'Task',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'ORG', 'TABLE', 'Task', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Task list identifier -> ORG.TaskList', 'SCHEMA', 'ORG', 'TABLE', 'Task',
     'COLUMN', 'TaskListID'
go

exec sp_addextendedproperty 'MS_Description', 'Referenced object type code -> GEN.ObjectType', 'SCHEMA', 'ORG', 'TABLE',
     'Task', 'COLUMN', 'ReferencedObjectTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Priority value set -> PRIORITY', 'SCHEMA', 'ORG', 'TABLE', 'Task',
     'COLUMN', 'PriorityCode'
go

exec sp_addextendedproperty 'MS_Description', 'Object type code -> GEN.ObjectType', 'SCHEMA', 'ORG', 'TABLE', 'Task',
     'COLUMN', 'ResultObjectTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Result object identiier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE', 'Task',
     'COLUMN', 'ResultObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Waiting for task identifier -> ORG.Task', 'SCHEMA', 'ORG', 'TABLE',
     'Task', 'COLUMN', 'WaitingForTaskID'
go

exec sp_addextendedproperty 'MS_Description', 'Date to schedule the task', 'SCHEMA', 'ORG', 'TABLE', 'Task', 'COLUMN',
     'ScheduleDate'
go

exec sp_addextendedproperty 'MS_Description', 'Schedule time', 'SCHEMA', 'ORG', 'TABLE', 'Task', 'COLUMN',
     'ScheduleTime'
go

exec sp_addextendedproperty 'MS_Description', 'External task identifier', 'SCHEMA', 'ORG', 'TABLE', 'Task', 'COLUMN',
     'ExternalTaskID'
go

exec sp_addextendedproperty 'MS_Description', 'Task group operation identifier -> ORG.TaskGroupOperation', 'SCHEMA',
     'ORG', 'TABLE', 'Task', 'COLUMN', 'TaskGroupOperationID'
go

exec sp_addextendedproperty 'MS_Description', 'Is immediate execution task? -> value set BOOLEAN', 'SCHEMA', 'ORG',
     'TABLE', 'Task', 'COLUMN', 'ImmediateExecutionCode'
go

create table COM.Alert
(
    ID                   numeric(16) identity
        constraint [PK_COM.Alert]
            primary key,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    TaskID               numeric(16)
        constraint [FK_COM.Alert_COM.Task]
            references ORG.Task,
    Comments             nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'COM', 'TABLE', 'Alert', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'COM', 'TABLE', 'Alert',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'COM', 'TABLE', 'Alert',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'COM', 'TABLE', 'Alert',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'COM', 'TABLE', 'Alert',
     'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'COM', 'TABLE', 'Alert',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'COM', 'TABLE', 'Alert',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'COM.Task Identifier', 'SCHEMA', 'COM', 'TABLE', 'Alert', 'COLUMN',
     'TaskID'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'COM', 'TABLE', 'Alert', 'COLUMN', 'Comments'
go

create index [IXFK_COM.Alert_COM.Task]
    on COM.Alert (TaskID)
go

create table COM.Event
(
    ID                   numeric(16) identity
        constraint [PK_COM.Event]
            primary key,
    ObjectID             numeric(16)
        constraint FK_Event_Object
            references GEN.Object,
    TaskID               numeric(16)
        constraint FK_Event_Task
            references ORG.Task,
    EventDate            date,
    EventTime            time,
    EventTypeCode        nvarchar(200),
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'COM', 'TABLE', 'Event', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Date of the Event', 'SCHEMA', 'COM', 'TABLE', 'Event', 'COLUMN',
     'EventDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time of the Event', 'SCHEMA', 'COM', 'TABLE', 'Event', 'COLUMN',
     'EventTime'
go

exec sp_addextendedproperty 'MS_Description', 'Type of the Event', 'SCHEMA', 'COM', 'TABLE', 'Event', 'COLUMN',
     'EventTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'COM', 'TABLE', 'Event',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'COM', 'TABLE', 'Event',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'COM', 'TABLE', 'Event',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'COM', 'TABLE', 'Event',
     'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'COM', 'TABLE', 'Event',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'COM', 'TABLE', 'Event',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'COM', 'TABLE', 'Event', 'COLUMN', 'Comments'
go

create table ORG.Event
(
    ID                   numeric(16) identity
        constraint PK_Event
            primary key,
    ObjectID             numeric(16)
        constraint FK_Event_Object
            references GEN.Object,
    TaskID               numeric(16)
        constraint FK_Event_Task
            references ORG.Task,
    EventTypeCode        nvarchar(200)
        constraint FK_Event_Code
            references GEN.Code,
    EventResultCode      nvarchar(200)
        constraint FK_Event_Code_02
            references GEN.Code,
    Subject              nvarchar(200),
    Comments             nvarchar(max),
    EventDate            date,
    EventTime            time,
    UserID               nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    RelatedObjectID      numeric(16)
        constraint FK_Event_Object_02
            references GEN.Object,
    UserName             nvarchar(200),
    ProcessCode          nvarchar(200)
        constraint FK_Event_Code_03
            references GEN.Code,
    ProcessID            numeric(16)
        constraint FK_Event_Process
            references ORG.Process
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'Event', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE', 'Event',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task identifier -> ORG.Task', 'SCHEMA', 'ORG', 'TABLE', 'Event',
     'COLUMN', 'TaskID'
go

exec sp_addextendedproperty 'MS_Description', 'Event type value set -> EVENT_TYPE', 'SCHEMA', 'ORG', 'TABLE', 'Event',
     'COLUMN', 'EventTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Event result value set -> EVENT_RESULT', 'SCHEMA', 'ORG', 'TABLE',
     'Event', 'COLUMN', 'EventResultCode'
go

exec sp_addextendedproperty 'MS_Description', 'Subject of event', 'SCHEMA', 'ORG', 'TABLE', 'Event', 'COLUMN', 'Subject'
go

exec sp_addextendedproperty 'MS_Description', 'Comments of the event', 'SCHEMA', 'ORG', 'TABLE', 'Event', 'COLUMN',
     'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the job in the event was done', 'SCHEMA', 'ORG', 'TABLE',
     'Event', 'COLUMN', 'EventDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the job in the event was done', 'SCHEMA', 'ORG', 'TABLE',
     'Event', 'COLUMN', 'EventTime'
go

exec sp_addextendedproperty 'MS_Description', 'User identifier, who has made the job -> PRT.AppUser', 'SCHEMA', 'ORG',
     'TABLE', 'Event', 'COLUMN', 'UserID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'Event',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'Event',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'Event',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE', 'Event',
     'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE', 'Event',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'Event',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Related object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'Event', 'COLUMN', 'RelatedObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'User identifier, who has made the job -> PRT.AppUser', 'SCHEMA', 'ORG',
     'TABLE', 'Event', 'COLUMN', 'UserName'
go

exec sp_addextendedproperty 'MS_Description', 'Process value set -> PROCESS', 'SCHEMA', 'ORG', 'TABLE', 'Event',
     'COLUMN', 'ProcessCode'
go

exec sp_addextendedproperty 'MS_Description', 'Process identifier -> ORG.Process', 'SCHEMA', 'ORG', 'TABLE', 'Event',
     'COLUMN', 'ProcessID'
go

create index IXFK_Event_Code
    on ORG.Event (EventTypeCode)
go

create index IXFK_Event_Object
    on COM.Event (ObjectID)
go

create index IXFK_Event_Code_02
    on ORG.Event (EventResultCode)
go

create index IXFK_Event_Task
    on COM.Event (TaskID)
go

create index IXFK_Event_Object
    on ORG.Event (ObjectID)
go

create index IXFK_Event_Task
    on ORG.Event (TaskID)
go

create table IFC.IndecsInkassoSync
(
    ID                   numeric(16) identity
        constraint PK_IndecsInkassoSync
            primary key,
    SyncDirectionCode    nvarchar(200) not null
        constraint FK_IndecsInkassoSync_Code
            references GEN.Code,
    WebserviceName       nvarchar(250),
    Content              nvarchar(max),
    InterfaceStatusCode  nvarchar(200) not null
        constraint FK_IndecsInkassoSync_Code_02
            references GEN.Code,
    ErrorMessage         nvarchar(max),
    CreationDate         date          not null,
    CreationTime         time          not null,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    TaskID               numeric(16)
        constraint FK_IndecsInkassoSync_Task
            references ORG.Task,
    CorrelationID        nvarchar(200),
    ContentDataID        nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'IndecsInkassoSync',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Sync direction -> SYNC_DIRECTION', 'SCHEMA', 'IFC', 'TABLE',
     'IndecsInkassoSync', 'COLUMN', 'SyncDirectionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Webservice name', 'SCHEMA', 'IFC', 'TABLE', 'IndecsInkassoSync',
     'COLUMN', 'WebserviceName'
go

exec sp_addextendedproperty 'MS_Description', 'Message content', 'SCHEMA', 'IFC', 'TABLE', 'IndecsInkassoSync',
     'COLUMN', 'Content'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'IndecsInkassoSync', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'IndecsInkassoSync', 'COLUMN',
     'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'IndecsInkassoSync', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'IndecsInkassoSync', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'IndecsInkassoSync', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'IndecsInkassoSync', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'IndecsInkassoSync', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'IndecsInkassoSync', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Task identifier -> ORG.Task', 'SCHEMA', 'IFC', 'TABLE',
     'IndecsInkassoSync', 'COLUMN', 'TaskID'
go

exec sp_addextendedproperty 'MS_Description', 'CorrelationID generated by the backend for the webservice communication',
     'SCHEMA', 'IFC', 'TABLE', 'IndecsInkassoSync', 'COLUMN', 'CorrelationID'
go

exec sp_addextendedproperty 'MS_Description',
     'If SyncDirection = ''SYNC_DIRECTION_INDECS'', the received json is stored in the Content field. In this case the value of the ID field read from the received json is separately stored here (debtcaseID or eventID)',
     'SCHEMA', 'IFC', 'TABLE', 'IndecsInkassoSync', 'COLUMN', 'ContentDataID'
go

create table IFC.InkassoSyncReceiveDebt
(
    ID                   numeric(16) identity
        constraint PK_InkassoSyncReceiveDebt
            primary key,
    IndecsInkassoSyncID  numeric(16)   not null
        constraint FK_InkassoSyncReceiveDebt_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    InkDebtTypeCode      nvarchar(200),
    DebtTotal            money,
    InkDebtCurrencyCode  nvarchar(200),
    InterfaceStatusCode  nvarchar(200) not null
        constraint FK_InkassoSyncReceiveDebt_Code
            references GEN.Code,
    ErrorMessage         nvarchar(max),
    CreationDate         date          not null,
    CreationTime         time          not null,
    CreationUserName     nvarchar(200) not null,
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveDebt',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncReceiveDebt', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', N'Tartozás típusa (lásd PenaldealType a táblázat alatt)
Ez úgy lett megoldva, hogy az ECINKDB.SEND_EGYENLEG táblájában az egyes tartozáselemek külön oszlopban szerepelnek:
VT = ENT
VUK = EUK
VKK = EKK
VKO = ENC
VKE = EKE	
VLC = ELC
SUK = SUK
SKK = SKK
SKO = SNC
SKE = SKE
SLC = SLC', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveDebt', 'COLUMN', 'InkDebtTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Tartozás összege', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveDebt',
     'COLUMN', 'DebtTotal'
go

exec sp_addextendedproperty 'MS_Description', N'Tartozás összeg devizája', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebt', 'COLUMN', 'InkDebtCurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncReceiveDebt', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveDebt',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebt', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebt', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebt', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebt', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebt', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebt', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InkassoSyncReceiveDebtCase
(
    ID                            numeric(16) identity
        constraint PK_InkassoSyncReceiveDebtCase
            primary key,
    IndecsInkassoSyncID           numeric(16)   not null
        constraint FK_InkassoSyncReceiveDebtCase_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    DebtCaseID                    numeric(16)   not null,
    DebtCalcDate                  date,
    DebtSumTotal                  money,
    InkCurrencyCode               nvarchar(200),
    DebtCostLocalCurrency         money,
    DebtTotalLocalCurrency        money,
    CreditTypeCode                nvarchar(200),
    DealType                      nvarchar(200),
    BankProduct                   nvarchar(200),
    ConcessionDate                date,
    UrbisAccountNumber            nvarchar(24),
    GDPRDepersonalizationDateTime datetime,
    SectionName                   nvarchar(200),
    PhaseName                     nvarchar(200),
    ActiveAgreement               nvarchar(200),
    OperatorUserName              nvarchar(200),
    OfficeID                      numeric(16),
    InterestSetValidFrom          date,
    NormalInterestRate            numeric(16, 4),
    PenaltyInterestRate           numeric(16, 4),
    CostInterestRate              numeric(16, 4),
    DailyCostMin                  numeric(16, 4),
    DailyCostMax                  numeric(16, 4),
    InterfaceStatusCode           nvarchar(200) not null
        constraint FK_InkassoSyncReceiveDebtCase_Code
            references GEN.Code,
    ErrorMessage                  nvarchar(max),
    CreationDate                  date          not null,
    CreationTime                  time          not null,
    CreationUserName              nvarchar(200) not null,
    LastModifiedDate              date,
    LastModifiedTime              time,
    LastModifiedUserName          nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', N'Egyedi azonosító', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncReceiveDebtCase', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', N'Ügy egyedi azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'DebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', N'Egyenleg dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'DebtCalcDate'
go

exec sp_addextendedproperty 'MS_Description', N'A teljes tartozás összege', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'DebtSumTotal'
go

exec sp_addextendedproperty 'MS_Description', N'Az egyenlegek devizája', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'InkCurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', N'A költségtartozás Forintban', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'DebtCostLocalCurrency'
go

exec sp_addextendedproperty 'MS_Description', N'A teljes tartozás Forintban', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'DebtTotalLocalCurrency'
go

exec sp_addextendedproperty 'MS_Description', N'Hiteltípus', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveDebtCase',
     'COLUMN', 'CreditTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Megbízásos/vásárolt követelés. Jelenleg mindig ''N''.', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncReceiveDebtCase', 'COLUMN', 'DealType'
go

exec sp_addextendedproperty 'MS_Description', N'Terméktípus. Jelenleg mindig Null értéket vesz fel.', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncReceiveDebtCase', 'COLUMN', 'BankProduct'
go

exec sp_addextendedproperty 'MS_Description', N'Engedményezés dátuma.
Ha fordulónap nincs megadva, akkor a megbízásdátum.', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveDebtCase', 'COLUMN',
     'ConcessionDate'
go

exec sp_addextendedproperty 'MS_Description', N'Az ügy Urbisszámlaszáma.', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'UrbisAccountNumber'
go

exec sp_addextendedproperty 'MS_Description', N'Az ügy GDPR törlésének dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'GDPRDepersonalizationDateTime'
go

exec sp_addextendedproperty 'MS_Description', 'Szakasz', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveDebtCase',
     'COLUMN', 'SectionName'
go

exec sp_addextendedproperty 'MS_Description', N'Fázis', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveDebtCase',
     'COLUMN', 'PhaseName'
go

exec sp_addextendedproperty 'MS_Description',
     N'Amennyiben az ügy szerepel a MEGALLAPODAS táblában akkor értéke ’I’ egyébként ’N’. Ez jelenleg nem jó, mert nézni kellene, hogy aktív-e a megállapodás.',
     'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveDebtCase', 'COLUMN', 'ActiveAgreement'
go

exec sp_addextendedproperty 'MS_Description', N'Ügyintéző', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveDebtCase',
     'COLUMN', 'OperatorUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Iroda', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveDebtCase', 'COLUMN',
     'OfficeID'
go

exec sp_addextendedproperty 'MS_Description', N'A kamatláb érvényesség kezdetének dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'InterestSetValidFrom'
go

exec sp_addextendedproperty 'MS_Description', N'Az ügyleti kamatláb értéke', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'NormalInterestRate'
go

exec sp_addextendedproperty 'MS_Description', N'A késedelmi kamatláb értéke', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'PenaltyInterestRate'
go

exec sp_addextendedproperty 'MS_Description', N'A kezelési költség kamatláb értéke', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'CostInterestRate'
go

exec sp_addextendedproperty 'MS_Description', N'Napi kezelési költség összegének minimum értéke', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncReceiveDebtCase', 'COLUMN', 'DailyCostMin'
go

exec sp_addextendedproperty 'MS_Description', N'Napi kezelési költség összegének maximum értéke', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncReceiveDebtCase', 'COLUMN', 'DailyCostMax'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncReceiveDebtCase', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveDebtCase',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveDebtCase', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InkassoSyncReceiveEvent
(
    ID                   numeric(16) identity
        constraint PK_InkassoSyncReceiveEvent
            primary key,
    IndecsInkassoSyncID  numeric(16)   not null
        constraint FK_InkassoSyncReceiveEvent_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    InkEventID           numeric(16),
    Description          nvarchar(max),
    InkDebtCaseID        numeric(16),
    InkEntityID          nvarchar(200),
    InkAssetID           numeric(16),
    InkAddressID         numeric(16),
    InkEventTypeID       numeric(16),
    ArrangeDateTime      datetime,
    InkCreationDateTime  datetime,
    InkCreationUser      nvarchar(200),
    InkArrangeUser       nvarchar(200),
    InterfaceStatusCode  nvarchar(200) not null
        constraint FK_InkassoSyncReceiveEvent_Code
            references GEN.Code,
    ErrorMessage         nvarchar(max),
    CreationDate         date          not null,
    CreationTime         time          not null,
    CreationUserName     nvarchar(200) not null,
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveEvent',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncReceiveEvent', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', N'Inkasszó esemény ID', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'InkEventID'
go

exec sp_addextendedproperty 'MS_Description', N'Szöveges leírás', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveEvent',
     'COLUMN', 'Description'
go

exec sp_addextendedproperty 'MS_Description', N'Ügy egyedi azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'InkDebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', N'Kötelezett egyedi azonosítója (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'InkEntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Fedezet egyedi azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'InkAssetID'
go

exec sp_addextendedproperty 'MS_Description',
     N'A postától visszaérkező küldemény kapcsán érintett címek azonosítóját (KUTCIMID) adjuk itt át.', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncReceiveEvent', 'COLUMN', 'InkAddressID'
go

exec sp_addextendedproperty 'MS_Description', N'Esemény típusa - ESEMENYTIPUS.ESEMENYTIPUSID', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'InkEventTypeID'
go

exec sp_addextendedproperty 'MS_Description', N'Esemény elvégzésének dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'ArrangeDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Esemény rögzítésének dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'InkCreationDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'A rögzítő user ldap userid-ja', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'InkCreationUser'
go

exec sp_addextendedproperty 'MS_Description', N'Az elintéző user ldap userid-ja', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'InkArrangeUser'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncReceiveEvent', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveEvent',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveEvent', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InkassoSyncReceiveTransaction
(
    ID                     numeric(16) identity
        constraint PK_InkassoSyncReceiveTransaction
            primary key,
    IndecsInkassoSyncID    numeric(16)   not null
        constraint FK_InkassoSyncReceiveTransaction_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    InkTransactionID       numeric(16),
    InkEntityID            nvarchar(50),
    AccountingDate         date,
    InkCreationDateTime    datetime,
    InkTransactionTypeCode nvarchar(200),
    InkPretenseCode        nvarchar(200),
    Amount                 money,
    InkCurrencyCode        nvarchar(200),
    AmountDebtCaseCurrency money,
    AmountLocalCurrency    money,
    PartyBankAccountNumber nvarchar(50),
    PartyName              nvarchar(250),
    InterfaceStatusCode    nvarchar(200) not null
        constraint FK_InkassoSyncReceiveTransaction_Code
            references GEN.Code,
    ErrorMessage           nvarchar(max),
    CreationDate           date          not null,
    CreationTime           time          not null,
    CreationUserName       nvarchar(200) not null,
    LastModifiedDate       date,
    LastModifiedTime       time,
    LastModifiedUserName   nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Uniqe identifier', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncReceiveTransaction', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', N'A befizetés belső azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'InkTransactionID'
go

exec sp_addextendedproperty 'MS_Description', N'Melyik kötelezettre érkezett a befizetés.', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'InkEntityID'
go

exec sp_addextendedproperty 'MS_Description', N'A forgalom könyvelésének dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'AccountingDate'
go

exec sp_addextendedproperty 'MS_Description', N'A forgalom rögzítésének dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'InkCreationDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'J: Jóváírás, T: Terhelés, X: Technikai tétel', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'InkTransactionTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Forgalom jogcíme, értékkészlet a táblázat alatt.', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncReceiveTransaction', 'COLUMN', 'InkPretenseCode'
go

exec sp_addextendedproperty 'MS_Description', N'A befizetés összege a befizetés devizájában', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'Amount'
go

exec sp_addextendedproperty 'MS_Description', N'A befizetés devizájának 3 betűs kódja', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'InkCurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', N'A forgalom összeg az ügy devizájában.', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'AmountDebtCaseCurrency'
go

exec sp_addextendedproperty 'MS_Description', N'A forgalom összeg Forintban.', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'AmountLocalCurrency'
go

exec sp_addextendedproperty 'MS_Description', '?', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveTransaction', 'COLUMN',
     'PartyBankAccountNumber'
go

exec sp_addextendedproperty 'MS_Description', '?', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncReceiveTransaction', 'COLUMN',
     'PartyName'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncReceiveTransaction', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncReceiveTransaction', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InkassoSyncSendAddress
(
    ID                        numeric(16) identity
        constraint PK_InkassoSyncSendAddress
            primary key,
    IndecsInkassoSyncID       numeric(16)   not null
        constraint FK_InkassoSyncSendAddress_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    AddressID                 numeric(16),
    EntityID                  numeric(16),
    ExternalEntityID          nvarchar(200),
    StatusCode                nvarchar(200),
    InkStatusCode             nvarchar(200),
    MailingAddressCode        nvarchar(200),
    InkMailingAddressCode     nvarchar(200),
    PostalAddressCode         nvarchar(200),
    InkPostalAddressCode      nvarchar(200),
    ValidFrom                 date,
    UnsuccessfulDeliveryCode  nvarchar(200),
    AddressTypeCode           nvarchar(200),
    InkAddressTypeCode        nvarchar(200),
    CountryText               nvarchar(200),
    CountryCode               nvarchar(200),
    InkCountryCode            nvarchar(200),
    ZipCode                   nvarchar(200),
    Settlement                nvarchar(200),
    PublicPlaceName           nvarchar(200),
    SearchablePublicPlaceName nvarchar(200),
    PublicPlaceTypeCode       nvarchar(200),
    PublicPlaceTypeText       nvarchar(200),
    HouseNr                   nvarchar(200),
    Building                  nvarchar(50),
    Staircase                 nvarchar(10),
    Floor                     nvarchar(10),
    Door                      nvarchar(10),
    Description               nvarchar(max),
    DataCreationUser          nvarchar(200),
    DataCreationDateTime      datetime,
    DataLastModUser           nvarchar(200),
    DataLastModDateTime       datetime,
    ModificationType          nvarchar(200) not null,
    InterfaceStatusCode       nvarchar(200) not null
        constraint FK_InkassoSyncSendAddress_Code
            references GEN.Code,
    ErrorMessage              nvarchar(max),
    CreationDate              date          not null,
    CreationTime              time          not null,
    CreationUserName          nvarchar(200),
    LastModifiedDate          date,
    LastModifiedTime          time,
    LastModifiedUserName      nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAddress',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync  identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendAddress', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', N'A KÜT-beli azonosító', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'AddressID'
go

exec sp_addextendedproperty 'MS_Description', N'Külső kulcs: CEG', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAddress',
     'COLUMN', 'EntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Külső entitás azonosító. Pl. ECOLLECTPARTNERID', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendAddress', 'COLUMN', 'ExternalEntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Aktív a cím? (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', N'Aktív a cím? (Inkasso) I = Igen, N = Nem', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'InkStatusCode'
go

exec sp_addextendedproperty 'MS_Description', N'Ez a default levelezési cím? (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'MailingAddressCode'
go

exec sp_addextendedproperty 'MS_Description', N'Ez a default levelezési cím? (Inkasso) I = Igen, N = Nem', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendAddress', 'COLUMN', 'InkMailingAddressCode'
go

exec sp_addextendedproperty 'MS_Description', N'Postacím flag (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'PostalAddressCode'
go

exec sp_addextendedproperty 'MS_Description', N'Postacím flag (Indecs) I = Igen, N = Nem', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'InkPostalAddressCode'
go

exec sp_addextendedproperty 'MS_Description', N'Mikortól érvényes az adott cím', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', N'történt-e már sikertelen kézbesítés erre a címre?', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendAddress', 'COLUMN', 'UnsuccessfulDeliveryCode'
go

exec sp_addextendedproperty 'MS_Description', N'Címtípus (Indecs)', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAddress',
     'COLUMN', 'AddressTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Címtípus (Inkasso). Külső kulcs: SZOTAR, TIPUS=CIMTIPUS', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendAddress', 'COLUMN', 'InkAddressTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'A címhez tartozó ország neve', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'CountryText'
go

exec sp_addextendedproperty 'MS_Description', N'A címhez tartozó ország kódja (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'CountryCode'
go

exec sp_addextendedproperty 'MS_Description', N'A címhez tartozó ország ISO2 kódja (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'InkCountryCode'
go

exec sp_addextendedproperty 'MS_Description', N'A címhez tartozó irányítószám', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'ZipCode'
go

exec sp_addextendedproperty 'MS_Description', N'A címhez tartozó helység neve', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'Settlement'
go

exec sp_addextendedproperty 'MS_Description',
     N'A címhez tartozó közterület neve (gyakran itt található az utcanév, házszám, emelet, lakásszám, stb. is)',
     'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAddress', 'COLUMN', 'PublicPlaceName'
go

exec sp_addextendedproperty 'MS_Description', N'ékezettelenített utcanév', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'SearchablePublicPlaceName'
go

exec sp_addextendedproperty 'MS_Description', N'A címhez tartozó közterület jellege (kód)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'PublicPlaceTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'A címhez tartozó közterület jellege (magyar név)', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendAddress', 'COLUMN', 'PublicPlaceTypeText'
go

exec sp_addextendedproperty 'MS_Description', N'A címhez tartozó házszám', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'HouseNr'
go

exec sp_addextendedproperty 'MS_Description', N'A címhez tartozó épület', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'Building'
go

exec sp_addextendedproperty 'MS_Description', N'A címhez tartozó emelet', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'Staircase'
go

exec sp_addextendedproperty 'MS_Description', N'A címhez tartozó emelet', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'Floor'
go

exec sp_addextendedproperty 'MS_Description', N'A címhez tartozó ajtó', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'Door'
go

exec sp_addextendedproperty 'MS_Description', N'Megjegyzés', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAddress',
     'COLUMN', 'Description'
go

exec sp_addextendedproperty 'MS_Description', N'Létrehozó azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'DataCreationUser'
go

exec sp_addextendedproperty 'MS_Description', N'Létrehozás dátuma', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAddress',
     'COLUMN', 'DataCreationDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Módosító azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'DataLastModUser'
go

exec sp_addextendedproperty 'MS_Description', N'Utolsó módosítás dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'DataLastModDateTime'
go

exec sp_addextendedproperty 'MS_Description', 'Modification type -> INSERT, UPDATE, DELETE', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'ModificationType'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendAddress', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAddress',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAddress', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InkassoSyncSendAsset
(
    ID                    numeric(16) identity
        constraint PK_InkassoSyncSendAsset
            primary key,
    IndecsInkassoSyncID   numeric(16)
        constraint FK_InkassoSyncSendAsset_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    AssetID               numeric(16) not null,
    LandRegisterReference nvarchar(200),
    TATypeCode            nvarchar(200),
    TASubTypeCode         nvarchar(200),
    ZipCode               nvarchar(200),
    Settlement            nvarchar(200),
    Street                nvarchar(200),
    StatusCode            nvarchar(200),
    InkStatusCode         nvarchar(200),
    LandRegisterCity      nvarchar(100),
    AssetTypeCode         nvarchar(200),
    InkAssetTypeCode      nvarchar(200),
    AssetNatureCode       nvarchar(200),
    InkAssetNatureCode    nvarchar(200),
    Name                  nvarchar(200),
    MarketValue           money,
    EscapeValue           money,
    RealMarketValue       money,
    RealEscapeValue       money,
    LastValuationDate     date,
    PropertySheetNr       nvarchar(100),
    DebtCaseID            numeric(16),
    ExecutionRightNr      nvarchar(100),
    ExecutionRightValue   money,
    ExecutionRightDate    date,
    MortgageRightNr       nvarchar(100),
    MortgageRightDate     date,
    OwnerEntityID         numeric(16),
    ExternalOwnerEntityID nvarchar(200),
    OwnershipValidFrom    date,
    OwnershipPretense     nvarchar(200),
    OwnershipValidUntil   date,
    ShareDividend         numeric(10, 4),
    DataLastModUser       nvarchar(200),
    DataLastModDateTime   datetime,
    DataCreationUser      nvarchar(200),
    DataCreationDateTime  datetime,
    InterfaceStatusCode   nvarchar(200)
        constraint FK_InkassoSyncSendAsset_Code
            references GEN.Code,
    ErrorMessage          nvarchar(max),
    CreationDate          date,
    CreationTime          time,
    CreationUserName      nvarchar(200),
    LastModifiedDate      date,
    LastModifiedTime      time,
    LastModifiedUserName  nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync  identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendAsset', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', N'Fedezet egyedi azonosító', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'AssetID'
go

exec sp_addextendedproperty 'MS_Description', N'Helyrajzi szám – FF13', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'LandRegisterReference'
go

exec sp_addextendedproperty 'MS_Description', N'TA tipus – FF11', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'TATypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'TA jelleg – FF12', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'TASubTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Irányítószám – FF18', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'ZipCode'
go

exec sp_addextendedproperty 'MS_Description', N'Város – FF19', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'Settlement'
go

exec sp_addextendedproperty 'MS_Description', N'Utca – FF20 + Házszám – FF21', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'Street'
go

exec sp_addextendedproperty 'MS_Description', N'Státusz (Indecs)', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', N'Státusz (Inkasso)', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'InkStatusCode'
go

exec sp_addextendedproperty 'MS_Description', N'Helyrajzi szám helység', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'LandRegisterCity'
go

exec sp_addextendedproperty 'MS_Description', N'Ingatlan típusa – FF11 (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'AssetTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Ingatlan típusa – FF11 (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'InkAssetTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Ingatlan jellege – FF12 (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'AssetNatureCode'
go

exec sp_addextendedproperty 'MS_Description', N'Ingatlan jellege – FF12 (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'InkAssetNatureCode'
go

exec sp_addextendedproperty 'MS_Description', N'Megnevezés – FF10', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'Name'
go

exec sp_addextendedproperty 'MS_Description', N'Kihelyezéskori ÉB – FF23', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'MarketValue'
go

exec sp_addextendedproperty 'MS_Description', N'Kihelyezéskori ÉB – FF24', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'EscapeValue'
go

exec sp_addextendedproperty 'MS_Description', N'Új értékbecslés – FF25', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'RealMarketValue'
go

exec sp_addextendedproperty 'MS_Description', N'Új értékbecslés – FF26', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'RealEscapeValue'
go

exec sp_addextendedproperty 'MS_Description', N'Utolsó értékbecslés dátuma – FF27', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'LastValuationDate'
go

exec sp_addextendedproperty 'MS_Description', N'Tulajdoni lap száma', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'PropertySheetNr'
go

exec sp_addextendedproperty 'MS_Description', N'Ügy egyedi azonosító', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'DebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', N'VH bejegyzés száma – FF16', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'ExecutionRightNr'
go

exec sp_addextendedproperty 'MS_Description', N'VH bejegyzés kelte – FF17', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'ExecutionRightDate'
go

exec sp_addextendedproperty 'MS_Description', N'Jelzálog bejegyzés száma – FF14', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'MortgageRightNr'
go

exec sp_addextendedproperty 'MS_Description', N'Jelzálog bejegyzés dátuma – FF15', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'MortgageRightDate'
go

exec sp_addextendedproperty 'MS_Description', N'Tulajdonos egyedi azonosító (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'OwnerEntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Tulajdonos egyedi azonosító (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'ExternalOwnerEntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Szerzés dátuma', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'OwnershipValidFrom'
go

exec sp_addextendedproperty 'MS_Description', N'Szerzés jogcíme ', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'OwnershipPretense'
go

exec sp_addextendedproperty 'MS_Description', N'Megszűnés dátuma', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'OwnershipValidUntil'
go

exec sp_addextendedproperty 'MS_Description', N'Tulajdoni hányad százalék – FF09', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'ShareDividend'
go

exec sp_addextendedproperty 'MS_Description', N'A módosítást végző felhasználó', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'DataLastModUser'
go

exec sp_addextendedproperty 'MS_Description', N'A módosítás dátuma', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'DataLastModDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'A létrehozást végző felhasználó', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'DataCreationUser'
go

exec sp_addextendedproperty 'MS_Description', N'A létrehozás dátuma', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'DataCreationDateTime'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendAsset', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendAsset',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendAsset', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InkassoSyncSendCompany
(
    ID                         numeric(16) identity
        constraint PK_InkassoSyncSendCompany
            primary key,
    IndecsInkassoSyncID        numeric(16)   not null
        constraint FK_InkassoSyncSendCompany_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    CompanyID                  numeric(16)   not null,
    Name                       nvarchar(250),
    ShortName                  nvarchar(250),
    LegalFormCode              nvarchar(200),
    InkLegalFormCode           nvarchar(200),
    ChamberMembershipBeginDate date,
    ShortNameCegkapu           nvarchar(250),
    CompanyFormCode            nvarchar(250),
    InkCompanyFormCode         nvarchar(250),
    Email                      nvarchar(100),
    RegistrationNr             nvarchar(50),
    TaxNr                      nvarchar(20),
    LEICode                    nvarchar(20),
    PartyBankID                nvarchar(30),
    SourceID                   nvarchar(200),
    Crefo                      nvarchar(16),
    GWBCustomerNr              nvarchar(50),
    URBISID                    nvarchar(8),
    DataLastModDateTime        datetime,
    DataLastModUser            nvarchar(200),
    DataCreationUser           nvarchar(200),
    DataCreationDateTime       datetime,
    DataVersionDateTime        datetime,
    DataVersionNr              nvarchar(22),
    ExternalCompanyID          nvarchar(200) not null,
    ModificationType           nvarchar(200) not null,
    InterfaceStatusCode        nvarchar(200) not null
        constraint FK_InkassoSyncSendCompany_Code
            references GEN.Code,
    ErrorMessage               nvarchar(max),
    CreationDate               date          not null,
    CreationTime               time          not null,
    CreationUserName           nvarchar(200),
    LastModifiedDate           date,
    LastModifiedTime           time,
    LastModifiedUserName       nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendCompany',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync  identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendCompany', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', N'PK - ECOLLECT azonosító = CEG.ECOLLECTPARTNERID', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendCompany', 'COLUMN', 'CompanyID'
go

exec sp_addextendedproperty 'MS_Description', N'Cég neve', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendCompany', 'COLUMN',
     'Name'
go

exec sp_addextendedproperty 'MS_Description', N'Cég rövid neve', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendCompany',
     'COLUMN', 'ShortName'
go

exec sp_addextendedproperty 'MS_Description', N'A cég cégformakódja (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'LegalFormCode'
go

exec sp_addextendedproperty 'MS_Description', N'A cég jogi formája (Inkasso).
Külső kulcs: JOGIFORMA', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendCompany', 'COLUMN', 'InkLegalFormCode'
go

exec sp_addextendedproperty 'MS_Description', N'Kamarai tagság kezdete', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'ChamberMembershipBeginDate'
go

exec sp_addextendedproperty 'MS_Description', N'A cég rövid neve a Cégkapu rendszerben', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'ShortNameCegkapu'
go

exec sp_addextendedproperty 'MS_Description', N'A cég cégformakódja (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'CompanyFormCode'
go

exec sp_addextendedproperty 'MS_Description', N'A cég cégformakódja (Inkasso)
Külső kulcs: CEGFORMA', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendCompany', 'COLUMN', 'InkCompanyFormCode'
go

exec sp_addextendedproperty 'MS_Description', N'Email cím', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendCompany',
     'COLUMN', 'Email'
go

exec sp_addextendedproperty 'MS_Description', N'Cégjegyzékszám', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendCompany',
     'COLUMN', 'RegistrationNr'
go

exec sp_addextendedproperty 'MS_Description', N'Adószám', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendCompany', 'COLUMN',
     'TaxNr'
go

exec sp_addextendedproperty 'MS_Description', N'ügyfél banki azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'PartyBankID'
go

exec sp_addextendedproperty 'MS_Description', N'Forrásrendszeri azonosító', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', N'CEGREGISZTER szám', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendCompany',
     'COLUMN', 'Crefo'
go

exec sp_addextendedproperty 'MS_Description', N'Ugyfélszám (GWB)', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendCompany',
     'COLUMN', 'GWBCustomerNr'
go

exec sp_addextendedproperty 'MS_Description', N'A partner URBIS azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'URBISID'
go

exec sp_addextendedproperty 'MS_Description', N'Utolsó módosítás dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'DataLastModDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Melyik user módosította utoljára', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'DataLastModUser'
go

exec sp_addextendedproperty 'MS_Description', N'Mikori a partnerverzió dátuma ? (KÜT)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'DataVersionDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Melyik partnerverzió ez? (KÜT)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'DataVersionNr'
go

exec sp_addextendedproperty 'MS_Description', N'Külső cég azonosító. Pl. ECOLLECTPARTNERID', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'ExternalCompanyID'
go

exec sp_addextendedproperty 'MS_Description', 'Modification type -> INSERT, UPDATE, DELETE', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'ModificationType'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendCompany', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendCompany',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendCompany', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InkassoSyncSendConstructionCode
(
    ID                       numeric(16) identity
        constraint PK_InkassoSyncSendConstructionCode
            primary key,
    IndecsInkassoSyncID      numeric(16)   not null
        constraint FK_InkassoSyncSendConstructionCode_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    ConstructionCode         nvarchar(200) not null
        constraint FK_InkassoSyncSendConstructionCode_ConstructionCode
            references FIN.ConstructionCode (Code),
    Level1                   nvarchar(200),
    Level2                   nvarchar(200),
    Level3                   nvarchar(200),
    Level4                   nvarchar(200),
    Level5                   nvarchar(200),
    Level6                   nvarchar(200),
    Level7                   nvarchar(200),
    ConsolidatedProductCode  nvarchar(200)
        constraint FK_InkassoSyncSendConstructionCode_ConsolidatedProduct
            references FIN.ConsolidatedProduct (Code),
    InkConsolidatedProductID nvarchar(200),
    RbProd                   nvarchar(200),
    IFRSProductCode          nvarchar(200),
    DataCreationUser         nvarchar(200),
    DataCreationDateTime     datetime,
    DataLastModUser          nvarchar(200),
    DataLastModDateTime      datetime,
    CurrencyCode             nvarchar(200)
        constraint FK_InkassoSyncSendConstructionCode_Code
            references GEN.Code,
    InkCurrencyCode          nvarchar(200),
    ModificationType         nvarchar(200) not null,
    InterfaceStatusCode      nvarchar(200) not null
        constraint FK_InkassoSyncSendConstructionCode_Code_02
            references GEN.Code,
    ErrorMessage             nvarchar(max),
    CreationDate             date          not null,
    CreationTime             time          not null,
    CreationUserName         nvarchar(200),
    LastModifiedDate         date,
    LastModifiedTime         time,
    LastModifiedUserName     nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendConstructionCode', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', 'Construction code identifier -> FIN.ConstructionCode', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendConstructionCode', 'COLUMN', 'ConstructionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Level #1 field', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'Level1'
go

exec sp_addextendedproperty 'MS_Description', 'Level #2 field', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'Level2'
go

exec sp_addextendedproperty 'MS_Description', 'Level #3 field', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'Level3'
go

exec sp_addextendedproperty 'MS_Description', 'Level #4 field', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'Level4'
go

exec sp_addextendedproperty 'MS_Description', 'Level #5 field', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'Level5'
go

exec sp_addextendedproperty 'MS_Description', 'Level #6 field', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'Level6'
go

exec sp_addextendedproperty 'MS_Description', 'Level #7 field', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'Level7'
go

exec sp_addextendedproperty 'MS_Description', 'Consolidated productCode (Indecs) --> FIN.ConsolidatedProduct.Code',
     'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendConstructionCode', 'COLUMN', 'ConsolidatedProductCode'
go

exec sp_addextendedproperty 'MS_Description', 'Consolidated product (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'InkConsolidatedProductID'
go

exec sp_addextendedproperty 'MS_Description', 'RbProd', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendConstructionCode',
     'COLUMN', 'RbProd'
go

exec sp_addextendedproperty 'MS_Description', 'IFRS product code', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'IFRSProductCode'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'DataCreationUser'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'DataCreationDateTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'DataLastModUser'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'DataLastModDateTime'
go

exec sp_addextendedproperty 'MS_Description', 'Currency code -> value set CURRENCY', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Currency (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'InkCurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Modification type -> INSERT, UPDATE, DELETE', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'ModificationType'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendConstructionCode', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendConstructionCode', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InkassoSyncSendDebtCase
(
    ID                               numeric(16) identity
        constraint PK_InkassoSyncSendDebtCase
            primary key,
    IndecsInkassoSyncID              numeric(16)   not null
        constraint FK_InkassoSyncSendDebtCase_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    DebtCaseID                       numeric(16),
    OriginalCreditorEntityID         numeric(16),
    ExternalOriginalCreditorEntityID nvarchar(200),
    MainDebtorID                     numeric(16),
    PurchaseDate                     date,
    CurrencyCode                     nvarchar(200),
    InkCurrencyCode                  nvarchar(200),
    PurchasePrice                    money,
    DebtCapital                      money,
    DebtInterest                     money,
    DebtPenaltyInterest              money,
    DebtCost                         money,
    DebtCostLocalCurrency            money,
    AccountNr                        nvarchar(200),
    SubAccountNr                     nvarchar(200),
    URBISAccountNr                   nvarchar(200),
    ContractID                       numeric(16),
    ContractNr                       nvarchar(200),
    PricingID                        nvarchar(200),
    DebtTypeCode                     nvarchar(200),
    DepartmentTypeCode               nvarchar(200),
    InkDepartmentTypeCode            nvarchar(200),
    ContractTypeCode                 nvarchar(200),
    InkContractTypeCode              nvarchar(200),
    ContractSignDate                 date,
    CreditTypeCode                   nvarchar(200),
    InkCreditTypeCode                nvarchar(200),
    DebtorName                       nvarchar(250),
    BalanceDate                      date,
    OfficeID                         numeric(16),
    SourceSystemID                   nvarchar(200),
    NormalInterestRate               numeric(10, 4),
    PenaltyInterestRate              numeric(10, 4),
    CostRate                         numeric(10, 4),
    TerminationDate                  date,
    IssueDate                        date,
    FulfillmentDate                  date,
    RiskPool                         nvarchar(200),
    ProductSegment                   nvarchar(200),
    HousingSaving                    nvarchar(200),
    HousingSavingDefaultStopDate     date,
    HPV                              nvarchar(200),
    CostMin                          money,
    CostMax                          money,
    CreditGuarantee                  nvarchar(200),
    DebtTotal                        money,
    KHR                              nvarchar(200),
    KHRPenaltyDate                   date,
    KHRDunningLetterDate             date,
    KHROmissionDate                  date,
    IncomeTransactionAmount          money,
    KHRContractID                    nvarchar(200),
    ContractDataOriginCode           nvarchar(200),
    InkContractDataOriginCode        nvarchar(200),
    ConsolidatedSource               nvarchar(200),
    ConsolidatedProduct              nvarchar(200),
    ConstructionCode                 nvarchar(200),
    ConsolidatedProductID            nvarchar(200),
    EVQualifyCode                    nvarchar(200),
    EVQualifyGroup                   nvarchar(200),
    Method                           nvarchar(200),
    Level5ID                         nvarchar(200),
    Level7ID                         nvarchar(200),
    ProductCategory                  nvarchar(200),
    CollectorRelatedDebtCaseID       numeric(16),
    CollectorRelatedDebtCaseType     nvarchar(200),
    DebtCaseCreationDateTime         datetime,
    OperatorUserName                 nvarchar(200),
    ModificationType                 nvarchar(200) not null,
    InterfaceStatusCode              nvarchar(200) not null
        constraint FK_InkassoSyncSendDebtCase_Code
            references GEN.Code,
    ErrorMessage                     nvarchar(max),
    CreationDate                     date          not null,
    CreationTime                     time          not null,
    CreationUserName                 nvarchar(200),
    LastModifiedDate                 date,
    LastModifiedTime                 time,
    LastModifiedUserName             nvarchar(200),
    CostMinMaxPeriodTypeCode         nvarchar(200)
        constraint FK_InkassoSyncSendDebtCase_PeriodTypeCode_Code
            references GEN.Code,
    InkSourceSystemID                nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync  identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', N'Ügy egyedi azonosító', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'DebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', N'Engedményező cég egyedi azonosítója (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'OriginalCreditorEntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Engedményező cég egyedi azonosítója (Inkasso)', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'ExternalOriginalCreditorEntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Adós egyedi azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'MainDebtorID'
go

exec sp_addextendedproperty 'MS_Description', N'Megbízás dátuma', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase',
     'COLUMN', 'PurchaseDate'
go

exec sp_addextendedproperty 'MS_Description', N'Ügy devizája – FK14 (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'CurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', N'Ügy devizája – FK14 (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'InkCurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', N'Vételár – F26', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase',
     'COLUMN', 'PurchasePrice'
go

exec sp_addextendedproperty 'MS_Description', N'Vásárolt tőketartozás – FK10', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'DebtCapital'
go

exec sp_addextendedproperty 'MS_Description', N'Vásárolt ügyleti kamattartozás – FK11', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'DebtInterest'
go

exec sp_addextendedproperty 'MS_Description', N'Vásárolt késedelmi kamattartozás – FK12', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'DebtPenaltyInterest'
go

exec sp_addextendedproperty 'MS_Description', N'Vásárolt költségtartozás – FK13', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'DebtCost'
go

exec sp_addextendedproperty 'MS_Description', N'Vásárolt HUF költségtartozás – FK60', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'DebtCostLocalCurrency'
go

exec sp_addextendedproperty 'MS_Description', N'Eredeti bankszámlaszám – FK02', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'AccountNr'
go

exec sp_addextendedproperty 'MS_Description', N'Alszámlaszám – FK03', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'SubAccountNr'
go

exec sp_addextendedproperty 'MS_Description', N'Követelés URBIS számlaszáma (Ha létezik )', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'URBISAccountNr'
go

exec sp_addextendedproperty 'MS_Description',
     N'Szerződés egyedi azonosító (Ha ez Ecollect képez egyedi azonosítót a szerződéshez)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'ContractID'
go

exec sp_addextendedproperty 'MS_Description', N'Szerződésszám az Interfészből – FK05', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'ContractNr'
go

exec sp_addextendedproperty 'MS_Description', N'Árazás azonosító– FK24', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'PricingID'
go

exec sp_addextendedproperty 'MS_Description', N'Lakossái fedezetlen (01), Lakossági fedezetes (02), Vállalati (03)',
     'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'DebtTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Üzletág kód – FK07 (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'DepartmentTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Üzletág kód – FK07 (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'InkDepartmentTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Szerződéstípus (Indecs) – FK28', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'ContractTypeCode'
go

exec sp_addextendedproperty 'MS_Description',
     N'Szerződéstípus (Inkasso). E = engedményezett, B = behajtásra átadott – FK28', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'InkContractTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Szerződés aláírás dátuma – FK30', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'ContractSignDate'
go

exec sp_addextendedproperty 'MS_Description', N'Hiteltípus – FK08 (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'CreditTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Hiteltípus – FK08 (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'InkCreditTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Adós neve', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase',
     'COLUMN', 'DebtorName'
go

exec sp_addextendedproperty 'MS_Description', N'Vásárlás fordulónapja. – FK25', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'BalanceDate'
go

exec sp_addextendedproperty 'MS_Description', N'Fiókkód  – FK01', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase',
     'COLUMN', 'OfficeID'
go

exec sp_addextendedproperty 'MS_Description', N'Forrásrendszer azonosítója – FK04 (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'SourceSystemID'
go

exec sp_addextendedproperty 'MS_Description', N'Ügyleti kamat % – FK16', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'NormalInterestRate'
go

exec sp_addextendedproperty 'MS_Description', N'Késedelmi kamat % – FK17', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'PenaltyInterestRate'
go

exec sp_addextendedproperty 'MS_Description', N'Kezelési költség%  – FK18', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'CostRate'
go

exec sp_addextendedproperty 'MS_Description', N'Felmondás dátuma – FK19 ', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'TerminationDate'
go

exec sp_addextendedproperty 'MS_Description', N'Hitelkihelyezés dátuma – FK20', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'IssueDate'
go

exec sp_addextendedproperty 'MS_Description', N'Késedelembe esés dátuma – FK21 ', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'FulfillmentDate'
go

exec sp_addextendedproperty 'MS_Description', N'Kockázati pool azonosító – FK31', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'RiskPool'
go

exec sp_addextendedproperty 'MS_Description', N'Termékszegmens azonosító, ha az Ecollect ezt meghatározza.', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'ProductSegment'
go

exec sp_addextendedproperty 'MS_Description', N'Speciális felmondott jelző – Késedelmi kamat leállítandó – FK54',
     'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'HousingSaving'
go

exec sp_addextendedproperty 'MS_Description', N'Késedelmi kamat leállításnak dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'HousingSavingDefaultStopDate'
go

exec sp_addextendedproperty 'MS_Description', N'HVP jelző – FK53 ', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase',
     'COLUMN', 'HPV'
go

exec sp_addextendedproperty 'MS_Description', N'Kezelési költség minimuma (1 napra) – FK43', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'CostMin'
go

exec sp_addextendedproperty 'MS_Description', N'Kezelési költség maximuma (1 napra) – FK44', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'CostMax'
go

exec sp_addextendedproperty 'MS_Description', N'Hitelgarancia jelző – FK61', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'CreditGuarantee'
go

exec sp_addextendedproperty 'MS_Description', N'Szerződés összege – FK38', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'DebtTotal'
go

exec sp_addextendedproperty 'MS_Description', N'A BAR-ba felkerülés lehetőségét szerződésben elfogadta – FK39',
     'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'KHR'
go

exec sp_addextendedproperty 'MS_Description', N'Az ügylet 90 napos figyelésének kezdő dátuma – FK40', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'KHRPenaltyDate'
go

exec sp_addextendedproperty 'MS_Description', N'Az ügyfélnek küldött figyelmeztető levél dátuma – FK41', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'KHRDunningLetterDate'
go

exec sp_addextendedproperty 'MS_Description', N'Amikor a forrásrendzser BAR-ba feladta – FK42', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'KHROmissionDate'
go

exec sp_addextendedproperty 'MS_Description', N'Ügyfél által befizetett összeg – FK62', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'IncomeTransactionAmount'
go

exec sp_addextendedproperty 'MS_Description', N'KHR szerződés azonosító – FK63', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'KHRContractID'
go

exec sp_addextendedproperty 'MS_Description', N'Milyen forrásból lett betöltve az ügy (Indecs)', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'ContractDataOriginCode'
go

exec sp_addextendedproperty 'MS_Description',
     N'Milyen forrásból lett betöltve az ügy (Inkasso). I = interfész, E = excel', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'InkContractDataOriginCode'
go

exec sp_addextendedproperty 'MS_Description', N'Konszolidált forrás', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'ConsolidatedSource'
go

exec sp_addextendedproperty 'MS_Description', N'Konszolidált termék', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'ConsolidatedProduct'
go

exec sp_addextendedproperty 'MS_Description', N'Konstrukció – FK55', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'ConstructionCode'
go

exec sp_addextendedproperty 'MS_Description', N'Konszolidált termék azonosító', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'ConsolidatedProductID'
go

exec sp_addextendedproperty 'MS_Description', N'EV minősítés', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase',
     'COLUMN', 'EVQualifyCode'
go

exec sp_addextendedproperty 'MS_Description', N'EV minősítés csoport', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'EVQualifyGroup'
go

exec sp_addextendedproperty 'MS_Description', N'Gyűjtőszámla kapcsolódó ügy.', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'CollectorRelatedDebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', N'Kapcsolódó ügy típusa. (GYGY- gyűjtő, FOGY- főszámla)', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'CollectorRelatedDebtCaseType'
go

exec sp_addextendedproperty 'MS_Description', N'Rögzítés dátuma – a követelés betöltésének dátuma', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'DebtCaseCreationDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Kezelő ügyintéző', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase',
     'COLUMN', 'OperatorUserName'
go

exec sp_addextendedproperty 'MS_Description', N'Amennyiben új rekord létrehozása történik a DCS.DebtCase táblába, akkor ''INSERT'', 
                                               ha meglévő DCS.DebtCase rekord módosítása történik, akkor ''UPDATE'', 
                                               ha meglévő DCS.DebtCase rekord törlése történik, akkor ''DELETE''.',
     'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'ModificationType'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description',
     N'A kezelési költség minimum/maximumának mértékegysége. Ha nem nap, akkor a szinkron során hibát jelzünk. value set -> PERIOD_TYPE',
     'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtCase', 'COLUMN', 'CostMinMaxPeriodTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Forrásrendszer azonosítója – FK04 (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtCase', 'COLUMN', 'InkSourceSystemID'
go

create table IFC.InkassoSyncSendDebtor
(
    ID                   numeric(16) identity
        constraint PK_InkassoSyncSendDebtor
            primary key,
    IndecsInkassoSyncID  numeric(16)   not null
        constraint FK_InkassoSyncSendDebtor_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    DebtorID             numeric(16),
    EntityID             numeric(16),
    ExternalEntityID     nvarchar(200),
    DebtCaseID           numeric(16),
    RoleCode             nvarchar(200),
    InkRoleCode          nvarchar(200),
    StatusCode           nvarchar(200),
    ValidUntil           date,
    DataLastModUser      nvarchar(200),
    DataLastModDateTime  datetime,
    DataCreationUser     nvarchar(200),
    DataCreationDateTime datetime,
    ModificationType     nvarchar(200) not null,
    InterfaceStatusCode  nvarchar(200) not null
        constraint FK_InkassoSyncSendDebtor_Code
            references GEN.Code,
    ErrorMessage         nvarchar(max),
    CreationDate         date          not null,
    CreationTime         time          not null,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtor',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync  identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendDebtor', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', 'INDECS rendszer partymap id', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'DebtorID'
go

exec sp_addextendedproperty 'MS_Description', N'Indecsrendszerazonosító', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'EntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Külső entitás azonosító. Pl. ECOLLECTPARTNERID', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDebtor', 'COLUMN', 'ExternalEntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Külső kulcs: UGY.UGYID', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'DebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', 'RoleCode (Indecs)', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtor',
     'COLUMN', 'RoleCode'
go

exec sp_addextendedproperty 'MS_Description', N'RoleCode (Inkasso). Külső kulcs: KEZESTIPUS.KEZESTIPUSID', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendDebtor', 'COLUMN', 'InkRoleCode'
go

exec sp_addextendedproperty 'MS_Description', N'A kapcsolat aktivitás jelölése értékei: F/T', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', N'A dátum jelöli a kapcsolat inaktivitás kezdetét', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDebtor', 'COLUMN', 'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', N'A módosítást végző felhasználó', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'DataLastModUser'
go

exec sp_addextendedproperty 'MS_Description', N'A módosítás dátuma', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtor',
     'COLUMN', 'DataLastModDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'A létrehozást végző felhasználó', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'DataCreationUser'
go

exec sp_addextendedproperty 'MS_Description', N'A létrehozás dátuma', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtor',
     'COLUMN', 'DataCreationDateTime'
go

exec sp_addextendedproperty 'MS_Description', 'Modification type -> INSERT, UPDATE, DELETE', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'ModificationType'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDebtor', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDebtor',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDebtor', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InkassoSyncSendDocument
(
    ID                       numeric(16) identity
        constraint PK_InkassoSyncSendDocument
            primary key,
    IndecsInkassoSyncID      numeric(16)   not null
        constraint FK_InkassoSyncSendDocument_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    DocumentLastModDateTime  datetime,
    DocumentLastModUserName  nvarchar(200),
    InkModificationTypeCode  nvarchar(100),
    DocumentID               numeric(16),
    DocumentCreationUserName nvarchar(200),
    InkDocumentTypeID        numeric(16),
    InkDocumentID            numeric(16),
    DocumentPath             nvarchar(500),
    Barcode                  nvarchar(100),
    PostalRegNr              nvarchar(100),
    DebtCaseID               numeric(16),
    EntityID                 numeric(16),
    DebtorEntityID           numeric(16),
    DebtorExternalEntityID   nvarchar(200),
    EntityAddressID          numeric(16),
    RelatedDocumentID        numeric(16),
    DocumentCreationDateTime datetime,
    InkDocumentStatusID      numeric(16),
    InkMediaID               numeric(16),
    DocumentMailingDate      date,
    DocumentPrintDate        date,
    InterfaceStatusCode      nvarchar(200) not null
        constraint FK_InkassoSyncSendDocument_Code
            references GEN.Code,
    ErrorMessage             nvarchar(max),
    CreationDate             date          not null,
    CreationTime             time          not null,
    CreationUserName         nvarchar(200),
    LastModifiedDate         date,
    LastModifiedTime         time,
    LastModifiedUserName     nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDocument',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync  identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description',
     N'Amennyiben a SZTORNO (törlés) dátum üres, akkor a MODOSITAS (módosítás) dátumot küldjük.', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'DocumentLastModDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Amennyiben a SZTORNOUSERID
(törlő user) azonosítója üres, akkor a MODOSITO (módosító user) azonosítóját dátumot küldjük.', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'DocumentLastModUserName'
go

exec sp_addextendedproperty 'MS_Description', N'A tranzakció típusa:
I: rögzítés (INSERT)
U: módosítás (UPDATE)
D: törlés (DELETE)', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'InkModificationTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'A dokumentum INDECS-es belső azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'DocumentID'
go

exec sp_addextendedproperty 'MS_Description', N'Rögzítő user azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'DocumentCreationUserName'
go

exec sp_addextendedproperty 'MS_Description', N'Az Inkasszó dokumentumtípus kódja', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'InkDocumentTypeID'
go

exec sp_addextendedproperty 'MS_Description', N'A dokumentum elérési útvonala + a fájlnév + kiterjesztés.', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'DocumentPath'
go

exec sp_addextendedproperty 'MS_Description', N'A központi levelezés során a levélre került ragszám.', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'Barcode'
go

exec sp_addextendedproperty 'MS_Description', '?', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDocument', 'COLUMN',
     'PostalRegNr'
go

exec sp_addextendedproperty 'MS_Description', N'A kapcsolódó ügy azonosítója.', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'DebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', N'A dokumentumhoz kapcsolódó ügyfél KÜT-ös azonosítója.', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'EntityID'
go

exec sp_addextendedproperty 'MS_Description', N'A dokumentumhoz kapcsolódó üzenetváltás címzettjének azonosítója.',
     'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'DebtorEntityID'
go

exec sp_addextendedproperty 'MS_Description',
     N'A dokumentumhoz kapcsolódó ügy adósának (UGY.ADOSCEGID alapján) KÜT-ös azonosítója.', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'DebtorExternalEntityID'
go

exec sp_addextendedproperty 'MS_Description',
     N'A dokumentum kötelezettjéhez (ACTORID) tartozó levélküldési címet kellene ide betölteni, de jelenleg az ügyön megadott alapértelmezett címet töltenénk bele, ami sántít, mert ez nem feltétlen az ACTORID-hoz tartozó cím.',
     'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'EntityAddressID'
go

exec sp_addextendedproperty 'MS_Description', N'A dokumentumhoz kapcsolódó dokumentum azonosítója.
!!!Meg kell ezt majd vizsgálni, mert jelenleg már van egy tábla ahol a dokumentum - dokumentum összerendelések zajlanak, így lehet több kapcsolódó dokumentum is.!!!',
     'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'RelatedDocumentID'
go

exec sp_addextendedproperty 'MS_Description', N'A rögzítés dátuma – YYYY.MM.DD HH24:MI:SS formátumban.', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'DocumentCreationDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'A dokumentum státusza.*', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'InkDocumentStatusID'
go

exec sp_addextendedproperty 'MS_Description', N'Értesítés típusa**', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'InkMediaID'
go

exec sp_addextendedproperty 'MS_Description', N'A dokumentum elküldésének dátuma. – YYYY.MM.DD formátumban.', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'DocumentMailingDate'
go

exec sp_addextendedproperty 'MS_Description', N'Monopost előállítás dátuma – YYYY.MM.DD formátumban.', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'DocumentPrintDate'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendDocument', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendDocument',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendDocument', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InkassoSyncSendEvent
(
    ID                    numeric(16) identity
        constraint PK_InkassoSyncSendEvent
            primary key,
    IndecsInkassoSyncID   numeric(16)   not null
        constraint FK_InkassoSyncSendEvent_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    EventID               numeric(16),
    Description           nvarchar(max),
    DebtCaseID            numeric(16),
    EntityID              numeric(16),
    ExternalEntityID      nvarchar(16),
    AssetID               numeric(16),
    EventTypeCode         nvarchar(200),
    InkEventTypeCode      nvarchar(200),
    ArrangeDateTime       datetime,
    EventCreationDateTime datetime,
    EventCreationUser     nvarchar(200),
    ModificationType      nvarchar(200) not null,
    EventArrangeUser      nvarchar(200),
    InterfaceStatusCode   nvarchar(200) not null
        constraint FK_InkassoSyncSendEvent_Code
            references GEN.Code,
    ErrorMessage          nvarchar(max),
    CreationDate          date          not null,
    CreationTime          time          not null,
    CreationUserName      nvarchar(200),
    LastModifiedDate      date,
    LastModifiedTime      time,
    LastModifiedUserName  nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendEvent',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync  identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendEvent', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', N'Rekord egyedi azonosító', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'EventID'
go

exec sp_addextendedproperty 'MS_Description', N'Szöveges leírás', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendEvent',
     'COLUMN', 'Description'
go

exec sp_addextendedproperty 'MS_Description', N'Ügy egyedi azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'DebtCaseID'
go

exec sp_addextendedproperty 'MS_Description', N'Kötelezett egyedi azonosítója (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'EntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Kötelezett egyedi azonosítója (Inkasso)
Itt a KÜT-ös referenciát (CEG.ECOLLECTPARTNERID-t) kapjuk és abból forgatjuk ki a CEG.CEGID-t', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendEvent', 'COLUMN', 'ExternalEntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Fedezet egyedi azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'AssetID'
go

exec sp_addextendedproperty 'MS_Description', N'Esemény típusa (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'EventTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Esemény típusa (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'InkEventTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Esemény elintézésének dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'ArrangeDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Esemény létrehozás dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'EventCreationDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Az eseményt rögzítő user azonosítója.', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'EventCreationUser'
go

exec sp_addextendedproperty 'MS_Description', N'Amennyiben új rekord létrehozása történik az ORG.Event táblába, akkor ''INSERT'',
                                               ha meglévő ORG.Event rekord módosítása történik, akkor ''UPDATE'', 
                                               ha meglévő ORG.Event rekord törlése történik, akkor ''DELETE''.',
     'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendEvent', 'COLUMN', 'ModificationType'
go

exec sp_addextendedproperty 'MS_Description', N'Az eseményt végrehajtó user azonosítója.', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'EventArrangeUser'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendEvent', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendEvent',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendEvent', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InkassoSyncSendPerson
(
    ID                            numeric(16) identity
        constraint PK_InkassoSyncSendPerson
            primary key,
    IndecsInkassoSyncID           numeric(16)   not null
        constraint FK_InkassoSyncSendPerson_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    PersonID                      numeric(16)   not null,
    Title                         nvarchar(200),
    LastName                      nvarchar(150),
    FirstName                     nvarchar(150),
    InkNationalityCode            nvarchar(200),
    NationalityCode               nvarchar(200),
    InkDeceasedCode               nvarchar(200),
    DeceasedCode                  nvarchar(200),
    DeceasedDate                  date,
    Email                         nvarchar(100),
    MaidenName                    nvarchar(40),
    BirthLastName                 nvarchar(150),
    BirthFirstName                nvarchar(150),
    BirthPlace                    nvarchar(100),
    BirthDate                     date,
    MothersFullName               nvarchar(40),
    MothersLastName               nvarchar(150),
    MothersFirstName              nvarchar(150),
    IDNumber                      nvarchar(20),
    PassportNumber                nvarchar(15),
    LicenseNumber                 nvarchar(15),
    RetiredIDNumber               nvarchar(20),
    LEICode                       nvarchar(20),
    PartyBankID                   nvarchar(30),
    SourceID                      nvarchar(200),
    Crefo                         nvarchar(16),
    GWBCustomerNr                 nvarchar(50),
    URBISID                       nvarchar(8),
    GDPRPreDeleteMarkingDateTime  datetime,
    GDPRPreDeleteDateTime         datetime,
    GDPRDepersonalizationDateTime datetime,
    DataLastModDateTime           datetime,
    DataLastModUser               nvarchar(200),
    DataCreationUser              nvarchar(200),
    DataCreationDateTime          datetime,
    DataVersionDateTime           datetime,
    DataVersionNr                 nvarchar(22),
    ExternalPersonID              nvarchar(200) not null,
    ModificationType              nvarchar(200) not null,
    InterfaceStatusCode           nvarchar(200) not null
        constraint FK_InkassoSyncSendPerson_Code
            references GEN.Code,
    ErrorMessage                  nvarchar(max),
    CreationDate                  date          not null,
    CreationTime                  time          not null,
    CreationUserName              nvarchar(200),
    LastModifiedDate              date,
    LastModifiedTime              time,
    LastModifiedUserName          nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync  identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendPerson', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', 'Person identifier -> PRT.Person', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'PersonID'
go

exec sp_addextendedproperty 'MS_Description', 'Titulus', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson', 'COLUMN',
     'Title'
go

exec sp_addextendedproperty 'MS_Description', N'Viselt vezetéknév', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'LastName'
go

exec sp_addextendedproperty 'MS_Description', N'Viselt keresztnév', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'FirstName'
go

exec sp_addextendedproperty 'MS_Description', N'Állampolgárság (Inkasszó)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'InkNationalityCode'
go

exec sp_addextendedproperty 'MS_Description', N'Állampolgárság (Indecs); Értékkészlet -> NATIONALITY', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendPerson', 'COLUMN', 'NationalityCode'
go

exec sp_addextendedproperty 'MS_Description', N'Elhunyt jelölő (I/N) (Inkasszó)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'InkDeceasedCode'
go

exec sp_addextendedproperty 'MS_Description', N'Elhunyt jelölő (Indecs); Értékkészlet -> BOOLEAN', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendPerson', 'COLUMN', 'DeceasedCode'
go

exec sp_addextendedproperty 'MS_Description', N'Elhalálozás dátuma', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'DeceasedDate'
go

exec sp_addextendedproperty 'MS_Description', N'Email cím', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson', 'COLUMN',
     'Email'
go

exec sp_addextendedproperty 'MS_Description', N'Leánykori név', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'MaidenName'
go

exec sp_addextendedproperty 'MS_Description', N'Születéskori név vezetéknév', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'BirthLastName'
go

exec sp_addextendedproperty 'MS_Description', N'Születéskori név keresztnév', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'BirthFirstName'
go

exec sp_addextendedproperty 'MS_Description', N'Születési hely', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'BirthPlace'
go

exec sp_addextendedproperty 'MS_Description', N'Születési dátum', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'BirthDate'
go

exec sp_addextendedproperty 'MS_Description', 'Anyja neve', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson', 'COLUMN',
     'MothersFullName'
go

exec sp_addextendedproperty 'MS_Description', N'Anyja neve vezetéknév', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'MothersLastName'
go

exec sp_addextendedproperty 'MS_Description', N'Anyja neve keresztnév', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'MothersFirstName'
go

exec sp_addextendedproperty 'MS_Description', N'Személyazonosító irat száma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'IDNumber'
go

exec sp_addextendedproperty 'MS_Description', N'Útlevélszám', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'PassportNumber'
go

exec sp_addextendedproperty 'MS_Description', N'Jogosítvany száma', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'LicenseNumber'
go

exec sp_addextendedproperty 'MS_Description', N'Nyugdíj törzsszám', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'RetiredIDNumber'
go

exec sp_addextendedproperty 'MS_Description', N'ügyfél banki azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'PartyBankID'
go

exec sp_addextendedproperty 'MS_Description', N'Forrásrendszeri azonosító', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'SourceID'
go

exec sp_addextendedproperty 'MS_Description', N'CEGREGISZTER szám', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'Crefo'
go

exec sp_addextendedproperty 'MS_Description', N'Ugyfélszám (GWB)', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'GWBCustomerNr'
go

exec sp_addextendedproperty 'MS_Description', N'A partner URBIS azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'URBISID'
go

exec sp_addextendedproperty 'MS_Description',
     N'Azt a dátumot (YYYY.MM.DD. HH24:MI:SS) jelöli amikor a partnert GDPR előtörölni kell majd.', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendPerson', 'COLUMN', 'GDPRPreDeleteMarkingDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'A GDPR előtörlés dátuma (YYYY.MM.DD. HH24:MI:SS)', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendPerson', 'COLUMN', 'GDPRPreDeleteDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'GDRP elévülés adattörlés dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'GDPRDepersonalizationDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Utolsó módosítás dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'DataLastModDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Melyik user módosította utoljára', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'DataLastModUser'
go

exec sp_addextendedproperty 'MS_Description', N'Mikori a partnerverzió dátuma ? (KÜT)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'DataVersionDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Melyik partnerverzió ez? (KÜT)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'DataVersionNr'
go

exec sp_addextendedproperty 'MS_Description', N'Külső magánszemély azonosító. Pl. ECOLLECTPARTNERID', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendPerson', 'COLUMN', 'ExternalPersonID'
go

exec sp_addextendedproperty 'MS_Description', 'Modification type -> INSERT, UPDATE, DELETE', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'ModificationType'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendPerson', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPerson',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPerson', 'COLUMN', 'LastModifiedUserName'
go

create table IFC.InkassoSyncSendPhone
(
    ID                               numeric(16) identity
        constraint PK_InkassoSyncSendPhone
            primary key,
    IndecsInkassoSyncID              numeric(16)   not null
        constraint FK_InkassoSyncSendPhone_IndecsInkassoSync
            references IFC.IndecsInkassoSync,
    ContactID                        numeric(16),
    EntityID                         numeric(16),
    ExternalEntityID                 nvarchar(200),
    StatusCode                       nvarchar(200),
    InkStatusCode                    nvarchar(200),
    Classification                   nvarchar(200),
    ContactTypeCode                  nvarchar(200),
    InkContactTypeCode               nvarchar(200),
    ValidatedCode                    nvarchar(200),
    Contact                          nvarchar(100),
    CountryCode                      nvarchar(200),
    Prefix                           nvarchar(10),
    Extension                        nvarchar(50),
    DataOriginCode                   nvarchar(200),
    InkDataOriginCode                nvarchar(200),
    ValidFrom                        date,
    Comments                         nvarchar(max),
    MaskingModeCode                  nvarchar(200),
    MaskingDateTime                  datetime,
    ContributionCode                 nvarchar(200),
    ContributionDateTime             datetime,
    ContributionCancellationDateTime datetime,
    DataCreationUser                 nvarchar(200),
    DataCreationDateTime             datetime,
    DataLastModUser                  nvarchar(200),
    DataLastModDateTime              datetime,
    ModificationType                 nvarchar(200) not null,
    InterfaceStatusCode              nvarchar(200) not null
        constraint FK_InkassoSyncSendPhone_Code
            references GEN.Code,
    ErrorMessage                     nvarchar(max),
    CreationDate                     date          not null,
    CreationTime                     time          not null,
    CreationUserName                 nvarchar(200),
    LastModifiedDate                 date,
    LastModifiedTime                 time,
    LastModifiedUserName             nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPhone',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Indecs Inkasso sync  identifier -> IFC.IndecsInkassoSync', 'SCHEMA',
     'IFC', 'TABLE', 'InkassoSyncSendPhone', 'COLUMN', 'IndecsInkassoSyncID'
go

exec sp_addextendedproperty 'MS_Description', N'Küt telefonszám ID', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPhone',
     'COLUMN', 'ContactID'
go

exec sp_addextendedproperty 'MS_Description', N'Külső kulcs: CEG', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPhone',
     'COLUMN', 'EntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Külső entitás azonosító. Pl. ECOLLECTPARTNERID', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendPhone', 'COLUMN', 'ExternalEntityID'
go

exec sp_addextendedproperty 'MS_Description', N'Mi a státusza a telefonszámnak (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', N'Mi a státusza a telefonszámnak (Inkasso). I/N', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendPhone', 'COLUMN', 'InkStatusCode'
go

exec sp_addextendedproperty 'MS_Description', N'A telefonszámok minősítését tartalmazó mező t1-t9', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendPhone', 'COLUMN', 'Classification'
go

exec sp_addextendedproperty 'MS_Description', N'Milyen típusú telefonszám? (kód)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'ContactTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Milyen típusú telefonszám? (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'InkContactTypeCode'
go

exec sp_addextendedproperty 'MS_Description', N'Validált telefonszám-e', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'ValidatedCode'
go

exec sp_addextendedproperty 'MS_Description', N'Telefonszám (egyben)', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPhone',
     'COLUMN', 'Contact'
go

exec sp_addextendedproperty 'MS_Description', N'Melyik országhoz tartozik?', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'CountryCode'
go

exec sp_addextendedproperty 'MS_Description', N'Körzet/mobil előtag', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPhone',
     'COLUMN', 'Prefix'
go

exec sp_addextendedproperty 'MS_Description', N'Mellék', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPhone', 'COLUMN',
     'Extension'
go

exec sp_addextendedproperty 'MS_Description', N'Honnan származik a telefonszám? (Indecs)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'DataOriginCode'
go

exec sp_addextendedproperty 'MS_Description', N'Honnan származik a telefonszám? (Inkasso)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'InkDataOriginCode'
go

exec sp_addextendedproperty 'MS_Description', N'Mikori dátumú a telefonszám?', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', N'Van-e a telefonszámhoz valamilyen egyéb információ?', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendPhone', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', N'Arra találtuk ki, hogy jelöljük melyik maszkoló eljárás hajtotta végre a maszkolást
(1 - GDPR előtörlés, 2 - Jogalap megszűnés). Jelenleg csak a Jogalapváltásos maszkolás tölti.', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendPhone', 'COLUMN', 'MaskingModeCode'
go

exec sp_addextendedproperty 'MS_Description', N'A telefonszám maszkolásának dátuma (YYYY.MM.DD HH24:MI:SS).
Jelenleg csak a Jogalapváltásos maszkolás tölti.', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPhone', 'COLUMN',
     'MaskingDateTime'
go

exec sp_addextendedproperty 'MS_Description',
     N'Annak jelölése, hogy a telefonszám kezeléshez hozzájárul-t a partner (I/N).', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'ContributionCode'
go

exec sp_addextendedproperty 'MS_Description',
     N'A hozzájárulás/hozzájárulás visszavonásának dátuma (YYYY.MM.DD HH24:MI:SS)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'ContributionDateTime'
go

exec sp_addextendedproperty 'MS_Description',
     N'Annak a dátuma amikor a telefonszámot mindenképp törölni kell (YYYY.MM.DD HH24:MI:SS)', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'ContributionCancellationDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Létrehozó azonosítója', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'DataCreationUser'
go

exec sp_addextendedproperty 'MS_Description', N'Létrehozás dátuma', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPhone',
     'COLUMN', 'DataCreationDateTime'
go

exec sp_addextendedproperty 'MS_Description', N'Módosító azonosítója', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPhone',
     'COLUMN', 'DataLastModUser'
go

exec sp_addextendedproperty 'MS_Description', N'Utolsó módosítás dátuma', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'DataLastModDateTime'
go

exec sp_addextendedproperty 'MS_Description', 'Modification type -> INSERT, UPDATE, DELETE', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'ModificationType'
go

exec sp_addextendedproperty 'MS_Description', 'Interface status value set -> INTERFACE_STATUS', 'SCHEMA', 'IFC',
     'TABLE', 'InkassoSyncSendPhone', 'COLUMN', 'InterfaceStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Error message', 'SCHEMA', 'IFC', 'TABLE', 'InkassoSyncSendPhone',
     'COLUMN', 'ErrorMessage'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'IFC', 'TABLE',
     'InkassoSyncSendPhone', 'COLUMN', 'LastModifiedUserName'
go

create table COM.Interaction
(
    ID                   numeric(16) identity
        constraint [PK_COM.Interaction]
            primary key,
    EventID              numeric(16)
        constraint [FK_COM.Interaction_COM.Event]
            references COM.Event,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    DirectionCode        nvarchar(200)
        constraint FK_Interaction_Code
            references GEN.Code,
    ChannelCode          nvarchar(200)
        constraint FK_Interaction_Code_02
            references GEN.Code,
    StatusCode           nvarchar(200)
        constraint FK_Interaction_Code_03
            references GEN.Code,
    LanguageCode         nvarchar(200)
        constraint FK_Interaction_Code_04
            references GEN.Code,
    RegistrationTypeCode nvarchar(200)
        constraint FK_Interaction_Code_05
            references GEN.Code,
    SenderEntityID       numeric(16)
        constraint FK_Interaction_Entity
            references PRT.Entity,
    RecipientEntityID    numeric(16)
        constraint FK_Interaction_Entity_02
            references PRT.Entity,
    Subject              nvarchar(200),
    RegistrationNr       nvarchar(200),
    ExternalReferenceNr  nvarchar(200),
    AnswerRequired       nvarchar(200),
    AnswerInDays         numeric(16),
    InteractionDate      date,
    InteractionTime      time,
    SendingDate          date,
    SendingTime          time,
    DeliveryDate         date,
    DeliveryTime         time,
    DeliveryStatusCode   nvarchar(200),
    SenderName           nvarchar(200),
    SenderAddressID      numeric(16)
        constraint FK_Interaction_Address
            references PRT.Address,
    SenderContactID      numeric(16)
        constraint FK_Interaction_Contact
            references PRT.Contact,
    RecipientName        nvarchar(200),
    RecipientAddressID   numeric(16)
        constraint FK_Interaction_Address_02
            references PRT.Address,
    RecipientContactID   numeric(16)
        constraint FK_Interaction_Contact_02
            references PRT.Contact,
    ObjectID             numeric(16)
        constraint FK_Interaction_Object
            references GEN.Object,
    RelatedObjectID      numeric(16)
        constraint FK_Interaction_Object_02
            references GEN.Object,
    PostalRegistrationNr nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', N'Van mĂˇsik fĂ©l', 'SCHEMA', 'COM', 'TABLE', 'Interaction'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'COM', 'TABLE', 'Interaction', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'COM.Event Identifier', 'SCHEMA', 'COM', 'TABLE', 'Interaction', 'COLUMN',
     'EventID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'COM', 'TABLE',
     'Interaction', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'COM', 'TABLE',
     'Interaction', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'COM', 'TABLE',
     'Interaction', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'COM', 'TABLE', 'Interaction', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> INTERACTION_DIRECTION', 'SCHEMA', 'COM', 'TABLE',
     'Interaction', 'COLUMN', 'DirectionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> CHANNEL', 'SCHEMA', 'COM', 'TABLE', 'Interaction', 'COLUMN',
     'ChannelCode'
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> INTERACTION_STATUS', 'SCHEMA', 'COM', 'TABLE',
     'Interaction', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> LANGUAGE', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'LanguageCode'
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> INTERACTION_REGISTRATION', 'SCHEMA', 'COM', 'TABLE',
     'Interaction', 'COLUMN', 'RegistrationTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Sender entity -> EntityID', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'SenderEntityID'
go

exec sp_addextendedproperty 'MS_Description', 'Subject of the interaction', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'Subject'
go

exec sp_addextendedproperty 'MS_Description', 'Own registration number', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'RegistrationNr'
go

exec sp_addextendedproperty 'MS_Description', 'External reference number', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'ExternalReferenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> BOOLEAN', 'SCHEMA', 'COM', 'TABLE', 'Interaction', 'COLUMN',
     'AnswerRequired'
go

exec sp_addextendedproperty 'MS_Description', 'Answer required in days', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'AnswerInDays'
go

exec sp_addextendedproperty 'MS_Description', 'Technical sending date', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'SendingDate'
go

exec sp_addextendedproperty 'MS_Description', 'Technical sending time', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'SendingTime'
go

exec sp_addextendedproperty 'MS_Description', 'Technical delivery date', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'DeliveryDate'
go

exec sp_addextendedproperty 'MS_Description', 'Technical delivery time', 'SCHEMA', 'COM', 'TABLE', 'Interaction',
     'COLUMN', 'DeliveryTime'
go

exec sp_addextendedproperty 'MS_Description', 'Value set -> INTERACTION_DELIVERY', 'SCHEMA', 'COM', 'TABLE',
     'Interaction', 'COLUMN', 'DeliveryStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Name of the sender at the moment of creating the interaction', 'SCHEMA',
     'COM', 'TABLE', 'Interaction', 'COLUMN', 'SenderName'
go

exec sp_addextendedproperty 'MS_Description', 'Hard copy of the sender address (postal) -> PRT.Address', 'SCHEMA',
     'COM', 'TABLE', 'Interaction', 'COLUMN', 'SenderAddressID'
go

exec sp_addextendedproperty 'MS_Description', 'Hard copy of the sender address (e-mail, phone) -> PRT.Contact',
     'SCHEMA', 'COM', 'TABLE', 'Interaction', 'COLUMN', 'SenderContactID'
go

exec sp_addextendedproperty 'MS_Description', 'Hard copy of the delivery address (postal) -> PRT.Address', 'SCHEMA',
     'COM', 'TABLE', 'Interaction', 'COLUMN', 'RecipientName'
go

exec sp_addextendedproperty 'MS_Description', 'Hard copy of the delivery address (postal) -> PRT.Address', 'SCHEMA',
     'COM', 'TABLE', 'Interaction', 'COLUMN', 'RecipientAddressID'
go

exec sp_addextendedproperty 'MS_Description', 'Hard copy of the delivery address (e-mail, phone) -> PRT.Contact',
     'SCHEMA', 'COM', 'TABLE', 'Interaction', 'COLUMN', 'RecipientContactID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'COM', 'TABLE',
     'Interaction', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Related (main) object identifier -> GEN.Object', 'SCHEMA', 'COM',
     'TABLE', 'Interaction', 'COLUMN', 'RelatedObjectID'
go

exec sp_addextendedproperty 'MS_Description', N'Postal registration number ("ragszám")', 'SCHEMA', 'COM', 'TABLE',
     'Interaction', 'COLUMN', 'PostalRegistrationNr'
go

create index [IXFK_COM.Interaction_COM.Event]
    on COM.Interaction (EventID)
go

create index IXFK_Interaction_Code
    on COM.Interaction (DirectionCode)
go

create index IXFK_Interaction_Code_02
    on COM.Interaction (ChannelCode)
go

create index IXFK_Interaction_Code_03
    on COM.Interaction (StatusCode)
go

create index IXFK_Interaction_Code_04
    on COM.Interaction (LanguageCode)
go

create index IXFK_Interaction_Code_05
    on COM.Interaction (RegistrationTypeCode)
go

create index IXFK_Interaction_Entity
    on COM.Interaction (SenderEntityID)
go

create index IXFK_Interaction_Entity_02
    on COM.Interaction (RecipientEntityID)
go

create index IXFK_Interaction_Address
    on COM.Interaction (SenderAddressID)
go

create index IXFK_Interaction_Address_02
    on COM.Interaction (RecipientAddressID)
go

create index IXFK_Interaction_Contact
    on COM.Interaction (SenderContactID)
go

create index IXFK_Interaction_Contact_02
    on COM.Interaction (RecipientContactID)
go

create table COM.InteractionDocument
(
    ID                        numeric(16) identity
        constraint PK_InteractionDocument
            primary key,
    InteractionID             numeric(16)
        constraint FK_InteractionDocument_Interaction
            references COM.Interaction
            on delete cascade,
    DocumentTemplateID        numeric(16),
    DocumentID                numeric(16)
        constraint FK_InteractionDocument_Document
            references GEN.Document,
    SequenceNr                numeric(16),
    CreationDate              date,
    CreationTime              time,
    CreationUserName          nvarchar(200),
    LastModifiedDate          date,
    LastModifiedTime          time,
    LastModifiedUserName      nvarchar(200),
    DocumentTemplateVariantID numeric(16)
        constraint FK_InteractionDocument_DocumentTemplateVariant
            references GEN.DocumentTemplateVariant
)
go

exec sp_addextendedproperty 'MS_Description', 'Interaction -> COM.Interaction', 'SCHEMA', 'COM', 'TABLE',
     'InteractionDocument', 'COLUMN', 'InteractionID'
go

exec sp_addextendedproperty 'MS_Description', 'Document template -> GEN.DocumentTemplate', 'SCHEMA', 'COM', 'TABLE',
     'InteractionDocument', 'COLUMN', 'DocumentTemplateID'
go

exec sp_addextendedproperty 'MS_Description', 'Document identifier -> GEN.Document', 'SCHEMA', 'COM', 'TABLE',
     'InteractionDocument', 'COLUMN', 'DocumentID'
go

exec sp_addextendedproperty 'MS_Description', 'Display order of the documents', 'SCHEMA', 'COM', 'TABLE',
     'InteractionDocument', 'COLUMN', 'SequenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Document template variant -> GEN.DocumentTemplateVariant', 'SCHEMA',
     'COM', 'TABLE', 'InteractionDocument', 'COLUMN', 'DocumentTemplateVariantID'
go

create index IXFK_InteractionDocument_Document
    on COM.InteractionDocument (DocumentID)
go

create index IXFK_InteractionDocument_DocumentTemplate
    on COM.InteractionDocument (DocumentTemplateID)
go

create index IXFK_InteractionDocument_Interaction
    on COM.InteractionDocument (InteractionID)
go

create table COM.InteractionObject
(
    ID                   numeric(16) identity
        constraint PK_InteractionObject
            primary key,
    ObjectID             numeric(16)
        constraint FK_InteractionObject_Object
            references GEN.Object,

    InteractionID        numeric(16)
        constraint FK_InteractionObject_Interaction
            references COM.Interaction
            on delete cascade,
    RelatedObjectID      numeric(16)
        constraint FK_RelatedObjectID
            references GEN.Object,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_InteractionObject_Interaction
    on COM.InteractionObject (InteractionID)
go

create index IXFK_InteractionObject_Object
    on COM.InteractionObject (ObjectID)
go

create table COM.InteractionProperty
(
    ID                   numeric(16) identity
        constraint PK_InteractionProperty
            primary key,
    InteractionID        numeric(16)
        constraint FK_InteractionProperty_Interaction
            references COM.Interaction
            on delete cascade,
    PropertyCode         nvarchar(200),
    PropertyValue        nvarchar(200),
    PropertyID           numeric(16),
    SequenceNr           numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Interaction -> COM.Interaction', 'SCHEMA', 'COM', 'TABLE',
     'InteractionProperty', 'COLUMN', 'InteractionID'
go

exec sp_addextendedproperty 'MS_Description', 'Property code', 'SCHEMA', 'COM', 'TABLE', 'InteractionProperty',
     'COLUMN', 'PropertyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Property value (if not numeric)', 'SCHEMA', 'COM', 'TABLE',
     'InteractionProperty', 'COLUMN', 'PropertyValue'
go

exec sp_addextendedproperty 'MS_Description', 'Property value (if numeric)', 'SCHEMA', 'COM', 'TABLE',
     'InteractionProperty', 'COLUMN', 'PropertyID'
go

exec sp_addextendedproperty 'MS_Description', 'Sequence number (of the properties)', 'SCHEMA', 'COM', 'TABLE',
     'InteractionProperty', 'COLUMN', 'SequenceNr'
go

create index IXFK_InteractionProperty_Interaction
    on COM.InteractionProperty (InteractionID)
go

create table COM.Journal
(
    ID                   numeric(16) identity
        constraint [PK_COM.Journal]
            primary key,
    EventID              numeric(16)
        constraint [FK_COM.Journal_COM.Event]
            references COM.Event,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', N'Ninics mA?sik fA©l', 'SCHEMA', 'COM', 'TABLE', 'Journal'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'COM', 'TABLE', 'Journal', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'COM.Event Identifier', 'SCHEMA', 'COM', 'TABLE', 'Journal', 'COLUMN',
     'EventID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'COM', 'TABLE', 'Journal',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'COM', 'TABLE', 'Journal',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'COM', 'TABLE', 'Journal',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'COM', 'TABLE',
     'Journal', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'COM', 'TABLE', 'Journal',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'COM', 'TABLE', 'Journal',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'COM', 'TABLE', 'Journal', 'COLUMN', 'Comments'
go

create index [IXFK_COM.Journal_COM.Event]
    on COM.Journal (EventID)
go

create table COM.NotificationSubscriptionInteraction
(
    ID                         numeric(16) identity
        constraint PK_NotificationSubscriptionInteraction
            primary key,
    NotificationSubscriptionID numeric(16)
        constraint FK_NotificationSubscriptionInteraction_NotificationSubscription
            references COM.NotificationSubscription,
    InteractionID              numeric(16)
        constraint FK_NotificationSubscriptionInteraction_Interaction
            references COM.Interaction,
    CreationDate               date,
    CreationTime               time,
    CreationUserName           nvarchar(200),
    LastModifiedDate           date,
    LastModifiedTime           time,
    LastModifiedUserName       nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscriptionInteraction', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Notification subscription -> COM.NotificationSubscription', 'SCHEMA',
     'COM', 'TABLE', 'NotificationSubscriptionInteraction', 'COLUMN', 'NotificationSubscriptionID'
go

exec sp_addextendedproperty 'MS_Description', 'Interaction identifier -> COM.Interaction', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscriptionInteraction', 'COLUMN', 'InteractionID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscriptionInteraction', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscriptionInteraction', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscriptionInteraction', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscriptionInteraction', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscriptionInteraction', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'COM', 'TABLE',
     'NotificationSubscriptionInteraction', 'COLUMN', 'LastModifiedUserName'
go

create table ORG.ObjectEvent
(
    ID                   numeric(16) identity
        constraint PK_ObjectEvent
            primary key,
    ObjectID             numeric(16) not null
        constraint FK_ObjectEvent_Object
            references GEN.Object,
    EventID              numeric(16) not null
        constraint FK_ObjectEvent_Event
            references ORG.Event,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'ObjectEvent', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ObjectEvent', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Event identifier -> ORG.Event', 'SCHEMA', 'ORG', 'TABLE', 'ObjectEvent',
     'COLUMN', 'EventID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'ObjectEvent',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'ObjectEvent',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'ObjectEvent',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ObjectEvent', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ObjectEvent', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'ObjectEvent',
     'COLUMN', 'LastModifiedUserName'
go

create unique index IX_ORG_ObjectEvent_Key
    on ORG.ObjectEvent (ObjectID, EventID)
go

create table ORG.ObjectTask
(
    ID                   numeric(16) identity
        constraint PK_ObjectTask
            primary key,
    ObjectID             numeric(16)
        constraint FK_ObjectTask_Object
            references GEN.Object,
    TaskID               numeric(16)
        constraint FK_ObjectTask_Task
            references ORG.Task,
    ReferencedObjectID   numeric(16)
        constraint FK_ObjectTask_Object_02
            references GEN.Object,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'ObjectTask', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE', 'ObjectTask',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task identifier -> ORG.Task', 'SCHEMA', 'ORG', 'TABLE', 'ObjectTask',
     'COLUMN', 'TaskID'
go

exec sp_addextendedproperty 'MS_Description', 'Referenced object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ObjectTask', 'COLUMN', 'ReferencedObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'ObjectTask',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'ObjectTask',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ObjectTask', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ObjectTask', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ObjectTask', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ObjectTask', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_ObjectTask_Object
    on ORG.ObjectTask (ObjectID)
go

create index IXFK_ObjectTask_Object_02
    on ORG.ObjectTask (ReferencedObjectID)
go

create index IXFK_ObjectTask_Task
    on ORG.ObjectTask (TaskID)
go

create table GEN.Tag
(
    ID                   numeric(16) identity
        constraint [PK_COM.Tag]
            primary key,
    EventID              numeric(16)
        constraint [FK_COM.Tag_COM.Event]
            references COM.Event,
    ObjectID             numeric(16)
        constraint [FK_COM.Tag_GEN.Object]
            references GEN.Object,
    CreationDate         date not null,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Comments             nvarchar(max),
    Label                nvarchar(200),
    ValidFrom            date,
    ValidUntil           date,
    StatusCode           nvarchar(200)
        constraint FK_Tag_Code
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description',
     N'ObjectID (csak 1 objektumra utalhat, ez egy egyszerĹ±sĂ­tĂ©s, de szĂĽksĂ©ges)', 'SCHEMA', 'GEN', 'TABLE', 'Tag'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'GEN', 'TABLE', 'Tag', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'COM.Event Identifier', 'SCHEMA', 'GEN', 'TABLE', 'Tag', 'COLUMN',
     'EventID'
go

exec sp_addextendedproperty 'MS_Description', 'GEN.Object Identifier', 'SCHEMA', 'GEN', 'TABLE', 'Tag', 'COLUMN',
     'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Creation date of the record', 'SCHEMA', 'GEN', 'TABLE', 'Tag', 'COLUMN',
     'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Creation time of the record', 'SCHEMA', 'GEN', 'TABLE', 'Tag', 'COLUMN',
     'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creation user of the record', 'SCHEMA', 'GEN', 'TABLE', 'Tag', 'COLUMN',
     'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Last modification date of the record', 'SCHEMA', 'GEN', 'TABLE', 'Tag',
     'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Last modified time of the record', 'SCHEMA', 'GEN', 'TABLE', 'Tag',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User ID of the last modification', 'SCHEMA', 'GEN', 'TABLE', 'Tag',
     'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Comments', 'SCHEMA', 'GEN', 'TABLE', 'Tag', 'COLUMN', 'Comments'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'GEN', 'TABLE', 'Tag', 'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'GEN', 'TABLE', 'Tag', 'COLUMN', 'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Status code -> value set STATUS', 'SCHEMA', 'GEN', 'TABLE', 'Tag',
     'COLUMN', 'StatusCode'
go

create table GEN.ObjectTag
(
    ID                   numeric(16) identity
        constraint PK_ObjectTag
            primary key,
    ObjectID             numeric(16)
        constraint FK_ObjectTag_Object
            references GEN.Object,
    TagID                numeric(16)
        constraint FK_ObjectTag_Tag
            references GEN.Tag,
    ReferencedObjectID   numeric(16)
        constraint FK_ObjectTag_Object_02
            references GEN.Object,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'ObjectTag', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE', 'ObjectTag',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Tag identifier -> GEN.Tag', 'SCHEMA', 'GEN', 'TABLE', 'ObjectTag',
     'COLUMN', 'TagID'
go

exec sp_addextendedproperty 'MS_Description', 'The object identifier to which the tag belongs -> GEN.Object', 'SCHEMA',
     'GEN', 'TABLE', 'ObjectTag', 'COLUMN', 'ReferencedObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'ObjectTag',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'ObjectTag',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectTag', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectTag', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ObjectTag', 'COLUMN', 'LastModifiedTime'
go

create index IXFK_ObjectTag_Object
    on GEN.ObjectTag (ObjectID)
go

create index IXFK_ObjectTag_Object_02
    on GEN.ObjectTag (ReferencedObjectID)
go

create index IXFK_ObjectTag_Tag
    on GEN.ObjectTag (TagID)
go

create table ORG.ProcessDefinitionSuspensionTag
(
    ID                   numeric(16) identity
        constraint PK_ProcessDefinitionSuspensionTag
            primary key,
    ProcessDefinitionID  numeric(16)
        constraint FK_ProcessDefinitionSuspensionTag_ProcessDefinition
            references ORG.ProcessDefinition,
    TagID                numeric(16)
        constraint FK_ProcessDefinitionSuspensionTag_Tag
            references GEN.Tag,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionSuspensionTag', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Process definition identifier -> ORG.ProcessDefinition', 'SCHEMA', 'ORG',
     'TABLE', 'ProcessDefinitionSuspensionTag', 'COLUMN', 'ProcessDefinitionID'
go

exec sp_addextendedproperty 'MS_Description', 'Tag identifier -> GEN.Tag', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionSuspensionTag', 'COLUMN', 'TagID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionSuspensionTag', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionSuspensionTag', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionSuspensionTag', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionSuspensionTag', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionSuspensionTag', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionSuspensionTag', 'COLUMN', 'LastModifiedUserName'
go

create table GEN.ResponsibilityDisableTag
(
    ID                   numeric(16) identity
        constraint PK_ResponsibilityDisableTag
            primary key,
    ResponsibilityID     numeric(16)
        constraint FK_ResponsibilityDisableTag_Responsibility
            references GEN.Responsibility,
    TagID                numeric(16)
        constraint FK_ResponsibilityDisableTag_Tag
            references GEN.Tag,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_ResponsibilityDisableTag_Responsibility
    on GEN.ResponsibilityDisableTag (ResponsibilityID)
go

create index IXFK_ResponsibilityDisableTag_Tag
    on GEN.ResponsibilityDisableTag (TagID)
go

create table GEN.ResponsibilityEnableTag
(
    ID                   numeric(16) identity
        constraint PK_ResponsibilityEnableTag
            primary key,
    ResponsibilityID     numeric(16)
        constraint FK_ResponsibilityEnableTag_Responsibility
            references GEN.Responsibility,
    TagID                numeric(16)
        constraint FK_ResponsibilityEnableTag_Tag
            references GEN.Tag,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_ResponsibilityEnableTag_Responsibility
    on GEN.ResponsibilityEnableTag (ResponsibilityID)
go

create index IXFK_ResponsibilityEnableTag_Tag
    on GEN.ResponsibilityEnableTag (TagID)
go

create table GEN.ResponsibilityObjectTag
(
    ID                     numeric(16) identity
        constraint PK_ResponsibilityObjectTag
            primary key,
    ResponsibilityObjectID numeric(16)
        constraint FK_ResponsibilityObjectTag_ResponsibilityObject
            references GEN.ResponsibilityObject,
    TagID                  numeric(16)
        constraint FK_ResponsibilityObjectTag_Tag
            references GEN.Tag,
    ResponsibilityCode     nvarchar(200)
        constraint FK_ResponsibilityObjectTag_Code
            references GEN.Code,
    CreationDate           date,
    CreationTime           time,
    CreationUserName       nvarchar(200),
    LastModifiedDate       date,
    LastModifiedTime       time,
    LastModifiedUserName   nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'ResponsibilityObjectTag',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Responsibility object identifier -> GEN.ResponsibilityObject', 'SCHEMA',
     'GEN', 'TABLE', 'ResponsibilityObjectTag', 'COLUMN', 'ResponsibilityObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Tag identifier -> GEN.Tag', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityObjectTag', 'COLUMN', 'TagID'
go

exec sp_addextendedproperty 'MS_Description', 'Responsibility value set -> RESPONSIBILITY', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityObjectTag', 'COLUMN', 'ResponsibilityCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityObjectTag', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityObjectTag', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityObjectTag', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityObjectTag', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityObjectTag', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilityObjectTag', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_ResponsibilityObjectTag_Code
    on GEN.ResponsibilityObjectTag (ResponsibilityCode)
go

create index IXFK_ResponsibilityObjectTag_ResponsibilityObject
    on GEN.ResponsibilityObjectTag (ResponsibilityObjectID)
go

create index IXFK_ResponsibilityObjectTag_Tag
    on GEN.ResponsibilityObjectTag (TagID)
go

create table GEN.ResponsibilitySystemObjectTag
(
    ID                           numeric(16) identity
        constraint PK_ResponsibilitySystemObjectTag
            primary key,
    ResponsibilitySystemObjectID numeric(16)
        constraint FK_ResponsibilitySystemObjectTag_ResponsibilitySystemObject
            references GEN.ResponsibilitySystemObject,
    TagID                        numeric(16)
        constraint FK_ResponsibilitySystemObjectTag_Tag
            references GEN.Tag,
    PermissionCode               nvarchar(200)
        constraint FK_ResponsibilitySystemObjectTag_Code
            references GEN.Code,
    CreationDate                 date,
    CreationTime                 time,
    CreationUserName             nvarchar(200),
    LastModifiedDate             date,
    LastModifiedTime             time,
    LastModifiedUserName         nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObjectTag', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Responsibility object identifier -> GEN.ResponsibilityObject', 'SCHEMA',
     'GEN', 'TABLE', 'ResponsibilitySystemObjectTag', 'COLUMN', 'ResponsibilitySystemObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Tag identifier -> GEN.Tag', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObjectTag', 'COLUMN', 'TagID'
go

exec sp_addextendedproperty 'MS_Description', 'Permission value set -> PERMISSION', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObjectTag', 'COLUMN', 'PermissionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObjectTag', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObjectTag', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObjectTag', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObjectTag', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObjectTag', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'ResponsibilitySystemObjectTag', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_ResponsibilitySystemObjectTag_Code
    on GEN.ResponsibilitySystemObjectTag (PermissionCode)
go

create index IXFK_ResponsibilitySystemObjectTag_ResponsibilitySystemObject
    on GEN.ResponsibilitySystemObjectTag (ResponsibilitySystemObjectID)
go

create index IXFK_ResponsibilitySystemObjectTag_Tag
    on GEN.ResponsibilitySystemObjectTag (TagID)
go

create index [IXFK_COM.Tag_COM.Event]
    on GEN.Tag (EventID)
go

create index [IXFK_COM.Tag_GEN.Object]
    on GEN.Tag (ObjectID)
go

create index IXFK_Task_Object
    on ORG.Task (ObjectID)
go

create index IXFK_Task_Task
    on ORG.Task (ParentTaskID)
go

create table ORG.TaskAction
(
    ID                   numeric(16) identity
        constraint PK_TaskAction
            primary key,
    ObjectID             numeric(16)
        constraint FK_TaskAction_Object
            references GEN.Object,
    TaskID               numeric(16)
        constraint FK_TaskAction_Task
            references ORG.Task,
    ActionID             numeric(16)
        constraint FK_TaskAction_Action
            references ORG.Action,
    TaskStatusCode       nvarchar(200)
        constraint FK_TaskAction_Code
            references GEN.Code,
    SequenceNr           numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'TaskAction', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE', 'TaskAction',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task identifier -> ORG.Task', 'SCHEMA', 'ORG', 'TABLE', 'TaskAction',
     'COLUMN', 'TaskID'
go

exec sp_addextendedproperty 'MS_Description', 'Action identifier -> ORG.Action', 'SCHEMA', 'ORG', 'TABLE', 'TaskAction',
     'COLUMN', 'ActionID'
go

exec sp_addextendedproperty 'MS_Description', 'Task status code value set -> TASK_TYPE_STATUS', 'SCHEMA', 'ORG',
     'TABLE', 'TaskAction', 'COLUMN', 'TaskStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Listing position of the action', 'SCHEMA', 'ORG', 'TABLE', 'TaskAction',
     'COLUMN', 'SequenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'TaskAction',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE', 'TaskAction',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskAction', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskAction', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskAction', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskAction', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_TaskAction_Action
    on ORG.TaskAction (ActionID)
go

create index IXFK_TaskAction_Code
    on ORG.TaskAction (TaskStatusCode)
go

create index IXFK_TaskAction_Object
    on ORG.TaskAction (ObjectID)
go

create index IXFK_TaskAction_Task
    on ORG.TaskAction (TaskID)
go

create table ORG.TaskGroupOperationDefinitionParameter
(
    ID                             numeric(16) identity
        constraint PK_TaskGroupOperationDefinitionParameter
            primary key,
    ObjectID                       numeric(16)
        constraint FK_TaskGroupOperationDefinitionParameter_Object
            references GEN.Object,
    TaskGroupOperationDefinitionID numeric(16)
        constraint FK_TaskGroupOperationDefinitionParameter_TaskGroupOperationDefinition
            references ORG.TaskGroupOperationDefinition,
    ParameterCode                  nvarchar(200)
        constraint FK_TaskGroupOperationDefinitionParameter_Code
            references GEN.Code,
    CreationDate                   date,
    CreationTime                   time,
    CreationUserName               nvarchar(200),
    LastModifiedDate               date,
    LastModifiedTime               time,
    LastModifiedUserName           nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinitionParameter', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinitionParameter', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description',
     'Task group operation definition identifier -> ORG.TaskGroupOperationDefinition', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinitionParameter', 'COLUMN', 'TaskGroupOperationDefinitionID'
go

exec sp_addextendedproperty 'MS_Description', 'Parameter code -> value set MODULE_PARAMETER', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinitionParameter', 'COLUMN', 'ParameterCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinitionParameter', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinitionParameter', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinitionParameter', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinitionParameter', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinitionParameter', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationDefinitionParameter', 'COLUMN', 'LastModifiedUserName'
go

create table ORG.TaskGroupOperationParameter
(
    ID                   numeric(16) identity
        constraint PK_TaskGroupOperationParameter
            primary key,
    ObjectID             numeric(16)
        constraint FK_TaskGroupOperationParameter_Object
            references GEN.Object,
    TaskGroupOperationID numeric(16)
        constraint FK_TaskGroupOperationParameter_TaskGroupOperation
            references ORG.TaskGroupOperation,
    ParameterCode        nvarchar(200)
        constraint FK_TaskGroupOperationParameter_Code
            references GEN.Code,
    ParameterValue       nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationParameter', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationParameter', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task group operation identifier -> ORG.TaskGroupOperation', 'SCHEMA',
     'ORG', 'TABLE', 'TaskGroupOperationParameter', 'COLUMN', 'TaskGroupOperationID'
go

exec sp_addextendedproperty 'MS_Description', 'Parameter code -> value set MODULE_PARAMETER', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationParameter', 'COLUMN', 'ParameterCode'
go

exec sp_addextendedproperty 'MS_Description', 'Parameter Value', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationParameter', 'COLUMN', 'ParameterValue'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationParameter', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationParameter', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationParameter', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationParameter', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationParameter', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationParameter', 'COLUMN', 'LastModifiedUserName'
go

create table ORG.TaskGroupOperationResult
(
    ID                   numeric(16) identity
        constraint PK_TaskGroupOperationResult
            primary key,
    ObjectID             numeric(16)
        constraint FK_TaskGroupOperationResult_Object
            references GEN.Object,
    TaskGroupOperationID numeric(16)
        constraint FK_TaskGroupOperationResult_TaskGroupOperation
            references ORG.TaskGroupOperation,
    RelatedObjectID      numeric(16)
        constraint FK_TaskGroupOperationResult_Object_02
            references GEN.Object,
    TaskID               numeric(16)
        constraint FK_TaskGroupOperationResult_Task
            references ORG.Task,
    ResultCode           nvarchar(200)
        constraint FK_TaskGroupOperationResult_Code
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'TaskGroupOperationResult',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResult', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task group operation identifier -> ORG.TaskGroupOperation', 'SCHEMA',
     'ORG', 'TABLE', 'TaskGroupOperationResult', 'COLUMN', 'TaskGroupOperationID'
go

exec sp_addextendedproperty 'MS_Description', 'Related object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResult', 'COLUMN', 'RelatedObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task identifier -> ORG.Task', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResult', 'COLUMN', 'TaskID'
go

exec sp_addextendedproperty 'MS_Description', 'Result code -> value set TASK_GROUP_OPERATION_RESULT', 'SCHEMA', 'ORG',
     'TABLE', 'TaskGroupOperationResult', 'COLUMN', 'ResultCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResult', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResult', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResult', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResult', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResult', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResult', 'COLUMN', 'LastModifiedUserName'
go

create table ORG.TaskGroupOperationResultCondition
(
    ID                         numeric(16) identity
        constraint PK_TaskGroupOperationResultCondition
            primary key,
    ObjectID                   numeric(16)
        constraint FK_TaskGroupOperationResultCondition_Object
            references GEN.Object,
    TaskGroupOperationResultID numeric(16)
        constraint FK_TaskGroupOperationResultCondition_TaskGroupOperationResult
            references ORG.TaskGroupOperationResult,
    ConditionID                numeric(16)
        constraint FK_TaskGroupOperationResultCondition_Condition
            references ORG.Condition,
    ConditionResultCode        nvarchar(200)
        constraint FK_TaskGroupOperationResultCondition_Code
            references GEN.Code,
    CreationDate               date,
    CreationTime               time,
    CreationUserName           nvarchar(200),
    LastModifiedDate           date,
    LastModifiedTime           time,
    LastModifiedUserName       nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResultCondition', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResultCondition', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task group operation result identifier -> ORG.TaskGroupOperationResult',
     'SCHEMA', 'ORG', 'TABLE', 'TaskGroupOperationResultCondition', 'COLUMN', 'TaskGroupOperationResultID'
go

exec sp_addextendedproperty 'MS_Description', 'Condition identifier -> ORG.Condition', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResultCondition', 'COLUMN', 'ConditionID'
go

exec sp_addextendedproperty 'MS_Description', 'Result of the condition -> value set CONDITION_RESULT', 'SCHEMA', 'ORG',
     'TABLE', 'TaskGroupOperationResultCondition', 'COLUMN', 'ConditionResultCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResultCondition', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResultCondition', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResultCondition', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResultCondition', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResultCondition', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskGroupOperationResultCondition', 'COLUMN', 'LastModifiedUserName'
go

create table ORG.TaskParameter
(
    ID                   numeric(16) identity
        constraint PK_TaskParameter
            primary key,
    ObjectID             numeric(16)
        constraint FK_TaskParameter_Object
            references GEN.Object,
    TaskID               numeric(16)
        constraint FK_TaskParameter_Task
            references ORG.Task,
    ParameterCode        nvarchar(200)
        constraint FK_TaskParameter_Code
            references GEN.Code,
    ParameterID          numeric(16),
    ParameterValue       nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'TaskParameter', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskParameter', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task identifier -> ORG.Task', 'SCHEMA', 'ORG', 'TABLE', 'TaskParameter',
     'COLUMN', 'TaskID'
go

exec sp_addextendedproperty 'MS_Description', 'Parameter code -> value set MODULE_PARAMETER', 'SCHEMA', 'ORG', 'TABLE',
     'TaskParameter', 'COLUMN', 'ParameterCode'
go

exec sp_addextendedproperty 'MS_Description', 'Parameter value, if the parameter is a numeric identifier', 'SCHEMA',
     'ORG', 'TABLE', 'TaskParameter', 'COLUMN', 'ParameterID'
go

exec sp_addextendedproperty 'MS_Description', 'Parameter value, if the parameter is an alphanumeric value', 'SCHEMA',
     'ORG', 'TABLE', 'TaskParameter', 'COLUMN', 'ParameterValue'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskParameter', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskParameter', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'TaskParameter',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskParameter', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskParameter', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE', 'TaskParameter',
     'COLUMN', 'LastModifiedUserName'
go

create index IXFK_TaskType_Code
    on ORG.TaskType (ID)
go

create index IXFK_TaskType_Code_02
    on ORG.TaskType (DeadlineDayTypeCode)
go

create index IXFK_TaskType_Code_03
    on ORG.TaskType (StatusCode)
go

create index IXFK_TaskType_Object
    on ORG.TaskType (ObjectID)
go

create table ORG.TaskTypeAction
(
    ID                   numeric(16) identity
        constraint PK_TaskTypeAction
            primary key,
    ObjectID             numeric(16)
        constraint FK_TaskTypeAction_Object
            references GEN.Object,
    TaskTypeID           nvarchar(200)
        constraint FK_TaskTypeAction_TaskType
            references ORG.TaskType,
    ActionCode           nvarchar(200)
        constraint FK_TaskTypeAction_Code
            references GEN.Code,
    ConditionSetID       numeric(16)
        constraint FK_TaskTypeAction_ConditionSet
            references ORG.ConditionSet,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    DefaultActionCode    nvarchar(200)
        constraint FK_TaskTypeAction_Code_02
            references GEN.Code,
    DetailedStatusCode   nvarchar(200)
        constraint FK_TaskTypeAction_Code_03
            references GEN.Code,
    EndPoint             nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'TaskTypeAction', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeAction', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task type identifier -> ORG.TaskType', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeAction', 'COLUMN', 'TaskTypeID'
go

exec sp_addextendedproperty 'MS_Description', 'Task type action code -> value set TASK_ACTION', 'SCHEMA', 'ORG',
     'TABLE', 'TaskTypeAction', 'COLUMN', 'ActionCode'
go

exec sp_addextendedproperty 'MS_Description', 'Conditon set identifier -> GEN.ConditionSet', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeAction', 'COLUMN', 'ConditionSetID'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeAction', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeAction', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeAction', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeAction', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeAction', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Default action code -> value set BOOLEAN', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeAction', 'COLUMN', 'DefaultActionCode'
go

exec sp_addextendedproperty 'MS_Description',
     'Status code of the task after the action -> value set TASK_DETAILED_STATUS', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeAction', 'COLUMN', 'DetailedStatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Endpoint name', 'SCHEMA', 'ORG', 'TABLE', 'TaskTypeAction', 'COLUMN',
     'EndPoint'
go

create table ORG.TaskTypeModule
(
    ID                   numeric(16) identity
        constraint PK_TaskTypeModule
            primary key,
    ObjectID             numeric(16)
        constraint FK_TaskTypeModule_Object
            references GEN.Object,
    TaskTypeID           nvarchar(200)
        constraint FK_TaskTypeModule_TaskType
            references ORG.TaskType,
    ModuleID             numeric(16)
        constraint FK_TaskTypeModule_Module
            references ORG.Module,
    ValidFrom            date,
    ValidUntil           date,
    StatusCode           nvarchar(200)
        constraint FK_TaskTypeModule_Code
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'TaskTypeModule', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeModule', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Task type identifier -> ORG.TaskType', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeModule', 'COLUMN', 'TaskTypeID'
go

exec sp_addextendedproperty 'MS_Description', 'Module identifier -> ORG.Module', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeModule', 'COLUMN', 'ModuleID'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'ORG', 'TABLE', 'TaskTypeModule', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'ORG', 'TABLE', 'TaskTypeModule', 'COLUMN',
     'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Status value set -> VALUESET_STATUS', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeModule', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeModule', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeModule', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeModule', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeModule', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeModule', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'TaskTypeModule', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_TaskTypeModule_Code
    on ORG.TaskTypeModule (StatusCode)
go

create index IXFK_TaskTypeModule_Module
    on ORG.TaskTypeModule (ModuleID)
go

create index IXFK_TaskTypeModule_Object
    on ORG.TaskTypeModule (ObjectID)
go

create index IXFK_TaskTypeModule_TaskType
    on ORG.TaskTypeModule (TaskTypeID)
go

create table ORG.TaskUser
(
    ID                   numeric(16) identity
        constraint PK_TaskUser
            primary key,
    ObjectID             numeric(16),
    TaskID               numeric(16),
    UserID               numeric(16),
    Status               nvarchar(200),
    StatusID             nvarchar(200),
    BeginDate            date,
    BeginTime            time,
    EndDate              date,
    EndTime              time,
    DeadlineDate         date,
    DeadlineTime         time,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table FIN.[Transaction]
(
    ID                   numeric(16) identity
        constraint PK_Transaction
            primary key,
    ObjectID             numeric(16)
        constraint FK_Transaction_Object
            references GEN.Object,
    AccountID            numeric(16)
        constraint FK_Transaction_Account
            references FIN.Account,
    PeriodID             numeric(16)
        constraint FK_Transaction_Period
            references FIN.Period,
    BankJournalDate      date,
    BankValueDate        date,
    ValueDate            date,
    AccountingDate       date,
    ExchangeDate         date,
    Amount               money,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    PretenseCode         nvarchar(200)
        constraint FK_Transaction_Code
            references GEN.Code,
    TransactionTypeCode  nvarchar(200)
        constraint FK_Transaction_TransactionTypeCode_Code
            references GEN.Code,
    AmountLocalCurrency  money
)
go

exec sp_addextendedproperty 'MS_Description', N'Eddig kĂĽlĂ¶n kezeltĂĽk:
DCS.Transaction, FIN.Transaction, DCS.DebtChange, DCS.PurchaseReturn, DCS.JournalDistribution

Ăšj dolgokat bevezetni:
- ĂĽgy folyĂłszĂˇmlĂˇja. A pĂ©nzek ide vannak helyezve, de mĂ©g nincsenek szĂ©tosztva a kĂ¶vetelĂ©sre
- adĂłs folyĂłszĂˇmlĂˇja. ', 'SCHEMA', 'FIN', 'TABLE', 'Transaction'
go

exec sp_addextendedproperty 'MS_Description', 'Unique Identifier', 'SCHEMA', 'FIN', 'TABLE', 'Transaction', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Transaction type -> value set TRANSACTION_TYPE', 'SCHEMA', 'FIN',
     'TABLE', 'Transaction', 'COLUMN', 'TransactionTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Amount of the transaction in local currency', 'SCHEMA', 'FIN', 'TABLE',
     'Transaction', 'COLUMN', 'AmountLocalCurrency'
go

create index IXFK_Transaction_Account
    on FIN.[Transaction] (AccountID)
go

create index IXFK_Transaction_Object
    on FIN.[Transaction] (ObjectID)
go

create index IXFK_Transaction_Period
    on FIN.[Transaction] (PeriodID)
go

create index IXFK_Transaction_Code
    on FIN.[Transaction] (PretenseCode)
go

create table GEN.Translation
(
    ID                   numeric(16) identity
        constraint PK_Translation
            primary key,
    CodeID               nvarchar(200) not null
        constraint FK_Translation_Code
            references GEN.Code
            on update cascade on delete cascade,
    Language             nvarchar(5)   not null,
    Text                 nvarchar(200) not null,
    PageID               numeric(16),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_Translation_Code
    on GEN.Translation (CodeID)
go

create unique index IXFK_Translation_CodeID_Language
    on GEN.Translation (CodeID, Language) include (Text)
go

create table GEN.UserAppStatement
(
    ID                   numeric(16) identity
        constraint PK_UserAppStatement
            primary key,
    ObjectID             numeric(16)
        constraint FK_UserAppStatement_Object
            references GEN.Object,
    AppStatementID       numeric(16)
        constraint FK_UserAppStatement_AppStatement
            references GEN.AppStatement,
    AppStatementOptionID numeric(16)
        constraint FK_UserAppStatement_AppStatementOption
            references GEN.AppStatementOption,
    UserName             nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'UserAppStatement',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'UserAppStatement', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'App statement identifier -> GEN.AppStatement', 'SCHEMA', 'GEN', 'TABLE',
     'UserAppStatement', 'COLUMN', 'AppStatementID'
go

exec sp_addextendedproperty 'MS_Description', 'App statement option identifier -> GEN.AppStatementOption', 'SCHEMA',
     'GEN', 'TABLE', 'UserAppStatement', 'COLUMN', 'AppStatementOptionID'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'UserAppStatement', 'COLUMN', 'UserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'UserAppStatement', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'UserAppStatement', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'UserAppStatement', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'UserAppStatement', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'UserAppStatement', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'UserAppStatement', 'COLUMN', 'LastModifiedUserName'
go

create table GEN.ValueSet
(
    ID                   numeric(16) identity
        constraint PK_ValueSet
            primary key,
    ObjectID             numeric(16)
        constraint FK_ValueSet_Object
            references GEN.Object,
    CodePrefix           nvarchar(200),
    DataType             nvarchar(20),
    DataLength           numeric(16),
    SQLStatement         nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    Code                 nvarchar(200)
)
go

alter table GEN.Code
    add constraint FK_Code_ValueSet
        foreign key (ValueSetID) references GEN.ValueSet
            on update cascade on delete cascade
go

create table FIN.Dimension
(
    ID                   numeric(16) identity
        constraint PK_Dimension
            primary key,
    ObjectID             numeric(16)
        constraint FK_Dimension_Object
            references GEN.Object,
    Code                 nvarchar(200)
        constraint FK_Dimension_Code
            references GEN.Code,
    ValueSetID           numeric(16)
        constraint FK_Dimension_ValueSet
            references GEN.ValueSet,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create table FIN.AccountDimension
(
    ID                   numeric(16) identity
        constraint PK_AccountDimension
            primary key,
    ObjectID             numeric(16)
        constraint FK_AccountDimension_Object
            references GEN.Object,
    AccountID            numeric(16)
        constraint FK_AccountDimension_Account
            references FIN.Account,
    DimensionID          numeric(16)
        constraint FK_AccountDimension_Dimension
            references FIN.Dimension,
    DimensionValue       nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

create index IXFK_AccountDimension_Account
    on FIN.AccountDimension (AccountID)
go

create index IXFK_AccountDimension_Dimension
    on FIN.AccountDimension (DimensionID)
go

create index IXFK_AccountDimension_Object
    on FIN.AccountDimension (ObjectID)
go

create index IXFK_Dimension_Code
    on FIN.Dimension (Code)
go

create index IXFK_Dimension_Object
    on FIN.Dimension (ObjectID)
go

create index IXFK_Dimension_ValueSet
    on FIN.Dimension (ValueSetID)
go

create table MIS.Filter
(
    ID                   numeric(16) identity
        constraint PK_Filter
            primary key,
    ObjectID             numeric(16)
        constraint FK_Filter_Object
            references GEN.Object,
    Code                 nvarchar(200)
        constraint FK_Filter_Code
            references GEN.Code
            on update cascade on delete set null,
    FilterType           nvarchar(200),
    DataType             nvarchar(200),
    ValueSetID           numeric(16)
        constraint FK_Filter_ValueSet
            references GEN.ValueSet,
    SQLText              nvarchar(max),
    LookupSQLText        nvarchar(max),
    KeyFieldName         nvarchar(50),
    ListFieldName        nvarchar(50),
    LookupSQLSelectText  nvarchar(max),
    LookupSQLFromText    nvarchar(max),
    LookupSQLWhereText   nvarchar(max),
    LookupSQLOrderByText nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    FilterMode           nvarchar(200)
        constraint FK_Filter_Code_02
            references GEN.Code,
    IntervalLowerSQLText nvarchar(max),
    IntervalUpperSQLText nvarchar(max),
    FolderID             numeric(16)
        constraint FK_Filter_Folder
            references GEN.Folder
)
go

exec sp_addextendedproperty 'MS_Description', 'n', 'SCHEMA', 'MIS', 'TABLE', 'Filter'
go

exec sp_addextendedproperty 'MS_Description', 'Filter mode -> value set FILTER_MODE', 'SCHEMA', 'MIS', 'TABLE',
     'Filter', 'COLUMN', 'FilterMode'
go

exec sp_addextendedproperty 'MS_Description', 'Interval lower SQL statement', 'SCHEMA', 'MIS', 'TABLE', 'Filter',
     'COLUMN', 'IntervalLowerSQLText'
go

exec sp_addextendedproperty 'MS_Description', 'Interval upper SQL statement', 'SCHEMA', 'MIS', 'TABLE', 'Filter',
     'COLUMN', 'IntervalUpperSQLText'
go

exec sp_addextendedproperty 'MS_Description', 'Folder identifier -> GEN.Folder', 'SCHEMA', 'MIS', 'TABLE', 'Filter',
     'COLUMN', 'FolderID'
go

create index IXFK_Filter_Code
    on MIS.Filter (Code)
go

create index IXFK_Filter_Object
    on MIS.Filter (ObjectID)
go

create index IXFK_Filter_ValueSet
    on MIS.Filter (ValueSetID)
go

create table GEN.FlexibleFormFieldType
(
    ID                   numeric(16) identity
        constraint PK_FlexibleFormFieldType
            primary key,
    ObjectID             numeric(16)
        constraint FK_FlexibleFormFieldType_Object
            references GEN.Object,
    FieldTypeCode        nvarchar(200)
        constraint FK_FlexibleFormFieldType_Code
            references GEN.Code,
    Block                nvarchar(200)
        constraint FK_FlexibleFormFieldType_Code_02
            references GEN.Code,
    ValueSetID           numeric(16)
        constraint FK_FlexibleFormFieldType_ValueSet
            references GEN.ValueSet,
    DataType             nvarchar(200),
    DataLength           numeric(4),
    DefaultValue         nvarchar(max),
    ValidFrom            date,
    ValidUntil           date,
    StatusCode           nvarchar(200)
        constraint FK_FlexibleFormFieldType_Code_03
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormFieldType',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormFieldType', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Field type value set -> FLEXIBLE_FIELD_TYPE', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormFieldType', 'COLUMN', 'FieldTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean value set -> VALUESET_BOOLEAN', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormFieldType', 'COLUMN', 'Block'
go

exec sp_addextendedproperty 'MS_Description', 'Value set identifier -> GEN.ValueSet', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormFieldType', 'COLUMN', 'ValueSetID'
go

exec sp_addextendedproperty 'MS_Description', 'Data type (CHARACTER, DATE, MONEY, NUMERIC, TIME)', 'SCHEMA', 'GEN',
     'TABLE', 'FlexibleFormFieldType', 'COLUMN', 'DataType'
go

exec sp_addextendedproperty 'MS_Description', 'Data length', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormFieldType',
     'COLUMN', 'DataLength'
go

exec sp_addextendedproperty 'MS_Description', 'Default value', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormFieldType',
     'COLUMN', 'DefaultValue'
go

exec sp_addextendedproperty 'MS_Description', 'Valid from', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormFieldType', 'COLUMN',
     'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Valid until', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormFieldType',
     'COLUMN', 'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Status value set -> VALUESET_STATUS', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormFieldType', 'COLUMN', 'StatusCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormFieldType', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormFieldType', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormFieldType', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormFieldType', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormFieldType', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormFieldType', 'COLUMN', 'LastModifiedUserName'
go

create table GEN.FlexibleFormField
(
    ID                        numeric(16) identity
        constraint PK_FlexibleFormField
            primary key,
    ObjectID                  numeric(16)
        constraint FK_FlexibleFormField_Object
            references GEN.Object,
    FlexibleFormID            numeric(16)
        constraint FK_FlexibleFormField_FlexibleForm
            references GEN.FlexibleForm,
    FlexibleFormFieldTypeID   numeric(16)
        constraint FK_FlexibleFormField_FlexibleFormFieldType
            references GEN.FlexibleFormFieldType,
    FieldValue                nvarchar(max),
    ParentFlexibleFormFieldID numeric(16)
        constraint FK_FlexibleFormField_FlexibleFormField
            references GEN.FlexibleFormField,
    SequenceNr                numeric(3),
    CreationDate              date,
    CreationTime              time,
    CreationUserName          nvarchar(200),
    LastModifiedDate          date,
    LastModifiedTime          time,
    LastModifiedUserName      nvarchar(200),
    FieldTypeCode             nvarchar(200) not null
        constraint FK_FlexibleFormField_Code
            references GEN.Code,
    Caption                   nvarchar(200),
    Block                     nvarchar(200) not null
        constraint FK_FlexibleFormField_Code_02
            references GEN.Code,
    ValueSetID                numeric(16)
        constraint FK_FlexibleFormField_ValueSet
            references GEN.ValueSet,
    DataLength                numeric(16)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormField',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormField', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Flexible form identifier -> GEN.FlexibleForm', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormField', 'COLUMN', 'FlexibleFormID'
go

exec sp_addextendedproperty 'MS_Description', 'Flexible form field type identifier -> GEN.FlexibleFormFieldTypeID',
     'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormField', 'COLUMN', 'FlexibleFormFieldTypeID'
go

exec sp_addextendedproperty 'MS_Description', 'Field value', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormField', 'COLUMN',
     'FieldValue'
go

exec sp_addextendedproperty 'MS_Description',
     'Flexible form field identifier within a instance -> GEN.FlexibleFormField', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormField', 'COLUMN', 'ParentFlexibleFormFieldID'
go

exec sp_addextendedproperty 'MS_Description', 'Order number in the instance or block', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormField', 'COLUMN', 'SequenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormField', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormField', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormField', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormField', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormField', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormField', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Visual field type value set -> VALUESET_FLEXIBLE_FIELD_TYPE', 'SCHEMA',
     'GEN', 'TABLE', 'FlexibleFormField', 'COLUMN', 'FieldTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Caption of the field', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormField',
     'COLUMN', 'Caption'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean value set -> VALUESET_BOOLEAN', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormField', 'COLUMN', 'Block'
go

exec sp_addextendedproperty 'MS_Description', 'Value set identifier -> GEN.ValueSet', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormField', 'COLUMN', 'ValueSetID'
go

exec sp_addextendedproperty 'MS_Description', 'Data length', 'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormField', 'COLUMN',
     'DataLength'
go

create index IXFK_FlexibleFormField_FlexibleForm
    on GEN.FlexibleFormField (FlexibleFormID)
go

create index IXFK_FlexibleFormField_FlexibleFormField
    on GEN.FlexibleFormField (ParentFlexibleFormFieldID)
go

create index IXFK_FlexibleFormField_FlexibleFormFieldType
    on GEN.FlexibleFormField (FlexibleFormFieldTypeID)
go

create index IXFK_FlexibleFormField_Object
    on GEN.FlexibleFormField (ObjectID)
go

create index IXFK_FlexibleFormFieldType_Code
    on GEN.FlexibleFormFieldType (FieldTypeCode)
go

create index IXFK_FlexibleFormFieldType_Code_02
    on GEN.FlexibleFormFieldType (Block)
go

create index IXFK_FlexibleFormFieldType_Code_03
    on GEN.FlexibleFormFieldType (StatusCode)
go

create index IXFK_FlexibleFormFieldType_Object
    on GEN.FlexibleFormFieldType (ObjectID)
go

create index IXFK_FlexibleFormFieldType_ValueSet
    on GEN.FlexibleFormFieldType (ValueSetID)
go

create table GEN.FlexibleFormTemplateField
(
    ID                                numeric(16) identity
        constraint PK_FlexibleFormTemplateField
            primary key,
    ObjectID                          numeric(16)
        constraint FK_FlexibleFormTemplateField_Object
            references GEN.Object,
    FlexibleFormTemplateID            numeric(16)
        constraint FK_FlexibleFormTemplateField_FlexibleFormTemplate
            references GEN.FlexibleFormTemplate,
    FlexibleFormFieldTypeID           numeric(16)
        constraint FK_FlexibleFormTemplateField_FlexibleFormFieldType
            references GEN.FlexibleFormFieldType,
    ParentFlexibleFormTemplateFieldID numeric(16)
        constraint FK_FlexibleFormTemplateField_FlexibleFormTemplateField
            references GEN.FlexibleFormTemplateField,
    SequenceNr                        numeric(3),
    CreationDate                      date,
    CreationTime                      time,
    CreationUserName                  nvarchar(200),
    LastModifiedDate                  date,
    LastModifiedTime                  time,
    LastModifiedUserName              nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplateField', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplateField', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Flexible form template identifier -> GEN.FlexibleFormTemplate', 'SCHEMA',
     'GEN', 'TABLE', 'FlexibleFormTemplateField', 'COLUMN', 'FlexibleFormTemplateID'
go

exec sp_addextendedproperty 'MS_Description', 'Flexible form field type identifier -> GEN.FlexibleFormFieldTypeID',
     'SCHEMA', 'GEN', 'TABLE', 'FlexibleFormTemplateField', 'COLUMN', 'FlexibleFormFieldTypeID'
go

exec sp_addextendedproperty 'MS_Description',
     'Flexible form field identifier within a template -> GEN.FlexibleFormTemplateField', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplateField', 'COLUMN', 'ParentFlexibleFormTemplateFieldID'
go

exec sp_addextendedproperty 'MS_Description',
     'Order number in the template or block (if the ParentFlexibleFormTemplateFieldID is not null)', 'SCHEMA', 'GEN',
     'TABLE', 'FlexibleFormTemplateField', 'COLUMN', 'SequenceNr'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplateField', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplateField', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplateField', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplateField', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplateField', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE',
     'FlexibleFormTemplateField', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_FlexibleFormTemplateField_FlexibleFormFieldType
    on GEN.FlexibleFormTemplateField (FlexibleFormFieldTypeID)
go

create index IXFK_FlexibleFormTemplateField_FlexibleFormTemplate
    on GEN.FlexibleFormTemplateField (FlexibleFormTemplateID)
go

create index IXFK_FlexibleFormTemplateField_FlexibleFormTemplateField
    on GEN.FlexibleFormTemplateField (ParentFlexibleFormTemplateFieldID)
go

create index IXFK_FlexibleFormTemplateField_Object
    on GEN.FlexibleFormTemplateField (ObjectID)
go

create table MIS.FormColumn
(
    ID                   numeric(16) identity
        constraint PK_FormColumn
            primary key,
    ObjectID             numeric(16)
        constraint FK_FormColumn_Object
            references GEN.Object,
    FormID               numeric(16)
        constraint FK_FormColumn_Form
            references MIS.Form,
    ColumnName           nvarchar(50),
    ColumnTitle          nvarchar(50),
    DisplayWidth         numeric(16),
    OrdNr                numeric(16),
    Alignment            nvarchar(50),
    ValueSetID           numeric(16)
        constraint FK_FormColumn_ValueSet
            references GEN.ValueSet,
    Color                nvarchar(50),
    Area                 nvarchar(50),
    AllowedArea          nvarchar(50),
    AreaIndex            numeric(16),
    ColumnVisible        nvarchar(50),
    FormatMask           nvarchar(50),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ColumnTitleCode      nvarchar(200)
        constraint FK_FormColumn_Code
            references GEN.Code
)
go

create index IXFK_FormColumn_Form
    on MIS.FormColumn (FormID)
go

create index IXFK_FormColumn_Object
    on MIS.FormColumn (ObjectID)
go

create index IXFK_FormColumn_ValueSet
    on MIS.FormColumn (ValueSetID)
go

create table MIS.FormFilter
(
    ID                   numeric(16) identity
        constraint PK_FormFilter
            primary key,
    ObjectID             numeric(16)
        constraint FK_FormFilter_Object
            references GEN.Object,
    FormID               numeric(16)
        constraint FK_FormFilter_Form
            references MIS.Form,
    FolderID             numeric(16)
        constraint FK_FormFilter_Folder
            references GEN.Folder,
    FilterID             numeric(16)
        constraint FK_FormFilter_Filter
            references MIS.Filter,
    Code                 nvarchar(200)
        constraint FK_FormFilter_Code
            references GEN.Code
            on update cascade on delete set null,
    IconName             nvarchar(50),
    OrdNr                numeric(16),
    SQLText              nvarchar(max),
    DefaultType          nvarchar(50),
    DefaultValue         nvarchar(max),
    Default2Type         nvarchar(50),
    Default2Value        nvarchar(max),
    AutoRefresh          nvarchar(50),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    DisableFilterMode    nvarchar(200)
        constraint FK_FormFilter_Code_02
            references GEN.Code,
    IntervalLowerSQLText nvarchar(max),
    IntervalUpperSQLText nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', 'Disable filter mode -> value set BOOLEAN', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilter', 'COLUMN', 'DisableFilterMode'
go

exec sp_addextendedproperty 'MS_Description', 'Interval lower SQL statement', 'SCHEMA', 'MIS', 'TABLE', 'FormFilter',
     'COLUMN', 'IntervalLowerSQLText'
go

exec sp_addextendedproperty 'MS_Description', 'Interval upper SQL statement', 'SCHEMA', 'MIS', 'TABLE', 'FormFilter',
     'COLUMN', 'IntervalUpperSQLText'
go

create index IXFK_FormFilter_Code
    on MIS.FormFilter (Code)
go

create index IXFK_FormFilter_Filter
    on MIS.FormFilter (FilterID)
go

create index IXFK_FormFilter_Folder
    on MIS.FormFilter (FolderID)
go

create index IXFK_FormFilter_Form
    on MIS.FormFilter (FormID)
go

create index IXFK_FormFilter_Object
    on MIS.FormFilter (ObjectID)
go

create table MIS.FormFilterListingMode
(
    ID                   numeric(16) identity
        constraint PK_FormFilterListingMode
            primary key,
    ObjectID             numeric(16)
        constraint FK_FormFilterListingMode_Object
            references GEN.Object,
    FormFilterID         numeric(16)
        constraint FK_FormFilterListingMode_FormFilter
            references MIS.FormFilter,
    ListingModeCode      nvarchar(200)
        constraint FK_FormFilterListingMode_Code
            references GEN.Code,
    SQLText              nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    DisableFilterMode    nvarchar(200),
    IntervalLowerSQLText nvarchar(max),
    IntervalUpperSQLText nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'MIS', 'TABLE', 'FormFilterListingMode',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilterListingMode', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Form filter identifier -> MIS.FormFilter', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilterListingMode', 'COLUMN', 'FormFilterID'
go

exec sp_addextendedproperty 'MS_Description', 'Listing mode -> value set FORM_LISTING_MODE', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilterListingMode', 'COLUMN', 'ListingModeCode'
go

exec sp_addextendedproperty 'MS_Description', 'SQL statement', 'SCHEMA', 'MIS', 'TABLE', 'FormFilterListingMode',
     'COLUMN', 'SQLText'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilterListingMode', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilterListingMode', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilterListingMode', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilterListingMode', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilterListingMode', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilterListingMode', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Disable filter mode -> value set BOOLEAN', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilterListingMode', 'COLUMN', 'DisableFilterMode'
go

exec sp_addextendedproperty 'MS_Description', 'Interval lower SQL statement', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilterListingMode', 'COLUMN', 'IntervalLowerSQLText'
go

exec sp_addextendedproperty 'MS_Description', 'Interval upper SQL statement', 'SCHEMA', 'MIS', 'TABLE',
     'FormFilterListingMode', 'COLUMN', 'IntervalUpperSQLText'
go

create table ORG.ModuleParameter
(
    ID                   numeric(16) identity
        constraint PK_ModuleParameter
            primary key,
    ObjectID             numeric(16)
        constraint FK_ModuleParameter_Object
            references GEN.Object,
    ModuleID             numeric(16)
        constraint FK_ModuleParameter_Module
            references ORG.Module,
    ParameterCode        nvarchar(200)
        constraint FK_ModuleParameter_Code
            references GEN.Code,
    DefaultType          nvarchar(200),
    DefaultValue         nvarchar(max),
    Required             nvarchar(200)
        constraint FK_ModuleParameter_Code_02
            references GEN.Code,
    Visible              nvarchar(200)
        constraint FK_ModuleParameter_Code_03
            references GEN.Code,
    ReadOnly             nvarchar(200)
        constraint FK_ModuleParameter_Code_04
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    ValueSetID           numeric(16)
        constraint FK_ModuleParameter_ValueSet
            references GEN.ValueSet
)
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleParameter', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Module identifier -> ORG.Module', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleParameter', 'COLUMN', 'ModuleID'
go

exec sp_addextendedproperty 'MS_Description', 'Module parameter value set -> VALUESET_MODULE_PARAMETER', 'SCHEMA',
     'ORG', 'TABLE', 'ModuleParameter', 'COLUMN', 'ParameterCode'
go

exec sp_addextendedproperty 'MS_Description', 'Module parameter default type value set -> VALUESET_MODULE_DEFAULT_TYPE',
     'SCHEMA', 'ORG', 'TABLE', 'ModuleParameter', 'COLUMN', 'DefaultType'
go

exec sp_addextendedproperty 'MS_Description', 'Parameter default value', 'SCHEMA', 'ORG', 'TABLE', 'ModuleParameter',
     'COLUMN', 'DefaultValue'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean value set -> VALUESET_BOOLEAN', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleParameter', 'COLUMN', 'Required'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean value set -> VALUESET_BOOLEAN', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleParameter', 'COLUMN', 'Visible'
go

exec sp_addextendedproperty 'MS_Description', 'Boolean value set -> VALUESET_BOOLEAN', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleParameter', 'COLUMN', 'ReadOnly'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleParameter', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleParameter', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleParameter', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleParameter', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleParameter', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleParameter', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Value set identifier -> GEN.ValueSet', 'SCHEMA', 'ORG', 'TABLE',
     'ModuleParameter', 'COLUMN', 'ValueSetID'
go

create index IXFK_ModuleParameter_Code
    on ORG.ModuleParameter (ParameterCode)
go

create index IXFK_ModuleParameter_Code_02
    on ORG.ModuleParameter (Required)
go

create index IXFK_ModuleParameter_Code_03
    on ORG.ModuleParameter (Visible)
go

create index IXFK_ModuleParameter_Code_04
    on ORG.ModuleParameter (ReadOnly)
go

create index IXFK_ModuleParameter_Module
    on ORG.ModuleParameter (ModuleID)
go

create index IXFK_ModuleParameter_Object
    on ORG.ModuleParameter (ObjectID)
go

create index IXFK_ModuleParameter_ValueSet
    on ORG.ModuleParameter (ValueSetID)
go

create table ORG.ProcessDefinitionVariable
(
    ID                   numeric(16) identity
        constraint PK_ProcessDefinitionVariable
            primary key,
    ObjectID             numeric(16)
        constraint FK_ProcessDefinitionVariable_Object
            references GEN.Object,
    ProcessDefinitionID  numeric(16)
        constraint FK_ProcessDefinitionVariable_ProcessDefinition
            references ORG.ProcessDefinition,
    VariableName         nvarchar(200),
    VariableValueSetID   numeric(16)
        constraint FK_ProcessDefinitionVariable_ValueSet
            references GEN.ValueSet,
    DataCode             nvarchar(200)
        constraint FK_ProcessDefinitionVariable_Code
            references GEN.Code,
    InitializationMethod nvarchar(200)
        constraint FK_ProcessDefinitionVariable_Code_02
            references GEN.Code,
    ConstantValue        nvarchar(200),
    Description          nvarchar(max),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200),
    DataSourceID         numeric(16)
        constraint FK_ProcessDefinitionVariable_DataSource
            references GEN.DataSource,
    ConditionSetID       numeric(16)
        constraint FK_ProcessDefinitionVariable_ConditionSet
            references ORG.ConditionSet,
    EvaluationMethodCode nvarchar(200)
        constraint FK_ProcessDefinitionVariable_Code_03
            references GEN.Code
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Process definition identifier -> ORG.ProcessDefinition', 'SCHEMA', 'ORG',
     'TABLE', 'ProcessDefinitionVariable', 'COLUMN', 'ProcessDefinitionID'
go

exec sp_addextendedproperty 'MS_Description', 'Variable name (as included in external process)', 'SCHEMA', 'ORG',
     'TABLE', 'ProcessDefinitionVariable', 'COLUMN', 'VariableName'
go

exec sp_addextendedproperty 'MS_Description', 'Value set identifier -> GEN.ValueSet', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'VariableValueSetID'
go

exec sp_addextendedproperty 'MS_Description', 'Data source value set -> DATA', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'DataCode'
go

exec sp_addextendedproperty 'MS_Description',
     'Process variable initialization method value set -> PROCESS_VARIABLE_INITIALIZATION_METHOD', 'SCHEMA', 'ORG',
     'TABLE', 'ProcessDefinitionVariable', 'COLUMN', 'InitializationMethod'
go

exec sp_addextendedproperty 'MS_Description', 'Constant value', 'SCHEMA', 'ORG', 'TABLE', 'ProcessDefinitionVariable',
     'COLUMN', 'ConstantValue'
go

exec sp_addextendedproperty 'MS_Description', 'Variable description', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'Description'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Data source identifier -> GEN.DataSource', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'DataSourceID'
go

exec sp_addextendedproperty 'MS_Description', 'Condition set identifier -> ORG.ConditionSet', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessDefinitionVariable', 'COLUMN', 'ConditionSetID'
go

exec sp_addextendedproperty 'MS_Description', 'Method of evaluation -> value set PROCESS_VARIABLE_EVALUATION_METHOD',
     'SCHEMA', 'ORG', 'TABLE', 'ProcessDefinitionVariable', 'COLUMN', 'EvaluationMethodCode'
go

create table ORG.ProcessVariable
(
    ID                          numeric(16) identity
        constraint PK_ProcessVariable
            primary key,
    ObjectID                    numeric(16)
        constraint FK_ProcessVariable_Object
            references GEN.Object,
    ProcessID                   numeric(16)
        constraint FK_ProcessVariable_Process
            references ORG.Process,
    ProcessDefinitionVariableID numeric(16)
        constraint FK_ProcessVariable_ProcessDefinitionVariable
            references ORG.ProcessDefinitionVariable,
    VariableName                nvarchar(200),
    VariableValueSetID          numeric(16)
        constraint FK_ProcessVariable_ValueSet
            references GEN.ValueSet,
    DataCode                    nvarchar(200)
        constraint FK_ProcessVariable_Code
            references GEN.Code,
    CreationDate                date,
    CreationTime                time,
    CreationUserName            nvarchar(200),
    LastModifiedDate            date,
    LastModifiedTime            time,
    LastModifiedUserName        nvarchar(200),
    VariableValue               nvarchar(max)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'ProcessVariable',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariable', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Process instance identifier -> ORG.Process', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariable', 'COLUMN', 'ProcessID'
go

exec sp_addextendedproperty 'MS_Description', 'Process definition variable identifier -> ORG.ProcessDefinitionVariable',
     'SCHEMA', 'ORG', 'TABLE', 'ProcessVariable', 'COLUMN', 'ProcessDefinitionVariableID'
go

exec sp_addextendedproperty 'MS_Description', 'Variable name (as included in external process)', 'SCHEMA', 'ORG',
     'TABLE', 'ProcessVariable', 'COLUMN', 'VariableName'
go

exec sp_addextendedproperty 'MS_Description', 'Value set identifier -> GEN.ValueSet', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariable', 'COLUMN', 'VariableValueSetID'
go

exec sp_addextendedproperty 'MS_Description', 'Data source value set -> DATA', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariable', 'COLUMN', 'DataCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariable', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariable', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariable', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariable', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariable', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariable', 'COLUMN', 'LastModifiedUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Value of variable', 'SCHEMA', 'ORG', 'TABLE', 'ProcessVariable',
     'COLUMN', 'VariableValue'
go

create table ORG.ProcessVariableHistory
(
    ID                   numeric(16) identity
        constraint PK_ProcessVariableHistory
            primary key,
    ObjectID             numeric(16)
        constraint FK_ProcessVariableHistory_Object
            references GEN.Object,
    ProcessVariableID    numeric(16)
        constraint FK_ProcessVariableHistory_ProcessVariable
            references ORG.ProcessVariable,
    Value                nvarchar(max),
    ValueDate            date,
    ValueTime            time,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'ORG', 'TABLE', 'ProcessVariableHistory',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariableHistory', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Process variable identifier -> ORG.ProcessVariable', 'SCHEMA', 'ORG',
     'TABLE', 'ProcessVariableHistory', 'COLUMN', 'ProcessVariableID'
go

exec sp_addextendedproperty 'MS_Description', 'Value of process variable', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariableHistory', 'COLUMN', 'Value'
go

exec sp_addextendedproperty 'MS_Description', 'Date of the value', 'SCHEMA', 'ORG', 'TABLE', 'ProcessVariableHistory',
     'COLUMN', 'ValueDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time of the value', 'SCHEMA', 'ORG', 'TABLE', 'ProcessVariableHistory',
     'COLUMN', 'ValueTime'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariableHistory', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariableHistory', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariableHistory', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariableHistory', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'ORG', 'TABLE',
     'ProcessVariableHistory', 'COLUMN', 'LastModifiedUserName'
go

create table GEN.Setting
(
    ID                   numeric(16) identity
        constraint PK_Setting
            primary key,
    ObjectID             numeric(16)
        constraint FK_Setting_Object
            references GEN.Object,
    [Schema]             nvarchar(200),
    SettingCode          nvarchar(200)
        constraint FK_Setting_Code
            references GEN.Code,
    SettingValue         nvarchar(max),
    ValueSetID           numeric(16)
        constraint FK_Setting_ValueSet
            references GEN.ValueSet,
    SettingLevelCode     nvarchar(200),
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'Setting', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'GEN', 'TABLE', 'Setting',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Schema', 'SCHEMA', 'GEN', 'TABLE', 'Setting', 'COLUMN', 'Schema'
go

exec sp_addextendedproperty 'MS_Description', 'Code of setting -> value set SETTING_CODE', 'SCHEMA', 'GEN', 'TABLE',
     'Setting', 'COLUMN', 'SettingCode'
go

exec sp_addextendedproperty 'MS_Description', 'Setting value', 'SCHEMA', 'GEN', 'TABLE', 'Setting', 'COLUMN',
     'SettingValue'
go

exec sp_addextendedproperty 'MS_Description', 'Value set identifier -> GEN.ValueSet', 'SCHEMA', 'GEN', 'TABLE',
     'Setting', 'COLUMN', 'ValueSetID'
go

exec sp_addextendedproperty 'MS_Description', 'Code of setting level -> SETTING_LEVEL', 'SCHEMA', 'GEN', 'TABLE',
     'Setting', 'COLUMN', 'SettingLevelCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'Setting',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'GEN', 'TABLE', 'Setting',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user name -> PRT.AppUser', 'SCHEMA', 'GEN', 'TABLE', 'Setting',
     'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'Setting', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'GEN', 'TABLE',
     'Setting', 'COLUMN', 'LastModifiedTime'
go

create index IXFK_ValueSet_Object
    on GEN.ValueSet (ObjectID)
go

create table FIN.Vat
(
    ID                   numeric(16) identity
        constraint PK_Vat
            primary key,
    ObjectID             numeric(16)
        constraint FK_Vat_Object
            references GEN.Object,
    Code                 nvarchar(200)
        constraint FK_Vat_Code
            references GEN.Code,
    Rate                 numeric(10, 4),
    ValidFrom            date,
    ValidUntil           date,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'FIN', 'TABLE', 'Vat', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'FIN', 'TABLE', 'Vat',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Vat value set -> VAT', 'SCHEMA', 'FIN', 'TABLE', 'Vat', 'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'VAT rate', 'SCHEMA', 'FIN', 'TABLE', 'Vat', 'COLUMN', 'Rate'
go

exec sp_addextendedproperty 'MS_Description', 'VAT is available from this date', 'SCHEMA', 'FIN', 'TABLE', 'Vat',
     'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'VAT is available until this date', 'SCHEMA', 'FIN', 'TABLE', 'Vat',
     'COLUMN', 'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'FIN', 'TABLE', 'Vat',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time part of CreationDate', 'SCHEMA', 'FIN', 'TABLE', 'Vat', 'COLUMN',
     'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creator user''s identifier -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'Vat', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'FIN', 'TABLE', 'Vat',
     'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'FIN', 'TABLE', 'Vat',
     'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User who changed the data last time -> PRT.AppUser', 'SCHEMA', 'FIN',
     'TABLE', 'Vat', 'COLUMN', 'LastModifiedUserName'
go

create table AST.AssetValuationValue
(
    ID                   numeric(16) identity
        constraint PK_AssetValuationValue
            primary key,
    ObjectID             numeric(16)
        constraint FK_AssetValuationValue_Object
            references GEN.Object,
    AssetValuationID     numeric(16)
        constraint FK_AssetValuationValue_AssetValuation
            references AST.AssetValuation,
    ValueTypeCode        nvarchar(200)
        constraint FK_AssetValuationValue_Code
            references GEN.Code,
    NetValue             money,
    VatID                numeric(16)
        constraint FK_AssetValuationValue_Vat
            references FIN.Vat,
    VatValue             money,
    GrossValue           money,
    ValueCurrencyCode    nvarchar(200)
        constraint FK_AssetValuationValue_Code_02
            references GEN.Code,
    CreationDate         date,
    CreationTime         time,
    CreationUserName     nvarchar(200),
    LastModifiedDate     date,
    LastModifiedTime     time,
    LastModifiedUserName nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'AST', 'TABLE', 'AssetValuationValue',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Asset valuation identifier -> AST.AssetValuation', 'SCHEMA', 'AST',
     'TABLE', 'AssetValuationValue', 'COLUMN', 'AssetValuationID'
go

exec sp_addextendedproperty 'MS_Description', 'Asset valuation value type -> ASSET_VALUATION_VALUE_TYPE', 'SCHEMA',
     'AST', 'TABLE', 'AssetValuationValue', 'COLUMN', 'ValueTypeCode'
go

exec sp_addextendedproperty 'MS_Description', 'Net Value', 'SCHEMA', 'AST', 'TABLE', 'AssetValuationValue', 'COLUMN',
     'NetValue'
go

exec sp_addextendedproperty 'MS_Description', 'Vat identifier -> FIN.Vat', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'VatID'
go

exec sp_addextendedproperty 'MS_Description', 'Vat Value', 'SCHEMA', 'AST', 'TABLE', 'AssetValuationValue', 'COLUMN',
     'VatValue'
go

exec sp_addextendedproperty 'MS_Description', 'Gross Value', 'SCHEMA', 'AST', 'TABLE', 'AssetValuationValue', 'COLUMN',
     'GrossValue'
go

exec sp_addextendedproperty 'MS_Description', 'Value currency -> CURRENCY value set', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'ValueCurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was entered', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'App user identifier -> PRT.AppUser', 'SCHEMA', 'AST', 'TABLE',
     'AssetValuationValue', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_AssetValuationValue_AssetValuation
    on AST.AssetValuationValue (AssetValuationID)
go

create index IXFK_AssetValuationValue_Code
    on AST.AssetValuationValue (ValueTypeCode)
go

create index IXFK_AssetValuationValue_Code_02
    on AST.AssetValuationValue (ValueCurrencyCode)
go

create index IXFK_AssetValuationValue_Object
    on AST.AssetValuationValue (ObjectID)
go

create index IXFK_AssetValuationValue_Vat
    on AST.AssetValuationValue (VatID)
go

create table FIN.Product
(
    ID                    numeric(16) identity
        constraint PK_Product
            primary key,
    ObjectID              numeric(16)
        constraint FK_Product_Object
            references GEN.Object,
    Code                  nvarchar(200)
        constraint FK_Product_Code
            references GEN.Code,
    Description           nvarchar(max),
    UnitCode              nvarchar(200)
        constraint FK_Product_Code_02
            references GEN.Code,
    UnitPrice             money,
    UnitPriceCurrencyCode nvarchar(200)
        constraint FK_Product_Code_03
            references GEN.Code,
    VatID                 numeric(16)
        constraint FK_Product_Vat
            references FIN.Vat,
    ValidFrom             date,
    ValidUntil            date,
    CreationDate          date,
    CreationTime          time,
    CreationUserName      nvarchar(200),
    LastModifiedDate      date,
    LastModifiedTime      time,
    LastModifiedUserName  nvarchar(200)
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'FIN', 'TABLE', 'Product', 'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Object identifier -> GEN.Object', 'SCHEMA', 'FIN', 'TABLE', 'Product',
     'COLUMN', 'ObjectID'
go

exec sp_addextendedproperty 'MS_Description', 'Product value set -> PRODUCT', 'SCHEMA', 'FIN', 'TABLE', 'Product',
     'COLUMN', 'Code'
go

exec sp_addextendedproperty 'MS_Description', 'Detailed description of the product', 'SCHEMA', 'FIN', 'TABLE',
     'Product', 'COLUMN', 'Description'
go

exec sp_addextendedproperty 'MS_Description', 'Unit value set -> FINANCIAL_UNIT', 'SCHEMA', 'FIN', 'TABLE', 'Product',
     'COLUMN', 'UnitCode'
go

exec sp_addextendedproperty 'MS_Description', 'Price per unit', 'SCHEMA', 'FIN', 'TABLE', 'Product', 'COLUMN',
     'UnitPrice'
go

exec sp_addextendedproperty 'MS_Description', 'The unit price''s currency identifier -> CURRENCY value set', 'SCHEMA',
     'FIN', 'TABLE', 'Product', 'COLUMN', 'UnitPriceCurrencyCode'
go

exec sp_addextendedproperty 'MS_Description', 'Default VAT identifier -> FIN.Vat', 'SCHEMA', 'FIN', 'TABLE', 'Product',
     'COLUMN', 'VatID'
go

exec sp_addextendedproperty 'MS_Description', 'Product is available from this date', 'SCHEMA', 'FIN', 'TABLE',
     'Product', 'COLUMN', 'ValidFrom'
go

exec sp_addextendedproperty 'MS_Description', 'Product is available until this date', 'SCHEMA', 'FIN', 'TABLE',
     'Product', 'COLUMN', 'ValidUntil'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was entered', 'SCHEMA', 'FIN', 'TABLE', 'Product',
     'COLUMN', 'CreationDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time part of CreationDate', 'SCHEMA', 'FIN', 'TABLE', 'Product',
     'COLUMN', 'CreationTime'
go

exec sp_addextendedproperty 'MS_Description', 'Creator user''s identifier -> PRT.AppUser', 'SCHEMA', 'FIN', 'TABLE',
     'Product', 'COLUMN', 'CreationUserName'
go

exec sp_addextendedproperty 'MS_Description', 'Date when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'Product', 'COLUMN', 'LastModifiedDate'
go

exec sp_addextendedproperty 'MS_Description', 'Time when the data was last modified', 'SCHEMA', 'FIN', 'TABLE',
     'Product', 'COLUMN', 'LastModifiedTime'
go

exec sp_addextendedproperty 'MS_Description', 'User who changed the data last time -> PRT.AppUser', 'SCHEMA', 'FIN',
     'TABLE', 'Product', 'COLUMN', 'LastModifiedUserName'
go

create index IXFK_Product_Code
    on FIN.Product (Code)
go

create index IXFK_Product_Code_02
    on FIN.Product (UnitCode)
go

create index IXFK_Product_Code_03
    on FIN.Product (UnitPriceCurrencyCode)
go

create index IXFK_Product_Object
    on FIN.Product (ObjectID)
go

create index IXFK_Product_Vat
    on FIN.Product (VatID)
go

create index IXFK_Vat_Code
    on FIN.Vat (Code)
go

create index IXFK_Vat_Object
    on FIN.Vat (ObjectID)
go

create table GEN.WorkingDay
(
    ID        nvarchar(200) not null
        constraint PK_WorkingDay
            primary key
        constraint FK_WorkingDay_01
            references GEN.Code,
    BeginWork time,
    EndWork   time
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'WorkingDay', 'COLUMN',
     'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Interface table identifier -> IFC.InterfaceTable', 'SCHEMA', 'GEN',
     'TABLE', 'WorkingDay', 'COLUMN', 'BeginWork'
go

exec sp_addextendedproperty 'MS_Description', 'Source interface type', 'SCHEMA', 'GEN', 'TABLE', 'WorkingDay', 'COLUMN',
     'EndWork'
go

create table GEN.WorkingDayException
(
    ID        numeric(16) identity
        constraint PK_WorkingDayException
            primary key,
    Day       date,
    BeginWork time,
    EndWork   time
)
go

exec sp_addextendedproperty 'MS_Description', 'Unique identifier', 'SCHEMA', 'GEN', 'TABLE', 'WorkingDayException',
     'COLUMN', 'ID'
go

exec sp_addextendedproperty 'MS_Description', 'Adjustment date code -> value set ADJUSTMENT_DATE', 'SCHEMA', 'GEN',
     'TABLE', 'WorkingDayException', 'COLUMN', 'Day'
go

exec sp_addextendedproperty 'MS_Description', 'Adjustment period code -> value set PERIOD_TYPE', 'SCHEMA', 'GEN',
     'TABLE', 'WorkingDayException', 'COLUMN', 'BeginWork'
go

exec sp_addextendedproperty 'MS_Description', 'Day of the period (-1 means last day of the period)', 'SCHEMA', 'GEN',
     'TABLE', 'WorkingDayException', 'COLUMN', 'EndWork'
go

create table dbo.sysdiagrams
(
    name         sysname not null,
    principal_id int     not null,
    diagram_id   int identity
        primary key,
    version      int,
    definition   varbinary(max),
    constraint UK_principal_name
        unique (principal_id, name)
)
go

exec sp_addextendedproperty 'microsoft_database_tools_support', 1, 'SCHEMA', 'dbo', 'TABLE', 'sysdiagrams'
go


CREATE VIEW [FIN].[AccountSum_View]
AS
SELECT        CONCAT(DebtCase.ID, AccountType.Code) AS ID, DebtCase.ID AS DebtCaseID, Calculation.ID CalculationID, AccountType.ID AccountTypeID, AccountType.Code,
                             (SELECT        sum(A.Balance)
                               FROM            FIN.Account A
                               WHERE        A.CalculationID = Calculation.ID AND A.AccountTypeID = AccountType.ID AND A.CurrencyCode = DebtCase.CurrencyCode) AS CaseCurrencyValue,
                             (SELECT        sum(A.Balance)
                               FROM            FIN.Account A
                               WHERE        A.CalculationID = Calculation.ID AND A.AccountTypeID = AccountType.ID AND A.CurrencyCode <> DebtCase.CurrencyCode AND A.CurrencyCode = 'CURRENCY_HUF') AS LocalCurrencyValue, COALESCE
                             ((SELECT        sum(A.Balance)
                                 FROM            FIN.Account A
                                 WHERE        A.CalculationID = Calculation.ID AND A.AccountTypeID = AccountType.ID AND A.CurrencyCode = DebtCase.CurrencyCode), 0) * COALESCE
                             ((SELECT        TOP 1 Rate
                                 FROM            FIN.ExchangeRate
                                 WHERE        SourceCurrencyCode = DebtCase.CurrencyCode AND TargetCurrencyCode = 'CURRENCY_HUF' AND ExchangeDate < SYSDATETIME()
                                 ORDER BY ExchangeDate DESC), 1) + COALESCE
                             ((SELECT        sum(A.Balance)
                                 FROM            FIN.Account A
                                 WHERE        A.CalculationID = Calculation.ID AND A.AccountTypeID = AccountType.ID AND A.CurrencyCode <> DebtCase.CurrencyCode AND A.CurrencyCode = 'CURRENCY_HUF'), 0) AS TotalInLocalCurrency
FROM            DCS.DebtCase JOIN
                         FIN.Calculation ON (DebtCase.MainCalculationID = Calculation.ID) JOIN
                         FIN.Account ON (Calculation.ID = Account.CalculationID) JOIN
                         FIN.AccountType ON (Account.AccountTypeID = AccountType.ID)
WHERE        AccountType.Code NOT IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT')
GROUP BY DebtCase.ID, DebtCase.CurrencyCode, Calculation.ID, AccountType.ID, AccountType.Code
UNION ALL
SELECT        
                         CONCAT(DebtCase.ID, 'ACCOUNT_TYPE_TOTAL') AS ID, DebtCase.ID AS DebtCaseID, Calculation.ID CalculationID, NULL AccountTypeID, 'ACCOUNT_TYPE_TOTAL' Code,
                             (SELECT        sum(A.Balance)
                               FROM            FIN.Account A
                               WHERE        A.CalculationID = Calculation.ID AND A.CurrencyCode = DebtCase.CurrencyCode
							   AND A.AccountTypeID NOT IN (SELECT ACCTYP.ID FROM FIN.AccountType ACCTYP WHERE ACCTYP.CODE IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT'))
							   ) AS CaseCurrencyValue,
                             (SELECT        sum(A.Balance)
                               FROM            FIN.Account A
                               WHERE        A.CalculationID = Calculation.ID AND A.CurrencyCode <> DebtCase.CurrencyCode AND A.CurrencyCode = 'CURRENCY_HUF'
							   AND A.AccountTypeID NOT IN (SELECT ACCTYP.ID FROM FIN.AccountType ACCTYP WHERE ACCTYP.CODE IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT'))
							   ) AS LocalCurrencyValue, COALESCE
                             ((SELECT        sum(A.Balance)
                                 FROM            FIN.Account A
                                 WHERE        A.CalculationID = Calculation.ID AND A.CurrencyCode = DebtCase.CurrencyCode
								 AND A.AccountTypeID NOT IN (SELECT ACCTYP.ID FROM FIN.AccountType ACCTYP WHERE ACCTYP.CODE IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT'))
								 ), 0) * COALESCE
                             ((SELECT        TOP 1 Rate
                                 FROM            FIN.ExchangeRate
                                 WHERE        SourceCurrencyCode = DebtCase.CurrencyCode AND TargetCurrencyCode = 'CURRENCY_HUF' AND ExchangeDate < SYSDATETIME()
                                 ORDER BY ExchangeDate DESC), 1) + COALESCE
                             ((SELECT        sum(A.Balance)
                                 FROM            FIN.Account A
                                 WHERE        A.CalculationID = Calculation.ID AND A.CurrencyCode <> DebtCase.CurrencyCode AND A.CurrencyCode = 'CURRENCY_HUF'
								 AND A.AccountTypeID NOT IN (SELECT ACCTYP.ID FROM FIN.AccountType ACCTYP WHERE ACCTYP.CODE IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT'))
								 ), 0) AS TotalInLocalCurrency
FROM            DCS.DebtCase JOIN
                         FIN.Calculation ON (DebtCase.MainCalculationID = Calculation.ID) JOIN
                         FIN.Account ON (Calculation.ID = Account.CalculationID) JOIN
                         FIN.AccountType ON (Account.AccountTypeID = AccountType.ID)
GROUP BY DebtCase.ID, DebtCase.CurrencyCode, Calculation.ID
go

exec sp_addextendedproperty 'MS_DiagramPane1', N'[0E232FF0-B466-11cf-A24F-00AA00A3EFFF, 1.00]
Begin DesignProperties = 
   Begin PaneConfigurations = 
      Begin PaneConfiguration = 0
         NumPanes = 4
         Configuration = "(H (1[11] 4[41] 2[30] 3) )"
      End
      Begin PaneConfiguration = 1
         NumPanes = 3
         Configuration = "(H (1 [50] 4 [25] 3))"
      End
      Begin PaneConfiguration = 2
         NumPanes = 3
         Configuration = "(H (1 [50] 2 [25] 3))"
      End
      Begin PaneConfiguration = 3
         NumPanes = 3
         Configuration = "(H (4 [30] 2 [40] 3))"
      End
      Begin PaneConfiguration = 4
         NumPanes = 2
         Configuration = "(H (1 [56] 3))"
      End
      Begin PaneConfiguration = 5
         NumPanes = 2
         Configuration = "(H (2 [66] 3))"
      End
      Begin PaneConfiguration = 6
         NumPanes = 2
         Configuration = "(H (4 [50] 3))"
      End
      Begin PaneConfiguration = 7
         NumPanes = 1
         Configuration = "(V (3))"
      End
      Begin PaneConfiguration = 8
         NumPanes = 3
         Configuration = "(H (1[56] 4[18] 2) )"
      End
      Begin PaneConfiguration = 9
         NumPanes = 2
         Configuration = "(H (1 [75] 4))"
      End
      Begin PaneConfiguration = 10
         NumPanes = 2
         Configuration = "(H (1[66] 2) )"
      End
      Begin PaneConfiguration = 11
         NumPanes = 2
         Configuration = "(H (4 [60] 2))"
      End
      Begin PaneConfiguration = 12
         NumPanes = 1
         Configuration = "(H (1) )"
      End
      Begin PaneConfiguration = 13
         NumPanes = 1
         Configuration = "(V (4))"
      End
      Begin PaneConfiguration = 14
         NumPanes = 1
         Configuration = "(V (2))"
      End
      ActivePaneConfig = 0
   End
   Begin DiagramPane = 
      Begin Origin = 
         Top = 0
         Left = 0
      End
      Begin Tables = 
      End
   End
   Begin SQLPane = 
   End
   Begin DataPane = 
      Begin ParameterDefaults = ""
      End
   End
   Begin CriteriaPane = 
      Begin ColumnWidths = 11
         Column = 1440
         Alias = 900
         Table = 1170
         Output = 720
         Append = 1400
         NewValue = 1170
         SortType = 1350
         SortOrder = 1410
         GroupBy = 1350
         Filter = 1350
         Or = 1350
         Or = 1350
         Or = 1350
      End
   End
End
', 'SCHEMA', 'FIN', 'VIEW', 'AccountSum_View'
go

exec sp_addextendedproperty 'MS_DiagramPaneCount', 1, 'SCHEMA', 'FIN', 'VIEW', 'AccountSum_View'
go



CREATE VIEW [ORG].[Event_View]
AS
SELECT e.ID,
		GEn.TranslateCode(e.ProcessCode, 'HU') processCode,
		GEN.TranslateCode(e.EventTypeCode, 'HU') eventTypeCode,
		e.Subject,
		e.Comments,
		e.CreationDate,
		e.CreationTime,
		e.CreationUserName,
		PRT.GetEntityName(e1.ID) objectName,
		e.RelatedObjectID
	FROM ORG.Event e
		JOIN gen.Object o ON e.RelatedObjectID = o.ID
		JOIN PRT.Entity e1 ON o.ID = e1.ObjectID
go



-- =============================================
-- Author:		Kiss János
-- Create date: 2022-11-19
-- Last modified date: 2022-11-23
-- Modify: Amount comment /Bognár Dávid/
-- Description:	Invoice view
-- =============================================
CREATE VIEW [FIN].[Invoice_View] AS
	SELECT FIN.Account.ID,
			FIN.Invoice.InvoiceNr,
			(SELECT GEN.Translation.Text
				FROM GEN.Translation
					JOIN GEN.Code ON GEN.Code.ID = GEN.Translation.CodeID
				WHERE GEN.Code.ID = FIN.AccountType.Code AND GEN.Translation.Language = 'HU') AS Code,
			(SELECT GEN.Translation.Text
				FROM GEN.Translation
					JOIN GEN.Code ON GEN.Code.ID = GEN.Translation.CodeID
				WHERE GEN.Code.ID = FIN.AccountType.MainClass AND GEN.Translation.Language = 'HU') AS MainClass,
			(SELECT SUM(FIN.[Transaction].Amount)
				FROM FIN.[Transaction]
					WHERE FIN.[Transaction].AccountID = FIN.Account.ID) AS Amount,
					--FIN.Account.Balance as Amount,
					FIN.AccountType.AccountNr as AccountNr,
			(SELECT GEN.Translation.Text
				FROM GEN.Translation
					JOIN GEN.Code ON GEN.Code.ID = GEN.Translation.CodeID
				WHERE GEN.Code.ID = FIN.Account.CurrencyCode AND GEN.Translation.Language = 'HU') AS Currency,
			FIN.Invoice.DebtCaseID
		FROM FIN.Invoice
			LEFT JOIN FIN.InvoiceArrears ON FIN.InvoiceArrears.InvoiceID = FIN.Invoice.ID
			LEFT JOIN FIN.Account ON FIN.Account.InvoiceArrearsID = FIN.InvoiceArrears.ID
			LEFT JOIN FIN.AccountType ON FIN.AccountType.ID = FIN.Account.AccountTypeID
			LEFT JOIN FIN.Calculation ON FIN.Calculation.ID = FIN.Account.CalculationID
			LEFT JOIN DCS.DebtCase ON DCS.DebtCase.MainCalculationID = FIN.Calculation.ID
go



-- =============================================
-- Author:		Kiss János
-- Create date: 2022-11-19
-- Last modified date: 2022-11-19
-- Description:	Invoice view
-- =============================================
CREATE   VIEW [PRT].[Party_View] AS
	SELECT PRT.Party.ID,
			PRT.Person.FirstName,
			PRT.Person.LastName,
			PRT.Company.Name,
			PRT.GetEntityName(PRT.Party.EntityID) AS FullName,
			(SELECT GEN.Translation.Text
				FROM GEN.Translation
					JOIN GEN.Code ON GEN.Code.ID = GEN.Translation.CodeID
				WHERE GEN.Code.ID = PRT.Address.AddressType AND GEN.Translation.Language = 'HU') AS AddressType,
			PRT.Address.ZipCode,
			PRT.Address.Settlement,
			PRT.Address.District,
			PRT.Address.PublicPlaceName,
			(SELECT GEN.Translation.Text
				FROM GEN.Translation
					JOIN GEN.Code ON GEN.Code.ID = GEN.Translation.CodeID
				WHERE GEN.Code.ID = PRT.Address.PublicPlaceType AND GEN.Translation.Language = 'HU') AS PublicPlaceType,
			PRT.Address.HouseNr,
			PRT.Address.Staircase,
			PRT.Address.Building,
			PRT.Address.Floor,
			PRT.Address.Door,
			(SELECT GEN.Translation.Text
				FROM GEN.Translation
					JOIN GEN.Code ON GEN.Code.ID = GEN.Translation.CodeID
				WHERE GEN.Code.ID = PRT.Contact.ContactType AND GEN.Translation.Language = 'HU') AS ContactType,
			PRT.Contact.Contact
		FROM PRT.Party
			JOIN PRT.Entity ON PRT.Party.EntityID = PRT.Entity.ID
			LEFT JOIN PRT.Person ON PRT.Person.EntityID = PRT.Entity.ID
			LEFT JOIN PRT.Company ON PRT.Company.EntityID = PRT.Entity.ID
			JOIN PRT.Address ON PRT.Address.EntityID = PRT.Entity.ID
			JOIN PRT.Contact ON PRT.Contact.EntityID = PRT.Entity.ID
go


CREATE VIEW [ORG].[TaskGroupOperationSetObject_View]
AS
SELECT        ORG.TaskGroupOperationSetObject.RelatedObjectID AS ObjectID, GEN.GetObjectName(ORG.TaskGroupOperationSetObject.RelatedObjectID) AS ObjectName, 
                         ORG.TaskGroupOperationSetObject.TaskGroupOperationSetID AS OperationSetID
FROM            GEN.Object INNER JOIN
                         GEN.ObjectType ON GEN.Object.ObjectType = GEN.ObjectType.Code INNER JOIN
                         ORG.TaskGroupOperationSetObject ON GEN.Object.ID = ORG.TaskGroupOperationSetObject.RelatedObjectID
go

exec sp_addextendedproperty 'MS_DiagramPane1', N'[0E232FF0-B466-11cf-A24F-00AA00A3EFFF, 1.00]
Begin DesignProperties = 
   Begin PaneConfigurations = 
      Begin PaneConfiguration = 0
         NumPanes = 4
         Configuration = "(H (1[40] 4[20] 2[20] 3) )"
      End
      Begin PaneConfiguration = 1
         NumPanes = 3
         Configuration = "(H (1 [50] 4 [25] 3))"
      End
      Begin PaneConfiguration = 2
         NumPanes = 3
         Configuration = "(H (1 [50] 2 [25] 3))"
      End
      Begin PaneConfiguration = 3
         NumPanes = 3
         Configuration = "(H (4 [30] 2 [40] 3))"
      End
      Begin PaneConfiguration = 4
         NumPanes = 2
         Configuration = "(H (1 [56] 3))"
      End
      Begin PaneConfiguration = 5
         NumPanes = 2
         Configuration = "(H (2 [66] 3))"
      End
      Begin PaneConfiguration = 6
         NumPanes = 2
         Configuration = "(H (4 [50] 3))"
      End
      Begin PaneConfiguration = 7
         NumPanes = 1
         Configuration = "(V (3))"
      End
      Begin PaneConfiguration = 8
         NumPanes = 3
         Configuration = "(H (1[56] 4[18] 2) )"
      End
      Begin PaneConfiguration = 9
         NumPanes = 2
         Configuration = "(H (1 [75] 4))"
      End
      Begin PaneConfiguration = 10
         NumPanes = 2
         Configuration = "(H (1[66] 2) )"
      End
      Begin PaneConfiguration = 11
         NumPanes = 2
         Configuration = "(H (4 [60] 2))"
      End
      Begin PaneConfiguration = 12
         NumPanes = 1
         Configuration = "(H (1) )"
      End
      Begin PaneConfiguration = 13
         NumPanes = 1
         Configuration = "(V (4))"
      End
      Begin PaneConfiguration = 14
         NumPanes = 1
         Configuration = "(V (2))"
      End
      ActivePaneConfig = 0
   End
   Begin DiagramPane = 
      Begin Origin = 
         Top = 0
         Left = 0
      End
      Begin Tables = 
         Begin Table = "Object (GEN)"
            Begin Extent = 
               Top = 36
               Left = 273
               Bottom = 166
               Right = 486
            End
            DisplayFlags = 280
            TopColumn = 0
         End
         Begin Table = "ObjectType (GEN)"
            Begin Extent = 
               Top = 34
               Left = 528
               Bottom = 164
               Right = 741
            End
            DisplayFlags = 280
            TopColumn = 0
         End
         Begin Table = "TaskGroupOperationSetObject (ORG)"
            Begin Extent = 
               Top = 23
               Left = 8
               Bottom = 189
               Right = 233
            End
            DisplayFlags = 280
            TopColumn = 0
         End
      End
   End
   Begin SQLPane = 
   End
   Begin DataPane = 
      Begin ParameterDefaults = ""
      End
   End
   Begin CriteriaPane = 
      Begin ColumnWidths = 11
         Column = 6450
         Alias = 1740
         Table = 1170
         Output = 720
         Append = 1400
         NewValue = 1170
         SortType = 1350
         SortOrder = 1410
         GroupBy = 1350
         Filter = 1350
         Or = 1350
         Or = 1350
         Or = 1350
      End
   End
End
', 'SCHEMA', 'ORG', 'VIEW', 'TaskGroupOperationSetObject_View'
go

exec sp_addextendedproperty 'MS_DiagramPaneCount', 1, 'SCHEMA', 'ORG', 'VIEW', 'TaskGroupOperationSetObject_View'
go

CREATE PROCEDURE [FIN].[AccountSum_List_Procedure]
  @p_correlationID NVARCHAR(200), 
  @p_DebtCaseId NVARCHAR(MAX),
  @p_ExchangeDate date

AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'FIN.AccountSum_List_Procedure'; --Naplózás miatt a tárolt eljárás neve
	DECLARE @l_ObjectType NVARCHAR(100);
    DECLARE @l_EntityID numeric(16);
    DECLARE @l_AddressObjectID numeric(16);
    DECLARE @l_ContactObjectID numeric(16);

    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,           -- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checking parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage


SELECT        CONCAT(DebtCase.ID, AccountType.Code) AS ID, DebtCase.ID AS DebtCaseID, Calculation.ID CalculationID, AccountType.ID AccountTypeID, AccountType.Code,
                             (SELECT        sum(A.Balance)
                               FROM            FIN.Account A
                               WHERE        A.CalculationID = Calculation.ID AND A.AccountTypeID = AccountType.ID AND A.CurrencyCode = DebtCase.CurrencyCode) AS CaseCurrencyValue,
                             (SELECT        sum(A.Balance)
                               FROM            FIN.Account A
                               WHERE        A.CalculationID = Calculation.ID AND A.AccountTypeID = AccountType.ID AND A.CurrencyCode <> DebtCase.CurrencyCode AND A.CurrencyCode = 'CURRENCY_HUF') AS LocalCurrencyValue, COALESCE
                             ((SELECT        sum(A.Balance)
                                 FROM            FIN.Account A
                                 WHERE        A.CalculationID = Calculation.ID AND A.AccountTypeID = AccountType.ID AND A.CurrencyCode = DebtCase.CurrencyCode), 0) * COALESCE
                             ((SELECT        TOP 1 Rate
                                 FROM            FIN.ExchangeRate
                                 WHERE        SourceCurrencyCode = DebtCase.CurrencyCode AND TargetCurrencyCode = 'CURRENCY_HUF' AND ExchangeDate <= @p_ExchangeDate
                                 ORDER BY ExchangeDate DESC), 1) + COALESCE
                             ((SELECT        sum(A.Balance)
                                 FROM            FIN.Account A
                                 WHERE        A.CalculationID = Calculation.ID AND A.AccountTypeID = AccountType.ID AND A.CurrencyCode <> DebtCase.CurrencyCode AND A.CurrencyCode = 'CURRENCY_HUF'), 0) AS TotalInLocalCurrency
FROM            DCS.DebtCase JOIN
                         FIN.Calculation ON (DebtCase.MainCalculationID = Calculation.ID) JOIN
                         FIN.Account ON (Calculation.ID = Account.CalculationID) JOIN
                         FIN.AccountType ON (Account.AccountTypeID = AccountType.ID)
WHERE        AccountType.Code NOT IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT')
and DebtCase.ID IN (SELECT value FROM STRING_SPLIT(@p_DebtCaseId, ','))
GROUP BY DebtCase.ID, DebtCase.CurrencyCode, Calculation.ID, AccountType.ID, AccountType.Code
UNION ALL
SELECT        
                         CONCAT(DebtCase.ID, 'ACCOUNT_TYPE_TOTAL') AS ID, DebtCase.ID AS DebtCaseID, Calculation.ID CalculationID, NULL AccountTypeID, 'ACCOUNT_TYPE_TOTAL' Code,
                             (SELECT        sum(A.Balance)
                               FROM            FIN.Account A
                               WHERE        A.CalculationID = Calculation.ID AND A.CurrencyCode = DebtCase.CurrencyCode
							   AND A.AccountTypeID NOT IN (SELECT ACCTYP.ID FROM FIN.AccountType ACCTYP WHERE ACCTYP.CODE IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT'))
							   ) AS CaseCurrencyValue,
                             (SELECT        sum(A.Balance)
                               FROM            FIN.Account A
                               WHERE        A.CalculationID = Calculation.ID AND A.CurrencyCode <> DebtCase.CurrencyCode AND A.CurrencyCode = 'CURRENCY_HUF'
							   AND A.AccountTypeID NOT IN (SELECT ACCTYP.ID FROM FIN.AccountType ACCTYP WHERE ACCTYP.CODE IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT'))
							   ) AS LocalCurrencyValue, COALESCE
                             ((SELECT        sum(A.Balance)
                                 FROM            FIN.Account A
                                 WHERE        A.CalculationID = Calculation.ID AND A.CurrencyCode = DebtCase.CurrencyCode
								 AND A.AccountTypeID NOT IN (SELECT ACCTYP.ID FROM FIN.AccountType ACCTYP WHERE ACCTYP.CODE IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT'))
								 ), 0) * COALESCE
                             ((SELECT        TOP 1 Rate
                                 FROM            FIN.ExchangeRate
                                 WHERE        SourceCurrencyCode = DebtCase.CurrencyCode AND TargetCurrencyCode = 'CURRENCY_HUF' AND ExchangeDate <= @p_ExchangeDate
                                 ORDER BY ExchangeDate DESC), 1) + COALESCE
                             ((SELECT        sum(A.Balance)
                                 FROM            FIN.Account A
                                 WHERE        A.CalculationID = Calculation.ID AND A.CurrencyCode <> DebtCase.CurrencyCode AND A.CurrencyCode = 'CURRENCY_HUF'
								 AND A.AccountTypeID NOT IN (SELECT ACCTYP.ID FROM FIN.AccountType ACCTYP WHERE ACCTYP.CODE IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT'))
								 ), 0) AS TotalInLocalCurrency
FROM            DCS.DebtCase JOIN
                         FIN.Calculation ON (DebtCase.MainCalculationID = Calculation.ID) JOIN
                         FIN.Account ON (Calculation.ID = Account.CalculationID) JOIN
                         FIN.AccountType ON (Account.AccountTypeID = AccountType.ID)
where DebtCase.ID IN (SELECT value FROM STRING_SPLIT(@p_DebtCaseId, ','))
GROUP BY DebtCase.ID, DebtCase.CurrencyCode, Calculation.ID
		
		--Naplóbejegyzés a befejezésről (kötelező)
		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;                  --LogMessage
			
		--COMMIT TRAN

		RETURN 1;

	END TRY

	BEGIN CATCH
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'cursor neve');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE tenderItem_cursor;

			DEALLOCATE tenderItem_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
			
		--ROLLBACK TRAN

		SELECT 99;

	END CATCH
END
go

-- =============================================
-- Author:		Bognár Dávid
-- Create date: 2023-02-16
-- Last modified date: YYYY-MM-DD
-- Description:	Account_sum_view átírása
-- =============================================
CREATE PROCEDURE [FIN].[AccountSum_Procedure]
	-- Tárolt eljárás bemenő paraméterei
  @p_correlationID NVARCHAR(200), --Kötelező paraméter a Session kezelés miatt 
	--További szükséges bemenő paraméterek
  @p_DebtCaseId NVARCHAR(200),
  @p_ExchangeDate date

AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'LOG.GetDataChange'; --Naplózás miatt a tárolt eljárás neve
	DECLARE @l_ObjectType NVARCHAR(100);
    DECLARE @l_EntityID numeric(16);
    DECLARE @l_AddressObjectID numeric(16);
    DECLARE @l_ContactObjectID numeric(16);
	--Specifikus változók definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-okat, akkor azok definiálása (opcionális)
	--...
	--Feldolgozás kezdete (kötelező)
	--BEGIN TRAN

    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,           -- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Paraméterek ellenőrzése

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Feldolgozás. 
		--Amennyiben példányosított modul, akkor a példány feldolgozottságának frissítése az ORG.ModuleInstance.Progress mező módosítása
			

         --if @l_ObjectType = 'PRT.Entity'

SELECT        CONCAT(DebtCase.ID, AccountType.Code) AS ID, DebtCase.ID AS DebtCaseID, Calculation.ID CalculationID, AccountType.ID AccountTypeID, AccountType.Code,
                             (SELECT        sum(A.Balance)
                               FROM            FIN.Account A
                               WHERE        A.CalculationID = Calculation.ID AND A.AccountTypeID = AccountType.ID AND A.CurrencyCode = DebtCase.CurrencyCode) AS CaseCurrencyValue,
                             (SELECT        sum(A.Balance)
                               FROM            FIN.Account A
                               WHERE        A.CalculationID = Calculation.ID AND A.AccountTypeID = AccountType.ID AND A.CurrencyCode <> DebtCase.CurrencyCode AND A.CurrencyCode = 'CURRENCY_HUF') AS LocalCurrencyValue, COALESCE
                             ((SELECT        sum(A.Balance)
                                 FROM            FIN.Account A
                                 WHERE        A.CalculationID = Calculation.ID AND A.AccountTypeID = AccountType.ID AND A.CurrencyCode = DebtCase.CurrencyCode), 0) * COALESCE
                             ((SELECT        TOP 1 Rate
                                 FROM            FIN.ExchangeRate
                                 WHERE        SourceCurrencyCode = DebtCase.CurrencyCode AND TargetCurrencyCode = 'CURRENCY_HUF' AND ExchangeDate <= @p_ExchangeDate
                                 ORDER BY ExchangeDate DESC), 1) + COALESCE
                             ((SELECT        sum(A.Balance)
                                 FROM            FIN.Account A
                                 WHERE        A.CalculationID = Calculation.ID AND A.AccountTypeID = AccountType.ID AND A.CurrencyCode <> DebtCase.CurrencyCode AND A.CurrencyCode = 'CURRENCY_HUF'), 0) AS TotalInLocalCurrency
FROM            DCS.DebtCase JOIN
                         FIN.Calculation ON (DebtCase.MainCalculationID = Calculation.ID) JOIN
                         FIN.Account ON (Calculation.ID = Account.CalculationID) JOIN
                         FIN.AccountType ON (Account.AccountTypeID = AccountType.ID)
WHERE        AccountType.Code NOT IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT')
and DebtCase.ID=@p_DebtCaseId
GROUP BY DebtCase.ID, DebtCase.CurrencyCode, Calculation.ID, AccountType.ID, AccountType.Code
UNION ALL
SELECT        
                         CONCAT(DebtCase.ID, 'ACCOUNT_TYPE_TOTAL') AS ID, DebtCase.ID AS DebtCaseID, Calculation.ID CalculationID, NULL AccountTypeID, 'ACCOUNT_TYPE_TOTAL' Code,
                             (SELECT        sum(A.Balance)
                               FROM            FIN.Account A
                               WHERE        A.CalculationID = Calculation.ID AND A.CurrencyCode = DebtCase.CurrencyCode
							   AND A.AccountTypeID NOT IN (SELECT ACCTYP.ID FROM FIN.AccountType ACCTYP WHERE ACCTYP.CODE IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT'))
							   ) AS CaseCurrencyValue,
                             (SELECT        sum(A.Balance)
                               FROM            FIN.Account A
                               WHERE        A.CalculationID = Calculation.ID AND A.CurrencyCode <> DebtCase.CurrencyCode AND A.CurrencyCode = 'CURRENCY_HUF'
							   AND A.AccountTypeID NOT IN (SELECT ACCTYP.ID FROM FIN.AccountType ACCTYP WHERE ACCTYP.CODE IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT'))
							   ) AS LocalCurrencyValue, COALESCE
                             ((SELECT        sum(A.Balance)
                                 FROM            FIN.Account A
                                 WHERE        A.CalculationID = Calculation.ID AND A.CurrencyCode = DebtCase.CurrencyCode
								 AND A.AccountTypeID NOT IN (SELECT ACCTYP.ID FROM FIN.AccountType ACCTYP WHERE ACCTYP.CODE IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT'))
								 ), 0) * COALESCE
                             ((SELECT        TOP 1 Rate
                                 FROM            FIN.ExchangeRate
                                 WHERE        SourceCurrencyCode = DebtCase.CurrencyCode AND TargetCurrencyCode = 'CURRENCY_HUF' AND ExchangeDate <= @p_ExchangeDate
                                 ORDER BY ExchangeDate DESC), 1) + COALESCE
                             ((SELECT        sum(A.Balance)
                                 FROM            FIN.Account A
                                 WHERE        A.CalculationID = Calculation.ID AND A.CurrencyCode <> DebtCase.CurrencyCode AND A.CurrencyCode = 'CURRENCY_HUF'
								 AND A.AccountTypeID NOT IN (SELECT ACCTYP.ID FROM FIN.AccountType ACCTYP WHERE ACCTYP.CODE IN ('ACCOUNT_TYPE_BOOK_VALUE', 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT'))
								 ), 0) AS TotalInLocalCurrency
FROM            DCS.DebtCase JOIN
                         FIN.Calculation ON (DebtCase.MainCalculationID = Calculation.ID) JOIN
                         FIN.Account ON (Calculation.ID = Account.CalculationID) JOIN
                         FIN.AccountType ON (Account.AccountTypeID = AccountType.ID)
where DebtCase.ID=@p_DebtCaseId
GROUP BY DebtCase.ID, DebtCase.CurrencyCode, Calculation.ID


		
		--Naplóbejegyzés a befejezésről (kötelező)
		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;                  --LogMessage
			
		--COMMIT TRAN

		RETURN 1;

	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'cursor neve');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE tenderItem_cursor;

			DEALLOCATE tenderItem_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
			
		--ROLLBACK TRAN

		SELECT 99;

	END CATCH
END
go

-- =============================================
-- Author:		Bognár Dávid
-- Create date: 2022-11-23
-- Last modified date: YYYY-MM-DD
-- Description:	Update Account data
-- =============================================
CREATE   PROCEDURE [FIN].[AccountTransactionList]
	-- Tárolt eljárás bemenő paraméterei
  @p_correlationID NVARCHAR(200), --Kötelező paraméter a Session kezelés miatt 
	--További szükséges bemenő paraméterek
  @p_DebtCaseID numeric(16), 
  @p_AccountDate date
  --@p_Amount numeric(16), 
  --@p_CurrencyCode nvarchar(16)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'LOG.GetDataChange'; --Naplózás miatt a tárolt eljárás neve
	DECLARE @l_ObjectType NVARCHAR(100);
    DECLARE @l_EntityID numeric(16);
    DECLARE @l_AddressObjectID numeric(16);
    DECLARE @l_ContactObjectID numeric(16);
	--Specifikus változók definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-okat, akkor azok definiálása (opcionális)
	--...
	--Feldolgozás kezdete (kötelező)
	--BEGIN TRAN

    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,           -- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Paraméterek ellenőrzése

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Feldolgozás. 
		--Amennyiben példányosított modul, akkor a példány feldolgozottságának frissítése az ORG.ModuleInstance.Progress mező módosítása
			
        SELECT FIN.Account.ID,
			FIN.Invoice.InvoiceNr,
			(SELECT GEN.Translation.Text
				FROM GEN.Translation
					JOIN GEN.Code ON GEN.Code.ID = GEN.Translation.CodeID
				WHERE GEN.Code.ID = FIN.AccountType.Code AND GEN.Translation.Language = 'HU') AS Code,
			(SELECT GEN.Translation.Text
				FROM GEN.Translation
					JOIN GEN.Code ON GEN.Code.ID = GEN.Translation.CodeID
				WHERE GEN.Code.ID = FIN.AccountType.MainClass AND GEN.Translation.Language = 'HU') AS MainClass,
			coalesce((SELECT SUM(FIN.[Transaction].Amount)
				FROM FIN.[Transaction]
					WHERE FIN.[Transaction].AccountID = FIN.Account.ID
					and BankValueDate<=@p_AccountDate),0) AS Amount,
					--FIN.Account.Balance as Amount,
					FIN.AccountType.AccountNr as AccountNr,
			(SELECT GEN.Translation.Text
				FROM GEN.Translation
					JOIN GEN.Code ON GEN.Code.ID = GEN.Translation.CodeID
				WHERE GEN.Code.ID = FIN.Account.CurrencyCode AND GEN.Translation.Language = 'HU') AS Currency,
			FIN.Invoice.DebtCaseID
		FROM FIN.Invoice
			LEFT JOIN FIN.InvoiceArrears ON FIN.InvoiceArrears.InvoiceID = FIN.Invoice.ID
			left join FIN.Account ON FIN.Account.InvoiceArrearsID = FIN.InvoiceArrears.ID
			LEFT JOIN FIN.AccountType ON FIN.AccountType.ID = FIN.Account.AccountTypeID

			where DebtCaseID=@p_DebtCaseID

			union all

	SELECT FIN.Account.ID,
		   null as InvoiceNr,
			(SELECT GEN.Translation.Text
				FROM GEN.Translation
					JOIN GEN.Code ON GEN.Code.ID = GEN.Translation.CodeID
				WHERE GEN.Code.ID = FIN.AccountType.Code AND GEN.Translation.Language = 'HU') AS Code,
			(SELECT GEN.Translation.Text
				FROM GEN.Translation
					JOIN GEN.Code ON GEN.Code.ID = GEN.Translation.CodeID
				WHERE GEN.Code.ID = FIN.AccountType.MainClass AND GEN.Translation.Language = 'HU') AS MainClass,
				FIN.Account.Balance as Amount,
				FIN.AccountType.AccountNr,
			 (SELECT GEN.Translation.Text
				FROM GEN.Translation
					JOIN GEN.Code ON GEN.Code.ID = GEN.Translation.CodeID
				WHERE GEN.Code.ID = FIN.Account.CurrencyCode AND GEN.Translation.Language = 'HU') AS Currency,
				
			DCS.DebtCase.ID as DebtCaseID 

   
	   from dcs.DebtCase 
				LEFT JOIN FIN.Account on FIN.Account.CalculationID=DCS.DebtCase.MainCalculationID
				LEFT JOIN FIN.AccountType ON FIN.AccountType.ID = FIN.Account.AccountTypeID
 
           where dcs.DebtCase.ID=@p_DebtCaseID
             and InvoiceArrearsID is null

			return

		
		--Naplóbejegyzés a befejezésről (kötelező)
		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;                  --LogMessage
			
		--COMMIT TRAN

		RETURN 1;

	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'cursor neve');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE tenderItem_cursor;

			DEALLOCATE tenderItem_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
			
		--ROLLBACK TRAN

		RETURN 99;

	END CATCH
END
go

CREATE       PROCEDURE [IFC].[AddressLoader](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16), @p_moduleInstanceIDInkasso Numeric(16) = null output)

/*
==========================================================================================
 Author:				Tóth Gábor
 Creation date:			2022.10.17.
 Last modified date:	2022.11.01.
						2022.11.02: ObjectType, AppUser, InterfaceStatus=NULL, Return, Errormessage
						2022.11.08: InterfaceStatusCode, LOG
						2022-11-09: @p_moduleInstanceID, Átnevezés, 999 -> 99
						2022-11-13: "Demo" mód törlése, "SourceInterfaceType" <-> "MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE" csere, EntityID másképp kezelése, SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
						2022-11-16: GEN.getAddressSplitted <- nem lett beépítve, mert nem lett jó a címek szétbontása
						2022-11-18: Kód ellenorzés, CountryID kikeresés országné alapján
						2022-11-19: @l_EntityID azonosítás, az elozo cím "VALIDUNTIL" beállítása
						2022-11-22: @l_AddressType <-- @AddressType, IFC.CrefoID <-- IFC.PersonID
						2022-11-29: Left(Housenr, 8)
						2022-11-29: StatusCode = 'STATUS_NORMAL'
						2022-11-30: PersonID <-> CrefoId
						2022-12-08: @l_AssetID
						2022-12-08: SourceAssetID, SourceAssetID, AddressStructure, District, PublicPlaceName, PublicPlaceType,
						2022-12-08: PublicPlaceTypeText, LandRegisterReference,	Staircase, Building, [Floor], [Door]
						2022-12-09: cursor: @SourceAssetID
						2022-12-14: "IF @l_EntityID = 0 AND @l_AssetID = 0" helyett: "IF @l_EntityID = NULL AND @l_AssetID = NULL"
						2022-12-14: 'SourceCompanyID / SourcePersonID / SourceAssetID is Empty')
						2022-12-16: @CurrentUserID<->@CurrentUserName
						2023-01-17: (SourceCompanyID, SourcePersonID) + címtípus meghatározás átvétele az IFC.TA_FC_Loader-bol
						2023-01-18: '= NULL' helyett 'is NULL'
						2023-01-24: TAFC06 --> AddressType id not valid
						2023-01-25: StatusCode = 'STATUS_DELETED'
						2023-01-27: SELECT CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID
						2023-02-02: ELSE @AddressType
						2023-02-02: @AddressStructure
						2023-02-08: DataOriginCode
						2023-02-16: @l_DataOriginCode
						2023-02-16: @AddressStructure
						2023-02-21: Hibakezelés
						2023-02-22: SET @AddressStructure = 'SPECIAL_ADDRESS_STRUCTURE_NORMAL'
						2023-03-01: Errormessage vesszővel lettek elválasztva
						2023-03-06: ValueSET ellenőrzés: COUNTRY, ADDRESS_TYPE
						2023-03-11: Address-Splitter
						2023-03-13: Címek szétbontása
						2023-03-14: Címek szétbontása + IFCError-tábla töltése + Irányítószámok validálása
						2023-03-17: PUBLIC_PLACE_TYPE_ErrorMessage
						2023-03-22: Cím szétszedés '-2' ->> '-1'
						2023.03.27: ErrorCode-ok, ObjectType
						2023.03.30: @l_PublicPlaceTypeText
						2023.03.30: @l_ErrorMessage, irányítószám-város
						2023.04.14: @PUBLIC_PLACE_TYPE_ErrorMessage, @ADDRESSCONFLICT_ErrorMessage hibák "beengedése", de "TAG"-elése
						2023.06.01: IF @TAAllomany = 'T', IF Isnull(@PublicPlaceTypeText,'') = '' AND Isnull(@PublicPlaceType,'') = ''  -- 2023-06-01
						2023.09.29: @HouseNr helyett @l_HouseNr
						2023.10.31: Egyező címek "megtalálása" hibás volt, javításra került --> INTERFACE_STATUS_IDENTIFIED
						2023.10.31: PRT.Address.PublicPlaceType értékének javítása. --> Szöveg helyet a kód került bele.
						2023.11.03: Inkasso szinkron DV-1592
						2023.11.27: Inkasso szinkron jav. DV-1592
						2023.11.29: @ADDRESSCONFLICT_ErrorMessage = 'T' then 'STATUS_DELETED', DV-1877
						2023.12.01: Hibakezelés DV-1936
						2023.12.09: "AND Isnull(SourceAssetID,'') = ''",  DV-1960
						2023.12.10: "InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'",  DV-1956
						2023.12.12: AssetID kivétele. Az Asset-ekhez tartozó címeket az IFC.AssetLoader tölti be
            2023.12.12: Inkasso szinkron ellenőrzés módosítás DV-1775
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(MAX);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	DECLARE @ValueSetId numeric(16);
	DECLARE @FieldCodeOut nvarchar(200);

	DECLARE @l_RefertencedObjectID numeric(16);
	DECLARE @PUBLIC_PLACE_TYPE_ErrorMessage nvarchar(500);
	DECLARE @ADDRESSCONFLICT_ErrorMessage nvarchar(500);

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	DECLARE @l_BlockerError nvarchar(1);
	-- ha van blokkoló hiba, akkor @l_BlockerError = 'T',
	-- InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_BLOCKING', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	-- ha csak kritikus hiba van, akkor @l_BlockerError = 'T',
	-- InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	--DECLARE @l_Prev_ModuleInstanceID Numeric(16);
	DECLARE @l_ErrorMessage nvarchar(MAX);

	SET @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
	--SET @l_Prev_ModuleInstanceID = (Select Top 1 ModuleInstanceID from IFC.InterfaceError where TableName = 'IFC.Address' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' order by id desc);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AddressLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);


    --BEGIN TRANSACTION /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/

    BEGIN TRY
        SET @LogMessage = 'AddressLoader Started at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;

-----------------------------------------------
		DECLARE @ID NUMERIC(16);
		DECLARE @ObjectID NUMERIC(16);
		DECLARE @SourceInterfaceType NVARCHAR(30);
		DECLARE @SourceID NVARCHAR(200);
		DECLARE @SourceCompanyID NVARCHAR(200);
		DECLARE @SourcePersonID NVARCHAR(200);
		DECLARE @RegistrationNr NVARCHAR(30);
		DECLARE @TaxNr NVARCHAR(30);
		DECLARE @StatisticalNr NVARCHAR(30);
		DECLARE @AddressType NVARCHAR(200);
		DECLARE @Country NVARCHAR(250);
		DECLARE @CountryCode NVARCHAR(200);
		DECLARE @CountryID NVARCHAR(200);
		DECLARE @ZipCode NVARCHAR(250);
		DECLARE @City NVARCHAR(250);
		DECLARE @Street NVARCHAR(250);
		DECLARE @HouseNr NVARCHAR(250);
		DECLARE @FullAddress NVARCHAR(250);
		DECLARE @Description NVARCHAR(250);
		DECLARE @ValidFrom DATE;
		DECLARE @ValidUntil DATE;
		DECLARE @Field1 NVARCHAR(250);
		DECLARE @Field2 NVARCHAR(250);
		DECLARE @Field3 NVARCHAR(250);
		DECLARE @Field4 NVARCHAR(250);
		DECLARE @Field5 NVARCHAR(250);
		DECLARE @CrefoID NUMERIC(16);
		DECLARE @InterfaceStatusCode NVARCHAR(1);

		DECLARE @ActualisationDate DATE;
		DECLARE @Operation NVARCHAR(1);
		DECLARE @InterfaceTableID NUMERIC(16);
		DECLARE @MainAddress NVARCHAR(1);
		DECLARE @CreationDate DATE;
		DECLARE @CreationTime TIME;
		DECLARE @CreationUserName NUMERIC(16);
		DECLARE @AddressStructure VARCHAR(50);
		DECLARE @CountryClassCode NVARCHAR(200);
		DECLARE @PublicPlaceName VARCHAR(50);
		DECLARE @PublicPlaceType NVARCHAR(200);
		DECLARE @PublicPlaceTypeText NVARCHAR(200);
		DECLARE @LandRegisterReference NVARCHAR(20);
		DECLARE @Staircase NVARCHAR(10);
		DECLARE @Building NVARCHAR(50);
		DECLARE @Floor NVARCHAR(10);
		DECLARE @Door NVARCHAR(10);
		DECLARE @District NVARCHAR(200);
		DECLARE @Comments NVARCHAR(MAX);

		DECLARE @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja

		DECLARE @l_AllRowCounts numeric(18);
		DECLARE @l_ImportedRowCounts numeric(18);
		DECLARE @l_ExisingRowCounts numeric(18);
		DECLARE @l_ErrorRowCounts numeric(18);
		DECLARE @l_AddressID numeric(18);
		DECLARE @l_EntityID numeric(18);
		DECLARE @l_ObjectID numeric(18);
		--DECLARE @l_AssetID numeric(18);


		DECLARE @l_Settlement NVARCHAR(50);
		DECLARE @l_District NVARCHAR(50);
		DECLARE @l_PublicPlaceName NVARCHAR(50);
		DECLARE @l_PublicPlaceType NVARCHAR(50);
		DECLARE @l_LandRegisterReference NVARCHAR(20);
		DECLARE @l_Staircase NVARCHAR(10);
		DECLARE @l_Building NVARCHAR(50);
		DECLARE @l_HouseNr NVARCHAR(10);
		DECLARE @l_Floor NVARCHAR(10);
		DECLARE @l_Door NVARCHAR(10);
		--DECLARE @l_Status NVARCHAR(10);
		DECLARE @l_PropertyID Numeric(16);
		DECLARE @l_DataSource NVARCHAR(200);
		DECLARE @l_PublicPlaceTypeText NVARCHAR(200);

		--DECLARE @SourceAssetID NvarChar(200);

		DECLARE @splitted_PublicPlaceName nvarchar(200);
		DECLARE @splitted_PublicPlaceType nvarchar(200);
		DECLARE @splitted_PublicPlaceTypeText nvarchar(200);
		DECLARE @splitted_HouseNr nvarchar(200);
		DECLARE @splitted_Building nvarchar(200);
		DECLARE @splitted_Staircase nvarchar(200);
		DECLARE @splitted_Floor nvarchar(200);
		DECLARE @splitted_Door nvarchar(200);

		DECLARE @l_PortfolioID Numeric(16);
		DECLARE @l_DataOriginCode nvarchar(200);

		DECLARE @l_Index numeric(5);
		DECLARE @i numeric(10);
		DECLARE @M_Result nvarchar(500);
		DECLARE @l_TagID numeric(16);
		DECLARE @TAAllomany nvarchar(1); /* értéke 'F', ha nem TA-s a betöltendő állomány, 'T'-s ha TA-s állomány */

		DECLARE @PRTAddress nVarchar(500);

    DECLARE @l_InkassoSyncOn int = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'Address', 'insert')
    DECLARE @inactivatedAddress table(addressID Numeric(16))
    DECLARE @inkassoAddressID Numeric(16)

		DECLARE @ERR_SIFTYPE_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SIFTYPE_CANNOT_BE_EMPTY = 'ERR_GENERAL';						-- SourceInterfaceTpye is empty
		DECLARE @ERR_SIDCANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SIDCANNOT_BE_EMPTY = 'ERR_GENERAL';							-- SourceID is Empty
		DECLARE @ERR_SourceCompanyID_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SourceCompanyID_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_SourcePersonID_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SourcePersonID_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		--DECLARE @ERR_SourceAssetID_CANNOT_BE_EMPTY nvarchar(200);
		--	SET @ERR_SourceAssetID_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_Country_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_Country_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_CountryCode_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_CountryCode_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_AddressType_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_AddressType_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_AddressType_NOT_VALID_FOR_COMPANY nvarchar(200);
			SET @ERR_AddressType_NOT_VALID_FOR_COMPANY = 'ERR_GENERAL';
		DECLARE @ERR_AddressType_NOT_VALID_FOR_PERSON nvarchar(200);
			SET @ERR_AddressType_NOT_VALID_FOR_PERSON = 'ERR_GENERAL';
		DECLARE @ERR_AddressType_NOT_VALID_FOR_ASSET nvarchar(200);
			SET @ERR_AddressType_NOT_VALID_FOR_ASSET = 'ERR_GENERAL';
		DECLARE @ERR_NOT_FOUND_ASSIGNED_ENTITY nvarchar(200);
			SET @ERR_NOT_FOUND_ASSIGNED_ENTITY = 'ERR_GENERAL';
		DECLARE @ERR_NOT_FOUND_ASSIGNED_ASSET nvarchar(200);
			SET @ERR_NOT_FOUND_ASSIGNED_ASSET = 'ERR_GENERAL';
		DECLARE @ERR_addressStructure_NOT_VALID nvarchar(200);
			SET @ERR_addressStructure_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_City_ZipCode_NOT_VALID nvarchar(200);
			SET @ERR_City_ZipCode_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_publicPlaceTypeText_NOT_VALID nvarchar(200);
			SET @ERR_publicPlaceTypeText_NOT_VALID = 'ERR_GENERAL';

		SET @PRTAddress = (Select Top 1 Code from GEN.ObjectType where TableName = 'PRT.ADDRESS' order by TableName desc);

		SET @l_AllRowCounts = 0;
		SET @l_ImportedRowCounts = 0;
		SET @l_ExisingRowCounts = 0;
		SET @l_ErrorRowCounts = 0;

		SET @l_TagID = (SELECT Top 1 ID from GEN.Tag where Tag.Label = 'Hibás cím' AND ValidUntil is NULL order by ID desc);

		SET @l_AllRowCounts = (Select Count(*)
							FROM IFC.Address
					where Address.SourceInterfaceType = @l_sourceInterfaceType
							AND Isnull(SourceAssetID,'') = ''
							AND
								(
								(Address.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
								or
								(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
								and Address.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Address' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
								));

		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END

		IF COALESCE(@l_sourceInterfaceType, '') = ''
			RAISERROR('The SourceInterfaceType field is not defined in ModuleInstance !', 16, 1);


		DECLARE db_cursor CURSOR FOR
		SELECT ID, ObjectID, SourceInterfaceType, SourceID, SourceCompanyID, SourcePersonID, RegistrationNr, TaxNr, StatisticalNr,
			AddressType, Country, CountryCode, CountryID, ZipCode, City, Street, HouseNr, FullAddress, [Description], ValidFrom, ValidUntil,
			Field1, Field2, Field3, Field4, Field5, CrefoID, InterfaceStatusCode, /*ErrorMessage,*/ ActualisationDate, [Operation], InterfaceTableID,
			MainAddress,
			/*SourceAssetID,*/ AddressStructure, District, PublicPlaceName, PublicPlaceType, PublicPlaceTypeText, LandRegisterReference,
			Staircase, Building, [Floor], [Door]
		FROM IFC.Address
		where Address.SourceInterfaceType = @l_sourceInterfaceType
				AND Isnull(SourceAssetID,'') = ''
				AND
					(
					(Address.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(Address.InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Address.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Address' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
		Order by Address.ID;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor
		INTO @ID, @ObjectID, @SourceInterfaceType, @SourceID, @SourceCompanyID, @SourcePersonID, @RegistrationNr, @TaxNr, @StatisticalNr,
			@AddressType, @Country, @CountryCode, @CountryID, @ZipCode, @City, @Street, @HouseNr, @FullAddress, @Description, @ValidFrom, @ValidUntil,
			@Field1, @Field2, @Field3, @Field4, @Field5, @CrefoID, @InterfaceStatusCode, /*@ErrorMessage,*/ @ActualisationDate, @Operation, @InterfaceTableID,
			@MainAddress,
			/*@SourceAssetID, */@AddressStructure, @District, @PublicPlaceName, @PublicPlaceType, @PublicPlaceTypeText, @LandRegisterReference,
			@Staircase, @Building, @Floor, @Door


		WHILE @@FETCH_STATUS = 0
		BEGIN

			SET @l_ImportID = 0;
			SET @l_EntityID = NULL;
			--SET @l_AssetID = NULL;

      delete from @inactivatedAddress

			SET @SourceID = TRIM(@SourceID);
			SET @PUBLIC_PLACE_TYPE_ErrorMessage = '';
			SET @ADDRESSCONFLICT_ErrorMessage = '';
  BEGIN TRY /* Belső-1 */

---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Error Section:
		SET @ErrorMessage = NULL;
		SET @l_BlockerError = '';
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceInterfaceType:
			If Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceInterfaceType is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'sourceInterfaceType', @ERR_SIFTYPE_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceID:
			If Trim(Isnull(@SourceID,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'sourceID', @ERR_SIDCANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceCompanyID, @SourcePersonID:
			IF TRIM(ISNULL(@SourceCompanyID,''))  = '' AND TRIM(ISNULL(@SourcePersonID,''))  = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceCompanyID / SourcePersonID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'sourceCompanyID', @ERR_SourceCompanyID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'sourcePersonID', @ERR_SourcePersonID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- @Country,@CountryCode:
			-- 0 - NULL:
			IF TRIM(ISNULL(@Country,'')) = ''
				SET @Country = NULL;
			IF TRIM(ISNULL(@CountryCode,'')) = ''
				SET @CountryCode = NULL;
			SET @Country = TRIM(@Country);
			SET @CountryCode = TRIM(@CountryCode);

			-- 1 - Üres:
			IF @Country is NULL AND @CountryCode is NULL
			BEGIN
				SET @ErrorMessage = @ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			IF @Country is NOT NULL AND @CountryCode is NULL
			BEGIN
				IF Not exists (
						SELECT 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'COUNTRY'
						AND Translation.Text = @Country)
					BEGIN
						Set @l_ErrorMessage = 'Country is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'country', @ERR_Country_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @Country = NULL;
						SET @l_BlockerError = 'T';
					END;
				Else
					SET @CountryCode = (SELECT Top 1 Code.Id
							from Gen.ValueSet
							left Join Gen.Code on Code.ValueSetID = ValueSet.Id
							left join Gen.Translation on Translation.CodeID = Code.Id
							where CodePrefix = 'COUNTRY'
							AND Translation.Text = @Country order by Id Desc);
			END;
			-- 3 - Code-NotValid:
			IF @Country is NULL AND @CountryCode is not NULL
			AND Not exists (SELECT 1
							from Gen.ValueSet
							left Join Gen.Code on Code.ValueSetID = ValueSet.Id
							left join Gen.Translation on Translation.CodeID = Code.Id
							where CodePrefix = 'COUNTRY'
							AND Code.Id = @CountryCode)
			BEGIN
						Set @l_ErrorMessage = 'CountryCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'countryCode', @ERR_CountryCode_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @CountryCode = NULL;
						SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- AddressType:
		Set @TAAllomany = 'F'; /* Excel-es */
		IF TRIM(ISNULL(@AddressType,''))  = ''
		BEGIN
						Set @l_ErrorMessage = 'AddressType is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'addressType', @ERR_AddressType_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;
		ELSE
		BEGIN

			IF @AddressType not like 'TAFC%'
			BEGIN

				IF TRIM(ISNULL(@AddressType,''))  <> '' AND TRIM(ISNULL(@SourceCompanyID,''))  <> ''
				BEGIN
					IF not exists (SELECT 1 from Gen.Code where Id Like 'ADDRESS_TYPE_COMPANY_%' AND id = @AddressType)
					Begin
						Set @l_ErrorMessage = 'AddressType is not valid (Company)';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'addressType', @ERR_AddressType_NOT_VALID_FOR_COMPANY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						SET @AddressType = NULL;
					End;
				END;

				IF TRIM(ISNULL(@AddressType,''))  <> '' AND TRIM(ISNULL(@SourcePersonID,''))  <> ''
				BEGIN
					IF not exists (SELECT 1 from Gen.Code where Id Like 'ADDRESS_TYPE_PERSON_%' AND id = @AddressType)
					Begin
						Set @l_ErrorMessage = 'AddressType is not valid (Person)';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'addressType', @ERR_AddressType_NOT_VALID_FOR_PERSON, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						SET @AddressType = NULL;
					End;
				END;

			END; /* @AddressType not like 'TAFC%' */
			/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


		SET @l_EntityID = NULL;

		IF exists (SELECT 1 from IFC.Company WHERE SourceInterfaceType = @SourceInterfaceType AND Company.SourceID = @SourceCompanyID AND InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED'))
		Begin

			SET @l_EntityID = (SELECT Top 1 Company.CrefoId from IFC.Company WHERE SourceInterfaceType = @SourceInterfaceType AND Company.SourceID = @SourceCompanyID AND InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by Id desc);
			IF @AddressType like 'TAFC%'
			BEGIN
				SET @AddressType = Case @AddressType
					When 'TAFC01' Then 'ADDRESS_TYPE_COMPANY_HEADQUARTERS'
					When 'TAFC03' Then 'ADDRESS_TYPE_COMPANY_HEADQUARTERS'
					When 'TAFC05' Then 'ADDRESS_TYPE_COMPANY_MAILING'
					When 'TAFC07' Then 'ADDRESS_TYPE_COMPANY_MAILING'
					ELSE NULL
				End;
				Set @TAAllomany = 'T';
				IF not exists (SELECT 1 from Gen.Code where id like 'ADDRESS_TYPE_COMPANY_%' AND id = @AddressType) or @AddressType is NULL
				Begin
						Set @l_ErrorMessage = 'AddressType is not valid (Company)';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'addressType', @ERR_AddressType_NOT_VALID_FOR_COMPANY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						SET @AddressType = NULL;
				End;
			END;
		End;


		IF exists (SELECT 1 from IFC.Person WHERE SourceInterfaceType = @SourceInterfaceType AND Person.SourceID = @SourcePersonID AND InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED'))
		Begin

			SET @l_EntityID = (SELECT Top 1 Person.CrefoId from IFC.Person WHERE SourceInterfaceType = @SourceInterfaceType AND Person.SourceID = @SourcePersonID AND InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by Id desc);
			IF @AddressType like 'TAFC%'
			BEGIN

				SET @AddressType = Case @AddressType
					When 'TAFC01' Then 'ADDRESS_TYPE_PERSON_PERMANENT'
					When 'TAFC03' Then 'ADDRESS_TYPE_PERSON_PERMANENT'
					When 'TAFC05' Then 'ADDRESS_TYPE_PERSON_RESIDENCE'
					When 'TAFC07' Then 'ADDRESS_TYPE_PERSON_RESIDENCE'
					ELSE NULL
				End;
				Set @TAAllomany = 'T';
				IF not exists (SELECT 1 from Gen.Code where id like 'ADDRESS_TYPE_PERSON_%' AND id = @AddressType) or @AddressType is NULL
				Begin
						Set @l_ErrorMessage = 'AddressType is not valid (Person)';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'addressType', @ERR_AddressType_NOT_VALID_FOR_PERSON, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						SET @AddressType = NULL;
				End;

			END;
		End;

		/*
		IF @l_EntityID is NULL
		BEGIN
			IF exists(SELECT 1 from AST.Asset where Asset.SourceInterfaceType = @SourceInterfaceType AND Asset.SourceID = @SourceAssetID)
			Begin
				SET @l_AssetID = (SELECT Top 1 Asset.Id from AST.Asset where Asset.SourceInterfaceType = @SourceInterfaceType AND Asset.SourceID = @SourceAssetID order by Asset.Id desc);
			End;
		END;
		*/

		IF @l_EntityID is NULL
		BEGIN
						Set @l_ErrorMessage = 'Entity/Asset is not found';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'sourcePersonID', @ERR_NOT_FOUND_ASSIGNED_ENTITY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'sourceCompanyID', @ERR_NOT_FOUND_ASSIGNED_ENTITY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;


		END; /* TRIM(ISNULL(@AddressType,''))  = '' */
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- @AddressStructure:
		IF TRIM(ISNULL(@AddressStructure,'')) <> ''
		Begin
			IF not exists(
						SELECT 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'SPECIAL_ADDRESS_STRUCTURE'
						AND Code.id = @AddressStructure)
				AND not exists(
						SELECT 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'SPECIAL_ADDRESS_STRUCTURE'
						AND Translation.Text = @AddressStructure)
				Begin
						Set @l_ErrorMessage = 'AddressStructure is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'addressStructure', @ERR_addressStructure_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
				End;
			Else
				IF exists(
						SELECT 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'SPECIAL_ADDRESS_STRUCTURE'
						AND Translation.Text = @AddressStructure)
					SET @AddressStructure = (SELECT Top 1 Code.Id
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'SPECIAL_ADDRESS_STRUCTURE'
						AND Translation.Text = @AddressStructure order by Code.Id desc);
			End; -- IF not exists
		Else -- IF TRIM(ISNULL(@AddressStructure,'')) <> ''
			SET @AddressStructure = 'SPECIAL_ADDRESS_STRUCTURE_NORMAL';

-- End of @AddressStructure:
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------




---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
/*
-- @PublicPlaceTypeText -- Excel-es
		--IF @TAAllomany = 'F' -- Excel-es
		--BEGIN
			-- 1 - Üres:
			IF Isnull(@PublicPlaceTypeText,'') = '' AND Isnull(@PublicPlaceType,'') = ''
			BEGIN
				SET @PUBLIC_PLACE_TYPE_ErrorMessage = 'T';
				-- SET @ErrorMessage = TRIM(ISNULL(@ErrorMessage,'') + ' PublicPlaceTypeText/PublicPlaceType are Empty,,');
				-- Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				-- Select 'IFC.ADDRESS', @ID, 'publicPlaceTypeText', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				-- Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				-- Select 'IFC.ADDRESS', @ID, 'publicPlaceType', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
			END;
			-- 2 - Text-NotValid:
			IF Isnull(@PublicPlaceTypeText,'') <> '' AND Isnull(@PublicPlaceType,'') = ''
			BEGIN
				IF Not exists (
						SELECT 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'PUBLIC_PLACE_TYPE'
						AND Translation.Text = @PublicPlaceTypeText)
					BEGIN
						--SET @ErrorMessage = TRIM(ISNULL(@ErrorMessage,'') + ' PublicPlaceTypeText is not Valid,');
						SET @PUBLIC_PLACE_TYPE_ErrorMessage = 'T';
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
						Select 'IFC.ADDRESS', @ID, 'publicPlaceTypeText', @ERR_CODE_NAME_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
					END;
				Else
					SET @PublicPlaceType = (SELECT Top 1 Code.Id
							from Gen.ValueSet
							left Join Gen.Code on Code.ValueSetID = ValueSet.Id
							left join Gen.Translation on Translation.CodeID = Code.Id
							where CodePrefix = 'PUBLIC_PLACE_TYPE'
							AND Translation.Text = @PublicPlaceTypeText order by Id Desc);
			END;
			-- 3 - Code-NotValid:
			IF Isnull(@PublicPlaceTypeText,'') = '' AND Isnull(@PublicPlaceType,'') <> ''
			AND Not exists (SELECT 1
							from Gen.ValueSet
							left Join Gen.Code on Code.ValueSetID = ValueSet.Id
							left join Gen.Translation on Translation.CodeID = Code.Id
							where CodePrefix = 'PUBLIC_PLACE_TYPE'
							AND Code.Id = @PublicPlaceType)
			BEGIN
				--SET @ErrorMessage = TRIM(ISNULL(@ErrorMessage,'') + ' PublicPlaceType is not Valid,');
				SET @PUBLIC_PLACE_TYPE_ErrorMessage = 'T';
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select 'IFC.ADDRESS', @ID, 'publicPlaceType', @ERR_CODE_CODE_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
			END;
		--END; -- IF @TAAllomany = 'F'

-- End if @PublicPlaceTypeText -- Excel-es
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
*/

-- Hibakiírás:

		IF @l_BlockerError = 'T'
		BEGIN
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			UPDATE IFC.Address SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage,
				LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName	WHERE ID = @ID;
		END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Betöltés:
		IF @l_BlockerError = ''
		BEGIN
			SET @l_PortfolioID = 0;
			SET @l_DataOriginCode = NULL;

			SET @l_PortfolioID = (SELECT Top 1 Object.PortfolioID from Prt.Entity
							Join Gen.Object on Object.ID = Entity.ObjectID
							where Entity.Id = @l_EntityID order by Object.ID desc);
			SELECT @l_DataOriginCode =
				CASE (SELECT TreatmentTypeCode from Gen.Portfolio where Id = @l_PortfolioID)
					WHEN 'TREATMENT_TYPE_MANDATE' THEN 'DATA_ORIGIN_PRINCIPAL' /* Megbízásos */
					WHEN 'TREATMENT_TYPE_ASSIGNMENT' THEN 'DATA_ORIGIN_LEGAL_PREDECESSOR'  /* Engedményzett */
					ELSE 'DATA_ORIGIN_LEGAL_PREDECESSOR' /* Engedményzett */
				END;


---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Irányítószám ellenőrzés:
		IF Not Exists (select 1 /*CityZipCode.ZipCode, City.City*/ from Gen.City
						join Gen.CityZipCode on CityZipCode.CityID = City.ID
						where City.CountryCode = City.CountryCode /*@CountryCode*/
						and City.City = @City
						and CityZipCode.ZipCode = @ZipCode)
		BEGIN
						Set @l_ErrorMessage = 'AddressStructure is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'city', @ERR_City_ZipCode_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.ADDRESS', @ID, 'zipCode', @ERR_City_ZipCode_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
		END;
-- End of Irányítószám ellenőrzés:
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------

---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Address:
				IF @TAAllomany = 'T'
				BEGIN

					SET @Street = TRIM(@Street
						+ ' ' + TRIM(TRIM(ISNULL(@HouseNr,''))
						+ ' ' + TRIM(TRIM(ISNULL(@Building,''))
						+ ' ' + TRIM(TRIM(ISNULL(@Staircase,''))
						+ ' ' + TRIM(TRIM(ISNULL(@Floor,''))
						+ ' ' + TRIM(ISNULL(@Door,'')))))));

--------------------------------------------------------------------------------------------------------------------
	-- címek szétbontása:
					SET @splitted_PublicPlaceTypeText = NULL;
					SET @splitted_PublicPlaceName = NULL;
					SET @splitted_HouseNr = NULL;
					SET @i=1;
					SET @M_Result = '';
					while(@i <= len(@Street))
					begin /*loop*/
						IF (substring(@Street, @i, 1) like '[0-9]')
							or (substring(@Street, @i, 1) like '[a-z]')
							or (substring(@Street, @i, 1) like '[A-Z]')
							or (CharIndex(substring(@Street, @i, 1), 'áéiíoóöőuúüűÁÉIÍOÓÖŐUÚÜŰ,!? (),.\/,*, -') > 0)
						begin
							SET @M_Result = @M_Result + substring(@Street, @i, 1);
						end;
						else
						begin
							SET @M_Result = @M_Result + ' ';
						end;

						SET @i = @i + 1;
					end /*loop*/;
					SET @Street = @M_Result;

					IF exists (SELECT 1
						FROM ifc.Address CROSS APPLY STRING_SPLIT (@Street, ' ') H
					Join GEN.Translation On Translation.Language = 'hu' AND Translation.CodeID like 'PUBLIC_PLACE_TYPE_%' AND Translation.Text  = H.[value]
						where H.[value] <> '')
					Begin

						Set @splitted_PublicPlaceTypeText = (SELECT Top 1  Translation.Text
							from STRING_SPLIT (@Street, ' ')
							Join GEN.Translation On (Translation.Language = 'hu')
											AND (Translation.CodeID like 'PUBLIC_PLACE_TYPE_%')
											AND (' ' + Translation.Text + ' ') = (' ' + [value] + ' ')
						where [value] <> '' order by Translation.ID desc);

						Set @splitted_PublicPlaceType = (SELECT Top 1 Translation.CodeID
							from STRING_SPLIT (@Street, ' ')
							Join GEN.Translation On (Translation.Language = 'hu')
											AND (Translation.CodeID like 'PUBLIC_PLACE_TYPE_%')
											AND (' ' + Translation.Text + ' ') = (' ' + [value] + ' ')
						where [value] <> '' order by Translation.ID desc);

						If ISNULL(@splitted_PublicPlaceTypeText,'') <> ''
						Begin
							If len(@Street) - len(@splitted_PublicPlaceTypeText) > 1
							Begin
								SET @splitted_PublicPlaceName = TRIM(Left(@Street, Charindex(@splitted_PublicPlaceTypeText, @Street)-1/*2*/));
								SET @splitted_HouseNr = TRIM(Right(@Street,Len(@Street) - Charindex(@splitted_PublicPlaceTypeText, @Street) - Len(@splitted_PublicPlaceTypeText)));
							End;
						End;
					End;

					Else
					Begin
						SET @l_Index = patindex('%[0-9]%', @Street);
						IF @l_Index <> 0
						Begin
							SET @splitted_PublicPlaceName = TRIM(LEFT(@Street, @l_Index-1));
							SET @splitted_HouseNr = TRIM(Right(@Street,Len(@Street) - @l_Index+1));
						End;
						Else
						Begin
							SET @splitted_HouseNr = TRIM(@Street);
						End;
					End;

--------------------------------------------------------------------------------------------------------------------

					SET @l_Settlement = @City;
					SET @l_District = '';
					SET @l_PublicPlaceName = @splitted_PublicPlaceName;
					SET @l_PublicPlaceType = @splitted_PublicPlaceType;
					SET @l_PublicPlaceTypeText = @splitted_PublicPlaceTypeText;
					SET @l_LandRegisterReference = NULL;
					SET @l_Staircase = @splitted_Staircase;
					SET @l_Building = @splitted_Building;
					SET @l_HouseNr = @splitted_HouseNr;
					SET @l_Floor = @splitted_Floor;
					SET @l_Door = @splitted_Door;
					--SET @l_Status = '';
					SET @l_PropertyID = NULL;
					SET @l_DataSource = NULL;
				End /* 'TAFC%' */
				Else
				Begin /* nem TA-s */
					SET @l_Settlement = TRIM(@City);
					SET @l_District = '';
					SET @l_PublicPlaceName = TRIM(@Street);
					SET @l_PublicPlaceType = TRIM(@PublicPlaceType);
					SET @l_PublicPlaceTypeText = TRIM(@PublicPlaceTypeText);
					SET @l_LandRegisterReference = TRIM(@LandRegisterReference);
					SET @l_Staircase = TRIM(@Staircase);
					SET @l_Building = TRIM(@Building);
					SET @l_HouseNr = TRIM(@HouseNr);
					SET @l_Floor = TRIM(@Floor);
					SET @l_Door = TRIM(@Door);
					--SET @l_Status = '';
					SET @l_PropertyID = NULL;
					SET @l_DataSource = NULL;
				End;

				SET @PUBLIC_PLACE_TYPE_ErrorMessage = '';

/*-------------------------------------------------------------------------------------------------------*/

				IF TRIM(ISNULL(@l_PublicPlaceTypeText,'')) = ''
					SET @l_PublicPlaceTypeText = NULL;
				IF TRIM(ISNULL(@l_PublicPlaceType,'')) = ''
					SET @l_PublicPlaceType = NULL;
				SET @l_PublicPlaceTypeText = TRIM(@l_PublicPlaceTypeText);
				SET @l_PublicPlaceType = TRIM(@l_PublicPlaceType);

			-- 1 - Üres:
				IF @l_PublicPlaceTypeText is NULL AND @l_PublicPlaceType is NULL
				BEGIN
					--SET @ErrorMessage = @ErrorMessage;
					Set @PUBLIC_PLACE_TYPE_ErrorMessage = 'T';
				END;
			-- 2 - Text-NotValid:
				IF @l_PublicPlaceTypeText is NOT NULL AND @l_PublicPlaceType is NULL
				BEGIN
					IF Not exists (
							SELECT 1
							from Gen.ValueSet
							left Join Gen.Code on Code.ValueSetID = ValueSet.Id
							left join Gen.Translation on Translation.CodeID = Code.Id
							where CodePrefix = 'PUBLIC_PLACE_TYPE'
							AND Translation.Text = @l_PublicPlaceTypeText)
						BEGIN
							Set @l_ErrorMessage = 'PublicPlaceTypeText is not Valid';
							SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
							Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
							Select 'IFC.ADDRESS', @ID, 'publicPlaceTypeText', @ERR_publicPlaceTypeText_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
							SET @PUBLIC_PLACE_TYPE_ErrorMessage = 'T';
						END;
					Else
						SET @l_PublicPlaceType = (SELECT Top 1 Code.Id
								from Gen.ValueSet
								left Join Gen.Code on Code.ValueSetID = ValueSet.Id
								left join Gen.Translation on Translation.CodeID = Code.Id
								where CodePrefix = 'PUBLIC_PLACE_TYPE'
								AND Translation.Text = @l_PublicPlaceTypeText order by Id Desc);
				END;
			-- 3 - Code-NotValid:
				IF @l_PublicPlaceTypeText is NULL AND @l_PublicPlaceType is not NULL
				AND Not exists (SELECT 1
								from Gen.ValueSet
								left Join Gen.Code on Code.ValueSetID = ValueSet.Id
								left join Gen.Translation on Translation.CodeID = Code.Id
								where CodePrefix = 'PUBLIC_PLACE_TYPE'
								AND Code.Id = @l_PublicPlaceType)
				BEGIN
							Set @l_ErrorMessage = 'PublicPlaceType is not Valid';
							SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
							Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
							Select 'IFC.ADDRESS', @ID, 'publicPlaceType', @ERR_publicPlaceTypeText_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
							SET @PUBLIC_PLACE_TYPE_ErrorMessage = 'T';
				END;

/*-------------------------------------------------------------------------------------------------------*/

			SET @l_AddressID = 0;
				-- Már létezik a cím:
			IF EXISTS (SELECT 1 FROM PRT.Address WHERE (Isnull(EntityID,0) = Isnull(@l_EntityID,0) /* or  Isnull(AssetID,0) = Isnull(@l_AssetID,0)*/)
				AND ISNULL(AddressType,'') = ISNULL(@AddressType,'')
				AND ISNULL(AddressStructure,'') = ISNULL(@AddressStructure,'')
				AND ISNULL(CountryID,'') = ISNULL(@CountryCode,'')
				AND ISNULL(CountryClassCode,'') = ISNULL(@CountryClassCode,'')
				AND ISNULL(ZipCode,'') = ISNULL(@ZipCode,'')
				AND ISNULL(Settlement,'') = ISNULL(@l_Settlement,'')
				AND ISNULL(District,'') = ISNULL(@l_District,'')
				AND ISNULL(PublicPlaceName,'') = ISNULL(@l_PublicPlaceName,'')
				AND ISNULL(PublicPlaceType,'') = ISNULL(@l_PublicPlaceType,'')
				AND ISNULL(HouseNr,'') = Left(ISNULL(@l_HouseNr,''),8)
				AND ISNULL(LandRegisterReference,'') = ISNULL(@l_LandRegisterReference,'')
				AND ISNULL(Staircase,'') = ISNULL(@l_Staircase,'')
				AND ISNULL(Building,'') = ISNULL(@l_Building,'')
				AND ISNULL([Floor],'') = ISNULL(@l_Floor,'')
				AND ISNULL(Door,'') = ISNULL(@l_Door,'')
				/* AND SourceInterfaceType = @SourceInterfaceType */
				/* AND SourceID = @SourceID */
				)
			BEGIN
				SET @l_AddressID = (SELECT Top 1 Address.ID FROM PRT.Address WHERE (Isnull(EntityID,0) = Isnull(@l_EntityID,0) /* or Isnull(AssetID,0) = Isnull(@l_AssetID,0)*/)
					AND ISNULL(AddressType,'') = ISNULL(@AddressType,'')
					AND ISNULL(AddressStructure,'') = ISNULL(@AddressStructure,'')
					AND ISNULL(CountryID,'') = ISNULL(@CountryCode,'')
					AND ISNULL(CountryClassCode,'') = ISNULL(@CountryClassCode,'')
					AND ISNULL(ZipCode,'') = ISNULL(@ZipCode,'')
					AND ISNULL(Settlement,'') = ISNULL(@l_Settlement,'')
					AND ISNULL(District,'') = ISNULL(@l_District,'')
					AND ISNULL(PublicPlaceName,'') = ISNULL(@l_PublicPlaceName,'')
					AND ISNULL(PublicPlaceType,'') = ISNULL(@l_PublicPlaceType,'')
					AND ISNULL(HouseNr,'') = Left(ISNULL(@l_HouseNr,''),8)
					AND ISNULL(LandRegisterReference,'') = ISNULL(@l_LandRegisterReference,'')
					AND ISNULL(Staircase,'') = ISNULL(@l_Staircase,'')
					AND ISNULL(Building,'') = ISNULL(@l_Building,'')
					AND ISNULL([Floor],'') = ISNULL(@l_Floor,'')
					AND ISNULL(Door,'') = ISNULL(@l_Door,'')
					/* AND SourceInterfaceType = @SourceInterfaceType */
					/* AND SourceID = @SourceID */
					Order by Id);
				SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
				UPDATE IFC.Address SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED',
				Errormessage = 'Identified by EntityID: ' + cast(@l_EntityID as nvarchar(18)) +
						(SELECT Case When (SELECT ISNULL(SourceID,'') from PRT.Entity where ID = @l_EntityID) <> ISNULL(@SourcePersonID,@SourceCompanyID)
						then ' Other SourceId: ' + (SELECT ISNULL(SourceID,'') from PRT.Entity where ID = @l_EntityID) end),
					LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName	WHERE ID = @ID;
			END;
			ELSE
			BEGIN
        BEGIN TRAN /*Nem létező Address*/
				  Update PRT.Address
          SET ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED'
          output inserted.ID
          into @inactivatedAddress
          where EntityID = @l_EntityID AND AddressType = @AddressType AND ValidUntil is NULL;

				  -- New ObjectID:
				  INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
					  SELECT @PRTAddress as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				  SET @l_RefertencedObjectID = @@Identity;

					  -- Új cím felvitele:
				  INSERT INTO PRT.Address(
					  AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName,
					  PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil,
					  StatusCode,
					  EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime,
					  CreationUserName, Comments, /*AssetID,*/ DataOriginCode)
				  SELECT
					  @AddressType, @AddressStructure, @CountryCode, @CountryClassCode, @ZipCode, @l_Settlement, @l_District, @l_PublicPlaceName,
					  @l_PublicPlaceType, Left(@l_HouseNr,8), @l_LandRegisterReference, @l_Staircase, @l_Building, @l_Floor, @l_Door, CAST( GETDATE() AS Date ), null,
					  Case when @ADDRESSCONFLICT_ErrorMessage = 'T' then 'STATUS_DELETED' else 'STATUS_NORMAL' end,
					  @l_EntityID, @l_RefertencedObjectID, NULL /*@l_PropertyID*/, @l_DataSource, @SourceInterfaceType, @SourceID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ),
					  @CurrentUserName, @Comments, /*@l_AssetID,*/ @l_DataOriginCode;

				  SET @l_ImportID = @@Identity;

          /*DV-1592: insert Inkasso sync record*/
          if @l_InkassoSyncOn = 1 and @l_EntityID is not null
          begin
            declare inkassoCur cursor local fast_forward for
              select addressID
              from @inactivatedAddress
              union all
              select @l_ImportID


            open inkassoCur
            while 1 = 1
            begin
              fetch next from inkassoCur into @inkassoAddressID

              if @@fetch_status <> 0
                 break

              begin try
                exec IFC.GenerateSendInkassoSyncData @syncType = 'Address',
                                                     @syncEventType = 'insert',
                                                     @entityID = null,
                                                     @ID = @inkassoAddressID,
                                                     @dataChangedUserName = @CurrentUserName,
                                                     @correlationID = @p_correlationID,
                                                     @moduleInstanceID = @p_moduleInstanceIDInkasso output,
                                                     @isBatch = 1
              end try
              begin catch
                close inkassoCur
                deallocate inkassoCur

                ;throw
              end catch
            end
            close inkassoCur
            deallocate inkassoCur
          end


				  SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
				  IF ISNULL(@ErrorMessage,'') = ''
					  Set @ErrorMessage = NULL;
				  UPDATE IFC.Address SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage = @ErrorMessage,
					LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;

			  /*-------------------------------------------------------------------------------------------------------*/
			  /* TAG */
				  IF @PUBLIC_PLACE_TYPE_ErrorMessage <> '' or @ADDRESSCONFLICT_ErrorMessage <> ''
				  BEGIN
					  -- New ObjectID:
					  INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
						  SELECT @PRTAddress as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
					  SET @l_ObjectID = @@Identity;
					  Insert Into GEN.ObjectTag(ObjectID, TagID, ReferencedObjectID, CreationDate, CreationTime, CreationUserName)
						  SELECT @l_ObjectID, @l_TagID, @l_RefertencedObjectID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName;

					  IF @ADDRESSCONFLICT_ErrorMessage <> ''
						  UPDATE IFC.Address SET ErrorMessage = TRIM(ISNULL(ErrorMessage,'') + ' City Name - ZIP Code Conflict,'),
							LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName	WHERE ID = @ID;
				  END;

        COMMIT /*Nem létező Address*/
			END;

		END;  /*@ErrorMessage = NULL*/

  END TRY /*Belső-1*/

  BEGIN CATCH /*Belső-1*/
    if @@TRANCOUNT > 0
       rollback

		SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
		SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
		UPDATE IFC.Address SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage = @ErrorMessage,
			LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName	WHERE ID = @ID;
	END CATCH /*Belső-1*/

			FETCH NEXT FROM db_cursor
			INTO @ID, @ObjectID, @SourceInterfaceType, @SourceID, @SourceCompanyID, @SourcePersonID, @RegistrationNr, @TaxNr, @StatisticalNr,
			@AddressType, @Country, @CountryCode, @CountryID, @ZipCode, @City, @Street, @HouseNr, @FullAddress, @Description, @ValidFrom, @ValidUntil,
			@Field1, @Field2, @Field3, @Field4, @Field5, @CrefoID, @InterfaceStatusCode, /*@ErrorMessage,*/ @ActualisationDate, @Operation, @InterfaceTableID,
			@MainAddress,
			/*@SourceAssetID, */@AddressStructure, @District, @PublicPlaceName, @PublicPlaceType, @PublicPlaceTypeText, @LandRegisterReference,
			@Staircase, @Building, @Floor, @Door

		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    --COMMIT TRANSACTION; /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/

    END TRY


    BEGIN CATCH

        SELECT
        @ErrorMessage = ERROR_MESSAGE(),
        @ErrorSeverity = ERROR_SEVERITY(),
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AddressLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;				-- LogMessage

        --RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );
        --ROLLBACK TRANSACTION; /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592), de ennek eredetileg is fentebb kellett volna lennie, hogy a logolás ne rollbackelődjön*/

        SELECT @ErrorMessage;

    END CATCH;


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------

	SET @LogMessage = @LogMessage + 'AddressLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AddressLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ExistingRowsCount: ' + CAST(@l_ExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ @LogMessage



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AddressLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage

	If Isnull(@ErrorMessage,'') <> ''
		Return 99;
	else
		Return 1;

END;
go


CREATE PROCEDURE [IFC].[AddressSearchLoader](@p_correlationID NVARCHAR(200))

/*
==========================================================================================
 Author:		Bognár Dávid
 Creation date:			2023.02.23.
 Last modified date:	
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUserName = 'Admin';

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);

	select '1'
------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	
	SET @LogMessage = @LogMessage + 'DebtorLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: '



	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return 1;


END;

go

-- =============================================
-- Author:		Dávid Bognár
-- Create date: 2022-12-03
-- Last modified date: YYYY-MM-DD
-- Description:	
-- =============================================
CREATE PROCEDURE [AST].[AssetAffiliation]
	-- Tárolt eljárás bemenő paraméterei
  @p_correlationID NVARCHAR(200), --Kötelező paraméter a Session kezelés miatt 
	--További szükséges bemenő paraméterek
  @p_AssetID numeric(16)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'LOG.GetDataChange'; --Naplózás miatt a tárolt eljárás neve
	DECLARE @l_ObjectType NVARCHAR(100);
    DECLARE @l_EntityID numeric(16);
    DECLARE @l_AddressObjectID numeric(16);
    DECLARE @l_ContactObjectID numeric(16);
	--Specifikus változók definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-okat, akkor azok definiálása (opcionális)
	--...
	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,           -- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Paraméterek ellenőrzése

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Feldolgozás. 
		--Amennyiben példányosított modul, akkor a példány feldolgozottságának frissítése az ORG.ModuleInstance.Progress mező módosítása
			
           begin 

		  select DISTINCT --DCS.DebtCase.DebtNr              as Ügyszám,
		--ORG.Task.Status                          as Állapot,
	    --DCS.DebtCase.ID                          as Ügyazonosító,
		PRT.GetEntityName (DCS.Debtor.EntityID)  as Kötelezett_neve,
		DCS.Debtor.EntityID as EntityID
		
from  AST.Asset 	  
      left join  AST.DebtCaseAsset   on   AST.DebtCaseAsset.AssetID           =AST.Asset.ID
	  left join  DCS.DebtCase        on   DCS.DebtCase.ID                     =AST.DebtCaseAsset.DebtCaseID
	  left join DCS.Debtor ON DCS.Debtor.DebtCaseID = DCS.DebtCase.ID
	  left join  ORG.Task            on   ORG.Task.ObjectID                         =DCS.DebtCase.ObjectID

	where AST.Asset.ID=@p_AssetID
		 and AST.DebtCaseAsset.StatusCode='STATUS_NORMAL'



           
            return;
          end;
		
		--Naplóbejegyzés a befejezésről (kötelező)
		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;                  --LogMessage
			
		RETURN 1;
	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'cursor neve');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE tenderItem_cursor;

			DEALLOCATE tenderItem_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
			
		RETURN 99;
	END CATCH
END
go


-- =============================================
-- Author:        Kiss János, Csaba Meszaros
-- Create date: 2022-11-18
-- Last modified date: 2022-12-09
--                     2023-02-13 B.D. csak az AST.Asset copy maradjon
-- Description:    Asset copy procedure
-- =============================================
CREATE     PROCEDURE [AST].[AssetCopy]
    @AssetID NUMERIC(16)



AS



BEGIN



   DECLARE @ErrorMSG NVARCHAR(200)
   DECLARE @LogMessage NVARCHAR(200)
   DECLARE @ObjectID NUMERIC(16)
   DECLARE @AssetCopy NUMERIC(16)
   DECLARE @AssetValuationCopy NUMERIC(16)
   DECLARE @AssetValuationValueCopy NUMERIC(16)


   SET @ErrorMSG = NULL



   BEGIN TRANSACTION
        BEGIN TRY

			SET @LogMessage = 'ASSET copy start...'
            PRINT (@LogMessage)

            INSERT INTO gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr, PortfolioID)
                VALUES('OBJECT_TYPE_AST_ASSET', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', CAST(@AssetID AS NVARCHAR(50)) + ' asset id copy', '1.0.0',
						(SELECT GEN.Object.PortfolioID
							FROM GEN.Object
							WHERE GEN.Object.ID = (SELECT AST.Asset.ObjectID
													FROM AST.Asset
													WHERE AST.Asset.ID = @AssetID)))



           SELECT @ObjectID = @@IDENTITY



           INSERT INTO AST.Asset(ObjectID, AssetClassCode, AssetTypeCode, Name, LandRegisterReference, StatusCode, LandRegisterOfficeEntityID, CreationDate, CreationTime, CreationUserName,
                                    LandRegisterCity, ExternalReferenceNr, StructureSize, LotSize, LotSizeUnitCode, InhabitedCode, RentedOutCode, UndividedCommonPropertyCode,
                                    DataOriginCode, SourceInterfaceType, SourceID,AssetNatureCode)
                SELECT @ObjectID,
                        AST.Asset.AssetClassCode,
                        AST.Asset.AssetTypeCode,
                        AST.Asset.Name,
                        AST.Asset.LandRegisterReference,
                        AST.Asset.StatusCode,
                        AST.Asset.LandRegisterOfficeEntityID,
                        CAST( GETDATE() AS Date),
                        CONVERT(VARCHAR(8), GETDATE(),108),
                        'Admin',
                        AST.Asset.LandRegisterCity,
                        AST.Asset.ExternalReferenceNr,
                        AST.Asset.StructureSize,
                        AST.Asset.LotSize,
                        AST.Asset.LotSizeUnitCode,
                        AST.Asset.InhabitedCode,
                        AST.Asset.RentedOutCode,
                        AST.Asset.UndividedCommonPropertyCode,
                        AST.Asset.DataOriginCode,
                        AST.Asset.SourceInterfaceType,
                        AST.Asset.SourceID,
						AST.Asset.AssetNatureCode
                    FROM AST.Asset
                    WHERE AST.Asset.ID = @AssetID

			SELECT @AssetCopy = @@IDENTITY

			/*INSERT INTO gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
                VALUES('PRT.Address', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', 'Address copy', '1.0.0')

			SELECT @ObjectID = @@IDENTITY

			INSERT INTO PRT.Address (ObjectID, AssetID, AddressType, AddressStructure, CountryID, ZipCode, Settlement, District, PublicPlaceName, PublicPlaceType, 
				HouseNr, LandRegisterReference, Staircase, Building, Floor, Door, ValidFrom, ValidUntil, Comments, CountryClassCode, 
				DataSource, SourceInterfaceType, SourceID, StatusCode,
				CreationDate, CreationTime, CreationUserName)
			SELECT @ObjectID, 
				@AssetCopy, 
				Address.AddressType,
				Address.AddressStructure, 
				Address.CountryID, 
				Address.ZipCode, 
				Address.Settlement, 
				Address.District, 
				Address.PublicPlaceName, 
				Address.PublicPlaceType, 
				Address.HouseNr, 
				Address.LandRegisterReference,
				Address.Staircase, 
				Address.Building,
				Address.Floor, 
				Address.Door, 
				Address.ValidFrom, 
				Address.ValidUntil, 
				Address.Comments, 
				Address.CountryClassCode, 
				Address.DataSource, 
				Address.SourceInterfaceType, 
				Address.SourceID, 
				Address.StatusCode, 
				 CAST( GETDATE() AS Date), 
				 CONVERT(VARCHAR(8), GETDATE(),108),
				 'Admin'
			FROM PRT.Address 
			WHERE Address.AssetID = @AssetID

			INSERT INTO gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
                VALUES('AST.AssetValuation', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 2, 'AssetValuation copy', '1.0.0')

			SELECT @ObjectID = @@IDENTITY

			INSERT INTO AST.AssetValuation(ObjectID, AssetID, ValuerEntityID, ValuationDate, ValuationTypeCode, ValidFrom, ValidUntil, CreationDate, CreationTime, CreationUserName)
				SELECT @ObjectID,
						@AssetCopy,
						AST.AssetValuation.ValuerEntityID,
						AST.AssetValuation.ValuationDate,
						AST.AssetValuation.ValuationTypeCode,
						AST.AssetValuation.ValidFrom,
						AST.AssetValuation.ValidUntil,
						CAST( GETDATE() AS Date),
                        CONVERT(VARCHAR(8), GETDATE(),108),
                        'Admin'
					FROM AST.AssetValuation
					WHERE AST.AssetValuation.AssetID = @AssetID

			SELECT @AssetValuationCopy = @@IDENTITY

			INSERT INTO gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
                VALUES('AST.AssetValuationValue', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', 'AssetValuationValue copy', '1.0.0')

			SELECT @ObjectID = @@IDENTITY

			INSERT INTO AST.AssetValuationValue(ObjectID, AssetValuationID, ValueTypeCode, NetValue, VatID, VatValue, GrossValue, ValueCurrencyCode, CreationDate, CreationTime, CreationUserName)
				SELECT @ObjectID,
						@AssetValuationCopy,
						AST.AssetValuationValue.ValueTypeCode,
						AST.AssetValuationValue.NetValue,
						AST.AssetValuationValue.VatID,
						AST.AssetValuationValue.VatValue,
						AST.AssetValuationValue.GrossValue,
						AST.AssetValuationValue.ValueCurrencyCode,
						CAST( GETDATE() AS Date),
                        CONVERT(VARCHAR(8), GETDATE(),108),
                        'Admin'
					FROM AST.AssetValuationValue
					JOIN AST.AssetValuation on AST.AssetValuation.ID = AST.AssetValuationValue.AssetValuationID
					WHERE AST.AssetValuation.AssetID = @AssetID

			INSERT INTO gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
                VALUES('AST.DebtCaseAsset', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', 'DebtCaseAsset copy', '1.0.0')

			SELECT @ObjectID = @@IDENTITY

			INSERT INTO AST.DebtCaseAsset(ObjectID, AssetID, DebtCaseID, StatusCode, TypeCode, DecisionNr, ValidFrom, ValidUntil, CreationDate, CreationTime, CreationUserName)
				SELECT @ObjectID,
						@AssetCopy,
						AST.DebtCaseAsset.DebtCaseID,
						AST.DebtCaseAsset.StatusCode,
						AST.DebtCaseAsset.TypeCode,
						AST.DebtCaseAsset.DecisionNr,
						AST.DebtCaseAsset.ValidFrom,
						AST.DebtCaseAsset.ValidUntil,
						CAST( GETDATE() AS Date),
                        CONVERT(VARCHAR(8), GETDATE(),108),
                        'Admin'
					FROM AST.DebtCaseAsset
					WHERE AST.DebtCaseAsset.AssetID = @AssetID;
			/*Az asset es a debtcaseasset portfolioid-je legyen paritasban*/
			UPDATE GEN.[Object] SET PortfolioID = (SELECT GEN.[Object].PortfolioID FROM GEN.[Object] geno JOIN AST.Asset ass on ass.ObjectID = geno.ID WHERE ass.ID = @AssetID) WHERE GEN.[Object].ID = @ObjectID;  

			INSERT INTO gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
                VALUES('AST.DebtorAsset', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', 'DebtorAsset copy', '1.0.0')

			SELECT @ObjectID = @@IDENTITY

			INSERT INTO AST.DebtorAsset(ObjectID, AssetID, DebtorID, OwnPercent, ValidFrom, ValidUntil, StatusCode, CreationDate, CreationTime, CreationUserName,
											AssetDebtorRelationTypeCode, SharePercent, ShareDividend, ShareDivisor)
				SELECT @ObjectID,
						@AssetCopy,
						AST.DebtorAsset.DebtorID,
						AST.DebtorAsset.OwnPercent,
						AST.DebtorAsset.ValidFrom,
						AST.DebtorAsset.ValidUntil,
						AST.DebtorAsset.StatusCode,
						CAST( GETDATE() AS Date),
                        CONVERT(VARCHAR(8), GETDATE(),108),
                        'Admin',
						AST.DebtorAsset.AssetDebtorRelationTypeCode,
						AST.DebtorAsset.SharePercent,
						AST.DebtorAsset.ShareDividend,
						AST.DebtorAsset.ShareDivisor
					FROM AST.DebtorAsset
					WHERE AST.DebtorAsset.AssetID = @AssetID
*/
			UPDATE AST.Asset
				SET UndividedCommonPropertyCode = 'BOOLEAN_TRUE'
				WHERE ID IN (@AssetID, @AssetCopy)

			SET @LogMessage = 'ASSET copy done'
            PRINT (@LogMessage) 

   COMMIT TRANSACTION



   SELECT AST.Asset.ID
                    FROM AST.Asset
                    WHERE AST.Asset.ID = @AssetCopy
            
        END TRY
        BEGIN CATCH
            SELECT  
                ERROR_NUMBER() AS ErrorNumber  
                ,ERROR_SEVERITY() AS ErrorSeverity  
                ,ERROR_STATE() AS ErrorState  
                ,ERROR_PROCEDURE() AS ErrorProcedure  
                ,ERROR_LINE() AS ErrorLine  
                ,ERROR_MESSAGE() AS ErrorMessage;



           SET @LogMessage = 'ERROR'
            PRINT (@LogMessage)



           ROLLBACK TRANSACTION



       END CATCH



END
go

-- =============================================
-- Author:		Dávid Bognár
-- Create date: 2022-12-02
-- Last modified date: YYYY-MM-DD
-- Description:	
-- =============================================
CREATE PROCEDURE [AST].[AssetDebtorProcedure]
	-- Tárolt eljárás bemenő paraméterei
  @p_correlationID NVARCHAR(200), --Kötelező paraméter a Session kezelés miatt 
	--További szükséges bemenő paraméterek
  @p_AssetID numeric(16)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'LOG.GetDataChange'; --Naplózás miatt a tárolt eljárás neve
	DECLARE @l_ObjectType NVARCHAR(100);
    DECLARE @l_EntityID numeric(16);
    DECLARE @l_AddressObjectID numeric(16);
    DECLARE @l_ContactObjectID numeric(16);
	--Specifikus változók definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-okat, akkor azok definiálása (opcionális)
	--...
	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,           -- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Paraméterek ellenőrzése

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Feldolgozás. 
		--Amennyiben példányosított modul, akkor a példány feldolgozottságának frissítése az ORG.ModuleInstance.Progress mező módosítása
			
           begin 

		  select  DCS.DebtCase.DebtNr                      as Ügyszám,
		--ORG.Task.Status                          as Állapot,
	    DCS.DebtCase.ID                          as Ügyazonosító,
		PRT.GetEntityName (AST.EntityAsset.EntityID)  as Kötelezett_neve,
		case when floor(AST.EntityAsset.ShareDividend/AST.EntityAsset.ShareDivisor*100) is null
		then ''
		else concat(floor(AST.EntityAsset.ShareDividend/AST.EntityAsset.ShareDivisor*100),'%') end as Tulajdoni_hányad
		

from  AST.Asset 
      left join  AST.EntityAsset     on   AST.Asset.ID                       =AST.EntityAsset.AssetID and AST.EntityAsset.StatusCode='STATUS_NORMAL'
	  
      left join  AST.DebtCaseAsset   on   AST.DebtCaseAsset.AssetID           =AST.Asset.ID
	  /*left*/ join  DCS.DebtCase        on   DCS.DebtCase.ID                     =AST.DebtCaseAsset.DebtCaseID
	  left join  ORG.Task            on   ORG.Task.ObjectID                         =DCS.DebtCase.ObjectID

	where AST.Asset.ID=@p_AssetID
		 and AST.DebtCaseAsset.StatusCode='STATUS_NORMAL'



           
            return;
          end;
		
		--Naplóbejegyzés a befejezésről (kötelező)
		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;                  --LogMessage
			
		RETURN 1;
	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		/*SELECT @l_cursorStatus = CURSOR_STATUS('global', 'cursor neve');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE tenderItem_cursor;

			DEALLOCATE tenderItem_cursor;
		END*/

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
			
		RETURN 99;
	END CATCH
END
go

CREATE   PROCEDURE [IFC].[AssetLoader](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16), @p_moduleInstanceIDInkasso Numeric(16) = null output)

/*
==========================================================================================
 Author:		Tóth Gábor, Csaba Mészáros
 Creation date:			2022.12.05.
 Last modified date:	2022.12.08: "IF @ErrorMessage is not NULL" áthelyezése
						2022.12.09: Duplikáció ellenőrzés kivéve
						2022.12.09: AST.DebtCaseAsset --> PortfolioId
						2022.12.10: @EntityId, @l_AssetValuationID, @InterfaceStatusCode, @StatusCode
						2022.12.10: IF asset typ is not 1-5 then chagne to ASSET_TYPE_5
						2022.12.16: CreationUserName
						2023.01.10: AssetClassCode, AssetTypeCode, StatusCode
						2023.01.27: Set @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
						2023.02.01: Létezik a fedezethez DebtCase ?
						2023.02.08: DebtorAsset kommentelése, mert megszűnt a DCS.DebtorAsset tábla
						2023.02.09: ASSET_TYPE_5 Feltételvizsgálat törlése
						2023.02.13: AssetClass-, AssetType default: "Ingó", "Egyéb"
						2023.02.15: @SourceEntityID
						2023.02.16: @l_DataOriginCode
						2023.02.20: 'ADDRESS_TYPE_ASSET_LOCATION' as AddressType,
						2023.02.21: Hibakezelés
						2023.02.23: Set @ValidFrom = Isnull(@ValidFrom,CAST( GETDATE() AS Date ));
						2023.02.28: 'ASSET_RELATION_TYPE_CODE_%' -> 'ASSET_RELATION_TYPE_%'
						2023.02.28: 'Select 1 from IFC.Asset' -> 'Select 1 from IFC.AssetValuation '
						2023.02.28: Errormessage vesszővel lettek elválasztva
						2023.02.28: Betöltési darabszámok szétválasztása
						2023.03.16: ErrorCode-ok
						2023.03.27: ErrorCode-ok, ObjectType
						2023.04.11: @AssetNatureCode
						2023.05.11: 'ENTITY_ASSET_RELATION_TYPE_' helyett ->> 'ASSET_DEBTOR_RELATION_TYPE_'
						2023.09.04: select * from AST.DebtCaseAsset komment
            2023.11.03: Inkasso szinkron DV-1592
            2023.11.07: 'ASSET_DEBTOR_RELATION_TYPE_' --> 'ENTITY_ASSET_RELATION_TYPE_' DV-1657
						2023.11.21: If not exists @..Code..
            2023.11.27: Inkasso szinkron - GenerateSendInkassoSyncData rendesen hibát dob DV-1592
                                         - ne fusson az Asset szinkron, ha a DebtCase szinkron nem lett sikeresen kiírva DV-1773
						2023.12.06: Hibakezelés DV-1736 ( csak az Asset-ekre vonatkozóan )
						2023.12.08: Hibakezelés DV-1956 - Betöltő eljárás módosítása a IFC.InterfaceError.Errormessage mező töltésére
						2023.12.08: SCOPE_IDENTITY
						2023.12.09: "AND Isnull(SourceCompanyID,'') = '' and Isnull(SourcePersonID,'') = '' and SourceAssetID is not NULL",  DV-1960
						2023.12.10: "InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'",  DV-1956
            2023.12.12: Inkasso szinkron ellenőrzés módosítás DV-1775
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(MAX);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	DECLARE @l_BlockerError nvarchar(1);
	-- ha van blokkoló hiba, akkor @l_BlockerError = 'T',
	-- InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_BLOCKING', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	-- ha csak kritikus hiba van, akkor @l_BlockerError = 'T',
	-- InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	--DECLARE @l_Prev_ModuleInstanceID Numeric(16);


	SET @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
	--SET @l_Prev_ModuleInstanceID = (Select Top 1 ModuleInstanceID from IFC.InterfaceError where TableName = 'IFC.Address' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' order by id desc);


	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AssetLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);


    BEGIN TRY
        SET @LogMessage = 'AssetLoader Started at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;

		DECLARE @ERR_Is_Empty nVarchar(500);
		DECLARE @ERR_CODE_CODE_Is_Not_Valid nVarchar(500);
		DECLARE @ERR_CODE_NAME_Is_Not_Valid nVarchar(500);
		DECLARE @ERR_LAND_REG_OFFICE_CANNOT_BE_NULL nVarchar(500);

		DECLARE @ASTAsset nVarchar(500);
		DECLARE @ASTAssetValuation nVarchar(500);
		DECLARE @ASTAssetValuationValue nVarchar(500);
		DECLARE @PRTADDRESS nVarchar(500);
		DECLARE @ASTDebtCaseAsset nVarchar(500);
		DECLARE @ASTEntityAsset nVarchar(500);



		DECLARE @ERR_AssetClass_Is_Not_Valid nvarchar(200);
			SET @ERR_AssetClass_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_AssetClassText_Is_Not_Valid nvarchar(200);
			SET @ERR_AssetClassText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_AssetNatureCode_Is_Not_Valid nvarchar(200);
			SET @ERR_AssetNatureCode_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_AssetNatureText_Is_Not_Valid nvarchar(200);
			SET @ERR_AssetNatureText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_AssetStatus_Is_Not_Valid nvarchar(200);
			SET @ERR_AssetStatus_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_AssetStatusText_Is_Not_Valid nvarchar(200);
			SET @ERR_AssetStatusText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_AssetType_Is_Not_Valid nvarchar(200);
			SET @ERR_AssetType_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_AssetTypeText_Is_Not_Valid nvarchar(200);
			SET @ERR_AssetTypeText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_Country_Is_Not_Valid nvarchar(200);
			SET @ERR_Country_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_Currency_Code_Is_Empty nvarchar(200);
			SET @ERR_Currency_Code_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_CurrencyCode_Is_Not_Valid nvarchar(200);
			SET @ERR_CurrencyCode_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_CurrencyText_Is_Empty nvarchar(200);
			SET @ERR_CurrencyText_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_CurrencyText_Is_Not_Valid nvarchar(200);
			SET @ERR_CurrencyText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_DebtCaseAssetTypeCode_Is_Not_Valid nvarchar(200);
			SET @ERR_DebtCaseAssetTypeCode_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_DebtCaseAssetTypeText_Is_Not_Valid nvarchar(200);
			SET @ERR_DebtCaseAssetTypeText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_DebtCaseAssset_Is_Not_Found nvarchar(200);
			SET @ERR_DebtCaseAssset_Is_Not_Found = 'ERR_GENERAL';
		DECLARE @ERR_EntityAssetRelationTypeCode_Is_Not_Valid nvarchar(200);
			SET @ERR_EntityAssetRelationTypeCode_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_EntityAssetRelationTypeText_Is_Not_Valid nvarchar(200);
			SET @ERR_EntityAssetRelationTypeText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_EntityAssetStatusCode_Is_Not_Valid nvarchar(200);
			SET @ERR_EntityAssetStatusCode_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_EntityAssetStatusText_Is_Not_Valid nvarchar(200);
			SET @ERR_EntityAssetStatusText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_InhabitedCode_Is_Not_Valid nvarchar(200);
			SET @ERR_InhabitedCode_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_InhabitedText_Is_Not_Valid nvarchar(200);
			SET @ERR_InhabitedText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_LandRegisterOfficeEntityID_Not_Exists nvarchar(200);
			SET @ERR_LandRegisterOfficeEntityID_Not_Exists = 'ERR_GENERAL';
		DECLARE @ERR_LotSizeUnitCode_Is_Not_Valid nvarchar(200);
			SET @ERR_LotSizeUnitCode_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_LotSizeUnitText_Is_Not_Valid nvarchar(200);
			SET @ERR_LotSizeUnitText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_PortfID_Is_Empty nvarchar(200);
			SET @ERR_PortfID_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_PortfName_Is_Not_Valid nvarchar(200);
			SET @ERR_PortfName_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_Related_Asset_Is_Not_Found nvarchar(200);
			SET @ERR_Related_Asset_Is_Not_Found = 'ERR_GENERAL';
		DECLARE @ERR_Related_Entity_Is_Not_Found nvarchar(200);
			SET @ERR_Related_Entity_Is_Not_Found = 'ERR_GENERAL';
		DECLARE @ERR_RentedOutCode_Is_Not_Valid nvarchar(200);
			SET @ERR_RentedOutCode_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_RentedOutText_Is_Not_Valid nvarchar(200);
			SET @ERR_RentedOutText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_SID_Is_Empty nvarchar(200);
			SET @ERR_SID_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_SIFTYPE_Is_Empty nvarchar(200);
			SET @ERR_SIFTYPE_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_SourceAsset_is_Not_Exists nvarchar(200);
			SET @ERR_SourceAsset_is_Not_Exists = 'ERR_GENERAL';
		DECLARE @ERR_SourceAssetID_Is_Empty nvarchar(200);
			SET @ERR_SourceAssetID_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_SourceAssetID_is_Not_Exists nvarchar(200);
			SET @ERR_SourceAssetID_is_Not_Exists = 'ERR_GENERAL';
		DECLARE @ERR_SourceAssetValuationID_Is_Empty nvarchar(200);
			SET @ERR_SourceAssetValuationID_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_SourceAssetValuationID_Is_Not_Valid nvarchar(200);
			SET @ERR_SourceAssetValuationID_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_SourceDebtCaseID_Is_Empty nvarchar(200);
			SET @ERR_SourceDebtCaseID_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_SourceEntityID_Is_Empty nvarchar(200);
			SET @ERR_SourceEntityID_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_SourceID_Is_Empty nvarchar(200);
			SET @ERR_SourceID_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_SourceInterfaceType_Is_Empty nvarchar(200);
			SET @ERR_SourceInterfaceType_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_StatusCode_Is_Empty nvarchar(200);
			SET @ERR_StatusCode_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_StatusCode_Is_Not_Valid nvarchar(200);
			SET @ERR_StatusCode_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_StatusText_Is_Empty nvarchar(200);
			SET @ERR_StatusText_Is_Empty = 'ERR_GENERAL';
		DECLARE @ERR_StatusText_Is_Not_Valid nvarchar(200);
			SET @ERR_StatusText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_UndividedCommonPropertyCode_Is_Not_Valid nvarchar(200);
			SET @ERR_UndividedCommonPropertyCode_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_UndividedCommonPropertyText_Is_Not_Valid nvarchar(200);
			SET @ERR_UndividedCommonPropertyText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_valuationTypeText_Is_Not_Valid nvarchar(200);
			SET @ERR_valuationTypeText_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_ValuerEntityID_Is_Not_Valid nvarchar(200);
			SET @ERR_ValuerEntityID_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_ValueTypeCode_Is_Not_Valid nvarchar(200);
			SET @ERR_ValueTypeCode_Is_Not_Valid = 'ERR_GENERAL';
		DECLARE @ERR_ValueTypeText_Is_Not_Valid nvarchar(200);
			SET @ERR_ValueTypeText_Is_Not_Valid = 'ERR_GENERAL';


		DECLARE @l_ErrorMessage nvarchar(max);


		SET @ASTAsset = (Select Top 1 Code from GEN.ObjectType where TableName = 'AST.ASSET' order by TableName desc);
		SET @ASTAssetValuation = (Select Top 1 Code from GEN.ObjectType where TableName = 'AST.ASSETVALUATION' order by TableName desc);
		SET @ASTAssetValuationValue = (Select Top 1 Code from GEN.ObjectType where TableName = 'AST.ASSETVALUATIONVALUE' order by TableName desc);
		SET @PRTADDRESS = (Select Top 1 Code from GEN.ObjectType where TableName = 'PRT.ADDRESS' order by TableName desc);
		SET @ASTDebtCaseAsset = (Select Top 1 Code from GEN.ObjectType where TableName = 'AST.DEBTCASEASSET' order by TableName desc);
		SET @ASTEntityAsset = (Select Top 1 Code from GEN.ObjectType where TableName = 'AST.ENTITYASSET' order by TableName desc);

    DECLARE @l_InkassoSyncOn int = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'Asset', 'insert')
    DECLARE @l_inkassoSyncDebtCaseID Numeric(16)
    DECLARE @today Date = GetDate()

-----------------------------------------------
	-- Asset:
		Declare @ID Numeric(16);
		Declare @AssetClass NvarChar(200);
		Declare @AssetClassText NvarChar(200);
		Declare @AssetType NvarChar(200);
		Declare @AssetTypeText NvarChar(200);
		Declare @Name NvarChar(200);
		Declare @LandRegisterCity NvarChar(100);
		Declare @LandRegisterReference NvarChar(200);
		Declare @Status NvarChar(200);
		Declare @StatusText NvarChar(200);
		Declare @LandRegisterOfficeEntityID Numeric(16);
		Declare @ExternalReferenceNr NvarChar(200);
		Declare @StructureSize Numeric(10, 4);
		Declare @LotSize Numeric(10, 4);
		Declare @LotSizeUnitCode NvarChar(200);
		Declare @LotSizeUnitText NvarChar(200);
		Declare @InhabitedCode NvarChar(200);
		Declare @InhabitedText NvarChar(200);
		Declare @RentedOutCode NvarChar(200);
		Declare @RentedOutText NvarChar(200);
		Declare @UndividedCommonPropertyCode NvarChar(200);
		Declare @UndividedCommonPropertyText NvarChar(200);
		Declare @DataOriginCode NvarChar(200);
		Declare @DataOriginText NvarChar(200);
		Declare @AssetID Numeric(16);
		Declare @SourceInterfaceType NvarChar(200);
		Declare @SourceID NvarChar(200);
		Declare @InterfaceStatusCode NvarChar(200);
		Declare @InterfaceTableID Numeric(16);
		Declare @PortfolioName NvarChar(200);
		Declare @PortfolioID Numeric(16);
		Declare @AssetNatureCode NvarChar(200);
		Declare @AssetNatureText NvarChar(200);
-----------------------------------------------
-- AssetValuation:
		Declare @ValuerEntityID Numeric(16);
		Declare @ValuationDate [Date];
		Declare @ValuationTypeCode NvarChar(200);
		Declare @ValuationTypeText NvarChar(200);
		Declare @ValidFrom [Date];
		Declare @ValidUntil [Date];
		Declare @AssetValuationID Numeric(16);
		Declare @SourceAssetID NvarChar(200);
		Declare @SourceCompanyID NvarChar(200);
		Declare @StatusCode NvarChar(200);
-----------------------------------------------
-- AssetValuationValue:
		Declare @ValueTypeCode NvarChar(200);
		Declare @ValueTypeText NvarChar(200);
		Declare @NetValue money;
		Declare @VatRate Numeric(10, 4);
		Declare @VatValue money;
		Declare @GrossValue money;
		Declare @ValueCurrencyCode NvarChar(200);
		Declare @ValueCurrencyText NvarChar(200);
		Declare @AssetValuationValueID Numeric(16);
		Declare @SourceAssetValuationID NvarChar(200);
		Declare @l_AssetValuation numeric(18);
-----------------------------------------------
-- Address:
		Declare @ObjectID Numeric(16);
		Declare @SourcePersonID NvarChar(200);
		Declare @RegistrationNr NvarChar(30);
		Declare @StatisticalNr NvarChar(30);
		Declare @AddressType NvarChar(200);
		Declare @Country NvarChar(250);
		Declare @CountryCode NvarChar(16);
		Declare @CountryID NvarChar(200);
		Declare @ZipCode NvarChar(250);
		Declare @City NvarChar(250);
		Declare @Street NvarChar(250);
		Declare @HouseNr NvarChar(250);
		Declare @FullAddress NvarChar(250);
		Declare @Description NvarChar(250);
		Declare @Field1 NvarChar(250);
		Declare @Field2 NvarChar(250);
		Declare @Field3 NvarChar(250);
		Declare @Field4 NvarChar(250);
		Declare @Field5 NvarChar(250);
		Declare @CrefoID Numeric(16);
		Declare @ActualisationDate [Date];
		Declare @Operation NvarChar(1);
		Declare @MainAddress NvarChar(1);
-----------------------------------------------
-- DebtorAsset:
/* 2023-02-08
		Declare @AssetDebtorRelationTypeCode NvarChar(200);
		Declare @AssetDebtorRelationTypeText NvarChar(200);
		Declare @OwnPercent Numeric(10, 4);
		Declare @DebtorAssetID Numeric(16);
		Declare @DebtorID Numeric(16);
		Declare @SourceDebtorID NvarChar(200);
*/
		Declare @SharePercent Numeric(10, 4);
		Declare @ShareDividend Numeric(10, 4);
		Declare @ShareDivisor Numeric(10, 4);
-----------------------------------------------
-- DebtCaseAsset:
		Declare @TypeCode NvarChar(200);
		Declare @TypeText NvarChar(200);
		Declare @DecisionNr NvarChar(200);
		Declare @DebtCaseAssetID Numeric(16);
		Declare @DebtCaseID Numeric(16);
		Declare @SourceDebtCaseID NvarChar(200);
-----------------------------------------------
-- EntityAsset:
		Declare @EntityAssetRelationTypeCode NvarChar(200);
		Declare @EntityAssetRelationTypeText NvarChar(200);
		Declare @EntityAssetID Numeric(16);
		Declare @EntityID Numeric(16);
		Declare @SourceEntityID NvarChar(200);
-----------------------------------------------
-- Általános:
		Declare @l_ObjectID numeric(18);
		Declare @l_ImportID numeric(18);

-- Asset:
		Declare @l_AssetAllRowCounts numeric(18);
		Declare @l_AssetImportedRowCounts numeric(18);
		Declare @l_AssetExisingRowCounts numeric(18);
		Declare @l_AssetErrorRowCounts numeric(18);
-- AssetValuation:
		Declare @l_AssetValuationAllRowCounts numeric(18);
		Declare @l_AssetValuationImportedRowCounts numeric(18);
		Declare @l_AssetValuationExisingRowCounts numeric(18);
		Declare @l_AssetValuationErrorRowCounts numeric(18);
-- AssetValuationValue:
		Declare @l_AssetValuationValueAllRowCounts numeric(18);
		Declare @l_AssetValuationValueImportedRowCounts numeric(18);
		Declare @l_AssetValuationValueExisingRowCounts numeric(18);
		Declare @l_AssetValuationValueErrorRowCounts numeric(18);
-- Address:
		Declare @l_AddressAllRowCounts numeric(18);
		Declare @l_AddressImportedRowCounts numeric(18);
		Declare @l_AddressExisingRowCounts numeric(18);
		Declare @l_AddressErrorRowCounts numeric(18);
-- DebtCaseAsset:
		Declare @l_DebtCaseAssetAllRowCounts numeric(18);
		Declare @l_DebtCaseAssetImportedRowCounts numeric(18);
		Declare @l_DebtCaseAssetExisingRowCounts numeric(18);
		Declare @l_DebtCaseAssetErrorRowCounts numeric(18);
-- EntityAsset:
		Declare @l_EntityAssetAllRowCounts numeric(18);
		Declare @l_EntityAssetImportedRowCounts numeric(18);
		Declare @l_EntityAssetExisingRowCounts numeric(18);
		Declare @l_EntityAssetErrorRowCounts numeric(18);

		Declare @l_AssetID numeric(18);
		Declare @l_EntityId numeric(18);
		Declare @l_DebtorID numeric(18);
		Declare @l_DebtCaseID numeric(18);
		Declare @l_PortfolioId numeric(18);
		Declare @l_AssetValuationID numeric(18);
		Declare @l_DataOriginCode nvarchar(200);

-- Asset:
		Set @l_AssetAllRowCounts = 0;
		Set @l_AssetImportedRowCounts = 0;
		Set @l_AssetExisingRowCounts = 0;
		Set @l_AssetErrorRowCounts = 0;
-- AssetValuation:
		Set @l_AssetValuationAllRowCounts = 0;
		Set @l_AssetValuationImportedRowCounts = 0;
		Set @l_AssetValuationExisingRowCounts = 0;
		Set @l_AssetValuationErrorRowCounts = 0;
-- AssetValuationValue:
		Set @l_AssetValuationValueAllRowCounts = 0;
		Set @l_AssetValuationValueImportedRowCounts = 0;
		Set @l_AssetValuationValueExisingRowCounts = 0;
		Set @l_AssetValuationValueErrorRowCounts = 0;
-- Address:
		Set @l_AddressAllRowCounts = 0;
		Set @l_AddressImportedRowCounts = 0;
		Set @l_AddressExisingRowCounts = 0;
		Set @l_AddressErrorRowCounts = 0;
-- DebtCaseAsset:
		Set @l_DebtCaseAssetAllRowCounts = 0;
		Set @l_DebtCaseAssetImportedRowCounts = 0;
		Set @l_DebtCaseAssetExisingRowCounts = 0;
		Set @l_DebtCaseAssetErrorRowCounts = 0;
-- EntityAsset:
		Set @l_EntityAssetAllRowCounts = 0;
		Set @l_EntityAssetImportedRowCounts = 0;
		Set @l_EntityAssetExisingRowCounts = 0;
		Set @l_EntityAssetErrorRowCounts = 0;

		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END

		IF COALESCE(@l_sourceInterfaceType, '') = ''
			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);


		SET @l_AssetAllRowCounts = (Select Count(*) FROM IFC.Asset where SourceInterfaceType = @l_sourceInterfaceType
				AND
					(
					(Asset.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Asset.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Asset' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));

---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- ASSET:
		DECLARE db_cursor CURSOR FOR
		SELECT ID,
			AssetClass, AssetClassText, AssetType, AssetTypeText, Name, LandRegisterCity, LandRegisterReference, Status, StatusText, LandRegisterOfficeEntityID, ExternalReferenceNr, StructureSize, LotSize, LotSizeUnitCode, LotSizeUnitText, InhabitedCode, InhabitedText, RentedOutCode, RentedOutText, UndividedCommonPropertyCode, UndividedCommonPropertyText, DataOriginCode, DataOriginText, AssetID, SourceInterfaceType, SourceID, InterfaceStatusCode, ErrorMessage, InterfaceTableID, /*CreationDate, CreationTime, CreationUserName*/ PortfolioName, PortfolioID, AssetNatureCode, AssetNatureText
		FROM IFC.Asset
		where SourceInterfaceType = @l_sourceInterfaceType
				AND
					(
					(Asset.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Asset.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Asset' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
				Order by Asset.ID;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO
			@ID, @AssetClass, @AssetClassText, @AssetType, @AssetTypeText, @Name, @LandRegisterCity, @LandRegisterReference, @Status, @StatusText,
			@LandRegisterOfficeEntityID, @ExternalReferenceNr, @StructureSize, @LotSize, @LotSizeUnitCode, @LotSizeUnitText, @InhabitedCode,
			@InhabitedText, @RentedOutCode, @RentedOutText, @UndividedCommonPropertyCode, @UndividedCommonPropertyText, @DataOriginCode, @DataOriginText,
			@AssetID, @SourceInterfaceType, @SourceID, @InterfaceStatusCode, @ErrorMessage, @InterfaceTableID, @PortfolioName, @PortfolioID, @AssetNatureCode, @AssetNatureText

		WHILE @@FETCH_STATUS = 0
		BEGIN
	BEGIN TRY /* Belső-1 */
			SET @l_ImportID = 0;

---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Error Section:
		SET @ErrorMessage = NULL;
		SET @l_BlockerError = '';
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceInterfaceType:
			If Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
				Set @l_ErrorMessage = 'SourceInterfaceType is Empty';
				SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
				Select 'IFC.ASSET', @ID, 'sourceInterfaceType', @ERR_SIFTYPE_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
				SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceID:
			If Trim(Isnull(@SourceID,'')) = ''
			BEGIN
				Set @l_ErrorMessage = 'SourceID is Empty';
				SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
				Select 'IFC.ASSET', @ID, 'sourceID', @ERR_SID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
				SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------

-- Portfolio ellenőrzése:
			IF Isnull(@PortfolioID, 0) = 0 and Trim(Isnull(@PortfolioName,'')) <> ''
			BEGIN
				IF exists(select 1 from Gen.Portfolio where Portfolio.Name = Trim(Isnull(@PortfolioName,'')))
				BEGIN
					SET @PortfolioID = (select Top 1 ID from Gen.Portfolio where Portfolio.Name = Trim(Isnull(@PortfolioName,'')) order by Id Desc);
				End
				Else
				BEGIN
					Set @l_ErrorMessage = 'PortfolioName is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'portfolioName', @ERR_PortfName_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					SET @l_BlockerError = 'T';
				END;
			END;

			IF Isnull(@PortfolioID, 0) = 0
			BEGIN
				Set @l_ErrorMessage = 'PortfolioID is Empty';
				SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
				Select 'IFC.ASSET', @ID, 'portfolioID', @ERR_PortfID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
				SET @l_BlockerError = 'T';
			END
			Else
			Begin
				SELECT @l_DataOriginCode =
					CASE (Select TreatmentTypeCode from Gen.Portfolio where Id = @PortfolioID)
					WHEN 'TREATMENT_TYPE_MANDATE' THEN 'DATA_ORIGIN_PRINCIPAL' /* Megbízásos */
					WHEN 'TREATMENT_TYPE_ASSIGNMENT' THEN 'DATA_ORIGIN_LEGAL_PREDECESSOR'  /* Engedményzett */
					ELSE 'DATA_ORIGIN_LEGAL_PREDECESSOR' /* Engedményzett */
				END;
			End;


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 2023-02-17:
-- Létezik a fedezethez DebtCase ?
			IF Not exists (Select 1 from IFC.DebtCaseAsset
							join DCS.DebtCase on DebtCase.SourceInterfaceType = DebtCaseAsset.SourceInterFaceType and DebtCase.SourceID = DebtCaseAsset.SourceDebtCaseId
							where DebtCaseAsset.SourceAssetID = Trim(@SourceID)
							and DebtCaseAsset.SourceInterFaceType = @SourceInterfaceType )
			BEGIN
				Set @l_ErrorMessage = 'IFC.DebtCaseAssset not found';
				SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
				Select 'IFC.ASSET', @ID, 'portfolioID', @ERR_DebtCaseAssset_Is_Not_Found, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
				SET @l_BlockerError = 'T';
			END;

-- @AssetClassText,@AssetClass:
			-- 0 - NULL:
			If Trim(Isnull(@AssetClassText,'')) = ''
				Set @AssetClassText = NULL;
			If Trim(Isnull(@AssetClass,'')) = ''
				Set @AssetClass = NULL;
			Set @AssetClassText = Trim(@AssetClassText);

			-- 1 - Üres:
			If @AssetClassText is NULL and @AssetClass is NULL
			BEGIN
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Asset.AssetClassText/Code is empty,');
				Set @AssetClass = 'ASSET_CLASS_CHATTEL'; /* Ingó */
			END;
			-- 2 - Text-NotValid:
			If @AssetClassText is NOT NULL and @AssetClass is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'ASSET_CLASS_%' and Text = @AssetClassText)
				Begin
					Set @l_ErrorMessage = 'AssetClassText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'assetClassText', @ERR_AssetClassText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @AssetClassText = NULL;
				End;

				Else
					Set @AssetClass = (select Top 1 CodeId from Gen.Translation where codeid like 'ASSET_CLASS_%' and Text = @AssetClassText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @AssetClassText is NULL and @AssetClass is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'ASSET_CLASS_%' and Id = @AssetClass)
			BEGIN
					Set @l_ErrorMessage = 'AssetClass is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'assetClass', @ERR_AssetClass_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @AssetClass = NULL;
			END;

-- @AssetTypeText, @AssetType:
			-- 0 - NULL:
			If Trim(Isnull(@AssetTypeText,'')) = ''
				Set @AssetTypeText = NULL;
			If Trim(Isnull(@AssetType,'')) = ''
				Set @AssetType = NULL;
			Set @AssetTypeText = Trim(@AssetTypeText);

			-- 1 - Üres:
			If @AssetTypeText is NULL and @AssetType is NULL
			BEGIN
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Asset.AssetClassText/Code is empty,');
				Set @AssetType = 'ASSET_PROPERTY_TYPE_5'; /* Egyéb */
			END;
			-- 2 - Text-NotValid:
			If @AssetTypeText is not NULL and @AssetType is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'ASSET_PROPERTY_TYPE_%' and Text = @AssetTypeText)
				Begin
					Set @l_ErrorMessage = 'AssetTypeText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'assetTypeText', @ERR_AssetTypeText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @AssetTypeText = NULL;
				End;
				Else
					Set @AssetType = (select Top 1 CodeId from Gen.Translation where codeid like 'ASSET_PROPERTY_TYPE_%' and Text = @AssetTypeText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @AssetTypeText is NULL and @AssetType is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'ASSET_PROPERTY_TYPE_%' and Id = @AssetType)
			BEGIN
					Set @l_ErrorMessage = 'AssetType is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'assetType', @ERR_AssetType_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @AssetType = NULL;
			END;


-- @StatusText, @Status:
			-- 0 - NULL:
			If Trim(Isnull(@StatusText,'')) = ''
				Set @StatusText = NULL;
			If Trim(Isnull(@Status,'')) = ''
				Set @Status = NULL;
			Set @StatusText = Trim(@StatusText);

			-- 1 - Üres:
			If @StatusText is NULL and @Status is NULL
			BEGIN
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Asset.AssetClassText/Code is empty,');
				Set @Status = @Status;
			END;
			-- 2 - Text-NotValid:
			If @StatusText is not NULL and @Status is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'ASSET_STATUS_%' and Text = @StatusText)
				Begin
					Set @l_ErrorMessage = 'StatusText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'statusText', @ERR_AssetStatusText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @StatusText = NULL;
				End
				Else
					Set @Status = (select Top 1 CodeId from Gen.Translation where codeid like 'ASSET_STATUS_%' and Text = @StatusText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @StatusText is NULL and @Status is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'ASSET_STATUS_%' and Id = @Status)
			BEGIN
					Set @l_ErrorMessage = 'Status is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'status', @ERR_AssetStatus_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @Status = NULL;
			END;

-- @LotSizeUnitText, @LotSizeUnitCode:
			-- 0 - NULL:
			If Trim(Isnull(@LotSizeUnitText,'')) = ''
				Set @LotSizeUnitText = NULL;
			If Trim(Isnull(@LotSizeUnitCode,'')) = ''
				Set @LotSizeUnitCode = NULL;
			Set @LotSizeUnitText = Trim(@LotSizeUnitText);
			Set @LotSizeUnitCode = NULL;  /* még tisztázandó */

			-- 1 - Üres:
			If @LotSizeUnitText is NULL and @LotSizeUnitCode is NULL
			BEGIN
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Asset.AssetClassText/Code is empty,');
				--Set @LotSizeUnit = 'SIZE_UNIT_SIZE_UNIT_M2'; /* Normál */
				Set @LotSizeUnitCode = @LotSizeUnitCode;
			END;
			-- 2 - Text-NotValid:
			If @LotSizeUnitText is not NULL and @LotSizeUnitCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'SIZE_UNIT_SIZE_UNIT_%' and Text = @LotSizeUnitText)
				Begin
					Set @l_ErrorMessage = 'LotSizeUnitText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'lotSizeUnitText', @ERR_LotSizeUnitText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @LotSizeUnitText = NULL;
				End;
				Else
					Set @LotSizeUnitCode = (select Top 1 CodeId from Gen.Translation where codeid like 'SIZE_UNIT_SIZE_UNIT_%' and Text = @LotSizeUnitText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @LotSizeUnitText is NULL and @LotSizeUnitCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'SIZE_UNIT_SIZE_UNIT_%' and Id = @LotSizeUnitCode)
			BEGIN
					Set @l_ErrorMessage = 'LotSizeUnitCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'lotSizeUnitCode', @ERR_LotSizeUnitCode_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @LotSizeUnitCode = NULL;
			END;


-- @InhabitedText, @InhabitedCode:
			-- 0 - NULL:
			If Trim(Isnull(@InhabitedText,'')) = ''
				Set @InhabitedText = NULL;
			If Trim(Isnull(@InhabitedCode,'')) = ''
				Set @InhabitedCode = NULL;
			Set @InhabitedText = Trim(@InhabitedText);

			-- 1 - Üres:
			If @InhabitedText is NULL and @InhabitedCode is NULL
			BEGIN
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Asset.AssetClassText/Code is empty,');
				--Set @LotSizeUnit = 'SIZE_UNIT_SIZE_UNIT_M2'; /* Normál */
				Set @InhabitedCode = @InhabitedCode;
			END;
			-- 2 - Text-NotValid:
			If @InhabitedText is not NULL and @InhabitedCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'BOOLEAN_%' and Text = @InhabitedText)
				Begin
					Set @l_ErrorMessage = 'InhabitedText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'inhabitedText', @ERR_InhabitedText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @InhabitedText = NULL;
				End
				Else
					Set @InhabitedCode = (select Top 1 CodeId from Gen.Translation where codeid like 'BOOLEAN_%' and Text = @InhabitedText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @InhabitedText is NULL and @InhabitedCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'BOOLEAN_%' and Id = @InhabitedCode)
			BEGIN
					Set @l_ErrorMessage = 'InhabitedCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'inhabitedCode', @ERR_InhabitedCode_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @InhabitedCode = NULL;
			END;

-- @AssetNatureText, @AssetNatureCode:
			-- 0 - NULL:
			If Trim(Isnull(@AssetNatureText,'')) = ''
				Set @AssetNatureText = NULL;
			If Trim(Isnull(@AssetNatureCode,'')) = ''
				Set @AssetNatureCode = NULL;
			Set @AssetNatureText = Trim(@AssetNatureText);

			-- 1 - Üres:
			If @AssetNatureText is NULL and @AssetNatureCode is NULL
			BEGIN
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Asset.AssetClassText/Code is empty,');
				--Set @LotSizeUnit = 'SIZE_UNIT_SIZE_UNIT_M2'; /* Normál */
				Set @AssetNatureCode = @AssetNatureCode;
			END;
			-- 2 - Text-NotValid:
			If @AssetNatureText is not NULL and @AssetNatureCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'ASSET_NATURE_%' and Text = @AssetNatureText)
				Begin
					Set @l_ErrorMessage = 'AssetNatureText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'assetNatureText', @ERR_AssetNatureText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @AssetNatureText = NULL;
				End;
				Else
					Set @AssetNatureCode = (select Top 1 CodeId from Gen.Translation where codeid like 'ASSET_NATURE_%' and Text = @AssetNatureText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @AssetNatureText is NULL and @AssetNatureCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'ASSET_NATURE_%' and Id = @AssetNatureCode)
			BEGIN
					Set @l_ErrorMessage = 'AssetNatureCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'assetNatureCode', @ERR_AssetNatureCode_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @AssetNatureCode = NULL;
			END;


-- @RentedOutText, @RentedOutCode:
			-- 0 - NULL:
			If Trim(Isnull(@RentedOutText,'')) = ''
				Set @RentedOutText = NULL;
			If Trim(Isnull(@RentedOutCode,'')) = ''
				Set @RentedOutCode = NULL;
			Set @RentedOutText = Trim(@RentedOutText);

			-- 1 - Üres:
			If @RentedOutText is NULL and @RentedOutCode is NULL
			BEGIN
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Asset.AssetClassText/Code is empty,');
				--Set @LotSizeUnit = 'SIZE_UNIT_SIZE_UNIT_M2'; /* Normál */
				Set @RentedOutCode = @RentedOutCode;
			END;
			-- 2 - Text-NotValid:
			If @RentedOutText is not NULL and @RentedOutCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'BOOLEAN_%' and Text = @RentedOutText)
				Begin
					Set @l_ErrorMessage = 'RentedOutText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'rentedOutText', @ERR_RentedOutText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @RentedOutText = NULL;
				End;
				Else
					Set @RentedOutCode = (select Top 1 CodeId from Gen.Translation where codeid like 'BOOLEAN_%' and Text = @RentedOutText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @RentedOutText is NULL and @RentedOutCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'BOOLEAN_%' and Id = @RentedOutCode)
			BEGIN
					Set @l_ErrorMessage = 'RentedOutCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'rentedOutText', @ERR_RentedOutCode_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @RentedOutCode = NULL;
			END;


-- @UndividedCommonPropertyText, @UndividedCommonPropertyCode:
			-- 0 - NULL:
			If Trim(Isnull(@UndividedCommonPropertyText,'')) = ''
				Set @UndividedCommonPropertyText = NULL;
			If Trim(Isnull(@UndividedCommonPropertyCode,'')) = ''
				Set @UndividedCommonPropertyCode = NULL;
			Set @UndividedCommonPropertyText = Trim(@UndividedCommonPropertyText);

			-- 1 - Üres:
			If @UndividedCommonPropertyText is NULL and @UndividedCommonPropertyCode is NULL
			BEGIN
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Asset.AssetClassText/Code is empty,');
				--Set @LotSizeUnit = 'SIZE_UNIT_SIZE_UNIT_M2'; /* Normál */
				Set @UndividedCommonPropertyCode = @UndividedCommonPropertyCode;
			END;
			-- 2 - Text-NotValid:
			If @UndividedCommonPropertyText is not NULL and @UndividedCommonPropertyCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'BOOLEAN_%' and Text = @UndividedCommonPropertyText)
				Begin
					Set @l_ErrorMessage = 'UndividedCommonPropertyText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'undividedCommonPropertyText', @ERR_UndividedCommonPropertyText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @UndividedCommonPropertyText = NULL;
				End;
				Else
					Set @UndividedCommonPropertyCode = (select Top 1 CodeId from Gen.Translation where codeid like 'BOOLEAN_%' and Text = @UndividedCommonPropertyText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @UndividedCommonPropertyText is NULL and @UndividedCommonPropertyCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'BOOLEAN_%' and Id = @UndividedCommonPropertyCode)
			BEGIN
					Set @l_ErrorMessage = 'UndividedCommonPropertyCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'undividedCommonPropertyCode', @ERR_UndividedCommonPropertyCode_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @UndividedCommonPropertyCode = NULL;
			END;


-- @LandRegisterOfficeEntityID:
			-- 0 - NULL:
			-- 1 - Üres:
			-- 2 - Text-NotValid:
			-- 3 - Code-NotValid:
			If Not exists (select 1 from PRt.Entity where Entity.Id = @LandRegisterOfficeEntityID)
			and @LandRegisterOfficeEntityID is not null
			BEGIN
					Set @l_ErrorMessage = 'LandRegisterOfficeEntityID is not Exists';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSET', @ID, 'landRegisterOfficeEntityID', @ERR_LandRegisterOfficeEntityID_Not_Exists, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @UndividedCommonPropertyCode = NULL;
			END;


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- Hibakiírás:

		IF @l_BlockerError = 'T'
		BEGIN
			SET @l_AssetErrorRowCounts = @l_AssetErrorRowCounts + 1;
			UPDATE IFC.ASSET SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage,
				LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
		END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Betöltés:
		IF @l_BlockerError = ''
		BEGIN
---------------------------------------------------------------------------------------------------------------------------------------------
			  BEGIN TRAN
				  -- New ObjectID:
				  INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr, PortfolioId)
				  SELECT @ASTAsset as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @PortfolioID;
				  SET @l_ObjectID = SCOPE_IDENTITY();

				  -- Új Asset felvitele:
				  INSERT INTO AST.Asset(ObjectID, AssetClassCode, AssetTypeCode, Name, LandRegisterReference, StatusCode, LandRegisterOfficeEntityID, CreationDate, CreationTime, CreationUserName, LandRegisterCity, ExternalReferenceNr, StructureSize, LotSize, LotSizeUnitCode, InhabitedCode, RentedOutCode, UndividedCommonPropertyCode, DataOriginCode, SourceInterfaceType, SourceID, AssetNatureCode)
				  SELECT
						  @l_ObjectID as ObjectID,
						  @AssetClass as AssetClass,
						  @AssetType as AssetType,
						  @Name as Name,
						  @LandRegisterReference,
						  @Status as Status,
						  @LandRegisterOfficeEntityID,
						  CAST( GETDATE() AS Date ) as CreationDate,
						  CAST( GETDATE() AS Time ) as CreationTime,
						  @CurrentUserName as CreationUserName,
						  @LandRegisterCity as LandRegisterCity,
						  @ExternalReferenceNr as ExternalReferenceNr,
						  @StructureSize as StructureSize,
						  @LotSize as LotSize,
						  @LotSizeUnitCode as LotSizeUnitCode,
						  @InhabitedCode as InhabitedCode,
						  @RentedOutCode as RentedOutCode,
						  @UndividedCommonPropertyCode as UndividedCommonPropertyCode,
						  @l_DataOriginCode as DataOriginCode,
						  @SourceInterfaceType as SourceInterfaceType,
						  @SourceID as SourceID,
						  @AssetNatureCode as AssetNatureCode;

				  SET @l_ImportID = SCOPE_IDENTITY()
				  SET @l_AssetImportedRowCounts = @l_AssetImportedRowCounts + 1;
				  UPDATE IFC.Asset SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', Errormessage = NULL, AssetID = @l_ImportID WHERE ID = @ID;
        COMMIT
			END; /* @ErrorMessage is NULL */

		  END TRY /*Belső-1*/
		  BEGIN CATCH /*Belső-1*/
        if @@trancount > 0
           rollback

				SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
				SET @l_AssetErrorRowCounts = @l_AssetErrorRowCounts + 1;
				UPDATE IFC.Asset SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage, AssetID = NULL WHERE ID = @ID;
			END CATCH /*Belső-1*/

			FETCH NEXT FROM db_cursor INTO
				@ID, @AssetClass, @AssetClassText, @AssetType, @AssetTypeText, @Name, @LandRegisterCity, @LandRegisterReference, @Status, @StatusText,
				@LandRegisterOfficeEntityID, @ExternalReferenceNr, @StructureSize, @LotSize, @LotSizeUnitCode, @LotSizeUnitText, @InhabitedCode,
				@InhabitedText, @RentedOutCode, @RentedOutText, @UndividedCommonPropertyCode, @UndividedCommonPropertyText, @DataOriginCode, @DataOriginText,
				@AssetID, @SourceInterfaceType, @SourceID, @InterfaceStatusCode, @ErrorMessage, @InterfaceTableID, @PortfolioName, @PortfolioID, @AssetNatureCode, @AssetNatureText
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;
/*
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- AssetValuation:
*/

		SET @l_AssetValuationAllRowCounts = (Select count(*) FROM IFC.AssetValuation
		where SourceInterfaceType = @l_sourceInterfaceType
				AND
					(
					(AssetValuation.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and AssetValuation.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.AssetValuation' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));

		DECLARE db_cursor CURSOR FOR
		SELECT ID,
			ValuerEntityID, ValuationDate, ValuationTypeCode, ValuationTypeText, ValidFrom, ValidUntil, AssetValuationID,
			SourceInterfaceType, SourceID, SourceAssetID, SourceCompanyID, InterfaceStatusCode, ErrorMessage, InterfaceTableID,
			StatusCode, StatusText
		FROM IFC.AssetValuation
		where SourceInterfaceType = @l_sourceInterfaceType
				AND
					(
					(AssetValuation.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and AssetValuation.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.AssetValuation' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
				Order by AssetValuation.ID;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID,
			@ValuerEntityID, @ValuationDate, @ValuationTypeCode, @ValuationTypeText,
			@ValidFrom, @ValidUntil, @AssetValuationID,
			@SourceInterfaceType, @SourceID, @SourceAssetID, @SourceCompanyID, @InterfaceStatusCode, @ErrorMessage, @InterfaceTableID,
			@StatusCode, @StatusText

		WHILE @@FETCH_STATUS = 0
		BEGIN
	BEGIN TRY /* Belső-2 */
			SET @l_ImportID = 0;
-- Error Section:
			SET @ErrorMessage = NULL;
			SET @l_BlockerError = '';
-- @SourceInterfaceType:
			If Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
				SET @l_ErrorMessage = 'SourceInterfaceType is Empty';
				SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
				Select 'IFC.ASSETVALUATION', @ID, 'sourceInterfaceType', @ERR_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
				SET @l_BlockerError = 'T';
			END;
-- @SourceID:
			If Trim(Isnull(@SourceID,'')) = ''
			BEGIN
				SET @l_ErrorMessage = 'SourceID is Empty';
				SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
				Select 'IFC.ASSETVALUATION', @ID, 'sourceID', @ERR_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
				SET @l_BlockerError = 'T';
			END;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 2023-02-17:
-- StatusCode:
			-- 0 - NULL:
			If Trim(Isnull(@StatusText,'')) = ''
				Set @StatusText = NULL;
			If Trim(Isnull(@StatusCode,'')) = ''
				Set @StatusCode = NULL;
			Set @StatusText = Trim(@StatusText);

			-- 1 - Üres:
			If @StatusText is NULL and @StatusCode is NULL
			BEGIN
				Set @StatusCode = 'STATUS_NORMAL';
			END;
			-- 2 - Text-NotValid:
			If @StatusText is not NULL and @StatusCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'Status_%' and Text = @StatusText)
				Begin
					Set @l_ErrorMessage = 'StatusText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATION', @ID, 'statusText', @ERR_StatusText_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @StatusText = NULL;
				End;
				Else
					Set @StatusCode = (select Top 1 CodeId from Gen.Translation where codeid like 'Status_%' and Text = @StatusText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @StatusText is NULL and @StatusCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'Status_%' and Id = @StatusCode)
			BEGIN
					Set @l_ErrorMessage = 'StatusCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATION', @ID, 'statusCode', @ERR_StatusCode_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @StatusCode = NULL;
			END;
-- @ValuerEntityID:
			-- 0 - NULL:
			-- 1 - Üres:
			If Isnull(@ValuerEntityID,0) = 0
			BEGIN
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' AssetValuation.ValuerEntiyID is Empty,');
				Set @ValuerEntityID = @ValuerEntityID;
			END;
			-- 2 - Text-NotValid:
			-- 3 - Code-NotValid:
			If Not exists (select 1 from PRt.Entity where Entity.Id = @ValuerEntityID)
			and @ValuerEntityID is not NULL
			BEGIN
					Set @l_ErrorMessage = 'ValuerEntiyID is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATION', @ID, 'valuerEntityID', @ERR_ValuerEntityID_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @ValuerEntityID = NULL;
			END;
-- @SourceAssetID:
			-- 0 - NULL:
			If Trim(Isnull(@SourceAssetID,'')) = ''
				Set @SourceAssetID = NULL;
			Set @SourceAssetID = Trim(@SourceAssetID);

			-- 1 - Üres:
			If @SourceAssetID is NULL
			Begin
					Set @l_ErrorMessage = 'SourceAssetID is empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATION', @ID, 'sourceAssetID', @ERR_SourceAssetID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			End;
			-- 2 - Text-NotValid:
			-- 3 - Code-NotValid:
			If not exists (Select 1 from IFC.Asset where SourceInterfaceType = @SourceInterfaceType and SourceID = @SourceAssetID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED'))
			Begin
					Set @l_ErrorMessage = 'SourceAssetID is not exists';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATION', @ID, 'sourceAssetID', @ERR_SourceAssetID_is_Not_Exists, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @SourceAssetID = NULL;
			End;
-- @ValuationTypeCode, @ValuationTypeText:
			-- 0 - NULL:
			If Trim(Isnull(@ValuationTypeCode,'')) = ''
				Set @ValuationTypeCode = NULL;
			If Trim(Isnull(@ValuationTypeText,'')) = ''
				Set @ValuationTypeText = NULL;
			Set @ValuationTypeText = Trim(@ValuationTypeText);

			-- 1 -Üres:
			If @ValuationTypeCode is NULL and @ValuationTypeText is NULL
			Begin
				Set @ErrorMessage = @ErrorMessage;
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' AssetValuation.ValuationTypeText/Code is empty,');
			End;
			-- 2 - Text-NotValid:
			If @ValuationTypeText is not NULL and @ValuationTypeCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'ASSET_VALUATION_TYPE_%' and Text = @ValuationTypeText)
				Begin
					Set @l_ErrorMessage = 'TypeText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATION', @ID, 'valuationTypeText', @ERR_valuationTypeText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @ValuationTypeText = NULL;
				End
				Else
					Set @ValuationTypeCode = (select Top 1 CodeId from Gen.Translation where codeid like 'ASSET_VALUATION_TYPE_%' and Text = @ValuationTypeText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @ValuationTypeText is NULL and @ValuationTypeCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'ASSET_VALUATION_TYPE_%' and Id = @ValuationTypeCode)
			BEGIN
					Set @l_ErrorMessage = 'TypeCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATION', @ID, 'valuationTypeCode', @ERR_valuationTypeText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @ValuationTypeCode = NULL;
			END;
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


			IF Isnull(@ErrorMessage,'') <> ''
			BEGIN
				SET @l_AssetValuationErrorRowCounts = @l_AssetValuationErrorRowCounts + 1;
				UPDATE IFC.AssetValuation SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage, AssetValuationID = NULL WHERE ID = @ID;
			END;

			Set @ValidFrom = Isnull(@ValidFrom,CAST( GETDATE() AS Date ));

-- Már létezik az értékelés:
/*
			IF @ErrorMessage is not NULL
			BEGIN
				If exists (Select 1 from AST.AssetValuation where AssetID = @l_AssetID and ValuerEntityID = @ValuerEntityID and Isnull(ValuationDate,'1901-01-01') = Isnull(@ValuationDate,'1901-01-01') and ValuationTypeCode = @ValuationTypeCode and Isnull(ValidFrom,'1901-01-01') = Isnull(@ValidFrom,'1901-01-01') and Isnull(ValidUntil,'1901-01-01') = Isnull(@ValidUntil,'1901-01-01'))
				BEGIN
					Set @l_ImportID = (Select Top 1 AssetValuation.Id from AST.AssetValuation where AssetID = @l_AssetID and ValuerEntityID = @ValuerEntityID and Isnull(ValuationDate,'1901-01-01') = Isnull(@ValuationDate,'1901-01-01') and ValuationTypeCode = @ValuationTypeCode and Isnull(ValidFrom,'1901-01-01') = Isnull(@ValidFrom,'1901-01-01') and Isnull(ValidUntil,'1901-01-01') = Isnull(@ValidUntil,'1901-01-01') order by AssetValuation.ID desc);
					SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
					UPDATE IFC.AssetValuation SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED', ErrorMessage = @ErrorMessage, AssetValuationID = @l_ImportID WHERE ID = @ID;
				END;
			END;
*/
			IF Isnull(@ErrorMessage,'') = ''
			BEGIN
				Set @l_AssetID = (Select Top 1 AssetID from IFC.Asset where SourceInterfaceType = @SourceInterfaceType and SourceID = @SourceAssetID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by ID Desc);

        BEGIN TRAN
				  -- New ObjectID:
				  INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				  SELECT @ASTAssetValuation as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				  SET @l_ObjectID = SCOPE_IDENTITY();

				  -- Új AssetValuation felvitele:
				  INSERT INTO AST.AssetValuation(ObjectID, AssetID, ValuerEntityID, ValuationDate, ValuationTypeCode, ValidFrom, ValidUntil, CreationDate, CreationTime, CreationUserName, StatusCode)
				  SELECT
					  @l_ObjectID as ObjectID,
					  @l_AssetID as AssetID,
					  @ValuerEntityID as ValuerEntityID,
					  @ValuationDate as ValuationDate,
					  @ValuationTypeCode as ValuationTypeCode,
					  @ValidFrom as ValidFrom,
					  @ValidUntil as ValidUntil,
					  CAST( GETDATE() AS Date ) as CreationDate,
					  CAST( GETDATE() AS Time ) as CreationTime,
					  @CurrentUserName as CreationUserName,
					  @StatusCode as StatusCode;

				  SET @l_ImportID = SCOPE_IDENTITY()
				  SET @l_AssetValuationImportedRowCounts = @l_AssetValuationImportedRowCounts + 1;
				  UPDATE IFC.AssetValuation SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', Errormessage = NULL, AssetValuationID = @l_ImportID WHERE ID = @ID;
        COMMIT
			END; /* @ErrorMessage is NULL */

			END TRY /*Belső-2*/
			BEGIN CATCH /*Belső-2*/
        if @@trancount > 0
           rollback

				SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
				SET @l_AssetValuationErrorRowCounts = @l_AssetValuationErrorRowCounts + 1;
				UPDATE IFC.AssetValuation SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage, AssetValuationID = NULL WHERE ID = @ID;
			END CATCH /*Belső-2*/

			FETCH NEXT FROM db_cursor INTO @ID,
			@ValuerEntityID, @ValuationDate, @ValuationTypeCode, @ValuationTypeText,
			@ValidFrom, @ValidUntil, @AssetValuationID,
			@SourceInterfaceType, @SourceID, @SourceAssetID, @SourceCompanyID, @InterfaceStatusCode, @ErrorMessage, @InterfaceTableID,
			@StatusCode, @StatusText

		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- AssetValuationValue:

		SET @l_AssetValuationValueAllRowCounts = (Select Count(*) FROM IFC.AssetValuationValue where SourceInterfaceType = @l_sourceInterfaceType
				AND
					(
					(AssetValuationValue.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and AssetValuationValue.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.AssetValuationValue' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));

		DECLARE db_cursor CURSOR FOR
		SELECT ID,
			ValueTypeCode, ValueTypeText, NetValue, VatRate, VatValue, GrossValue, ValueCurrencyCode, ValueCurrencyText,
			AssetValuationValueID, AssetValuationID, SourceInterfaceType, SourceID, SourceAssetValuationID, InterfaceStatusCode, ErrorMessage,
			InterfaceTableID
		FROM IFC.AssetValuationValue
		where SourceInterfaceType = @l_sourceInterfaceType
				AND
					(
					(AssetValuationValue.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and AssetValuationValue.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.AssetValuationValue' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
				Order by AssetValuationValue.ID;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID,
			@ValueTypeCode, @ValueTypeText, @NetValue, @VatRate, @VatValue, @GrossValue, @ValueCurrencyCode, @ValueCurrencyText,
			@AssetValuationValueID, @AssetValuationID, @SourceInterfaceType, @SourceID, @SourceAssetValuationID, @InterfaceStatusCode, @ErrorMessage,
			@InterfaceTableID

		WHILE @@FETCH_STATUS = 0
		BEGIN
	BEGIN TRY /* Belső-3 */
			SET @l_ImportID = 0;
-- Error Section:
			SET @ErrorMessage = NULL;
-- @SourceInterfaceType:
			If Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
					Set @l_ErrorMessage = 'SourceInterfaceType is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATIONVALUE', @ID, 'sourceInterfaceType', @ERR_SourceInterfaceType_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;
-- @SourceID:
			If Trim(Isnull(@SourceID,'')) = ''
			BEGIN
					Set @l_ErrorMessage = 'SourceID is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATIONVALUE', @ID, 'sourceID', @ERR_SourceID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- @ValueCurrencyText, @ValueCurrencyCode
			-- 0 - NULL:
			If Trim(Isnull(@ValueCurrencyText,'')) = ''
				Set @ValueCurrencyText = NULL;
			If Trim(Isnull(@ValueCurrencyCode,'')) = ''
				Set @ValueCurrencyCode = NULL;
			Set @ValueCurrencyText = Trim(@ValueCurrencyText);

			-- 1 -Üres:
			If @ValueCurrencyText is NULL and @ValueCurrencyCode is NULL
			Begin
					Set @l_ErrorMessage = 'CurrencyText/Code is empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATIONVALUE', @ID, 'valueCurrencyText', @ERR_CurrencyText_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATIONVALUE', @ID, 'valueCurrencyCode', @ERR_Currency_Code_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			End;
			-- 2 - Text-NotValid:
			If @ValueCurrencyText is not NULL and @ValueCurrencyCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'CURRENCY_%' and Text = @ValueCurrencyText)
				Begin
					Set @l_ErrorMessage = 'CurrencyText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATIONVALUE', @ID, 'valueCurrencyText', @ERR_CurrencyText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @ValueCurrencyText = NULL;
				End;
				Else
					Set @ValueCurrencyCode = (select Top 1 CodeId from Gen.Translation where codeid like 'CURRENCY_%' and Text = @ValueCurrencyText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @ValueCurrencyText is NULL and @ValueCurrencyCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'CURRENCY_%' and Id = @ValueCurrencyCode)
			BEGIN
					Set @l_ErrorMessage = 'CurrencyCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATIONVALUE', @ID, 'valueCurrencyCode', @ERR_CurrencyCode_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @ValueCurrencyCode = NULL;
			END;
-- @ValueTypeText, @ValueTypeCode
			-- 0 - NULL:
			If Trim(Isnull(@ValueTypeText,'')) = ''
				Set @ValueTypeText = NULL;
			If Trim(Isnull(@ValueTypeCode,'')) = ''
				Set @ValueTypeCode = NULL;
			Set @ValueTypeText = Trim(@ValueTypeText);

			-- 1 -Üres:
			If @ValueTypeText is NULL and @ValueTypeCode is NULL
			Begin
				Set @ErrorMessage = @ErrorMessage;
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' AssetValuationValueValue.TypeText/Code is empty,');
			End;
			-- 2 - Text-NotValid:
			If @ValueTypeText is not NULL and @ValueTypeCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'ASSET_VALUATION_VALUE_TYPE_%' and Text = @ValueTypeText)
				Begin
					Set @l_ErrorMessage = 'ValueTypeText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATIONVALUE', @ID, 'valueTypeText', @ERR_ValueTypeText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @ValueTypeText = NULL;
				End;
				Else
					Set @ValueTypeCode = (select Top 1 CodeId from Gen.Translation where codeid like 'ASSET_VALUATION_VALUE_TYPE_%' and Text = @ValueTypeText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @ValueTypeText is NULL and @ValueTypeCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'ASSET_VALUATION_VALUE_TYPE_%' and Id = @ValueTypeCode)
			BEGIN
					Set @l_ErrorMessage = 'ValueTypeCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATIONVALUE', @ID, 'valueTypeCode', @ERR_ValueTypeCode_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @ValueTypeCode = NULL;
			END;
-- @SourceAssetValuationID
			-- 0 - NULL:
			If Trim(Isnull(@SourceAssetValuationID,'')) = ''
				Set @SourceAssetValuationID = NULL;
			Set @SourceAssetValuationID = Trim(@SourceAssetValuationID);

			-- 1 - Üres:
			If @SourceAssetValuationID is NULL
			Begin
					Set @l_ErrorMessage = 'SourceAssetValuationID is empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATIONVALUE', @ID, 'sourceAssetValuationID', @ERR_SourceAssetValuationID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			End;
			-- 2 - Text-NotValid:
			-- 3 - Code-NotValid:
			If not exists (Select 1 from IFC.AssetValuation where SourceInterfaceType = @SourceInterfaceType and SourceID = @SourceAssetValuationID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED'))
			Begin
					Set @l_ErrorMessage = 'SourceAssetValuationID is not valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ASSETVALUATIONVALUE', @ID, 'sourceAssetValuationID', @ERR_SourceAssetValuationID_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @SourceAssetValuationID = NULL;
			End;


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

			IF Isnull(@ErrorMessage,'') <> ''
			BEGIN
				SET @l_AssetValuationValueErrorRowCounts = @l_AssetValuationValueErrorRowCounts + 1;
				UPDATE IFC.AssetValuationValue SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage, AssetValuationValueID = NULL WHERE ID = @ID;
			END;



			--Set @l_AssetID = (Select Top 1 AssetID from IFC.Asset where SourceInterfaceType = @SourceInterfaceType and SourceID = @SourceAssetID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by ID Desc);
			Set @l_AssetValuationID = (Select Top 1 AssetValuationID from IFC.AssetValuation where SourceInterfaceType = @SourceInterfaceType and SourceID = @SourceAssetValuationID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by ID Desc);

			--Set @l_AssetValuation = (Select Top 1 AssetValuation.ID from AST.AssetValuation where AssetID = @l_AssetID and ValuerEntityID = @ValuerEntityID and Isnull(ValuationDate,'1901-01-01') = Isnull(@ValuationDate,'1901-01-01') and ValuationTypeCode = @ValuationTypeCode and Isnull(ValidFrom,'1901-01-01') = Isnull(@ValidFrom,'1901-01-01') and Isnull(ValidUntil,'1901-01-01') = Isnull(@ValidUntil,'1901-01-01'));

-- Már létezik az értékelés:
/*
			IF @ErrorMessage is not NULL
			BEGIN
				If exists (Select 1 from AST.AssetValuationValue where AssetValuationID = @l_AssetValuation and ValueTypeCode = @ValueTypeCode and Isnull(NetValue,0) = @NetValue /*and Isnull(VatID,0) = @VatID*/ and Isnull(VatValue,0) = @VatValue and Isnull(GrossValue,0) = @GrossValue)
				BEGIN
					Set @l_ImportID = (Select Top 1 AssetValuationValue.ID from AST.AssetValuationValue where AssetValuationID = @l_AssetValuation and ValueTypeCode = @ValueTypeCode and Isnull(NetValue,0) = @NetValue /*and Isnull(VatID,0) = @VatID*/ and Isnull(VatValue,0) = @VatValue and Isnull(GrossValue,0) = @GrossValue order by AssetValuationValue.ID desc);
					SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
					UPDATE IFC.AssetValuationValue SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED', ErrorMessage = @ErrorMessage, AssetValuationValueID = @l_ImportID WHERE ID = @ID;
				END;
			END;
*/
			IF Isnull(@ErrorMessage,'') = ''
			BEGIN
        BEGIN TRAN
				  -- New ObjectID:
				  INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				  SELECT @ASTAssetValuationValue as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				  SET @l_ObjectID = SCOPE_IDENTITY();

				  -- Új AssetValuationValue felvitele:
				  INSERT INTO AST.AssetValuationValue(ObjectID, AssetValuationID, ValueTypeCode, NetValue, VatID, VatValue, GrossValue, ValueCurrencyCode, CreationDate, CreationTime, CreationUserName)
				  SELECT
					  @l_ObjectID as ObjectID,
					  @l_AssetValuationID as AssetValuationID,
					  @ValueTypeCode as ValueTypeCode,
					  @NetValue as NetValue,
					  NULL as VatID,
					  @VatValue as VatValue,
					  @GrossValue as GrossValue,
					  @ValueCurrencyCode as ValueCurrencyCode,
					  CAST( GETDATE() AS Date ) as CreationDate,
					  CAST( GETDATE() AS Time ) as CreationTime,
					  @CurrentUserName as CreationUserName;

				  SET @l_ImportID = SCOPE_IDENTITY()
				  SET @l_AssetValuationValueImportedRowCounts = @l_AssetValuationValueImportedRowCounts + 1;
				  UPDATE IFC.AssetValuationValue SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', Errormessage = NULL, AssetValuationValueID = @l_ImportID WHERE ID = @ID;
        COMMIT
			END; /* @ErrorMessage is NULL */
			END TRY /*Belső-3*/
			BEGIN CATCH /*Belső-3*/
        if @@trancount > 0
           rollback

				SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
				SET @l_AssetValuationValueErrorRowCounts = @l_AssetValuationValueErrorRowCounts + 1;
				UPDATE IFC.AssetValuationValue SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage, AssetValuationValueID = NULL WHERE ID = @ID;
			END CATCH /*Belső-3*/

			FETCH NEXT FROM db_cursor INTO @ID,
				@ValueTypeCode, @ValueTypeText, @NetValue, @VatRate, @VatValue, @GrossValue, @ValueCurrencyCode, @ValueCurrencyText,
				@AssetValuationValueID, @AssetValuationID, @SourceInterfaceType, @SourceID, @SourceAssetValuationID, @InterfaceStatusCode, @ErrorMessage,
				@InterfaceTableID
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Address:
		SET @l_AddressAllRowCounts = (Select Count(*) FROM IFC.Address where SourceInterfaceType = @l_sourceInterfaceType
				AND Isnull(SourceCompanyID,'') = '' and Isnull(SourcePersonID,'') = '' and SourceAssetID is not NULL
				AND
					(
					(Address.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Address.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Address' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));

		DECLARE db_cursor CURSOR FOR
		SELECT ID,
			ObjectID, SourceInterfaceType, SourceID, SourceCompanyID, SourcePersonID, RegistrationNr, StatisticalNr, AddressType,
			Country, CountryCode, CountryID, ZipCode, City, Street, HouseNr, FullAddress, [Description], ValidFrom, ValidUntil, Field1,
			Field2, Field3, Field4, Field5, CrefoID, InterfaceStatusCode, ErrorMessage, ActualisationDate, [Operation], InterfaceTableID, MainAddress,
			SourceAssetID
		FROM IFC.Address
		where SourceInterfaceType = @l_sourceInterfaceType
				AND Isnull(SourceCompanyID,'') = '' and Isnull(SourcePersonID,'') = '' and SourceAssetID is not NULL
				 AND
					(
					(Address.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(Address.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Address' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
				Order by Address.ID;


		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID,
			@ObjectID, @SourceInterfaceType, @SourceID, @SourceCompanyID, @SourcePersonID, @RegistrationNr, @StatisticalNr, @AddressType,
			@Country, @CountryCode, @CountryID, @ZipCode, @City, @Street, @HouseNr, @FullAddress, @Description, @ValidFrom, @ValidUntil, @Field1,
			@Field2, @Field3, @Field4, @Field5, @CrefoID, @InterfaceStatusCode, @ErrorMessage, @ActualisationDate, @Operation, @InterfaceTableID, @MainAddress,
			@SourceAssetID

		WHILE @@FETCH_STATUS = 0
		BEGIN
	BEGIN TRY /* Belső-4 */
			SET @l_ImportID = 0;
-- Error Section:
			SET @ErrorMessage = NULL;
-- @SourceInterfaceType:
			If Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
					Set @l_ErrorMessage = 'SourceInterfaceType is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ADDRESS', @ID, 'sourceInterfaceType', @ERR_SourceInterfaceType_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;
-- @SourceID:
			If Trim(Isnull(@SourceID,'')) = ''
			BEGIN
					Set @l_ErrorMessage = 'SourceID is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ADDRESS', @ID, 'sourceID', @ERR_SourceID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;
-- @SourceAssetID:
			If Trim(Isnull(@SourceAssetID,'')) = ''
			BEGIN
					Set @l_ErrorMessage = 'SourceAssetID is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ADDRESS', @ID, 'sourceID', @ERR_SourceAssetID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;
			If @SourceAssetID is Not NULL and not exists(Select 1 from IFC.Asset where SourceInterfaceType = @SourceInterfaceType and SourceId = Trim(@SourceAssetID) and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED'))
				Set @l_AssetID = (Select Top 1 AssetID from IFC.Asset where SourceInterfaceType = @SourceInterfaceType and SourceId = Trim(@SourceAssetID) and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by Id desc);
			Else
				Begin
					Set @l_ErrorMessage = 'SourceAsset is not exists';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ADDRESS', @ID, 'sourceAssetID', @ERR_SourceAsset_is_Not_Exists, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @SourceAssetValuationID = NULL;
				End;

-- @Country,@CountryCode:
			-- 0 - NULL:
			If Trim(Isnull(@Country,'')) = ''
				Set @Country = NULL;
			If Trim(Isnull(@CountryCode,'')) = ''
				Set @CountryCode = NULL;
			Set @Country = Trim(@Country);

			-- 1 - Üres:
			If @Country is NULL and @CountryCode is NULL
			BEGIN
				SET @ErrorMessage = @ErrorMessage;
				--Set @CountryCode = 'COUNTRY_CHATTEL'; /* Ingó */
			END;
			-- 2 - Text-NotValid:
			If @Country is NOT NULL and @CountryCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'COUNTRY_%' and Text = @Country)
				Begin
					Set @l_ErrorMessage = 'Country is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ADDRESS', @ID, 'country', @ERR_Country_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @Country = NULL;
				End
				Else
					Set @CountryCode = (select Top 1 CodeId from Gen.Translation where codeid like 'COUNTRY_%' and Text = @Country order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @Country is NULL and @CountryCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'COUNTRY_%' and Id = @CountryCode)
			BEGIN
					Set @l_ErrorMessage = 'CountryCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ADDRESS', @ID, 'countryCode', @ERR_Country_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @CountryCode = NULL;
			END;



			IF Isnull(@ErrorMessage,'') <> ''
			BEGIN
				SET @l_AddressErrorRowCounts = @l_AddressErrorRowCounts + 1;
				UPDATE IFC.Address SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage/*, AddressID = NULL*/ WHERE ID = @ID;
			END;



-- Már van a cím:
/*
			IF @ErrorMessage is NULL
			BEGIN
				If exists (Select 1 from PRT.[Address] where AddressType = @AddressType and AssetID = @l_AssetID)
				BEGIN
					/*Set @l_ImportID = (Select Top 1 [Address].ID from PRT.[Address] where AddressType = @AddressType and  AssetID = @l_AssetID order by [Address].ID desc);*/
					SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
					UPDATE IFC.Address SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED', ErrorMessage = @ErrorMessage/*, AssetID  = @l_ImportID*/ WHERE ID = @ID;
				END;
			END;
*/
			IF Isnull(@ErrorMessage,'') = ''
			BEGIN
        BEGIN TRAN
				  -- New ObjectID:
				  INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				  SELECT @PRTADDRESS as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				  SET @l_ObjectID = SCOPE_IDENTITY();

				  -- Új Address felvitele:
				  INSERT INTO PRT.Address(
					  AddressType, AddressStructure, CountryID, ZipCode, Settlement, District, PublicPlaceName, PublicPlaceType,
					  HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, EntityID,
					  ObjectID, PropertyID, CreationDate, CreationTime, CreationUserName,
					  Comments, AssetID, CountryClassCode, DataSource, SourceInterfaceType, SourceID, StatusCode, DataOriginCode)
				  SELECT
					  'ADDRESS_TYPE_ASSET_LOCATION' as AddressType,
					  NULL as AddressStructure,
					  NULL as CountryID,
					  @ZipCode as ZipCode,
					  @City as Settlement,
					  NULL as District,
					  @Street as PublicPlaceName,
					  NULL as PublicPlaceType,
					  NULL as HouseNr,
					  @LandRegisterReference as LandRegisterReference,
					  NULL as Staircase,
					  NULL as Building,
					  NULL as [Floor],
					  NULL as Door,
					  NULL as ValidFrom,
					  NULL as ValidUntil,
					  NULL as EntityID,
					  @l_ObjectID as ObjectID,
					  NULL as PropertyID,
					  CAST( GETDATE() AS Date ) as CreationDate,
					  CAST( GETDATE() AS Time ) as CreationTime,
					  @CurrentUserName as CreationUserName,
					  NULL as Comments,
					  @l_AssetID as AssetID,
					  NULL as CountryClassCode,
					  NULL as DataSource,
					  @SourceInterfaceType as SourceInterfaceType,
					  @SourceID as SourceID,
					  'STATUS_NORMAL' as StatusCode,
					  @l_DataOriginCode as DataOriginCode;

				  SET @l_ImportID = SCOPE_IDENTITY()
				  SET @l_AddressImportedRowCounts = @l_AddressImportedRowCounts + 1;
				  UPDATE IFC.Address SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', Errormessage = NULL/*, AddressID = @l_ImportID*/ WHERE ID = @ID;
        COMMIT
			END; /* @ErrorMessage is NULL */

			END TRY /*Belső-4*/
			BEGIN CATCH /*Belső-4*/
        if @@trancount > 0
           rollback

				SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
				SET @l_AddressErrorRowCounts = @l_AddressErrorRowCounts + 1;
				UPDATE IFC.Address SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage/*, AddressID = NULL*/ WHERE ID = @ID;
			END CATCH /*Belső-4*/

			FETCH NEXT FROM db_cursor INTO @ID,
				@ObjectID, @SourceInterfaceType, @SourceID, @SourceCompanyID, @SourcePersonID, @RegistrationNr, @StatisticalNr, @AddressType,
				@Country, @CountryCode, @CountryID, @ZipCode, @City, @Street, @HouseNr, @FullAddress, @Description, @ValidFrom, @ValidUntil, @Field1,
				@Field2, @Field3, @Field4, @Field5, @CrefoID, @InterfaceStatusCode, @ErrorMessage, @ActualisationDate, @Operation, @InterfaceTableID, @MainAddress,
				@SourceAssetID
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- DebtorAsset:
/* 2023-02-08:
		DECLARE db_cursor CURSOR FOR
		SELECT ID, AssetDebtorRelationTypeCode, AssetDebtorRelationTypeText, OwnPercent, SharePercent, ShareDividend, ShareDivisor, ValidFrom, ValidUntil, StatusCode, Status, DebtorAssetID, AssetID, DebtorID, SourceInterfaceType, SourceID, SourceAssetID, SourceDebtorID, InterfaceStatusCode, ErrorMessage, InterfaceTableID
		FROM IFC.DebtorAsset
		where InterfaceStatusCode = 'INTERFACE_STATUS_NEW' and SourceInterfaceType = @l_sourceInterfaceType Order by Id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID,
			@AssetDebtorRelationTypeCode, @AssetDebtorRelationTypeText, @OwnPercent, @SharePercent, @ShareDividend, @ShareDivisor,
			@ValidFrom, @ValidUntil, @StatusCode, @Status, @DebtorAssetID, @AssetID, @DebtorID, @SourceInterfaceType, @SourceID,
			@SourceAssetID, @SourceDebtorID, @InterfaceStatusCode, @ErrorMessage, @InterfaceTableID

		WHILE @@FETCH_STATUS = 0
		BEGIN

			SET @l_ImportID = 0;
-- Error Section:
			SET @ErrorMessage = NULL;
-- @SourceInterfaceType:
			If Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
				SET @ErrorMessage = 'SourceInterfaceType is Empty,';
			END;
-- @SourceID:
			If Trim(Isnull(@SourceID,'')) = ''
			BEGIN
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' SourceID is Empty,');
			END;

			IF @ErrorMessage is not NULL
			BEGIN
				SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
				UPDATE IFC.DebtorAsset SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage, DebtorAssetID = NULL WHERE ID = @ID;
			END;


			Set @l_AssetID = (Select Top 1 AssetID from IFC.Asset where SourceInterfaceType = @SourceInterfaceType and SourceId = @SourceAssetID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by Id desc);
			Set @l_DebtorID = (Select Top 1 DebtorID from IFC.Debtor where SourceInterfaceType = @SourceInterfaceType and SourceId = @SourceId and Isnull(SourcePersonId, SourceCompanyId) = @SourceDebtorID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by Id desc);

-- Már létezik:
/*
			IF @ErrorMessage is NULL
			BEGIN
				If exists (Select 1 from AST.DebtorAsset where AssetID = @AssetID and DebtorID = @l_DebtorID)
				BEGIN
					SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
					UPDATE IFC.DebtorAsset SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED', ErrorMessage = @ErrorMessage/*, AssetID  = @l_ImportID*/ WHERE ID = @ID;
				END;
			END;
*/
			IF @ErrorMessage is NULL
			BEGIN
				-- New ObjectID:
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				SELECT @ASTDebtorAsset as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				SET @l_ObjectID = SCOPE_IDENTITY();

				-- Új DebtorAsset felvitele:
				INSERT INTO AST.DebtorAsset(
					ObjectID, AssetID, DebtorID, OwnPercent, ValidFrom, ValidUntil, StatusCode, CreationDate, CreationTime, CreationUserName,
					AssetDebtorRelationTypeCode, SharePercent, ShareDividend, ShareDivisor)
				SELECT
					@l_ObjectID as ObjectID,
					@l_AssetID as AssetID,
					@l_DebtorID as DebtorID,
					@OwnPercent as OwnPercent,
					@ValidFrom as ValidFrom,
					@ValidUntil as ValidUntil,
					@StatusCode as StatusCode,
					CAST( GETDATE() AS Date ) as CreationDate,
					CAST( GETDATE() AS Time ) as CreationTime,
					@CurrentUserName as CreationUserName,
					NULL as AssetDebtorRelationTypeCode,
					@SharePercent as SharePercent,
					@ShareDividend as ShareDividend,
					@ShareDivisor as ShareDivisor;

				SET @l_ImportID = SCOPE_IDENTITY();
				SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
				UPDATE IFC.DebtorAsset SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', Errormessage = NULL, DebtorAssetID = @l_ImportID WHERE ID = @ID;

			END; /* @ErrorMessage is NULL */

			FETCH NEXT FROM db_cursor INTO @ID,
				@AssetDebtorRelationTypeCode, @AssetDebtorRelationTypeText, @OwnPercent, @SharePercent, @ShareDividend, @ShareDivisor,
				@ValidFrom, @ValidUntil, @StatusCode, @Status, @DebtorAssetID, @AssetID, @DebtorID, @SourceInterfaceType, @SourceID,
				@SourceAssetID, @SourceDebtorID, @InterfaceStatusCode, @ErrorMessage, @InterfaceTableID
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;
*/
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- DebtCaseAsset
		SET @l_DebtCaseAssetAllRowCounts = (Select Count(*) FROM IFC.DebtCaseAsset where SourceInterfaceType = @l_sourceInterfaceType
				AND
					(
					(DebtCaseAsset.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and DebtCaseAsset.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.DebtCaseAsset' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));

		DECLARE db_cursor CURSOR FOR
		SELECT ID,
			StatusCode, StatusText, TypeCode, TypeText, DecisionNr, ValidFrom, ValidUntil,
			DebtCaseAssetID, AssetID, DebtCaseID, SourceInterfaceType, SourceID, SourceAssetID, SourceDebtCaseID,
			InterfaceStatusCode, ErrorMessage, InterfaceTableID
		FROM IFC.DebtCaseAsset
		where SourceInterfaceType = @l_sourceInterfaceType
				AND
					(
					(DebtCaseAsset.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and DebtCaseAsset.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.DebtCaseAsset' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
				Order by Id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID,
			@StatusCode, @StatusText, @TypeCode, @TypeText, @DecisionNr, @ValidFrom, @ValidUntil,
			@DebtCaseAssetID, @AssetID, @DebtCaseID, @SourceInterfaceType, @SourceID, @SourceAssetID, @SourceDebtCaseID,
			@InterfaceStatusCode, @ErrorMessage, @InterfaceTableID

		WHILE @@FETCH_STATUS = 0
		BEGIN
	BEGIN TRY /* Belső-5 */
			SET @l_ImportID = 0;
-- Error Section:
			SET @ErrorMessage = NULL;
-- @SourceInterfaceType:
			If Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
					Set @l_ErrorMessage = 'SourceInterfaceType is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.DEBTCASEASSET', @ID, 'sourceInterfaceType', @ERR_SourceInterfaceType_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;
-- @SourceID:
			If Trim(Isnull(@SourceID,'')) = ''
			BEGIN
					Set @l_ErrorMessage = 'SourceID is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.DEBTCASEASSET', @ID, 'sourceID', @ERR_SourceID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;

-- SourceAssetID:
	-- 0 - NULL:
			If Trim(Isnull(@SourceAssetID,'')) = ''
				Set @SourceAssetID = NULL;
			Set @SourceAssetID = Trim(@SourceAssetID);

			If @SourceAssetID is NULL
			BEGIN
					Set @l_ErrorMessage = 'SourceAssetID is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.DEBTCASEASSET', @ID, 'sourceAssetID', @ERR_SourceAssetID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;
	-- 1 - Not exists:
			Set @l_AssetID = NULL;
			if exists (Select 1 from IFC.Asset where SourceInterfaceType = @SourceInterfaceType and SourceId = @SourceAssetID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED'))
				Set @l_AssetID = (Select Top 1 AssetID from IFC.Asset where SourceInterfaceType = @SourceInterfaceType and SourceId = @SourceAssetID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by Id desc);
			Else
				Begin
					Set @l_ErrorMessage = 'Related Asset is not Found';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.DEBTCASEASSET', @ID, 'sourceAssetID', @ERR_Related_Asset_Is_Not_Found, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @SourceAssetID = NULL;
				End;

-- SourceDebtCaseID:
	-- 0 - NULL:
			If Trim(Isnull(@SourceDebtCaseID,'')) = ''
				Set @SourceDebtCaseID = NULL;
			Set @SourceDebtCaseID = Trim(@SourceDebtCaseID);

			If @SourceDebtCaseID is NULL
			BEGIN
					Set @l_ErrorMessage = 'SourceDebtCaseID is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.DEBTCASEASSET', @ID, 'sourceDebtCaseID', @ERR_SourceDebtCaseID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @SourceAssetID = NULL;
			END;
	-- 1 - Not exists:
			Set @l_DebtCaseID = NULL;
			if exists (Select 1 from IFC.DebtCase where SourceInterfaceType = @SourceInterfaceType and SourceId = @SourceDebtCaseID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED'))
				Set @l_DebtCaseID = (Select Top 1 DebtCaseID from IFC.DebtCase where SourceInterfaceType = @SourceInterfaceType and SourceId = @SourceDebtCaseID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by Id desc);


-- @StatusCode
			-- 0 - NULL:
			If Trim(Isnull(@StatusText,'')) = ''
				Set @StatusText = NULL;
			If Trim(Isnull(@StatusCode,'')) = ''
				Set @StatusCode = NULL;
			Set @StatusText = Trim(@StatusText);

			-- 1 -Üres:
			If @StatusText is NULL and @StatusCode is NULL
			Begin
				Set @StatusCode = 'STATUS_NORMAL';
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' DebtCaseAsset.StatusText/Code is empty,');
			End;
			-- 2 - Text-NotValid:
			If @StatusText is not NULL and @StatusCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'STATUS_%' and Text = @StatusText)
				Begin
					Set @l_ErrorMessage = 'StatusText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.DEBTCASEASSET', @ID, 'statusText', @ERR_StatusText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @StatusText = NULL;
				End
				Else
					Set @StatusCode = (select Top 1 CodeId from Gen.Translation where codeid like 'STATUS_%' and Text = @StatusText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @StatusText is NULL and @StatusCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'STATUS_%' and Id = @StatusCode)
			BEGIN
					Set @l_ErrorMessage = 'StatusCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.DEBTCASEASSET', @ID, 'statusCode', @ERR_StatusCode_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @StatusCode = NULL;
			END;


-- @TypeCode
			-- 0 - NULL:
			If Trim(Isnull(@TypeText,'')) = ''
				Set @TypeText = NULL;
			If Trim(Isnull(@TypeCode,'')) = ''
				Set @TypeCode = NULL;
			Set @TypeText = Trim(@TypeText);

			-- 1 -Üres:
			If @TypeText is NULL and @TypeCode is NULL
			Begin
				Set @ErrorMessage = @ErrorMessage;
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' DebtCaseAsset.TypeText/Code is Empty,');
			End;
			-- 2 - Text-NotValid:
			If @TypeText is not NULL and @TypeCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'ASSET_RELATION_TYPE_%' and Text = @TypeText)
				Begin
					Set @l_ErrorMessage = 'DebtCaseAssetTypeText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.DEBTCASEASSET', @ID, 'typeText', @ERR_DebtCaseAssetTypeText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @TypeText = NULL;
				End
				Else
					Set @TypeCode = (select Top 1 CodeId from Gen.Translation where codeid like 'ASSET_RELATION_TYPE_%' and Text = @TypeText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @TypeText is NULL and @TypeCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'ASSET_RELATION_TYPE_%' and Id = @TypeCode)
			BEGIN
					Set @l_ErrorMessage = 'DebtCaseAssetTypeCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.DEBTCASEASSET', @ID, 'typeCode', @ERR_DebtCaseAssetTypeCode_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @TypeCode = NULL;
			END;

--- Error kiírás:
			IF Isnull(@ErrorMessage,'') <> ''
			BEGIN
				SET @l_DebtCaseAssetErrorRowCounts = @l_DebtCaseAssetErrorRowCounts + 1;
				UPDATE IFC.DebtCaseAsset SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage, DebtCaseAssetID = NULL WHERE ID = @ID;
			END;


--- létezik:
/*
			IF @ErrorMessage is NULL
			BEGIN
				If exists (Select 1 from AST.DebtorAsset where AssetID = @AssetID and DebtorID = @l_DebtorID)
				BEGIN
					SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
					UPDATE IFC.DebtCaseAsset SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED', ErrorMessage = @ErrorMessage WHERE ID = @ID;
				END;
			END;

*/

			IF Isnull(@ErrorMessage,'') = ''
			BEGIN

				Set @l_PortfolioId = NULL;
				if exists (Select Object.PortfolioID
											from GEN.Object
											join AST.Asset on Asset.ObjectID = Object.ID
											where Asset.ID = @l_AssetID)
				Set @l_PortfolioId = (Select Top 1 Object.PortfolioID
										from GEN.Object
										join AST.Asset on Asset.ObjectID = Object.ID
										where Asset.ID = @l_AssetID order by Object.ID desc);

        BEGIN TRAN

				  -- New ObjectID:
				  INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr, PortfolioID)
				  SELECT @ASTDebtCaseAsset as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @l_PortfolioId;
				  SET @l_ObjectID = SCOPE_IDENTITY();
				  --select * from AST.DebtCaseAsset
				  -- Új debtcaseAsset felvitele:


				  INSERT INTO AST.DebtCaseAsset(ObjectID, AssetID, DebtCaseID, StatusCode, TypeCode, DecisionNr, ValidFrom, ValidUntil, CreationDate, CreationTime, CreationUserName)
				  SELECT
					  @l_ObjectID as ObjectID,
					  @l_AssetID as AssetID,
					  @l_DebtCaseID as DebtCaseID,
					  @StatusCode as StatusCode,
					  @TypeCode as TypeCode,
					  @DecisionNr as DecisionNr,
					  @ValidFrom as ValidFrom,
					  @ValidUntil as ValidUntil,
					  CAST( GETDATE() AS Date ) as CreationDate,
					  CAST( GETDATE() AS Time ) as CreationTime,
					  @CurrentUserName as CreationUserName;

				  SET @l_ImportID = SCOPE_IDENTITY()
				  SET @l_DebtCaseAssetImportedRowCounts = @l_DebtCaseAssetImportedRowCounts + 1;
				  UPDATE IFC.DebtCaseAsset SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', Errormessage = NULL, DebtCaseAssetID = @l_ImportID WHERE ID = @ID;
        COMMIT
			END; /* @ErrorMessage is NULL */

			END TRY /*Belső-5*/
			BEGIN CATCH /*Belső-5*/
        if @@trancount > 0
           rollback

				SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
				SET @l_DebtCaseAssetErrorRowCounts = @l_DebtCaseAssetErrorRowCounts + 1;
				UPDATE IFC.DebtCaseAsset SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage, DebtCaseAssetID = NULL WHERE ID = @ID;
			END CATCH /*Belső-5*/

			FETCH NEXT FROM db_cursor INTO @ID,
			@StatusCode, @StatusText, @TypeCode, @TypeText, @DecisionNr, @ValidFrom, @ValidUntil,
			@DebtCaseAssetID, @AssetID, @DebtCaseID, @SourceInterfaceType, @SourceID, @SourceAssetID, @SourceDebtCaseID,
			@InterfaceStatusCode, @ErrorMessage, @InterfaceTableID
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- EntityAsset:
		SET @l_EntityAssetAllRowCounts = (Select Count(*) FROM IFC.EntityAsset where SourceInterfaceType = @l_sourceInterfaceType
				AND
					(
					(EntityAsset.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and EntityAsset.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.EntityAsset' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));

		DECLARE db_cursor CURSOR FOR
		SELECT ID, EntityAssetRelationTypeCode, EntityAssetRelationTypeText, SharePercent, ShareDividend, ShareDivisor,
			ExternalReferenceNr, DecisionNr, ValidFrom, ValidUntil, StatusCode, StatusText, EntityAssetID, AssetID,
			EntityID, SourceInterfaceType, SourceID, SourceAssetID, SourceEntityID, InterfaceStatusCode, ErrorMessage, InterfaceTableID
		FROM IFC.EntityAsset
		where SourceInterfaceType = @l_sourceInterfaceType
				AND
					(
					(EntityAsset.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and EntityAsset.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.EntityAsset' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /* and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
				Order by EntityAsset.ID;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO
			@ID, @EntityAssetRelationTypeCode, @EntityAssetRelationTypeText, @SharePercent, @ShareDividend, @ShareDivisor,
			@ExternalReferenceNr, @DecisionNr, @ValidFrom, @ValidUntil, @StatusCode, @StatusText, @EntityAssetID, @AssetID,
			@EntityID, @SourceInterfaceType, @SourceID, @SourceAssetID, @SourceEntityID, @InterfaceStatusCode, @ErrorMessage, @InterfaceTableID

		WHILE @@FETCH_STATUS = 0
		BEGIN
	BEGIN TRY /* Belső-6 */
			SET @l_ImportID = 0;
-- Error Section:
			SET @ErrorMessage = NULL;
-- @SourceInterfaceType:
			If Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
					Set @l_ErrorMessage = 'SourceInterfaceType is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ENTITYASSET', @ID, 'sourceInterfaceType', @ERR_SourceInterfaceType_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
		END;
-- @SourceID:
			If Trim(Isnull(@SourceID,'')) = ''
			BEGIN
					Set @l_ErrorMessage = 'SourceID is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ENTITYASSET', @ID, 'sourceID', @ERR_SourceID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;

-- SourceAssetID:
	-- 0 - NULL:
			If Trim(Isnull(@SourceAssetID,'')) = ''
				Set @SourceAssetID = NULL;
			Set @SourceAssetID = Trim(@SourceAssetID);

			If @SourceAssetID is NULL
			BEGIN
					Set @l_ErrorMessage = 'SourceAssetID is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ENTITYASSET', @ID, 'sourceAssetID', @ERR_SourceAssetID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;
	-- 1 - Not exists:
			Set @l_AssetID = NULL;
			if exists (Select 1 from IFC.Asset where SourceInterfaceType = @SourceInterfaceType and SourceId = @SourceAssetID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED'))
				Set @l_AssetID = (Select Top 1 AssetID from IFC.Asset where SourceInterfaceType = @SourceInterfaceType and SourceId = @SourceAssetID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by Id desc);
			Else
				Begin
					Set @l_ErrorMessage = 'Related Asset is not Found';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ENTITYASSET', @ID, 'sourceAssetID', @ERR_Related_Asset_Is_Not_Found, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
				End;


-- SourceEntityID:
	-- 0 - NULL:
			If Trim(Isnull(@SourceEntityID,'')) = ''
				Set @SourceEntityID = NULL;
			Set @SourceEntityID = Trim(@SourceEntityID);

			If @SourceEntityID is NULL
			BEGIN
					Set @l_ErrorMessage = 'SourceEntityID is Empty';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ENTITYASSET', @ID, 'sourceEntityID', @ERR_SourceEntityID_Is_Empty, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;
	-- 1 - Not exists:
			Set @l_EntityID = NULL;
			if exists (Select 1 From PRT.Entity where Entity.SourceInterfaceType = @SourceInterfaceType and Entity.SourceId = @SourceEntityID)
				Set @l_EntityID = (Select Top 1 Entity.Id From PRT.Entity where Entity.SourceInterfaceType = @SourceInterfaceType and Entity.SourceId = @SourceEntityID Order by Entity.ID desc);
			Else
				Begin
					Set @l_ErrorMessage = 'Related Entity is not Found';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ENTITYASSET', @ID, 'sourceEntityID', @ERR_Related_Entity_Is_Not_Found, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
				ENd;

-- @EntityAssetRelationTypeCode:
			-- 0 - NULL:
			If Trim(Isnull(@EntityAssetRelationTypeText,'')) = ''
				Set @EntityAssetRelationTypeText = NULL;
			If Trim(Isnull(@EntityAssetRelationTypeCode,'')) = ''
				Set @EntityAssetRelationTypeCode = NULL;
			Set @EntityAssetRelationTypeText = Trim(@EntityAssetRelationTypeText);

			-- 1 -Üres:
			If @EntityAssetRelationTypeText is NULL and @EntityAssetRelationTypeCode is NULL
			Begin
				Set @ErrorMessage = @ErrorMessage;
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' EntityAsset.EntityAssetRelationTypeText/Code is Empty,');
			End;
			-- 2 - Text-NotValid:
			If @EntityAssetRelationTypeText is not NULL and @EntityAssetRelationTypeCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'ENTITY_ASSET_RELATION_TYPE_%' and Text = @EntityAssetRelationTypeText)
				Begin
					Set @l_ErrorMessage = 'EntityAssetRelationTypeText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ENTITYASSET', @ID, 'entityAssetRelationTypeText', @ERR_EntityAssetRelationTypeText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @EntityAssetRelationTypeText = NULL;
				End;
				Else
					Set @EntityAssetRelationTypeCode = (select Top 1 CodeId from Gen.Translation where codeid like 'ENTITY_ASSET_RELATION_TYPE_%' and Text = @EntityAssetRelationTypeText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @EntityAssetRelationTypeText is NULL and @EntityAssetRelationTypeCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'ENTITY_ASSET_RELATION_TYPE_%' and Id = @EntityAssetRelationTypeCode)
			BEGIN
					Set @l_ErrorMessage = 'EntityAssetRelationTypeCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ENTITYASSET', @ID, 'entityAssetRelationTypeCode', @ERR_EntityAssetRelationTypeCode_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @EntityAssetRelationTypeCode = NULL;
			END;


-- @StatusCode
			-- 0 - NULL:
			If Trim(Isnull(@StatusText,'')) = ''
				Set @StatusText = NULL;
			If Trim(Isnull(@StatusCode,'')) = ''
				Set @StatusCode = NULL;
			Set @StatusText = Trim(@StatusText);

			-- 1 -Üres:
			If @StatusText is NULL and @StatusCode is NULL
			Begin
				Set @StatusCode = 'STATUS_NORMAL';
				--SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' EntityAsset.StatusText/Code is Empty,');
			End;
			-- 2 - Text-NotValid:
			If @StatusText is not NULL and @StatusCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'STATUS_%' and Text = @StatusText)
				Begin
					Set @l_ErrorMessage = 'EntityAssetStatusText is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ENTITYASSET', @ID, 'statusText', @ERR_EntityAssetStatusText_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @StatusText = NULL;
				End;
				Else
					Set @StatusCode = (select Top 1 CodeId from Gen.Translation where codeid like 'STATUS_%' and Text = @StatusText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @StatusText is NULL and @StatusCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'STATUS_%' and Id = @StatusCode)
			BEGIN
					Set @l_ErrorMessage = 'EntityAssetStatusCode is not Valid';
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.ENTITYASSET', @ID, 'statusCode', @ERR_EntityAssetStatusCode_Is_Not_Valid, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
					Set @StatusCode = NULL;
			END;

/*
			IF @ErrorMessage is NULL
			BEGIN
				If exists (Select 1 from AST.EntityAsset where EntityID = @EntityID and AssetID = @AssetID and EntityAssetRelationTypeCode = @EntityAssetRelationTypeCode)
				BEGIN
					SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
					UPDATE IFC.EntityAsset SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED', ErrorMessage = @ErrorMessage WHERE ID = @ID;
				END;
			END;
*/

--- Error kiírás:
			IF Isnull(@ErrorMessage,'') <> ''
			BEGIN
				SET @l_EntityAssetErrorRowCounts = @l_EntityAssetErrorRowCounts + 1;
				UPDATE IFC.EntityAsset SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage WHERE ID = @ID;
			END;

			IF Isnull(@ErrorMessage,'') = ''
			BEGIN
			  BEGIN TRAN
				  -- New ObjectID:
				  INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				  SELECT @ASTEntityAsset as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				  SET @l_ObjectID = SCOPE_IDENTITY()

				  INSERT INTO AST.EntityAsset(ObjectID, EntityID, AssetID, EntityAssetRelationTypeCode, SharePercent, ShareDividend, ShareDivisor, ExternalReferenceNr, DecisionNr, ValidFrom, ValidUntil, StatusCode, CreationDate, CreationTime, CreationUserName)
				  SELECT
					  @l_ObjectID as ObjectID,
					  @l_EntityId as EntityID,
					  @l_AssetId as AssetID,
					  @EntityAssetRelationTypeCode as EntityAssetRelationTypeCode,
					  @SharePercent as SharePercent,
					  @ShareDividend as ShareDividend,
					  @ShareDivisor as ShareDivisor,
					  @ExternalReferenceNr as ExternalReferenceNr,
					  @DecisionNr as DecisionNr,
					  @ValidFrom as ValidFrom,
					  @ValidUntil as ValidUntil,
					  @StatusCode as StatusCode,
					  CAST( GETDATE() AS Date ) as CreationDate,
					  CAST( GETDATE() AS Time ) as CreationTime,
					  @CurrentUserName as CreationUserName;

				  SET @l_ImportID = SCOPE_IDENTITY()

          /*DV-1592: insert Inkasso sync record*/
          if @l_InkassoSyncOn  = 1
          begin
            if   @EntityAssetRelationTypeCode = 'ENTITY_ASSET_RELATION_TYPE_OWNER'
             and @StatusCode = 'STATUS_NORMAL'
             and IsNull(@ValidFrom, @today) <= @today
             and @today <= IsNull(@ValidUntil, @today)
            begin
              set @l_inkassoSyncDebtCaseID = null

              select top 1 /*just in case*/ @l_inkassoSyncDebtCaseID = dca.DebtCaseID
              from AST.DebtCaseAsset dca
              where dca.AssetID = @l_AssetId
                and dca.StatusCode = 'STATUS_NORMAL'
                and IsNull(dca.ValidFrom, @today) <= @today
                and @today <= IsNull(dca.ValidUntil, @today)

              if @l_inkassoSyncDebtCaseID is not null
              begin
                /*the DebtCase sync is activated in the InvoiceLoader, so we have to check whether it was successful */
                if exists(select *
                          from IFC.InkassoSyncSendDebtCase d
                          where d.DebtCaseID = @l_inkassoSyncDebtCaseID
                         )
                begin
                  exec IFC.GenerateSendInkassoSyncData @syncType = 'Asset',
                                                       @syncEventType = 'insert',
                                                       @entityID = null,
                                                       @ID = @l_AssetId,
                                                       @debtCaseID = @l_inkassoSyncDebtCaseID,
                                                       @dataChangedUserName = @CurrentUserName,
                                                       @correlationID = @p_correlationID,
                                                       @moduleInstanceID = @p_moduleInstanceIDInkasso output,
                                                       @isBatch = 1
                end
              end
            end
          end

				  SET @l_EntityAssetImportedRowCounts = @l_EntityAssetImportedRowCounts + 1;
				  If Isnull(@ErrorMessage,'') = ''
					  Set @ErrorMessage = NULL;
				  UPDATE IFC.EntityAsset SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', Errormessage = @ErrorMessage, EntityAssetID = @l_ImportID WHERE ID = @ID;
        COMMIT
			END; /* @ErrorMessage is NULL */

			END TRY /*Belső-6*/
			BEGIN CATCH /*Belső-6*/
        if @@trancount > 0
           rollback

				SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
				SET @l_EntityAssetErrorRowCounts = @l_EntityAssetErrorRowCounts + 1;
				UPDATE IFC.EntityAsset SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage WHERE ID = @ID;
			END CATCH /*Belső-6*/

			FETCH NEXT FROM db_cursor INTO
				@ID, @EntityAssetRelationTypeCode, @EntityAssetRelationTypeText, @SharePercent, @ShareDividend, @ShareDivisor,
				@ExternalReferenceNr, @DecisionNr, @ValidFrom, @ValidUntil, @StatusCode, @StatusText, @EntityAssetID, @AssetID,
				@EntityID, @SourceInterfaceType, @SourceID, @SourceAssetID, @SourceEntityID, @InterfaceStatusCode, @ErrorMessage, @InterfaceTableID
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------



    END TRY


    BEGIN CATCH

        SELECT
        @ErrorMessage = ERROR_MESSAGE(),
        @ErrorSeverity = ERROR_SEVERITY(),
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'db_cursor');
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE db_cursor;

			DEALLOCATE db_cursor;
		END;

		INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT
			CAST( GETDATE() AS Date ),	-- LogDate,
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',				-- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			'IFC.AssetLoader',			-- ServiceName
			'1.0',						-- ServiceVersion
			'FATAL',					-- SeverityLevel
			NULL,						-- MessageCategory
			@ErrorMessage;				-- LogMessage

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

    -- ide.. 2022-11-22: ROLLBACK TRANSACTION;

        SELECT @ErrorMessage

    END CATCH;

--	END -- 'DEMO'
------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------

	SET @LogMessage = @LogMessage + 'AssetLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;

-- Asset:
	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AssetLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'Asset: ' + @CRLF
		+ 'All Row Nr.: ' + CAST(@l_AssetAllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Imported Nr.: ' + CAST(@l_AssetImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Existing Nr.: ' + CAST(@l_AssetExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Error Nr.: ' + CAST(@l_AssetErrorRowCounts as NVARCHAR(18));

-- AssetValuation:
INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AssetLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AssetValuation: ' + @CRLF
		+ 'All Row Nr.: ' + CAST(@l_AssetValuationAllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Imported Nr.: ' + CAST(@l_AssetValuationImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Existing Nr.: ' + CAST(@l_AssetValuationExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Error Nr.: ' + CAST(@l_AssetValuationErrorRowCounts as NVARCHAR(18));

-- AssetValuationValue:
INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AssetLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AssetValuationValue: ' + @CRLF
		+ 'All Row Nr.: ' + CAST(@l_AssetValuationValueAllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Imported Nr.: ' + CAST(@l_AssetValuationValueImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Existing Nr.: ' + CAST(@l_AssetValuationValueExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Error Nr.: ' + CAST(@l_AssetValuationValueErrorRowCounts as NVARCHAR(18));

-- Address:
INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AssetLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'Address: ' + @CRLF
		+ 'All Row Nr.: ' + CAST(@l_AddressAllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Imported Nr.: ' + CAST(@l_AddressImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Existing Nr.: ' + CAST(@l_AddressExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Error Nr.: ' + CAST(@l_AddressErrorRowCounts as NVARCHAR(18));

-- DebtCaseAsset:
INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AssetLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'DebtCaseAsset: ' + @CRLF
		+ 'All Row Nr.: ' + CAST(@l_DebtCaseAssetAllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Imported Nr.: ' + CAST(@l_DebtCaseAssetImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Existing Nr.: ' + CAST(@l_DebtCaseAssetExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Error Nr.: ' + CAST(@l_DebtCaseAssetErrorRowCounts as NVARCHAR(18));

-- EntityAsset:
INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AssetLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'EntityAsset: ' + @CRLF
		+ 'All: ' + CAST(@l_EntityAssetAllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Imp: ' + CAST(@l_EntityAssetImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Exist: ' + CAST(@l_EntityAssetExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'Err: ' + CAST(@l_EntityAssetErrorRowCounts as NVARCHAR(18));

-- EntityAsset:
INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AssetLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'Errors: ' + @CRLF
		+ @LogMessage;



	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.AssetLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	--If Isnull(@ErrorMessage,'') <> ''
	If	(@l_AssetErrorRowCounts  + @l_AssetValuationErrorRowCounts
		+ @l_AssetValuationValueErrorRowCounts  + @l_AddressErrorRowCounts
		+ @l_DebtCaseAssetErrorRowCounts  + @l_EntityAssetErrorRowCounts)
		<> 0
		Return 99;
	else
		Return 1;

END;


go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2023-04-16
-- Last modified date: 2023-04-16
-- Description:	It checks the responsibility based on the object and user specified in the parameter.
-- =============================================
CREATE PROCEDURE [GEN].[CheckResponsibilitySystemObject] 
	-- Add the parameters for the stored procedure here
	@p_systemObjectPath NVARCHAR(MAX),
	@p_referencedObjectID NUMERIC(16),
	@p_userName NVARCHAR(200)
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_systemObjectCode NVARCHAR(200) = NULL;
	DECLARE @l_persmissionCode NVARCHAR(200) = 'PERMISSION_DISABLED';
	DECLARE @l_responsibilitySystemObjectID NUMERIC(16) = NULL;
	DECLARE @l_responsibilitysystemObjectPermissionCode NVARCHAR(200) = NULL;
	DECLARE @l_objectTagList NVARCHAR(MAX) = NULL;
	DECLARE @l_responsibilitySystemObjectTagTagID NUMERIC(16) = NULL;
	DECLARE @l_responsibilitySystemObjectTagPermissionCode NVARCHAR(200) = NULL;

	BEGIN TRY
		IF COALESCE(@p_referencedObjectID, 0) > 0 
			SELECT @l_objectTagList = ',' + STRING_AGG([Tag].[ID], ',') + ','
			FROM [GEN].[ObjectTag] 
			JOIN [GEN].[Tag] ON ([Tag].[ID] = [ObjectTag].[TagID])
			WHERE [ObjectTag].[ReferencedObjectID] = @p_referencedObjectID;

		DECLARE @tempTable_Permissions AS TABLE
			(SystemObjectCode NVARCHAR(200),
			 PermissionCode NVARCHAR(200));

		DELETE FROM @tempTable_Permissions;

		DECLARE systemObject_cursor CURSOR FOR 
		SELECT 
			SystemObject.Code, 
			ResponsibilitySystemObject.ID,
			ResponsibilitySystemObject.PermissionCode
		FROM GEN.SystemObject 
		JOIN GEN.ResponsibilitySystemObject ON (ResponsibilitySystemObject.SystemObjectID = SystemObject.ID)
		JOIN GEN.Responsibility ON (Responsibility.ID = ResponsibilitySystemObject.ResponsibilityID)
		JOIN GEN.ResponsibilityUser ON (ResponsibilityUser.ResponsibilityID = Responsibility.ID)
		JOIN PRT.AppUser ON (AppUser.ID = ResponsibilityUser.UserID)
		WHERE SystemObject.ObjectPath = @p_systemObjectPath
		AND AppUser.UserName = @p_userName
		ORDER BY SystemObject.Code;

		OPEN systemObject_cursor;
		FETCH NEXT FROM systemObject_cursor
		INTO 
			@l_systemObjectCode,
			@l_responsibilitySystemObjectID,
			@l_responsibilitySystemObjectPermissionCode;

		WHILE @@FETCH_STATUS = 0 
		BEGIN 
			SELECT @l_persmissionCode = @l_responsibilitySystemObjectPermissionCode;

			DECLARE systemObjectTag_cursor CURSOR FOR 
			SELECT 
				ResponsibilitySystemObjectTag.TagID, 
				ResponsibilitySystemObjectTag.PermissionCode
			FROM GEN.ResponsibilitySystemObjectTag
			WHERE ResponsibilitySystemObjectTag.ResponsibilitySystemObjectID = @l_responsibilitySystemObjectID;

			OPEN systemObjectTag_cursor;
			FETCH NEXT FROM systemObjectTag_cursor 
			INTO 
				@l_responsibilitySystemObjectTagTagID,
				@l_responsibilitySystemObjectTagPermissionCode;

			WHILE @@FETCH_STATUS = 0 
			BEGIN
				IF @l_objectTagList LIKE CONCAT('%,', COALESCE(@l_responsibilitySystemObjectTagTagID, 0), ',%') 
					SELECT @l_persmissionCode = @l_responsibilitySystemObjectTagPermissionCode;

				FETCH NEXT FROM systemObjectTag_cursor 
				INTO 
					@l_responsibilitySystemObjectTagTagID,
					@l_responsibilitySystemObjectTagPermissionCode;
			END

			CLOSE systemObjectTag_cursor;
			DEALLOCATE systemObjectTag_cursor;

			INSERT INTO @tempTable_Permissions (SystemObjectCode, PermissionCode)
			SELECT @l_systemObjectCode, @l_persmissionCode;

			FETCH NEXT FROM systemObject_cursor
			INTO 
				@l_systemObjectCode,
				@l_responsibilitySystemObjectID,
				@l_responsibilitysystemObjectPermissionCode;
		END

		CLOSE systemObject_cursor;
		DEALLOCATE systemObject_cursor;

		SELECT SystemObjectCode, PermissionCode FROM @tempTable_Permissions;
	END TRY 

	BEGIN CATCH 
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'systemObject_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE systemObject_cursor;

			DEALLOCATE systemObject_cursor;
		END

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'systemObjectTag_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE systemObjectTag_cursor;

			DEALLOCATE systemObjectTag_cursor;
		END

		SELECT NULL, @l_persmissionCode;
	END CATCH
END
go

-- =============================================
-- Author:		<Kiss János>
-- Create date: <2022.08.11.>
-- Description:	<Description,,>
-- =============================================
CREATE FUNCTION [GEN].[CodeConverter] 
(	
	-- Add the parameters for the function here
	@Code as NVARCHAR(50)
)
RETURNS NVARCHAR(50)
AS
BEGIN

	DECLARE @l_AccentRemove NVARCHAR(150);
	
	SET @l_AccentRemove = REPLACE(@Code, 'Á', 'A');
	SET @l_AccentRemove = REPLACE(@l_AccentRemove, 'É', 'E');
	SET @l_AccentRemove = REPLACE(@l_AccentRemove, 'Í', 'I');
	SET @l_AccentRemove = REPLACE(@l_AccentRemove, 'Ó', 'O');
	SET @l_AccentRemove = REPLACE(@l_AccentRemove, 'Ö', 'O');
	SET @l_AccentRemove = REPLACE(@l_AccentRemove, 'Ő', 'O');
	SET @l_AccentRemove = REPLACE(@l_AccentRemove, 'Ú', 'U');
	SET @l_AccentRemove = REPLACE(@l_AccentRemove, 'Ü', 'U');
	SET @l_AccentRemove = REPLACE(@l_AccentRemove, 'Ű', 'U');
	SET @l_AccentRemove = REPLACE(@l_AccentRemove, ' ', '');
	SET @l_AccentRemove = REPLACE(@l_AccentRemove, '-', '');
	
RETURN
(
	-- Add the SELECT statement with parameter references here
	SELECT UPPER(@l_AccentRemove)
)
END
go

/*
=============================================
Author:		Balázs ARANYI
Create date: 2022-11-20
Last modified date: 2022-11-20
					2023-10-30 (T.Gé): [ContractItem].[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED'
Description:	Transfer data from IFC.CollectionContractItem table to CRM.CollectionContractItem
=============================================
*/
CREATE   PROCEDURE [IFC].[CollectionContractItemLoader] 
	-- Add the parameters for the stored procedure here
	@p_correlationID NVARCHAR(200), 
	@p_moduleInstanceID NUMERIC(16),
	@p_result INT OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'IFC.CollectionContractItemLoader'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_contractItemID NUMERIC(16) = NULL;
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--Az IFC.CollectionContractItem változói
	DECLARE @l_id NUMERIC(16, 0) = NULL;
	DECLARE @l_currencyCode NVARCHAR(200) = NULL;
	DECLARE @l_debtCapital MONEY = NULL;
	DECLARE @l_debtInterest MONEY = NULL;
	DECLARE @l_debtPenaltyInterest MONEY = NULL;
	DECLARE @l_debtCost MONEY = NULL;
	DECLARE @l_debtCostLocalCurrency MONEY = NULL;
	DECLARE @l_debtTotal MONEY = NULL;
	DECLARE @l_constructionCode NVARCHAR(200) = NULL;
	DECLARE @l_debtorName NVARCHAR(200) = NULL;
	DECLARE @l_pricingMethodCode NVARCHAR(200) = NULL;
	DECLARE @l_pricingMethodText NVARCHAR(200) = NULL;
	DECLARE @l_businessPercent NUMERIC(10, 0) = NULL;
	DECLARE @l_businessPrice MONEY = NULL;
	DECLARE @l_contractNr NVARCHAR(200) = NULL;
	DECLARE @l_decisionNr NVARCHAR(200) = NULL;
	DECLARE @l_accountNr NVARCHAR(200) = NULL;
	DECLARE @l_contractDate DATE = NULL;
	DECLARE @l_terminationDate DATE = NULL;
	DECLARE @l_financialMilestoneDate DATE = NULL;
	DECLARE @l_legalActionCode NVARCHAR(200) = NULL;
	DECLARE @l_legalActionText NVARCHAR(200) = NULL;
	DECLARE @l_collectionContractItemID NUMERIC(16, 0) = NULL;
	DECLARE @l_sourceID NVARCHAR(200) = NULL;
	DECLARE @l_sourceContractItemID NVARCHAR(200) = NULL;	
	DECLARE @l_operationCode NVARCHAR(200) = NULL;
	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		SELECT @p_result = NULL;
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
			
		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END

		IF COALESCE(@l_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		
		SELECT @l_logMsg = CONCAT('The value of SourceInterfaceType variable: ', @l_sourceInterfaceType);
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		
		SELECT @l_logMsg = 'Processing of Collection contract item rows...';
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--ContraactItem sorok feldolgozása
		DECLARE collectionContractItem_cursor CURSOR FOR
		SELECT 
			[ID],
			[ObjectID],
			[CurrencyCode],
			[DebtCapital],
			[DebtInterest],
			[DebtPenaltyInterest],
			[DebtCost],
			[DebtCostLocalCurrency],
			[DebtTotal],
			[ConstructionCode],
			[DebtorName],
			[PricingMethodCode],
			[PricingMethodText],
			[BusinessPercent],
			[BusinessPrice],
			[ContractNr],
			[DecisionNr],
			[AccountNr],
			[ContractDate],
			[TerminationDate],
			[FinancialMilestoneDate],
			[LegalActionCode],
			[LegalActionText],
			[CollectionContractItemID],
			[SourceID],
			[SourceContractItemID],
			[OperationCode]
		FROM [IFC].[CollectionContractItem]
		WHERE [CollectionContractItem].[SourceInterfaceType] = @l_sourceInterfaceType
		AND [CollectionContractItem].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
		ORDER BY [CollectionContractItem].[ID];
		
		OPEN collectionContractItem_cursor;
		FETCH NEXT FROM collectionContractItem_cursor
		INTO 
			@l_id,
			@l_objectID,
			@l_currencyCode,
			@l_debtCapital,
			@l_debtInterest,
			@l_debtPenaltyInterest,
			@l_debtCost,
			@l_debtCostLocalCurrency,
			@l_debtTotal,
			@l_constructionCode,
			@l_debtorName,
			@l_pricingMethodCode,
			@l_pricingMethodText,
			@l_businessPercent,
			@l_businessPrice,
			@l_contractNr,
			@l_decisionNr,
			@l_accountNr,
			@l_contractDate,
			@l_terminationDate,
			@l_financialMilestoneDate,
			@l_legalActionCode,
			@l_legalActionText,
			@l_collectionContractItemID,
			@l_sourceID,
			@l_sourceContractItemID,	
			@l_operationCode;

		WHILE @@FETCH_STATUS = 0 
		BEGIN	
			--Szerződés tétel ellenőrzése
			IF COALESCE(@l_sourceContractItemID, '') <> '' 
				SELECT @l_contractItemID = [ContractItem].[ContractItemID]
				FROM [IFC].[ContractItem]
				WHERE [ContractItem].[SourceInterfaceType] = @l_sourceInterfaceType
				AND [ContractItem].[SourceID] = @l_sourceContractItemID
				--AND [ContractItem].[InterfaceStatusCode] NOT IN ('INTERFACE_STATUS_NEW', 'INTERFACE_STATUS_ERROR', 'INTERFACE_STATUS_FIXED'); 
				AND [ContractItem].[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED';
			
			IF COALESCE(@l_contractItemID, 0) <> 0 
			BEGIN							
				--Pénznem mező ellenőrzése
				IF COALESCE(@l_currencyCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The currency is not specified.';
					
				--Konstrukctiós kód mező ellenőrzése
				IF COALESCE(@l_constructionCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The construction code is not specified.';
					
				--Adós mező ellenőrzése
				IF COALESCE(@l_debtorName, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The debtor is not specified.';
					
				--Szerződés mező ellenőrzése
				IF COALESCE(@l_contractNr, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The contract number is not specified.';
					
				--Szerződés dátum mező ellenőrzése
				IF COALESCE(@l_contractDate, '') = '1900-01-01'
					SELECT @l_errorMsg = @l_errorMsg +  'The contract date is not specified.';
					
				--Fizetési mód mező ellenőrzése
				IF COALESCE(@l_pricingMethodText, '') = '' AND COALESCE(@l_pricingMethodCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The pricing method is not specified.'
				ELSE 
				BEGIN
					IF COALESCE(@l_pricingMethodCode, '') = ''
						SELECT @l_pricingMethodCode = [Code].[ID]
						FROM [GEN].[Code] 
						JOIN [GEN].[Translation] ON ([Translation].[CodeID] = [Code].[ID])
						WHERE [Translation].[Language] = 'HU'
						AND [Translation].[CodeID] LIKE 'PRICING_METHOD_%'
						AND [Translation].[Text] = @l_pricingMethodText;
					
					IF COALESCE(@l_pricingMethodCode, '') = ''
						SELECT @l_errorMsg = @l_errorMsg +  'The specified pricing method cannot be found.';
				END;
				
				--Jogi esemény mező ellenőrzése
				IF COALESCE(@l_legalActionText, '') = '' AND COALESCE(@l_legalActionCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The legal action is not specified.'
				ELSE 
				BEGIN
					IF COALESCE(@l_legalActionCode, '') = ''
						SELECT @l_legalActionCode = [Code].[ID]
						FROM [GEN].[Code] 
						JOIN [GEN].[Translation] ON ([Translation].[CodeID] = [Code].[ID])
						WHERE [Translation].[Language] = 'HU'
						AND [Translation].[CodeID] LIKE 'LEGAL_ACTION_%'
						AND [Translation].[Text] = @l_legalActionText;
					
					IF COALESCE(@l_pricingMethodCode, '') = ''
						SELECT @l_errorMsg = @l_errorMsg +  'The specified legal action cannot be found.';
				END;
			
				--Ha nincs hiba, akkor mehet a feldolgozás tovább
				IF COALESCE(@l_errorMsg, '') = ''
				BEGIN
					BEGIN TRY
						--CRM.CollectionContractItem objektum létrehozása
						INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
						SELECT 'CRM.CollectionContractItem', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
							'ADMIN',
							'CRM.CollectionContractItem object', '1.0';
					
						SELECT @l_objectID = @@IDENTITY;
				
						--CRM.Contract sor létrehozása
						INSERT INTO [CRM].[CollectionContractItem] ([ObjectID], [ContractItemID], [DebtCapital], [DebtInterest], [DebtPenaltyInterest], 
							[DebtCost], [DebtCostLocalCurrency], [DebtTotal], [ConstructionCode], [DebtorName], [PricingMethodID], [BusinessPercent], 
							[BusinessPrice], [ContractNr], [DecisionNr], [AccountNr], [ContractDate], [TerminationDate], [FinancialMilestoneDate], 
							[CurrencyCode], [LegalActionCode], [DaysPastDue], [SourceInterfaceType], [SourceID],   
							[CreationDate], [CreationTime], [CreationUserName])
						SELECT @l_objectID, @l_contractItemID, @l_debtCapital, @l_debtInterest, @l_debtPenaltyInterest, @l_debtCost, 
							@l_debtCostLocalCurrency, @l_debtTotal, @l_constructionCode, @l_debtorName, @l_pricingMethodCode, @l_businessPercent,
							@l_businessPrice, @l_contractNr, @l_decisionNr, @l_accountNr, @l_contractDate, @l_terminationDate, @l_financialMilestoneDate, 
							@l_currencyCode, @l_legalActionCode, NULL, @l_sourceInterfaceType, @l_sourceID,
							CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
							 'ADMIN';
							
						SELECT @l_collectionContractItemID = @@IDENTITY;
					END TRY
					BEGIN CATCH
						SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
							' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());
					END CATCH
				END;

				IF COALESCE(@l_errorMsg, '') = ''
					UPDATE [IFC].[CollectionContractItem] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED',
						[CollectionContractItemID] = @l_collectionContractItemID,
						[ErrorMessage] = 'OK',
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] = 'ADMIN'
					WHERE [CollectionContractItem].[ID] = @l_id
				ELSE 
				BEGIN
					UPDATE [IFC].[CollectionContractItem] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
						[ErrorMessage] = @l_errorMsg,
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] =  'ADMIN'
					WHERE [CollectionContractItem].[ID] = @l_id;
					
					SELECT @l_logMsg = CONCAT('##ERROR: ID: ', @l_id, ' Message: ', @l_errorMsg);

					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),				-- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						0,					        -- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;
				END
			END
			ELSE
				UPDATE [IFC].[CollectionContractItem] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
					[ErrorMessage] = 'Collection contract item not found',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] =  'ADMIN'
				WHERE [CollectionContractItem].[ID] = @l_id;

			FETCH NEXT FROM collectionContractItem_cursor
			INTO 
				@l_id,
				@l_objectID,
				@l_currencyCode,
				@l_debtCapital,
				@l_debtInterest,
				@l_debtPenaltyInterest,
				@l_debtCost,
				@l_debtCostLocalCurrency,
				@l_debtTotal,
				@l_constructionCode,
				@l_debtorName,
				@l_pricingMethodCode,
				@l_pricingMethodText,
				@l_businessPercent,
				@l_businessPrice,
				@l_contractNr,
				@l_decisionNr,
				@l_accountNr,
				@l_contractDate,
				@l_terminationDate,
				@l_financialMilestoneDate,
				@l_legalActionCode,
				@l_legalActionText,
				@l_collectionContractItemID,
				@l_sourceID,
				@l_sourceContractItemID,	
				@l_operationCode;
		END

		CLOSE collectionContractItem_cursor;
		DEALLOCATE collectionContractItem_cursor;

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;

		SELECT @p_result = 1;
		RETURN;
	END TRY

	BEGIN CATCH
		SELECT @p_result = 99;
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'collectionContractItem_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE collectionContractItem_cursor;

			DEALLOCATE collectionContractItem_cursor;
		END;

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage

		RETURN;
	END CATCH
END
go

/*
=============================================
Author:		Balázs ARANYI
Create date: 2022-11-21
Last modified date: 2022-11-21
					2023-10-30 (T.Gé): [ContractItem].[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED'
Description:	Transfer data from IFC.CollectionContractSummary table to CRM.CollectionContractSummary
=============================================
*/
CREATE   PROCEDURE [IFC].[CollectionContractSummaryLoader] 
	-- Add the parameters for the stored procedure here
	@p_correlationID NVARCHAR(200), 
	@p_moduleInstanceID NUMERIC(16),
	@p_result INT OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'IFC.CollectionContractSummaryLoader'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_contractID NUMERIC(16) = NULL;
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--Az IFC.CollectionContractItem változói
	DECLARE @l_id NUMERIC(16) = NULL;
	DECLARE @l_currencyCode NVARCHAR(200) = NULL;
	DECLARE @l_itemCount NUMERIC(16) = NULL;
	DECLARE @l_debtCapital MONEY = NULL;
	DECLARE @l_debtInterest MONEY = NULL;
	DECLARE @l_debtPenaltyInterest MONEY = NULL;
	DECLARE @l_debtCost MONEY = NULL;
	DECLARE @l_debtCostLocalCurrency MONEY = NULL;
	DECLARE @l_debtTotal MONEY = NULL;
	DECLARE @l_purchasePrice MONEY = NULL;
	DECLARE @l_purchasePriceCurrencyCode NVARCHAR(200) = NULL;
	DECLARE @l_collectionContractSummaryID NUMERIC(18) = NULL;
	DECLARE @l_sourceID NVARCHAR(200) = NULL;
	DECLARE @l_sourceContractID NVARCHAR(200) = NULL;
	DECLARE @l_operationCode NVARCHAR(200) = NULL;	
	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		SELECT @p_result = NULL;
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
			
		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END

		IF COALESCE(@l_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		
		SELECT @l_logMsg = CONCAT('The value of SourceInterfaceType variable: ', @l_sourceInterfaceType);
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		
		SELECT @l_logMsg = 'Processing of Collection contract summary rows...';
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--CollectionContractItem sorok feldolgozása
		DECLARE collectionContractSummary_cursor CURSOR FOR
		SELECT 
			[ID],
			[ObjectID],
			[CurrencyCode],
			[ItemCount],
			[DebtCapital],
			[DebtInterest],
			[DebtPenaltyInterest],
			[DebtCost],
			[DebtCostLocalCurrency],
			[DebtTotal],
			[PurchasePrice],
			[PurchasePriceCurrencyCode],
			[CollectionContractSummaryID],
			[SourceID],
			[SourceContractID],
			[OperationCode]
		FROM [IFC].[CollectionContractSummary]
		WHERE [CollectionContractSummary].[SourceInterfaceType] = @l_sourceInterfaceType
		AND [CollectionContractSummary].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
		ORDER BY [CollectionContractSummary].[ID];
		
		OPEN collectionContractSummary_cursor;
		FETCH NEXT FROM collectionContractSummary_cursor
		INTO 
			@l_id,
			@l_objectID,
			@l_currencyCode,
			@l_itemCount,
			@l_debtCapital,
			@l_debtInterest,
			@l_debtPenaltyInterest,
			@l_debtCost,
			@l_debtCostLocalCurrency,
			@l_debtTotal,
			@l_purchasePrice,
			@l_purchasePriceCurrencyCode,
			@l_collectionContractSummaryID,
			@l_sourceID,
			@l_sourceContractID,
			@l_operationCode;

		WHILE @@FETCH_STATUS = 0 
		BEGIN	
			--Szerződés ellenőrzése
			IF COALESCE(@l_sourceContractID, '') <> '' 
				SELECT @l_contractID = [Contract].[ContractID]
				FROM [IFC].[Contract]
				WHERE [Contract].[SourceInterfaceType] = @l_sourceInterfaceType
				AND [Contract].[SourceID] = @l_sourceContractID
				--AND [Contract].[InterfaceStatusCode] NOT IN ('INTERFACE_STATUS_NEW', 'INTERFACE_STATUS_ERROR', 'INTERFACE_STATUS_FIXED'); 
				AND [Contract].[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED';
			
			IF COALESCE(@l_contractID, 0) <> 0 
			BEGIN										
				--Ha nincs hiba, akkor mehet a feldolgozás tovább
				IF COALESCE(@l_errorMsg, '') = ''
				BEGIN
					BEGIN TRY
						--CRM.CollectionContractItem objektum létrehozása
						INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
						SELECT 'CRM.CollectionContractSummary', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
							 'ADMIN',
							'CRM.CollectionContractSummary object', '1.0';
					
						SELECT @l_objectID = @@IDENTITY;
				
						--CRM.Contract sor létrehozása
						INSERT INTO [CRM].[CollectionContractSummary] ([ObjectID], [ContractID], [CurrencyCode], [ItemCount], 
							[DebtCapital], [DebtInterest], [DebtPenaltyInterest], [DebtCost], [DebtCostLocalCurrency], [DebtTotal], 
							[PurchasePrice], [PurchasePriceCurrencyCode], [CreationDate], [CreationTime], [CreationUserName])
						SELECT @l_objectID, @l_contractID, @l_currencyCode, @l_itemCount, 
							@l_debtCapital, @l_debtInterest, @l_debtPenaltyInterest, @l_debtCost, @l_debtCostLocalCurrency, @l_debtTotal, 
							@l_purchasePrice, @l_purchasePriceCurrencyCode,	CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
							 'ADMIN';
							
						SELECT @l_collectionContractSummaryID = @@IDENTITY;
					END TRY
					BEGIN CATCH
						SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
							' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());
					END CATCH
				END;

				IF COALESCE(@l_errorMsg, '') = ''
					UPDATE [IFC].[CollectionContractSummary] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED',
						[CollectionContractSummaryID] = @l_collectionContractSummaryID,
						[ErrorMessage] = 'OK',
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] = 'ADMIN'
					WHERE [CollectionContractSummary].[ID] = @l_id
				ELSE 
				BEGIN
					UPDATE [IFC].[CollectionContractSummary] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
						[ErrorMessage] = @l_errorMsg,
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] = 'ADMIN'
					WHERE [CollectionContractSummary].[ID] = @l_id;
					
					SELECT @l_logMsg = CONCAT('##ERROR: ID: ', @l_id, ' Message: ', @l_errorMsg);

					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),				-- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						0,					        -- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;
				END
			END
			ELSE
				UPDATE [IFC].[CollectionContractSummary] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
					[ErrorMessage] = 'Contract not found',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] = 'ADMIN'
				WHERE [CollectionContractSummary].[ID] = @l_id;

			FETCH NEXT FROM collectionContractSummary_cursor
			INTO 
				@l_id,
				@l_objectID,
				@l_currencyCode,
				@l_itemCount,
				@l_debtCapital,
				@l_debtInterest,
				@l_debtPenaltyInterest,
				@l_debtCost,
				@l_debtCostLocalCurrency,
				@l_debtTotal,
				@l_purchasePrice,
				@l_purchasePriceCurrencyCode,
				@l_collectionContractSummaryID,
				@l_sourceID,
				@l_sourceContractID,
				@l_operationCode;
		END

		CLOSE collectionContractSummary_cursor;
		DEALLOCATE collectionContractSummary_cursor;

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;

		SELECT @p_result = 1;
		RETURN;
	END TRY

	BEGIN CATCH
		SELECT @p_result = 99;
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'collectionContractSummary_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE collectionContractSummary_cursor;

			DEALLOCATE collectionContractSummary_cursor;
		END;

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage

		RETURN;
	END CATCH
END
go

CREATE   PROCEDURE [IFC].[CompanyLoader](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16), @p_moduleInstanceIDInkasso Numeric(16) = null output)
/*
==========================================================================================
 Author:		Tóth Gábor
 Creation date:			2022.10.17.
 Last modified date:	2022.11.02: AppUser = CreationUserName, InterfaceStatus='N', INTO Gen.Object(PRT.Company)
						2022.11.08: InterfaceStatusCode, LOG
						2022-11-09: @p_moduleInstanceID, Átnevezés, 999 -> 99
						2022-11-11: Legalform ellenőrzés: csak akkor hibás, ha ki van töltve, de nem szerepel a Gen.Code táblába
						2022-11-13: "Demo" mód törlése, "SourceInterfaceType" <-> "MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE" csere, SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
						2022-11-16: PRT.Company.StatusCode = "ENTITY_STATUS_COMPANY_ACTIVE", PRT.Entity.EntityType = 'C'
						2022-11-17: @LegalForm
						2022-11-18: 'LEGAL_FORM' törlés, @RegistrationDate
						2022-11-19: Entity azonosítás, Portfolió insert, Trim ALL
						2022-11-25: Azonosságvizsgálat kiterjesztése a PortfolioID-val
						2022-11-28: @PortfolioID
						2022.12.16: CreationUserName
						2023.01.09: LeglalFormID <-> LegalformCode, LegalStatus <-> LegalStatusCode
						2023.01.16: @CreationUserName típusváltoztatás
						2023.01.17: Ha nincs Valid jogi forma, akkor '0' lesz beírva ('Ismeretlen')
						2023.01.27: SET @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
						2023.02.21: Hibakezelés
						2023.03.01: Errormessage vesszővel lettek elválasztva
						2023.03.06: ValueSet: CodePrefix = 'LEGAL_FORM'
						2023.03.06: @l_DataOriginCode, Előző cégnév
						2023.03.16: ErrorCode-ok
						2023.03.27: ErrorCode-ok, ObjectType
						2023.10.03: SET @LegalFormID = 'LEGAL_FORM_9999';
						2023.10.04: Nem kell "INSERT INTO Gen.Object"
						2023.11.03: Inkasso szinkron DV-1592
						2023.11.07: 'OBJECT_TYPE_PRT_ENTITY' --> 'OBJECT_TYPE_PRT_COMPANY' DV-1676
						2023.11.13: @PRTName --> @PRTCompany
						2023.11.27: Inkasso szinkron - GenerateSendInkassoSyncData rendesen hibát dob DV-1592
						2023.11.30: Kritikus és Blokkoló hibák kezelése
						2023.12.08: Kritikus és Blokkoló hibák kezelése DV-1956 - Betöltő eljárás módosítása a IFC.InterfaceError.Errormessage mező töltésére
						2023.12.10: "InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'",  DV-1956
            2023.12.12: Inkasso szinkron ellenőrzés módosítás DV-1775
						2023.12.29: Legalform, LegalFormID DV-1989
						2023.12.29: DV-1991
						2023.12.29: Taxnr Is Empty DV-1990
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(MAX);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	DECLARE @CurrentUserName nvarchar(200);
	DECLARE @CurrentUser nvarchar(50);

	DECLARE @l_BlockerError nvarchar(1);
	-- ha van blokkoló hiba, akkor @l_BlockerError = 'T',
	-- InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_BLOCKING', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	-- ha csak kritikus hiba van, akkor @l_BlockerError = 'T',
	-- InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	--DECLARE @l_Prev_ModuleInstanceID Numeric(16);
	DECLARE @l_ErrorMessage nvarchar(MAX);


	SET @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
	--SET @l_Prev_ModuleInstanceID = (Select Top 1 ModuleInstanceID from IFC.InterfaceError where TableName = 'IFC.Company' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' order by id desc);



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.CompanyLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);

    --BEGIN TRANSACTION /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/

    BEGIN TRY
        SET @LogMessage = 'CompanyLoader Started at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;

		DECLARE @l_Company nvarchar(1); -- Company = 'T'
-----------------------------------------------
		DECLARE @ID NUMERIC(16);
		DECLARE @ObjectID NUMERIC(16);
		DECLARE @SourceInterfaceType NVARCHAR(200);
		DECLARE @SourceID NVARCHAR(200);
		DECLARE @RegistrationNr NVARCHAR(30);
		DECLARE @RegistrationDate DATE;
		DECLARE @TaxNr NVARCHAR(30);
		DECLARE @StatisticalNr NVARCHAR(30);
		DECLARE @LegalForm NVARCHAR(200);
		DECLARE @LegalFormID NVARCHAR(200);
		DECLARE @Name NVARCHAR(250);
		DECLARE @ZipCode NVARCHAR(250);
		DECLARE @City NVARCHAR(250);
		DECLARE @Street NVARCHAR(250);
		DECLARE @MainActivityCode NVARCHAR(16);
		DECLARE @LegalStatus NVARCHAR(200);
		DECLARE @LegalStatusID NVARCHAR(200);
		DECLARE @Field1 NVARCHAR(250);
		DECLARE @Field2 NVARCHAR(250);
		DECLARE @Field3 NVARCHAR(250);
		DECLARE @Field4 NVARCHAR(250);
		DECLARE @Field5 NVARCHAR(250);
		DECLARE @CrefoID NUMERIC(16);
		DECLARE @InterfaceStatusCode NVARCHAR(1);

		DECLARE @ParentStatisticalNr NVARCHAR(100);
		DECLARE @ValidFrom DATE;
		DECLARE @UpdateDate DATE;
		DECLARE @ValidUntil DATE;
		DECLARE @ActualisationDate DATE;
		DECLARE @InternationalTaxNr NVARCHAR(50);
		DECLARE @IndustryCode NVARCHAR(200);
		DECLARE @EntrepreneurNr NVARCHAR(100);
		DECLARE @TaxResidence NVARCHAR(1);
		DECLARE @Operation NVARCHAR(1);
		DECLARE @InterfaceTableID NUMERIC(16);
		DECLARE @CountryID NVARCHAR(200);
		DECLARE @Country NVARCHAR(16);
		DECLARE @OrganizationUnitCode NVARCHAR(200);
		DECLARE @OrganizationUnitID NVARCHAR(200);
		DECLARE @CreationDate DATE;
		DECLARE @CreationTime TIME;
		DECLARE @CreationUserName NVARCHAR(200);
		DECLARE @PortfolioID numeric(18);
		DECLARE @PortfolioName NVARCHAR(200);


		DECLARE @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		DECLARE @l_EntityID numeric(18);
		DECLARE @l_ObjectID numeric(18);
		DECLARE @l_LegalFormID  NVARCHAR(50);


		DECLARE @l_AllRowCounts numeric(18);
		DECLARE @l_ImportedRowCounts numeric(18);
		DECLARE @l_ExisingRowCounts numeric(18);
		DECLARE @l_ErrorRowCounts numeric(18);
		DECLARE @l_CompanyID numeric(18);
		DECLARE @l_Comments NVARCHAR(MAX);

		DECLARE @AdosEgyezik nvarchar(1);
		DECLARE @l_DataOriginCode nvarchar(200);

		DECLARE @PRTCompany nvarchar(200);

	  DECLARE @l_InkassoSyncInsertOn int = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'Company', 'insert')
    DECLARE @l_InkassoSyncUpdateOn int = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'Company', 'update')


		DECLARE @ERR_SIFTYPE_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SIFTYPE_CANNOT_BE_EMPTY = 'ERR_GENERAL';						-- SourceInterfaceTpye is empty
		DECLARE @ERR_SIDCANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SIDCANNOT_BE_EMPTY = 'ERR_GENERAL';							-- SourceID is Empty
		DECLARE @ERR_PortfName_NOT_VALID nvarchar(200);
			SET @ERR_PortfName_NOT_VALID = 'ERR_GENERAL';							-- Portfolió Name is not Empty
		DECLARE @ERR_PortfID_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_PortfID_CANNOT_BE_EMPTY = 'ERR_PORTFOLIOID_CANNOT_BE_NULL';	-- Portfolió ID is not Empty
		DECLARE @ERR_Name_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_Name_CANNOT_BE_EMPTY = 'ERR_NAME_CANNOT_BE_EMPTY';				-- CompanyName is not Empty
		DECLARE @ERR_TaxNr_NOT_VALID nvarchar(200);
			SET @ERR_TaxNr_NOT_VALID = 'ERR_GENERAL';								-- TaxNr is not Valid
		DECLARE @ERR_TaxNr_IS_EMPTY nvarchar(200);
			SET @ERR_TaxNr_IS_EMPTY = 'ERR_GENERAL';								-- TaxNr is not Valid
		DECLARE @ERR_LegalFormID_NOT_VALID nvarchar(200);
			SET @ERR_LegalFormID_NOT_VALID = 'ERR_GENERAL';							-- LegalformID is not Valid
		DECLARE @ERR_LegalFormID_IS_EMPTY nvarchar(200);
			SET @ERR_LegalFormID_IS_EMPTY = 'ERR_LEGALFORMCODE_CANNOT_BE_EMPTY'		-- LegalformID is empty
		DECLARE @ERR_LegalForm_IS_EMPTY nvarchar(200);
			SET @ERR_LegalForm_IS_EMPTY = 'ERR_GENERAL';							-- Legalform is empty
		DECLARE @ERR_LegalForm_NOT_VALID nvarchar(200);
			SET @ERR_LegalForm_NOT_VALID = 'ERR_GENERAL';							-- LegalformID is not Valid

		SET @PRTCompany = (Select Top 1 Code from GEN.ObjectType where TableName = 'PRT.COMPANY' order by TableName desc);




/* *************************************************************************************************************** */
		--SET @l_PortfolioID = (Select Portfolio.ID from GEN.Portfolio where Portfolio.[Name] = 'Portfolio3');
/* *************************************************************************************************************** */

		SET @l_AllRowCounts = 0;
		SET @l_ImportedRowCounts = 0;
		SET @l_ExisingRowCounts = 0;
		SET @l_ErrorRowCounts = 0;

		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END


		IF COALESCE(@l_sourceInterfaceType, '') = ''
			RAISERROR('The SourceInterfaceType field in ParameterValue is not defined!', 16, 1);

		SET @l_AllRowCounts = (Select Count(*) FROM IFC.Company where Company.SourceInterfaceType = @l_sourceInterfaceType
					and
					(
					(Company.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Company.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Company' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));

		DECLARE db_cursor CURSOR FOR
		SELECT ID, ObjectID, SourceInterfaceType, SourceID, RegistrationNr, RegistrationDate, TaxNr, StatisticalNr, LegalForm, LegalFormID,
			Name, ZipCode, City, Street, MainActivityCode, LegalStatus, LegalStatusID, Field1, Field2, Field3, Field4, Field5, CrefoID, InterfaceStatusCode,
			/*ErrorMessage,*/ ParentStatisticalNr, ValidFrom, UpdateDate, ValidUntil, ActualisationDate, InternationalTaxNr, IndustryCode, EntrepreneurNr, TaxResidence,
			[Operation], InterfaceTableID, CountryID, Country, OrganizationUnitCode, OrganizationUnitID, CreationDate, CreationTime, CreationUserName, PortfolioID, PortfolioName
		FROM IFC.Company
		where Company.SourceInterfaceType = @l_sourceInterfaceType
				AND
					(
					(Company.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Company.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Company' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
		Order by Company.ID;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID, @ObjectID, @SourceInterfaceType, @SourceID, @RegistrationNr, @RegistrationDate, @TaxNr, @StatisticalNr, @LegalForm, @LegalFormID,
		@Name, @ZipCode, @City, @Street, @MainActivityCode, @LegalStatus, @LegalStatusID, @Field1, @Field2, @Field3, @Field4, @Field5, @CrefoID, @InterfaceStatusCode,
		/*@ErrorMessage,*/ @ParentStatisticalNr, @ValidFrom, @UpdateDate, @ValidUntil, @ActualisationDate, @InternationalTaxNr, @IndustryCode, @EntrepreneurNr, @TaxResidence,
		@Operation, @InterfaceTableID, @CountryID, @Country, @OrganizationUnitCode, @OrganizationUnitID, @CreationDate, @CreationTime, @CreationUserName, @PortfolioID, @PortfolioName



		WHILE @@FETCH_STATUS = 0
		BEGIN

		SET @LegalFormID = Trim(@LegalFormID);
		SET @Name = trim(@Name);

  BEGIN TRY /* Belső-1 */
---------------------------------------------------------------------------------------------------------------------------------------------
-- Error Section:
			SET @ErrorMessage = NULL;
			SET @l_BlockerError = '';
-- @SourceInterfaceType:
			IF Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceInterfaceType is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.COMPANY', @ID, 'sourceInterfaceType', @ERR_SIFTYPE_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
-- @SourceID:
			IF Trim(Isnull(@SourceID,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.COMPANY', @ID, 'sourceID', @ERR_SIDCANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;

-- Portfolio ellenőrzése:
			IF Isnull(@PortfolioID, 0) = 0 and Trim(Isnull(@PortfolioName,'')) <> ''
			BEGIN
				IF exists(select 1 from Gen.Portfolio where Portfolio.Name = Trim(Isnull(@PortfolioName,'')))
				BEGIN
					SET @PortfolioID = (select Top 1 ID from Gen.Portfolio where Portfolio.Name = Trim(Isnull(@PortfolioName,'')) order by Id Desc);
				End
				Else
				BEGIN
						Set @l_ErrorMessage = 'PortfolioName is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.COMPANY', @ID, 'portfolioName', @ERR_PortfName_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
				END;
			END;

			IF Isnull(@PortfolioID, 0) = 0
			BEGIN
						Set @l_ErrorMessage = 'PortfolioID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.COMPANY', @ID, 'portfolioID', @ERR_PortfID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;

-- Name:
		IF Trim(Isnull(@Name,''))  = ''
		BEGIN
						Set @l_ErrorMessage = 'Name is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.COMPANY', @ID, 'name', @ERR_Name_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;

-- TaxNr:
		IF Trim(Isnull(@TaxNr,'')) = ''  -- DV-1990
		BEGIN
						Set @l_ErrorMessage = 'Tax Number is empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.COMPANY', @ID, 'taxNr', @ERR_TaxNr_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;

		IF Trim(Isnull(@TaxNr,'')) like '%00000%'
		BEGIN
						Set @l_ErrorMessage = 'Tax Number is not valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.COMPANY', @ID, 'taxNr', @ERR_TaxNr_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;


-- Hibakiírás:

		IF @l_BlockerError = 'T'
		BEGIN
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			UPDATE IFC.COMPANY SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage,
				LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
		END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Betöltés:
		IF @l_BlockerError = ''
		BEGIN
---------------------------------------------------------------------------------------------------------------------------------------------

-- LegalFormCode:
		IF Trim(Isnull(@LegalFormID,''))  = '' and Trim(Isnull(@LegalForm,'')) = ''
			BEGIN
						SET @LegalFormID = 'LEGAL_FORM_9999';
						SET @LegalForm = NULL;
						Set @l_ErrorMessage = 'LegalForm ID and LegalForm are Empty, LegalForm ID value is Setted to Default';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.COMPANY', @ID, 'legalformID', @ERR_LegalFormID_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.COMPANY', @ID, 'legalform', @ERR_LegalForm_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;

		IF Trim(Isnull(@LegalFormID,''))  <> '' and Trim(Isnull(@LegalForm,'')) = ''
			and Not exists (Select 1
							from Gen.ValueSet
							Join Gen.Code on Code.ValueSetID = ValueSet.Id
							join Gen.Translation on Translation.CodeID = Code.Id
							where CodePrefix = 'LEGAL_FORM'
							and Code.ID = Isnull(Trim(@LegalFormID),''))
		BEGIN
						SET @LegalFormID = 'LEGAL_FORM_9999';

						Set @l_ErrorMessage = 'LegalForm ID not valid, LegalForm ID value is Setted to Default';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.COMPANY', @ID, 'legalformID', @ERR_LegalFormID_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
		END;

		IF Trim(Isnull(@LegalFormID,''))  = '' and Trim(Isnull(@LegalForm,'')) <> ''
		BEGIN
			IF exists (Select 1
							from Gen.ValueSet
							Join Gen.Code on Code.ValueSetID = ValueSet.Id
							join Gen.Translation on Translation.CodeID = Code.Id
							where CodePrefix = 'LEGAL_FORM'
							and Translation.Text = Trim(@LegalForm))

				SET @LegalFormID = (Select Top 1 Code.Id
							from Gen.ValueSet
							Join Gen.Code on Code.ValueSetID = ValueSet.Id
							join Gen.Translation on Translation.CodeID = Code.Id
							where CodePrefix = 'LEGAL_FORM'
							and Translation.Text = Trim(@LegalForm) order by Code.Id desc);
			Else
			BEGIN
				SET @LegalFormID = 'LEGAL_FORM_9999';
				-- DV-1991
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' LegalForm is NOT valid, LegalForm ID value is Setted to Default');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
				Select 'IFC.COMPANY', @ID, 'legalform', @ERR_LegalForm_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;

			END;
		END;

---------------------------------------------------------------------------------------------------------------------------------------------
			SET @AdosEgyezik = 'F';
			IF Trim(Isnull(@TaxNr,'')) <> '' and Trim(Isnull(@TaxNr,'')) not like '%00000%'
			BEGIN
				IF exists (Select 1 from PRT.Company
							Join PRT.Entity on Entity.ID = Company.EntityID
							Join Gen.Object on Object.Id = Entity.ObjectId
							where
								Object.PortfolioID = @PortfolioID
								and Trim(Replace(@TaxNr,' ','')) = Trim(Replace(Company.TaxNr,' ',''))
							)
				BEGIN
					SET @AdosEgyezik = 'T';

					SET @l_EntityID = (Select Top 1 Company.EntityID from PRT.Company
							Join PRT.Entity on Entity.ID = Company.EntityID
							Join Gen.Object on Object.Id = Entity.ObjectId
							where
								Object.PortfolioID = @PortfolioID
								and Trim(Replace(@TaxNr,' ','')) = Trim(Replace(Company.TaxNr,' ',''))
							order by Company.ID desc);

				END;
			END;

---------------------------------------------------------------------------------------------------------------------------------------------
			IF @AdosEgyezik = 'T'
				BEGIN

					SET @l_DataOriginCode = NULL;
					SELECT @l_DataOriginCode =
						CASE (Select TreatmentTypeCode from Gen.Portfolio where Id = @PortfolioID)
							WHEN 'TREATMENT_TYPE_MANDATE' THEN 'DATA_ORIGIN_PRINCIPAL' /* Megbízásos */
							WHEN 'TREATMENT_TYPE_ASSIGNMENT' THEN 'DATA_ORIGIN_LEGAL_PREDECESSOR'  /* Engedményzett */
							ELSE 'DATA_ORIGIN_LEGAL_PREDECESSOR' /* Engedményzett */
						END;

---------------------------------------------------------------------------------------------------------------------------------------------
				-- Létezik a Company:
---------------------------------------------------------------------------------------------------------------------------------------------
					-- Update
-- Változott a neve:
          BEGIN TRAN /*Company update*/

					  IF @l_EntityID is not NULL
						  and (Select Trim(Isnull(Company.Name,'')) from PRT.Company
							  Join PRT.Entity on Entity.ID = Company.EntityID
							  Join Gen.Object on Object.Id = Entity.ObjectId and Object.PortfolioID = @PortfolioID
						  where Company.EntityID = @l_EntityID) <> ''
					  BEGIN
						  IF (Select Top 1 Trim(Isnull(Company.Name,'')) from PRT.Company
							  Join PRT.Entity on Entity.ID = Company.EntityID
							  Join Gen.Object on Object.Id = Entity.ObjectId and Object.PortfolioID = @PortfolioID
						  where Company.EntityID = @l_EntityID order by Company.ID)
							  <> Trim(Isnull(@Name,''))
						  BEGIN
							  Update Prt.Name SET ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED', LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime =  CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName
									  where EntityID = @l_EntityID and NameTypeCode = 'NAME_TYPE_COMPANY_FORMER';
							  -- New ObjectID:
							  INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr,  PortfolioID)
								  SELECT @PRTCompany as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @PortfolioID;
							  SET @l_ObjectID = @@Identity;
								  Insert Into Prt.Name(ObjectID, EntityID, Name, ValidFrom, StatusCode, NameTypeCode, SourceInterfaceType, SourceID, CreationDate, CreationTime, CreationUserName, DataOriginCode)
								  Select @l_ObjectID, @l_EntityID, (Select Trim(Isnull(Company.Name,'')) from PRT.Company where Company.EntityID = @l_EntityID),
								  CAST( GETDATE() AS Date ), 'STATUS_NORMAL', 'NAME_TYPE_COMPANY_FORMER', @SourceInterfaceType, @SourceID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, @l_DataOriginCode;

							  Update Prt.Company SET Name = Trim(@Name),
								  LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName where EntityID = @l_EntityID;


                /*DV-1592: insert Inkasso sync record*/
                if @l_InkassoSyncUpdateOn = 1
                begin
                  exec IFC.GenerateSendInkassoSyncData @syncType = 'Company',
                                                       @syncEventType = 'update',
                                                       @entityID = @l_EntityID,
                                                       @ID = null,
                                                       @dataChangedUserName = @CurrentUserName,
                                                       @correlationID = @p_correlationID,
                                                       @moduleInstanceID = @p_moduleInstanceIDInkasso output,
                                                       @isBatch = 1
                end
						  END;
					  END;

  ---------------------------------------------------------------------------------------------------------------------------------------------

					  SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
					  UPDATE IFC.COMPANY SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED',
						  ErrorMessage = 'Identified by existing Company, EntityID: ' + Cast(@l_EntityID as nvarchar(18)) +
						  (Select Case When (Select Isnull(SourceID,'') from PRT.Entity where ID = @l_EntityID) <> @SourceID
						  then ' Other SourceId: ' + (Select Isnull(SourceID,'') from PRT.Entity where ID = @l_EntityID) end),
						  CrefoID = @l_EntityID,
						  LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
          COMMIT /*Company update*/
				END;
			ELSE
			-- Nem létezik a Company:
			BEGIN
        BEGIN TRAN /*Company insert*/
---------------------------------------------------------------------------------------------------------------------------------------------
          -- New ObjectID:
          INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr,  PortfolioID)
	          SELECT @PRTCompany as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @PortfolioID;
          SET @l_ObjectID = @@Identity;

          INSERT INTO PRT.Entity (ObjectID, EntityType, SourceInterfaceType, SourceID, CreationDate, CreationTime, CreationUserName, Status)
            SELECT @l_ObjectID, 'C', @SourceInterfaceType, @SourceID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, 'STATUS_NORMAL';
          SET @l_EntityID = @@Identity; /*(SELECT ID FROM PRT.Entity WHERE Entity.SourceInterfaceType = @SourceInterfaceType and Entity.SourceID = @SourceID);*/
          ---------------------------------------------------------------------------------------------------------------------------------------------

          -- New ObjectID:
          -- Új cég felvitele:
          INSERT INTO PRT.Company(
	          /*ObjectID,*/							Name, 											RegistrationNr,
	          TaxNr, 									StatisticalNr, 									LegalFormCode,
	          LegalStatusCode, 						EntityID, 										CreationDate,
	          CreationTime, 							CreationUserName,									Comments,
	          StatusCode,								RegistrationDate)
          SELECT
	          /*@l_ObjectID,*/						Trim(@Name),									Trim(@RegistrationNr),
	          Trim(@TaxNr), 							Trim(@StatisticalNr), 							Trim(@LegalFormID),
	          'ENTITY_STATUS_COMPANY_ACTIVE' /*@LegalStatus*/, 	@l_EntityID, 						CAST( GETDATE() AS Date ),
	          CAST( GETDATE() AS Time ), 				@CurrentUserName,									@l_Comments,
	          'ENTITY_STATUS_COMPANY_ACTIVE',			@RegistrationDate;

          SET @l_ImportID = @@Identity;

          /*DV-1592: insert Inkasso sync record*/
          if @l_InkassoSyncInsertOn = 1
          begin
            exec IFC.GenerateSendInkassoSyncData @syncType = 'Company',
                                                 @syncEventType = 'insert',
                                                 @entityID = @l_EntityID,
                                                 @ID = null,
                                                 @dataChangedUserName = @CurrentUserName,
                                                 @correlationID = @p_correlationID,
                                                 @moduleInstanceID = @p_moduleInstanceIDInkasso output,
                                                 @isBatch = 1
          end

          SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
          IF ISNULL(@ErrorMessage,'') = ''
	          SET @ErrorMessage = NULL;
          UPDATE IFC.COMPANY SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage = Trim(@ErrorMessage), CrefoID = @l_EntityID,
			LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
        COMMIT /*Company insert*/
      END;

---------------------------------------------------------------------------------------------------------------------------------------------
		END;  /*@ErrorMessage = NULL*/

  END TRY /*Belső-1*/

  BEGIN CATCH /*Belső-1*/
    if @@TRANCOUNT > 0
      rollback

    SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
		SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;

    UPDATE IFC.COMPANY SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage,
	LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;

	END CATCH /*Belső-1*/


			FETCH NEXT FROM db_cursor INTO @ID, @ObjectID, @SourceInterfaceType, @SourceID, @RegistrationNr, @RegistrationDate, @TaxNr, @StatisticalNr, @LegalForm, @LegalFormID,
						@Name, @ZipCode, @City, @Street, @MainActivityCode, @LegalStatus, @LegalStatusID, @Field1, @Field2, @Field3, @Field4, @Field5, @CrefoID, @InterfaceStatusCode,
						/*@ErrorMessage,*/ @ParentStatisticalNr, @ValidFROM, @UpdateDate, @ValidUntil, @ActualisationDate, @InternationalTaxNr, @IndustryCode, @EntrepreneurNr, @TaxResidence,
						@Operation, @InterfaceTableID, @CountryID, @Country, @OrganizationUnitCode, @OrganizationUnitID, @CreationDate, @CreationTime, @CreationUserName, @PortfolioID, @PortfolioName
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;

    END TRY


    BEGIN CATCH

        SELECT
        @ErrorMessage = ERROR_MESSAGE(),
        @ErrorSeverity = ERROR_SEVERITY(),
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	      INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	      SELECT
		      CAST( GETDATE() AS Date ),	-- LogDate,
		      CAST( GETDATE() AS Time ),	-- LogTime,
		      SUSER_SNAME(),				-- UserName
		      @p_CorrelationID,			-- CorrelationID
		      'INDECS 3.0',				-- ApplicationName
		      DB_NAME(),					-- Environment
		      'BACKEND',					-- Layer
		      'IFC.CompanyLoader',		-- ServiceName
		      '1.0',						-- ServiceVersion
		      'FATAL',					-- SeverityLevel
		      NULL,						-- MessageCategory
		      @ErrorMessage;

        --RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );
        --ROLLBACK TRANSACTION; /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592), de ennek eredetileg is fentebb kellett volna lennie, hogy a logolás ne rollbackelődjön*/

        SELECT @ErrorMessage;

    END CATCH;


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------

	SET @LogMessage = @LogMessage + 'CompanyLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.CompanyLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ExistingRowsCount: ' + CAST(@l_ExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ @LogMessage;



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.CompanyLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If Isnull(@ErrorMessage,'') <> ''
		Return 99;
	else
		Return 1;

END;
go


CREATE PROCEDURE [ORG].[ConditionPersonValidAddress](@p_correlationID NVARCHAR(200),@p_objectID NVARCHAR(200),@p_conditionsetcode NVARCHAR(200))

/*
==========================================================================================
 Author:		Bognár Dávid
 Creation date:			2023.02.23.
 Last modified date:	
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUserName = 'Admin';

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);

    

	--select @l_error=null;


	--select @l_error=concat((select 1 from prt.person where ID=22189 and FirstName='Dani'),@l_error);
	--select @l_error=concat((select 1 from prt.person where ID=22189 and LastName='Bognár'),@l_error);



	--select @l_error;

----------------------------------------------------------------------------------------------
declare @l_condition nvarchar(max);
declare @l_sqltext nvarchar(max);
declare @l_sqltext_row nvarchar(max);
declare @l_error nvarchar(max);
declare @l_resultcode nvarchar(max);
--declare @p_objectID NVARCHAR(200);


DECLARE condition_cursor CURSOR FOR 
					SELECT 
						SQLExpression,ConditionResultCode
					from ORG.ConditionSet 
                           left join ORG.Condition on ORG.Condition.ConditionSetID=ORG.ConditionSet.ID
                           left join GEN.DataSource on GEN.DataSource.ID=ORG.Condition.DataSourceID
                where ConditionSetCode=@p_conditionsetcode;

					OPEN condition_cursor;

					FETCH NEXT FROM condition_cursor
					INTO 
						@l_condition,@l_resultcode
						;

					WHILE @@FETCH_STATUS = 0
					BEGIN 


				--SELECT @l_sqltext =concat('select', @l_error,'=concat((',@l_condition,' and objectid=',@p_objectid,'),','@l_error);');
                select @l_sqltext_row=concat('select case when ( ',@l_condition,' and objectid=',@p_objectid,' )=1 then ''',@l_resultcode,''' else null end as ''Criterium''');
				select @l_sqltext =concat(@l_sqltext,@l_sqltext_row,' union all ');
				select @l_sqltext_row='';

				--print @l_sqltext;

              
			   
			  


			
							
							FETCH NEXT FROM condition_cursor
						INTO
							@l_condition,@l_resultcode;

							END

							CLOSE condition_cursor;
				DEALLOCATE condition_cursor;

						--select @l_error;

					--EXEC(@l_sqltext)
					
					select @l_sqltext=SUBSTRING(@l_sqltext, -8, LEN(@l_sqltext) - CHARINDEX(' ', REVERSE(@l_sqltext)));
					select @l_sqltext=concat('select * from (',@l_sqltext,') a where Criterium is not null');
					--print @l_sqltext
					EXEC (@l_sqltext);


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	
	SET @LogMessage = @LogMessage + 'DebtorLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: '



	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return 1;


END;

go


CREATE PROCEDURE [ORG].[ConditionPersonValidAddress_Count](@p_correlationID NVARCHAR(200),@p_objectID NVARCHAR(200),@p_conditionsetcode NVARCHAR(200))

/*
==========================================================================================
 Author:		Bognár Dávid
 Creation date:			2023.02.23.
 Last modified date:	
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUserName = 'Admin';

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);

    

	--select @l_error=null;


	--select @l_error=concat((select 1 from prt.person where ID=22189 and FirstName='Dani'),@l_error);
	--select @l_error=concat((select 1 from prt.person where ID=22189 and LastName='Bognár'),@l_error);



	--select @l_error;

----------------------------------------------------------------------------------------------
declare @l_condition nvarchar(max);
declare @l_sqltext nvarchar(max);
declare @l_sqltext_row nvarchar(max);
declare @l_error nvarchar(max);
declare @l_resultcode nvarchar(max);
--declare @p_objectID NVARCHAR(200);


DECLARE condition_cursor CURSOR FOR 
					SELECT 
						SQLExpression,ConditionResultCode
					from ORG.ConditionSet 
                           left join ORG.Condition on ORG.Condition.ConditionSetID=ORG.ConditionSet.ID
                           left join GEN.DataSource on GEN.DataSource.ID=ORG.Condition.DataSourceID
                where ConditionSetCode=@p_conditionsetcode;

					OPEN condition_cursor;

					FETCH NEXT FROM condition_cursor
					INTO 
						@l_condition,@l_resultcode
						;

					WHILE @@FETCH_STATUS = 0
					BEGIN 


				--SELECT @l_sqltext =concat('select', @l_error,'=concat((',@l_condition,' and objectid=',@p_objectid,'),','@l_error);');
                select @l_sqltext_row=concat('select case when ( ',@l_condition,' and objectid=',@p_objectid,' )=1 then ''',@l_resultcode,''' else null end as ''Criterium''');
				select @l_sqltext =concat(@l_sqltext,@l_sqltext_row,' union all ');
				select @l_sqltext_row='';

				--print @l_sqltext;

              
			   
			  


			
							
							FETCH NEXT FROM condition_cursor
						INTO
							@l_condition,@l_resultcode;

							END

							CLOSE condition_cursor;
				DEALLOCATE condition_cursor;

						--select @l_error;

					--EXEC(@l_sqltext)
					
					select @l_sqltext=SUBSTRING(@l_sqltext, -8, LEN(@l_sqltext) - CHARINDEX(' ', REVERSE(@l_sqltext)));
					select @l_sqltext=concat('select * from (',@l_sqltext,') a where Criterium is not null');
                    select @l_sqltext=concat('select count(*) from (',@l_sqltext,') a');			
					
					print @l_sqltext
					EXEC (@l_sqltext);


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	
	SET @LogMessage = @LogMessage + 'DebtorLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: '



	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return 1;


END;

go


CREATE PROCEDURE [ORG].[ConditionSetTester](@p_correlationID NVARCHAR(200),@p_objectID NVARCHAR(200),@p_conditionsetcode NVARCHAR(200))

/*
==========================================================================================
 Author:		Bognár Dávid
 Creation date:			2023.02.23.
 Last modified date:	
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUserName = 'Admin';

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);

    

	--select @l_error=null;


	--select @l_error=concat((select 1 from prt.person where ID=22189 and FirstName='Dani'),@l_error);
	--select @l_error=concat((select 1 from prt.person where ID=22189 and LastName='Bognár'),@l_error);



	--select @l_error;

----------------------------------------------------------------------------------------------
declare @l_condition nvarchar(max);
declare @l_sqltext nvarchar(max);
declare @l_sqltext_row nvarchar(max);
declare @l_error nvarchar(max);
declare @l_resultcode nvarchar(max);
--declare @p_objectID NVARCHAR(200);


DECLARE condition_cursor CURSOR FOR 
					SELECT 
						SQLExpression,ConditionResultCode
					from ORG.ConditionSet 
                           left join ORG.Condition on ORG.Condition.ConditionSetID=ORG.ConditionSet.ID
                           left join GEN.DataSource on GEN.DataSource.ID=ORG.Condition.DataSourceID
                where ConditionSetCode=@p_conditionsetcode;

					OPEN condition_cursor;

					FETCH NEXT FROM condition_cursor
					INTO 
						@l_condition,@l_resultcode
						;

					WHILE @@FETCH_STATUS = 0
					BEGIN 


				--SELECT @l_sqltext =concat('select', @l_error,'=concat((',@l_condition,' and objectid=',@p_objectid,'),','@l_error);');
                select @l_sqltext_row=concat('select case when ( ',@l_condition,' and objectid=',@p_objectid,' )=1 then ''',@l_resultcode,''' else null end as ''Criterium''');
				select @l_sqltext =concat(@l_sqltext,@l_sqltext_row,' union all ');
				select @l_sqltext_row='';

				--print @l_sqltext;

              
			   
			  


			
							
							FETCH NEXT FROM condition_cursor
						INTO
							@l_condition,@l_resultcode;

							END

							CLOSE condition_cursor;
				DEALLOCATE condition_cursor;

						--select @l_error;

					--EXEC(@l_sqltext)
					
					select @l_sqltext=SUBSTRING(@l_sqltext, -8, LEN(@l_sqltext) - CHARINDEX(' ', REVERSE(@l_sqltext)));
					select @l_sqltext=concat('select * from (',@l_sqltext,') a where Criterium is not null');
					--print @l_sqltext
					EXEC (@l_sqltext);


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	
	SET @LogMessage = @LogMessage + 'DebtorLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: '



	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return 1;


END;

go

CREATE   PROCEDURE [ORG].[ConditionSetTesterList](@p_correlationID NVARCHAR(200),@t GEN.NumericType READONLY, @p_conditionsetcode nvarchar(max), @p_objectgroupID Numeric(16, 0) = null)
/*
==========================================================================================
 Author:		Bognár Dávid
 Creation date:			2023.02.23.
 Last modified date:	
==========================================================================================
*/

AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @logMessage NVARCHAR(MAX);
	Declare @CurrentUserName nvarchar(200) = SUSER_SNAME(), @procedureName NVarChar(200) = 'ORG.ConditionSetTesterList'

  set @logMessage = Concat('Start procedure ', @procedureName)
  exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                          @p_UserName = @CurrentUserName,
                          @p_ServiceName = @procedurename, 
                          @p_LogMessage = @logMessage


    
----------------------------------------------------------------------------------------------------------------------------------

  declare @sqlText NVarChar(max) = '', @sqlParameters NVarChar(max)
  declare @conditionSetID Numeric(16, 0), @conditionID Numeric(16, 0), @SQLExpression NVarChar(max), @conditionResultCode NVarChar(200)


  select @sqlText = String_AGG(Concat('select ', ORG.Condition.ID, ' ConditionID, t.ID ObjectID,
       Case when (', GEN.DataSource.SQLExpression, ' and t.ID = ObjectID) = 1 then ''',  ORG.Condition.ConditionResultCode, ''' else null end Criterium
from @t t '
                          ), 
                    Concat(CHAR(13), 'union all', CHAR(13))
                   )
  from ORG.ConditionSet join ORG.Condition on ORG.condition.conditionsetid = org.conditionset.id
                        join GEN.DataSource on GEN.DataSource.id = ORG.Condition.datasourceid
  where ORG.CONDITIONSET.conditionsetcode = @p_conditionsetcode

  --print @sqlText

  exec sp_executesql @sqlText, N' @T [GEN].[NumericType] readonly, @p_objectgroupID Numeric(16, 0)', @t, @p_objectgroupID


----------------------------------------------------------------------------------------------------------------------------------
	

  set @logMessage = Concat('End procedure ', @procedureName)
  exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                          @p_UserName = @CurrentUserName,
                          @p_ServiceName = @procedurename, 
                          @p_LogMessage = @logMessage
END
go


CREATE PROCEDURE [ORG].[ConditionSetTester_Count](@p_correlationID NVARCHAR(200),@p_objectID NVARCHAR(200),@p_conditionsetcode NVARCHAR(200))

/*
==========================================================================================
 Author:		Bognár Dávid
 Creation date:			2023.11.26.
 Last modified date:	
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUserName = 'Admin';

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);

    

	--select @l_error=null;


	--select @l_error=concat((select 1 from prt.person where ID=22189 and FirstName='Dani'),@l_error);
	--select @l_error=concat((select 1 from prt.person where ID=22189 and LastName='Bognár'),@l_error);



	--select @l_error;

----------------------------------------------------------------------------------------------
declare @l_condition nvarchar(max);
declare @l_sqltext nvarchar(max);
declare @l_sqltext_row nvarchar(max);
declare @l_error nvarchar(max);
declare @l_resultcode nvarchar(max);
--declare @p_objectID NVARCHAR(200);


DECLARE condition_cursor CURSOR FOR 
					SELECT 
						SQLExpression,ConditionResultCode
					from ORG.ConditionSet 
                           left join ORG.Condition on ORG.Condition.ConditionSetID=ORG.ConditionSet.ID
                           left join GEN.DataSource on GEN.DataSource.ID=ORG.Condition.DataSourceID
                where ConditionSetCode=@p_conditionsetcode;

					OPEN condition_cursor;

					FETCH NEXT FROM condition_cursor
					INTO 
						@l_condition,@l_resultcode
						;

					WHILE @@FETCH_STATUS = 0
					BEGIN 


				--SELECT @l_sqltext =concat('select', @l_error,'=concat((',@l_condition,' and objectid=',@p_objectid,'),','@l_error);');
                select @l_sqltext_row=concat('select case when ( ',@l_condition,' and objectid=',@p_objectid,' )=1 then ''',@l_resultcode,''' else null end as ''Criterium''');
				select @l_sqltext =concat(@l_sqltext,@l_sqltext_row,' union all ');
				select @l_sqltext_row='';

				--print @l_sqltext;

              
			   
			  


			
							
							FETCH NEXT FROM condition_cursor
						INTO
							@l_condition,@l_resultcode;

							END

							CLOSE condition_cursor;
				DEALLOCATE condition_cursor;

						--select @l_error;

					--EXEC(@l_sqltext)
					
					select @l_sqltext=SUBSTRING(@l_sqltext, -8, LEN(@l_sqltext) - CHARINDEX(' ', REVERSE(@l_sqltext)));
					select @l_sqltext=concat('select * from (',@l_sqltext,') a where Criterium is not null');
                    select @l_sqltext=concat('select count(*) from (',@l_sqltext,') a');			
					
					print @l_sqltext
					EXEC (@l_sqltext);


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	
	SET @LogMessage = @LogMessage + 'DebtorLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: '



	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return 1;


END;

go

CREATE   PROCEDURE [IFC].[ContactLoader](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16), @p_moduleInstanceIDInkasso Numeric(16) = null output)

/*
==========================================================================================
 Author:				Tóth Gábor
 Creation date:			2022.10.17.
 Last modified date:	2022.11.01.
						2022.11.02 ObjectType, AppUser, InterfaceStatus=NULL, Return, Errormessage
						2022-11-09: @p_moduleInstanceID, Átnevezés, 999 -> 99
						2022-11-13: "Demo" mód törlése, "SourceInterfaceType" <-> "MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE" csere, EntityID másképp kezelése, SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
						2022-11-18: ContactType ellenőrzés
						2022-11-19: @l_EntityID azonosítás, előző contact "VALIDUNTIL" beállítása, Trim All
						2022-11-22: @l_ContactType <-- @ContactType, Person.CrefoID <-- Person.PersonID
						2022-11-30: StatusCode = 'STATUS_NORMAL'
						2022-11-30: PersonID <-> CrefoId
						2022-12-07: @ObjectId <-> @l_ObjectId
						2022.12.16: CreationUserName
						2023.01.27, Set @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
						2023.02.06: @ContactType <-> @ContactTypeCode
						2023.02.08: DataOriginCode
						2023.02.21: Hibakezelés
						2023.03.01: Errormessage vesszővel lettek elválasztva
						2023.03.06: ValueSet ellenőrzés: CONTACT_TYPE
						2023.03.16: ErrorCode-ok
						2023.03.27: ErrorCode-ok, ObjectType
						2023.05.31: Set @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' ContactType and ContactTypeCode is Empty,');
            2023.11.03: Inkasso szinkron DV-1592
						2023.11.21: If not exists @..Code..
            2023.11.27: Inkasso szinkron - GenerateSendInkassoSyncData rendesen hibát dob DV-1592
						2023.12.01: Kritikus és Blokkoló hibák kezelése
						2023.12.09: Kritikus és Blokkoló hibák kezelése DV-1956 - Betöltő eljárás módosítása a IFC.InterfaceError.Errormessage mező töltésére
						2023.12.09:	Üres "Contact" rekordok automatikus "Processed"-re állítása
						2023.12.10: "InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'",  DV-1956
            2023.12.12: Inkasso szinkron ellenőrzés módosítás DV-1775
						2023.12.29: Üres a Contact mező DV-1992

==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(MAX);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);


	DECLARE @l_BlockerError nvarchar(1);
	-- ha van blokkoló hiba, akkor @l_BlockerError = 'T',
	-- InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_BLOCKING', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	-- ha csak kritikus hiba van, akkor @l_BlockerError = 'T',
	-- InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	--DECLARE @l_Prev_ModuleInstanceID Numeric(16);
	DECLARE @l_ErrorMessage nvarchar(MAX);

	SET @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
	--SET @l_Prev_ModuleInstanceID = (Select Top 1 ModuleInstanceID from IFC.InterfaceError where TableName = 'IFC.Address' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' order by id desc);


	INSERT INTO LOG.log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE () AS Date ),	-- LogDate,
		CAST( GETDATE () AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'TA Loader',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.ContactLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);

--    IF @l_sourceInterfaceType <> 'DEMO'
--	BEGIN

	--BEGIN TRANSACTION /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/

    BEGIN TRY
        SET @LogMessage = 'IFC.ContactLoader Started at ' + Cast(CAST( GETDATE () AS DateTime ) as NVARCHAR(20)) + 	@CRLF;

		Declare @l_Contact nvarchar(1); -- Contact = 'T'
-----------------------------------------------
		Declare @ID NUMERIC(16);
		Declare @ObjectID NUMERIC(16);
		Declare @SourceInterfaceType NVARCHAR(200);
		Declare @SourceID NVARCHAR(200);
		Declare @SourcePersonID NVARCHAR(200);
		Declare @SourceCompanyID NVARCHAR(200);
		Declare @RegistrationNr NVARCHAR(30);
		Declare @TaxNr NVARCHAR(30);
		Declare @StatisticalNr NVARCHAR(30);
		Declare @ContactType NVARCHAR(200);
		Declare @ContactTypeCode NVARCHAR(200);
		Declare @Contact NVARCHAR(250);
		Declare @MainContact NVARCHAR(1);
		Declare @Description NVARCHAR(250);
		Declare @CrefoID NUMERIC(16);
		Declare @InterfaceStatusCode NVARCHAR(1);
		--Declare @ErrorMessage NVARCHAR(200);
		Declare @ActualisationDate DATE;
		Declare @ContactID NUMERIC(16);
		Declare @Operation NVARCHAR(1);
		Declare @InterfaceTableID NUMERIC(16);
		Declare @ValidFrom DATE;
		Declare @ValidUntil DATE;
		Declare @CreationDate DATE;
		Declare @CreationTime TIME;
		Declare @CreationUserName NUMERIC(16);
		Declare @l_ContactID numeric(18);
		--Declare @l_ContactType Nvarchar(200);

		Declare @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		Declare @l_EntityID numeric(18);
		Declare @l_ObjectID numeric(18);

		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ExisingRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);

		Declare @l_PortfolioID numeric(16);
		Declare @l_DataOriginCode nvarchar(200);

		DECLARE @PRTContact nVarchar(500);

		SET @l_AllRowCounts = 0;
		SET @l_ImportedRowCounts = 0;
		SET @l_ExisingRowCounts = 0;
		SET @l_ErrorRowCounts = 0;

    DECLARE @l_InkassoSyncOn int = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'Phone', 'insert')

		DECLARE @ERR_SIFTYPE_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SIFTYPE_CANNOT_BE_EMPTY = 'ERR_GENERAL';						-- SourceInterfaceTpye is empty
		DECLARE @ERR_SIDCANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SIDCANNOT_BE_EMPTY = 'ERR_GENERAL';							-- SourceID is Empty

		DECLARE @ERR_SourceCompanyID_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SourceCompanyID_CANNOT_BE_EMPTY = 'ERR_GENERAL';

		DECLARE @ERR_SourcePersonID_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SourcePersonID_CANNOT_BE_EMPTY = 'ERR_GENERAL';

		DECLARE @ERR_ContactType_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_ContactType_CANNOT_BE_EMPTY = 'ERR_CONTACTTYPE_CANNOT_BE_EMPTY';

		DECLARE @ERR_ContactTypeCode_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_ContactTypeCode_CANNOT_BE_EMPTY = 'ERR_GENERAL';

		DECLARE @ERR_ContactType_IS_NOT_VALID nvarchar(200);
			SET @ERR_ContactType_IS_NOT_VALID = 'ERR_GENERAL';

		DECLARE @ERR_ContactTypeCode_IS_NOT_VALID nvarchar(200);
			SET @ERR_ContactTypeCode_IS_NOT_VALID = 'ERR_GENERAL';

		DECLARE @ERR_CONTACT_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_CONTACT_CANNOT_BE_EMPTY = 'ERR_CONTACT_CANNOT_BE_EMPTY';

		DECLARE @ERR_NOT_FOUND_ASSIGNED_ENTITY nvarchar(200);
			SET @ERR_NOT_FOUND_ASSIGNED_ENTITY = 'ERR_GENERAL';

		DECLARE @ERR_PORTFOLIOID_NOT_EXISTS nvarchar(200);
			SET @ERR_PORTFOLIOID_NOT_EXISTS = 'ERR_GENERAL';


		SET @PRTContact = (Select Top 1 Code from GEN.ObjectType where TableName = 'PRT.CONTACT' order by TableName desc);


		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END

		IF COALESCE(@l_sourceInterfaceType, '') = ''
			RAISERROR('The SourceInterfaceType field in ParameterValue is not defined!', 16, 1);

		SET @l_AllRowCounts = (Select Count(*) FROM IFC.Contact where SourceInterfaceType = @l_sourceInterfaceType
					and
					(
					(Contact.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Contact.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Contact' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));


		DECLARE db_cursor CURSOR FOR
		SELECT ID, ObjectID, SourceInterfaceType, SourceID, SourcePersonID, SourceCompanyID, RegistrationNr, TaxNr, StatisticalNr,
			ContactType, ContactTypeCode, Contact, MainContact, Description, CrefoID, InterfaceStatusCode, /*ErrorMessage,*/ ActualisationDate,
			ContactID, [Operation], InterfaceTableID, ValidFrom, ValidUntil, CreationDate, CreationTime, CreationUserName
		FROM IFC.Contact
		where SourceInterfaceType = @l_sourceInterfaceType
				and
					(
					(Contact.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Contact.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Contact' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
		Order by Id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID, @ObjectID, @SourceInterfaceType, @SourceID, @SourcePersonID, @SourceCompanyID, @RegistrationNr, @TaxNr, @StatisticalNr,
			@ContactType, @ContactTypeCode, @Contact, @MainContact, @Description, @CrefoID, @InterfaceStatusCode, /*@ErrorMessage, */@ActualisationDate,
			@ContactID, @Operation, @InterfaceTableID, @ValidFrom, @ValidUntil, @CreationDate, @CreationTime, @CurrentUserName

		WHILE @@FETCH_STATUS = 0
		BEGIN

			SET @l_ImportID = 0;
			SET @l_EntityID = 0;

	BEGIN TRY /* Belső-1 */
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Error Section:
		SET @ErrorMessage = NULL;
		SET @l_BlockerError = '';
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceInterfaceType:
			IF Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceInterfaceType is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'sourceInterfaceType', @ERR_SIFTYPE_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceID:
			IF Trim(Isnull(@SourceID,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'sourceID', @ERR_SIDCANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;

---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceCompanyID, @SourcePersonID:
			IF TRIM(ISNULL(@SourceCompanyID,''))  = '' AND TRIM(ISNULL(@SourcePersonID,''))  = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceCompanyID / SourcePersonID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'sourceCompanyID', @ERR_SourceCompanyID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'sourcePersonID', @ERR_SourcePersonID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Üres a Contact mező:
-- DV-1992:
			IF Isnull(@Contact,'') = ''
			BEGIN
						Set @l_ErrorMessage = 'Contact is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'contact', @ERR_CONTACT_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------


-- @ContactType,@ContactTypeCode:
			-- 1 - Üres:
			If Isnull(@ContactType,'') = '' and Isnull(@ContactTypeCode,'') = ''
			BEGIN
						Set @l_ErrorMessage = 'ContactType and ContactTypeCode is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'contactType', @ERR_ContactType_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'contactTypeCode', @ERR_ContactTypeCode_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
			-- 2 - Text-NotValid:
			If Isnull(@ContactType,'') <> '' and Isnull(@ContactTypeCode,'') = ''
			BEGIN
				If Not exists (
						select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CONTACT_TYPE'
						and Translation.Text = @ContactType)
					Begin
						Set @l_ErrorMessage = 'ContactType is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'contactType', @ERR_ContactType_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @ContactType = NULL;
					End;
				Else
					Set @ContactTypeCode = (select Top 1 Code.Id
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CONTACT_TYPE'
						and Translation.Text = @ContactType order by Code.Id desc);
			END;
			-- 3 - Code-NotValid:
			If Isnull(@ContactType,'') = '' and Isnull(@ContactTypeCode,'') <> ''
			and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CONTACT_TYPE'
						and Code.Id = @ContactTypeCode)
			BEGIN
						Set @l_ErrorMessage = 'ContactTypeCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'contactTypeCode', @ERR_ContactTypeCode_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @ContactTypeCode = NULL;
			END;

-- EntityID:
		Set @l_EntityID= NULL;
		If exists (Select 1 from IFC.Person WHERE SourceInterfaceType = @SourceInterfaceType and Person.SourceID = @SourcePersonID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED'))
			Set @l_EntityID = (Select Top 1 Person.CrefoId from IFC.Person WHERE SourceInterfaceType = @SourceInterfaceType and Person.SourceID = @SourcePersonID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by Id desc);

		If exists (Select 1 from IFC.Company WHERE SourceInterfaceType = @SourceInterfaceType and Company.SourceID = @SourceCompanyID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED'))
			Set @l_EntityID = (Select Top 1 Company.CrefoId from IFC.Company WHERE SourceInterfaceType = @SourceInterfaceType and Company.SourceID = @SourceCompanyID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by Id desc);

		IF @l_EntityID is NULL
		BEGIN
						Set @l_ErrorMessage = 'Entity is not found';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'sourcePersonID', @ERR_NOT_FOUND_ASSIGNED_ENTITY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'sourceCompanyID', @ERR_NOT_FOUND_ASSIGNED_ENTITY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;

-- PortfolioID:
		Set @l_PortfolioID = NULL;
		Set @l_DataOriginCode = NULL;

		Set @l_PortfolioID = (Select Top 1 Object.PortfolioID from Prt.Entity
						Join Gen.Object on Object.ID = Entity.ObjectID
						where Entity.Id = @l_EntityID order by Object.ID desc);
		If @l_PortfolioID = NULL
			Begin
						Set @l_ErrorMessage = 'PortfolioID is not exists';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'sourcePersonID', @ERR_PORTFOLIOID_NOT_EXISTS, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.CONTACT', @ID, 'sourceCompanyID', @ERR_PORTFOLIOID_NOT_EXISTS, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			End;

		If @l_PortfolioID <> 0
			SELECT @l_DataOriginCode =
				CASE (Select TreatmentTypeCode from Gen.Portfolio where Id = @l_PortfolioID)
					WHEN 'TREATMENT_TYPE_MANDATE' THEN 'DATA_ORIGIN_PRINCIPAL' /* Megbízásos */
					WHEN 'TREATMENT_TYPE_ASSIGNMENT' THEN 'DATA_ORIGIN_LEGAL_PREDECESSOR'  /* Engedményzett */
					ELSE 'DATA_ORIGIN_LEGAL_PREDECESSOR' /* Engedményzett */
				END;

-- Contact:
/*
		if Trim(Isnull(@Contact,'')) = ''
		Begin
				SET @ErrorMessage = Concat(@ErrorMessage, ' ContactValue is empty,');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
				Select 'IFC.CONTACT', @ID, 'contact', @ERR_CONTACT_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
				SET @l_BlockerError = 'T';
		End;
*/

-- Hibakiírás:

		IF @l_BlockerError = 'T'
		BEGIN
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			UPDATE IFC.CONTACT SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage,
				LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName	WHERE ID = @ID;
		END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Betöltés:
		IF @l_BlockerError = ''
		BEGIN
-- Contact:
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
			Set @Contact = Trim(@Contact);


			-- Már létezik a contact:
			SET @l_ContactID = 0;
			IF EXISTS (SELECT 1 FROM PRT.Contact WHERE EntityID = @l_EntityID
				and ContactType = @ContactTypeCode
				and Contact = @Contact
				--and SourceInterfaceType = @SourceInterfaceType
				--and SourceID = Isnull(@SourcePersonID, @SourceCompanyID)
				)
				--and Isnull(@Operation,'') <> 'U'
				--OR EXISTS (SELECT 1 FROM PRT.Entity WHERE TaxNr = @TaxNr)
			BEGIN
				SET @l_ContactID = (SELECT Top 1 Contact.ID FROM PRT.Contact WHERE EntityID = @l_EntityID
					and ContactType = @ContactTypeCode
					and Contact = @Contact
					--and SourceInterfaceType = @SourceInterfaceType
					--and SourceID = Isnull(@SourcePersonID, @SourceCompanyID)
					Order by Id);
				SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
				UPDATE IFC.Contact SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED',
				Errormessage = 'Identified by EntityID: ' + cast(@l_EntityID as nvarchar(18)) +
						(Select Case When (Select Isnull(SourceID,'') from PRT.Entity where ID = @l_EntityID) <> Isnull(@SourcePersonID,@SourceCompanyID)
						then ' Other SourceId: ' + (Select Isnull(SourceID,'') from PRT.Entity where ID = @l_EntityID) end),
					LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName	WHERE ID = @ID;
			END;
			ELSE
			BEGIN
        BEGIN TRAN /*Nem létező kontakt*/
          /*itt a StatusCode nincs állítva valamiért - ha egyszer lesz, akkor ezt a változást is szinkronizálni kell az Inkasso felé*/
				  Update PRT.Contact
          Set ValidUntil = CAST( GETDATE() AS Date )
          where EntityID = @l_EntityID and ContactType = @ContactTypeCode and ValidUntil is NULL;

				  -- New ObjectID:
				  INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
					  SELECT @PRTContact as ObjectType, CAST( GETDATE () AS Date ), CAST( GETDATE () AS Time ), @CurrentUserName, '1.0.0';
				  SET @l_ObjectID = @@Identity;

				  -- Új contact felvitele:
				  INSERT INTO PRT.Contact(
					  ObjectID, ContactType, EntityID, Contact, ValidFrom, ValidUntil, StatusCode, DataSourceCode, Comments,
					  SourceInterfaceType, SourceID, CreationDate, CreationTime, CreationUserName, DataOriginCode)
					  SELECT
						  @l_ObjectID, @ContactTypeCode, @l_EntityID, Trim(@Contact), CAST( GETDATE () AS Date ), NULL, 'STATUS_NORMAL' as Status, NULL as DataSourceCode, @Description,
						  @SourceInterfaceType, @SourceID, CAST( GETDATE () AS Date ), CAST( GETDATE () AS Time ), @CurrentUserName, @l_DataOriginCode;

					  SET @l_ImportID = @@Identity;

            /*DV-1592: insert Inkasso sync record*/
            if @l_InkassoSyncOn = 1 and @ContactTypeCode in('CONTACT_TYPE_FOREIGNPHONE', 'CONTACT_TYPE_MOBILE', 'CONTACT_TYPE_PHONE')
            begin
              exec IFC.GenerateSendInkassoSyncData @syncType = 'Phone',
                                                   @syncEventType = 'insert',
                                                   @entityID = null,
                                                   @ID = @l_ImportID,
                                                   @dataChangedUserName = @CurrentUserName,
                                                   @correlationID = @p_correlationID,
                                                   @moduleInstanceID = @p_moduleInstanceIDInkasso output,
                                                   @isBatch = 1
            end

					  SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
					  If ISNULL(@ErrorMessage,'') = @ErrorMessage
						  Set @ErrorMessage = NULL;
					  UPDATE IFC.Contact SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', Errormessage = @ErrorMessage, CrefoID = @l_EntityID,
						LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
        COMMIT /*Nem létező kontakt*/
			END;
		END;  /*@ErrorMessage = NULL*/

  END TRY /*Belső-1*/
  BEGIN CATCH /*Belső-1*/
    SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
    SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
    UPDATE IFC.Contact SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage,
		LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName	WHERE ID = @ID;
  END CATCH /*Belső-1*/



			FETCH NEXT FROM db_cursor INTO @ID, @ObjectID, @SourceInterfaceType, @SourceID, @SourcePersonID, @SourceCompanyID, @RegistrationNr, @TaxNr, @StatisticalNr,
				@ContactType, @ContactTypeCode, @Contact, @MainContact, @Description, @CrefoID, @InterfaceStatusCode, /*@ErrorMessage, */ @ActualisationDate,
				@ContactID, @Operation, @InterfaceTableID, @ValidFrom, @ValidUntil, @CreationDate, @CreationTime, @CurrentUserName
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    --COMMIT TRANSACTION; /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/

    END TRY


    BEGIN CATCH

        SELECT
        @ErrorMessage = ERROR_MESSAGE(),
        @ErrorSeverity = ERROR_SEVERITY(),
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE () AS Date ),	-- LogDate,
		CAST( GETDATE () AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'TA Loader',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.ContactLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;				-- LogMessage

        --RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );
        --ROLLBACK TRANSACTION; /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592), de ennek eredetileg is fentebb kellett volna lennie, hogy a logolás ne rollbackelődjön*/

        SELECT @ErrorMessage;

    END CATCH;

--	END -- 'DEMO'
------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------

	SET @LogMessage = @LogMessage + 'IFC.ContactLoader Ended at ' + Cast(CAST( GETDATE () AS DateTime ) as NVARCHAR(20)) + 	@CRLF;

	INSERT INTO LOG.log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE () AS Date ),	-- LogDate,
		CAST( GETDATE () AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'TA Loader',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.ContactLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ExistingRowsCount: ' + CAST(@l_ExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ @LogMessage



	INSERT INTO LOG.log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE () AS Date ),	-- LogDate,
		CAST( GETDATE () AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'TA Loader',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.ContactLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If Isnull(@ErrorMessage,'') <> ''
		Return 99;
	else
		Return 1;


END;
go

/*
=============================================
Author:		Balázs ARANYI
Create date: 2022-11-18
Last modified date: 2022-11-18
					2023-10-30 (T.Gé): [ContractItem].[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED'
Description:	Transfer data from IFC.ContractItem table to CRM.ContractItem
=============================================
*/
CREATE   PROCEDURE [IFC].[ContractItemLoader] 
	-- Add the parameters for the stored procedure here
	@p_correlationID NVARCHAR(200), 
	@p_moduleInstanceID NUMERIC(16),
	@p_result INT OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'IFC.ContractItemLoader'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_contractID NUMERIC(16) = NULL;
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--Az IFC.Contract változói
	DECLARE @l_id NUMERIC(16) = NULL;
	DECLARE @l_sequenceNr NUMERIC(16) = NULL;
	DECLARE @l_referenceNr NVARCHAR(200) = NULL;
	DECLARE @l_netValue MONEY = NULL;
	DECLARE @l_vatValue MONEY = NULL;
	DECLARE @l_grossValue MONEY = NULL;
	DECLARE @l_currencyCode NVARCHAR(200) = NULL;
	DECLARE @l_productID NVARCHAR(50) = NULL;
	DECLARE @l_productName NVARCHAR(200) = NULL;
	DECLARE @l_description NVARCHAR(MAX) = NULL;
	DECLARE @l_statusCode NVARCHAR(200) = NULL;
	DECLARE @l_statusText NVARCHAR(200) = NULL;
	DECLARE @l_sourceID NVARCHAR(200) = NULL;
	DECLARE @l_sourceContractID NVARCHAR(200) = NULL;
	DECLARE @l_sourceContractNr NVARCHAR(200) = NULL;
	DECLARE @l_contractItemID NUMERIC(16) = NULL;
	DECLARE @l_operationCode NVARCHAR(200) = NULL;
	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		SELECT @p_result = NULL;
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
			
		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END

		IF COALESCE(@l_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		
		SELECT @l_logMsg = CONCAT('The value of SourceInterfaceType variable: ', @l_sourceInterfaceType);
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		
		SELECT @l_logMsg = 'Processing of Contract rows...';
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--ContraactItem sorok feldolgozása
		DECLARE contractItem_cursor CURSOR FOR
		SELECT 
			[ContractItem].[ID],
			[ContractItem].[SequenceNr],
			[ContractItem].[ReferenceNr],
			[ContractItem].[NetValue],
			[ContractItem].[VATValue],
			[ContractItem].[GrossValue],
			[ContractItem].[CurrencyCode],
			[ContractItem].[ProductID],
			[ContractItem].[ProductName],
			[ContractItem].[Description],
			[ContractItem].[StatusCode],
			[ContractItem].[StatusText],
			[ContractItem].[ContractItemID],
			[ContractItem].[SourceID],
			[ContractItem].[SourceContractID],
			[ContractItem].[SourceContractNr],
			[ContractItem].[OperationCode]
		FROM [IFC].[ContractItem]
		WHERE [ContractItem].[SourceInterfaceType] = @l_sourceInterfaceType
		AND [ContractItem].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
		ORDER BY [ContractItem].[ID];
		
		OPEN contractItem_cursor;
		FETCH NEXT FROM contractItem_cursor
		INTO 
			@l_id,
			@l_sequenceNr,
			@l_referenceNr,
			@l_netValue,
			@l_vatValue,
			@l_grossValue,
			@l_currencyCode,
			@l_productID,
			@l_productName,
			@l_description,
			@l_statusCode,
			@l_statusText,
			@l_contractItemID,
			@l_sourceID,
			@l_sourceContractID,
			@l_sourceContractNr,
			@l_operationCode;

		WHILE @@FETCH_STATUS = 0 
		BEGIN	
			--Szerződés ellenőrzése
			IF COALESCE(@l_sourceContractID, '') <> '' 
				SELECT @l_contractID = [Contract].[ContractID]
				FROM [IFC].[Contract]
				WHERE [Contract].[SourceInterfaceType] = @l_sourceInterfaceType
				AND [Contract].[SourceID] = @l_sourceContractID
				--AND [Contract].[InterfaceStatusCode] NOT IN ('INTERFACE_STATUS_NEW', 'INTERFACE_STATUS_ERROR', 'INTERFACE_STATUS_FIXED');
				AND [Contract].[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED';
				
			IF COALESCE(@l_contractID, 0) = 0 AND COALESCE(@l_sourceContractNr, '') <> '' 
				SELECT @l_contractID = [Contract].[ContractID]
				FROM [IFC].[Contract]
				WHERE [Contract].[ContractNr] = @l_sourceContractNr
				--AND [Contract].[InterfaceStatusCode] NOT IN ('INTERFACE_STATUS_NEW', 'INTERFACE_STATUS_ERROR', 'INTERFACE_STATUS_FIXED');
				AND [Contract].[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED';
				
			IF COALESCE(@l_contractID, 0) = 0 AND COALESCE(@l_sourceContractNr, '') <> '' 
				SELECT @l_contractID = [Contract].[ID]
				FROM [CRM].[Contract]
				WHERE [Contract].[ContractNr] = @l_sourceContractNr; 
			
			IF COALESCE(@l_contractID, 0) <> 0 
			BEGIN							
				--Pénznem mező ellenőrzése
				IF COALESCE(@l_currencyCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The currency is not specified.';
				
				--Termék mező ellenőrzése
				IF COALESCE(@l_productName, '') = '' AND COALESCE(@l_productID, 0) = 0
					SELECT @l_errorMsg = @l_errorMsg +  'The product is not specified.'
				ELSE 
				BEGIN
					IF COALESCE(@l_productID, 0) = 0 
						SELECT TOP 1 @l_productID = [Product].[ID]
						FROM [FIN].[Product]
						JOIN [GEN].[Translation] ON ([Translation].[CodeID] = [Product].[Code])
						WHERE [Translation].[Text] = @l_productName
						AND [Translation].[CodeID] LIKE 'PRODUCT_%';
				
					IF COALESCE(@l_productID, 0) = 0
						SELECT @l_errorMsg = @l_errorMsg +  'The specified product cannot be found.';
				END;
			
				--Státusz mező ellenőrzése
				IF COALESCE(@l_statusCode, '') = '' AND COALESCE(@l_statusText, '') <> ''
				BEGIN
					SELECT @l_statusCode = [Translation].[CodeID]
					FROM [GEN].[Translation]
					WHERE [Translation].[Text] = @l_statusText 
					AND [Translation].[CodeID] LIKE 'STATUS_%';
				
					IF COALESCE(@l_statusCode, '') = ''
						SELECT @l_errorMsg = @l_errorMsg +  'The specified status cannot be found.';
				END;
				
				IF COALESCE(@l_statusCode, '') = '' 
					SELECT @l_statusCode = 'STATUS_NORMAL';
			
				--Ha nincs hiba, akkor mehet a feldolgozás tovább
				IF COALESCE(@l_errorMsg, '') = ''
				BEGIN
					BEGIN TRY
						--CRM.Contract objektum létrehozása
						INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
						SELECT 'CRM.ContractItem', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
							 'ADMIN',
							'CRM.ContractItem object', '1.0';
					
						SELECT @l_objectID = @@IDENTITY;
				
						--CRM.Contract sor létrehozása
						INSERT INTO [CRM].[ContractItem] ([ObjectID], [ContractID], [SequenceNr], [ReferenceNr], [NetValue], [VatValue], [GrossValue], [CurrencyID], 
							[ProductID], [Status], [Description], [CreationDate], [CreationTime], [CreationUserName])
						SELECT @l_objectID, @l_contractID, @l_sequenceNr, @l_referenceNr, @l_netValue, @l_vatValue, @l_grossValue, @l_currencyCode, @l_productID,
							@l_statusCode, @l_description, CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
							'ADMIN';
							
						SELECT @l_contractItemID = @@IDENTITY;
					END TRY
					BEGIN CATCH
						SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
							' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());
					END CATCH
				END;

				IF COALESCE(@l_errorMsg, '') = ''
					UPDATE [IFC].[ContractItem] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED',
						[ContractItemID] = @l_contractItemID,
						[ErrorMessage] = 'OK',
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] = 'ADMIN'
					WHERE [ContractItem].[ID] = @l_id
				ELSE 
				BEGIN
					UPDATE [IFC].[ContractItem] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
						[ErrorMessage] = @l_errorMsg,
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] =  'ADMIN'
					WHERE [ContractItem].[ID] = @l_id;
					
					SELECT @l_logMsg = CONCAT('##ERROR: ID: ', @l_id, ' Message: ', @l_errorMsg);

					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),				-- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						'INFO',					        -- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;
				END
			END
			ELSE
				UPDATE [IFC].[ContractItem] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
					[ErrorMessage] = 'Contract not found',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] =  'ADMIN'
				WHERE [ContractItem].[ID] = @l_id;

			FETCH NEXT FROM contractItem_cursor
			INTO 
				@l_id,
				@l_sequenceNr,
				@l_referenceNr,
				@l_netValue,
				@l_vatValue,
				@l_grossValue,
				@l_currencyCode,
				@l_productID,
				@l_productName,
				@l_description,
				@l_statusCode,
				@l_statusText,
				@l_contractItemID,
				@l_sourceID,
				@l_sourceContractID,
				@l_sourceContractNr,
				@l_operationCode;
		END

		CLOSE contractItem_cursor;
		DEALLOCATE contractItem_cursor;

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;

		SELECT @p_result = 1;
		RETURN;
	END TRY

	BEGIN CATCH
		SELECT @p_result = 99;
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'contractItem_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE contractItem_cursor;

			DEALLOCATE contractItem_cursor;
		END;

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage

		RETURN;
	END CATCH
END
go


/*
=============================================
Author:		Balázs ARANYI
Create date: 2022-11-15
Last modified date: 2023.06.22:	Description:	Transfer data from IFC.Contract, IFC.ContractItem, IFC.CollectionContractItem, IFC.CollectionContractSummary table to 
								CRM.Contract, CRM.ContractItem, CRM.CollectionContractItem, CRM.CollectionContractSummary
					2023.06.22 (B.Dávid):	DataOriginCode javítás
-- =============================================
*/
CREATE PROCEDURE [IFC].[ContractLoader] 
	-- Add the parameters for the stored procedure here
	@p_correlationID NVARCHAR(200), 
	@p_moduleInstanceID NUMERIC(16)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = ''; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = ''; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = ''; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'IFC.ContractLoader'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_objectID NUMERIC(16) = 0;
	DECLARE @l_foundSummary NVARCHAR(1) = 'F';
	DECLARE @l_foundItem NVARCHAR(1) = 'F';
	DECLARE @l_summaryItemCount NUMERIC(16) = 0;
	DECLARE @l_summaryDebtCapital MONEY = 0;
	DECLARE @l_summaryDebtInterest MONEY = 0;
	DECLARE @l_summaryDebtPenaltyInterest MONEY = 0;
	DECLARE @l_summaryDebtCost MONEY = 0;
	DECLARE @l_summaryDebtCostLocalCurrency MONEY = 0;
	DECLARE @l_summaryDebtTotal MONEY = 0;
	DECLARE @l_summaryCurrencyCode NVARCHAR(200) = NULL;
	DECLARE @l_itemItemCount NUMERIC(16) = 0;
	DECLARE @l_itemDebtCapital MONEY = 0;
	DECLARE @l_itemDebtInterest MONEY = 0;
	DECLARE @l_itemDebtPenaltyInterest MONEY = 0;
	DECLARE @l_itemDebtCost MONEY = 0;
	DECLARE @l_itemDebtCostLocalCurrency MONEY = 0;
	DECLARE @l_itemDebtTotal MONEY = 0;
	DECLARE @l_sqlStatement NVARCHAR(MAX) = NULL;
	DECLARE @l_params NVARCHAR(MAX) = NULL;
	DECLARE @l_interactionID NUMERIC(16) = NULL;
	DECLARE @l_moduleInstanceID NUMERIC(16) = NULL;
	DECLARE @l_moduleInstanceStartDateTime DATETIME = NULL;
	DECLARE @l_interactionDocumentID NUMERIC(16) = NULL;
	DECLARE @l_contractSignerID NUMERIC(16) = NULL;
	DECLARE @l_liveContractID NUMERIC(16) = 0;
    DECLARE @l_liveContractNr NVARCHAR(200) = NULL;
    DECLARE @l_liveContractPhase NVARCHAR(200) = NULL;
    DECLARE @l_liveContractStatus NVARCHAR(200) = NULL;
	DECLARE @l_copyContractItems BIT = 1;
	DECLARE @l_liveContractContractNr NVARCHAR(200) = NULL;
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--Közös változók (amelyek legalább kettő IFC táblában megtalálhatóak)
	DECLARE @l_id NUMERIC(16) = NULL;
	DECLARE @l_sourceID NVARCHAR(200) = NULL;
	DECLARE @l_operationCode NVARCHAR(200) = NULL;
	DECLARE @l_statusCode NVARCHAR(200) = NULL;
	DECLARE @l_statusText NVARCHAR(200) = NULL;
	DECLARE @l_currencyCode NVARCHAR(200) = NULL;
	DECLARE @l_decisionNr NVARCHAR(200) = NULL;
	DECLARE @l_contractNr NVARCHAR(200) = NULL;
	DECLARE @l_contractDate DATE = NULL;
	DECLARE @l_debtCapital MONEY = NULL;
	DECLARE @l_debtInterest MONEY = NULL;
	DECLARE @l_debtPenaltyInterest MONEY = NULL;
	DECLARE @l_debtCost MONEY = NULL;
	DECLARE @l_debtCostLocalCurrency MONEY = NULL;
	DECLARE @l_debtTotal MONEY = NULL;
	DECLARE @l_sourceContractID NVARCHAR(200) = NULL;
	--Az IFC.Contract változói
	DECLARE @l_sellerName NVARCHAR(200) = NULL;
	DECLARE @l_sellerPartyID NUMERIC(16) = NULL;
	DECLARE @l_buyerName NVARCHAR(200) = NULL;
	DECLARE @l_buyerPartyID NUMERIC(16) = NULL;
	DECLARE @l_referencedContractNr NVARCHAR(200) = NULL;
	DECLARE @l_referencedContractID NUMERIC(16) = NULL;
	DECLARE @l_contractTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_contractTypeText NVARCHAR(200) = NULL;
	DECLARE @l_contractPhaseCode NVARCHAR(200) = NULL;
	DECLARE @l_contractPhaseText NVARCHAR(200) = NULL;
	DECLARE @l_registrationNr NVARCHAR(200) = NULL;
	DECLARE @l_externalContractNr NVARCHAR(200) = NULL;
	DECLARE @l_validFrom DATE = NULL;
	DECLARE @l_validUntil DATE = NULL;
	DECLARE @l_contractID NUMERIC(16) = NULL;
	DECLARE @l_contractFinancialMilestoneDate DATE = NULL;
	--Az IFC.ContractItem változói
	DECLARE @l_sequenceNr NUMERIC(16) = NULL;
	DECLARE @l_referenceNr NVARCHAR(200) = NULL;
	DECLARE @l_netValue MONEY = NULL;
	DECLARE @l_vatValue MONEY = NULL;
	DECLARE @l_grossValue MONEY = NULL;
	DECLARE @l_productID NVARCHAR(50) = NULL;
	DECLARE @l_productName NVARCHAR(200) = NULL;
	DECLARE @l_description NVARCHAR(MAX) = NULL;
	DECLARE @l_sourceContractNr NVARCHAR(200) = NULL;
	DECLARE @l_contractItemID NUMERIC(16) = NULL;
	--Az IFC.CollectionContractItem változói
	DECLARE @l_constructionCode NVARCHAR(200) = NULL;
	DECLARE @l_debtorName NVARCHAR(200) = NULL;
	DECLARE @l_pricingMethodCode NVARCHAR(200) = NULL;
	DECLARE @l_pricingMethodText NVARCHAR(200) = NULL;
	DECLARE @l_businessPercent NUMERIC(10, 0) = NULL;
	DECLARE @l_businessPrice MONEY = NULL;
	DECLARE @l_accountNr NVARCHAR(200) = NULL;
	DECLARE @l_terminationDate DATE = NULL;
	DECLARE @l_financialMilestoneDate DATE = NULL;
	DECLARE @l_legalActionCode NVARCHAR(200) = NULL;
	DECLARE @l_legalActionText NVARCHAR(200) = NULL;
	DECLARE @l_collectionContractItemID NUMERIC(16, 0) = NULL;
	DECLARE @l_sourceContractItemID NVARCHAR(200) = NULL;	
	--Az IFC.CollectionContractSummary változói
	DECLARE @l_itemCount NUMERIC(16) = NULL;
	DECLARE @l_purchasePrice MONEY = NULL;
	DECLARE @l_purchasePriceCurrencyCode NVARCHAR(200) = NULL;
	DECLARE @l_collectionContractSummaryID NUMERIC(18) = NULL;
	--Amennyiben alkalmazunk cursor-okat, akkor azok definiálása (opcionális)	
	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
			
		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END

		IF COALESCE(@l_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		
		SELECT @l_logMsg = CONCAT('The value of SourceInterfaceType variable: ', @l_sourceInterfaceType);
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		
		SELECT @l_logMsg = 'Processing of Contract rows...';
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

--===========================================================
--BLOCK: BEGIN
--TABLE: tempdb..
--===========================================================

		--Ideiglenes táblák létrehozása 
		IF OBJECT_ID('tempdb..#Contracts', 'U') IS NOT NULL
			DROP TABLE #Contracts;

		CREATE TABLE #Contracts (
			SourceInterfaceType NVARCHAR(200),
			SourceID NVARCHAR(200), 
			PreparationContractID NUMERIC(16),
			LiveContractID NUMERIC(16),
			InteractionID NUMERIC(16)
		);

		IF OBJECT_ID('tempdb..#ContractItems', 'U') IS NOT NULL
			DROP TABLE #ContractItems;

		CREATE TABLE #ContractItems (
			SourceInterfaceType NVARCHAR(200),
			SourceID NVARCHAR(200), 
			ContractItemID NUMERIC(16)
		);

--===========================================================
--BLOCK: END
--TABLE: tempdb..
--===========================================================

--===========================================================
--BLOCK: BEGIN
--TABLE: IFC.Contract
--===========================================================
		DECLARE contract_cursor CURSOR FOR
		SELECT 
			[Contract].[ID],
			[Contract].[SellerName],
			[Contract].[SellerPartyID],
			[Contract].[BuyerName],
			[Contract].[BuyerPartyID],
			[Contract].[ReferencedContractNr],
			[Contract].[ReferencedContractID],
			[Contract].[ContractTypeCode],
			[Contract].[ContractTypeText],
			[Contract].[ContractPhaseCode],
			[Contract].[ContractPhaseText],
			[Contract].[StatusCode],
			[Contract].[StatusText],
			[Contract].[ContractNr],
			[Contract].[RegistrationNr],
			[Contract].[ExternalContractNr],
			[Contract].[DecisionNr],
			[Contract].[ValidFrom],
			[Contract].[ValidUntil],
			[Contract].[ContractDate],
			[Contract].[FinancialMilestoneDate],
			[Contract].[SourceID],
			[Contract].[Operation]
		FROM [IFC].[Contract] 
		WHERE [Contract].[SourceInterfaceType] = @l_sourceInterfaceType
			AND [Contract].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
		ORDER BY [Contract].[ID];
		
		--OTP_SRM_F sorok feldolgozása
		OPEN contract_cursor;
		FETCH NEXT FROM contract_cursor
		INTO 
			 @l_id,
			 @l_sellerName,
			 @l_sellerPartyID,
			 @l_buyerName,
			 @l_buyerPartyID,
			 @l_referencedContractNr,
			 @l_referencedContractID,
			 @l_contractTypeCode,
			 @l_contractTypeText,
			 @l_contractPhaseCode,
			 @l_contractPhaseText,
			 @l_statusCode,
			 @l_statusText,
			 @l_contractNr,
			 @l_registrationNr,
			 @l_externalContractNr,
			 @l_decisionNr,
			 @l_validFrom,
			 @l_validUntil,
			 @l_contractDate,
			 @l_contractFinancialMilestoneDate,
			 @l_sourceID,
			 @l_operationCode;

		WHILE @@FETCH_STATUS = 0 
		BEGIN
			SELECT @l_errorMsg = '';
			SELECT @l_contractID = 0;

			IF COALESCE(@l_contractNr, '') <> '' 
			BEGIN
				SELECT @l_contractID = [Contract].[ID] 
				FROM [CRM].[Contract]
				WHERE [Contract].[ContractNr] = @l_contractNr;
			END;

			IF COALESCE(@l_contractID, 0) = 0 AND COALESCE(@l_externalContractNr, '') <> ''
			BEGIN
				SELECT @l_contractID = [Contract].[ID] 
				FROM [CRM].[Contract]
				WHERE [Contract].[ExternalContractNr] = @l_externalContractNr;
			END;
				
			IF COALESCE(@l_contractID, 0) = 0 
			BEGIN
				--Összesítő adat ellenőrzése
				DECLARE contract_summary_cursor CURSOR FOR 
				SELECT 
					SUM([CollectionContractSummary].[ItemCount]),
					SUM([CollectionContractSummary].[DebtCapital]),
					SUM([CollectionContractSummary].[DebtInterest]),
					SUM([CollectionContractSummary].[DebtPenaltyInterest]),
					SUM([CollectionContractSummary].[DebtCost]), 
					SUM([CollectionContractSummary].[DebtCostLocalCurrency]),
					SUM([CollectionContractSummary].[DebtTotal]), 
					[CollectionContractSummary].[CurrencyCode]
				FROM [IFC].[CollectionContractSummary]
				WHERE [CollectionContractSummary].[SourceContractID] = @l_sourceID 
					AND [CollectionContractSummary].[SourceInterfaceType] = @l_sourceInterfaceType 
					AND [CollectionContractSummary].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
				GROUP BY [CollectionContractSummary].[CurrencyCode];

				OPEN contract_summary_cursor;
				FETCH NEXT FROM contract_summary_cursor
				INTO
					@l_summaryItemCount,
					@l_summaryDebtCapital,
					@l_summaryDebtInterest,
					@l_summaryDebtPenaltyInterest,
					@l_summaryDebtCost, 
					@l_summaryDebtCostLocalCurrency,
					@l_summaryDebtTotal, 
					@l_summaryCurrencyCode;

				WHILE @@FETCH_STATUS = 0 
				BEGIN
					IF COALESCE(@l_summaryItemCount, 0) = 0 
						SELECT @l_errorMsg = @l_errorMsg + 'Summary data cannot be found or the number of items is 0.'
					ELSE 
					BEGIN
						SELECT 
							@l_itemItemCount = COUNT([CollectionContractItem].[ID]), 
							@l_itemDebtCapital = SUM([CollectionContractItem].[DebtCapital]),
							@l_itemDebtInterest = SUM([CollectionContractItem].[DebtInterest]),
							@l_itemDebtPenaltyInterest = SUM([CollectionContractItem].[DebtPenaltyInterest]),
							@l_itemDebtCost = SUM([CollectionContractItem].[DebtCost]), 
							@l_itemDebtCostLocalCurrency = SUM([CollectionContractItem].[DebtCostLocalCurrency]),
							@l_itemDebtTotal = SUM([CollectionContractItem].[DebtTotal])
						FROM [IFC].[CollectionContractItem]
						JOIN [IFC].[ContractItem] ON 
							([ContractItem].[SourceInterfaceType] = [CollectionContractItem].[SourceInterfaceType] 
							AND [ContractItem].[SourceID] = [CollectionContractItem].[SourceContractItemID]) 
						WHERE [ContractItem].[SourceContractID] = @l_sourceID
							AND [ContractItem].[SourceInterfaceType] = @l_sourceInterfaceType 
							AND [ContractItem].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
							AND [CollectionContractItem].[CurrencyCode] = @l_summaryCurrencyCode
						GROUP BY [ContractItem].[SourceContractID];
					
						IF COALESCE(@l_summaryItemCount, 0) <> COALESCE(@l_itemItemCount, 0) 
							SELECT @l_errorMsg = @l_errorMsg + 
								CONCAT('The number of items does not match. Summary: ', @l_summaryItemCount, 
									' Item(s): ', @l_itemItemCount);
								
						IF COALESCE(@l_summaryDebtCapital, 0) <> COALESCE(@l_itemDebtCapital, 0) 
							SELECT @l_errorMsg = @l_errorMsg + 
								CONCAT('The value of the capital does not match. Summary: ', @l_summaryDebtCapital, 
									' Item(s): ', @l_itemDebtCapital);
								
						IF COALESCE(@l_summaryDebtInterest, 0) <> COALESCE(@l_itemDebtInterest, 0) 
							SELECT @l_errorMsg = @l_errorMsg + 
								CONCAT('The value of the interest does not match. Summary: ', @l_summaryDebtInterest, 
									' Item(s): ', @l_itemDebtInterest);
								
						IF COALESCE(@l_summaryDebtPenaltyInterest, 0) <> COALESCE(@l_itemDebtPenaltyInterest, 0) 
							SELECT @l_errorMsg = @l_errorMsg + 
								CONCAT('The value of the penalty interest does not match. Summary: ', @l_summaryDebtPenaltyInterest, 
									' Item(s): ', @l_itemDebtPenaltyInterest);
								
						IF COALESCE(@l_summaryDebtCost, 0) <> COALESCE(@l_itemDebtCost, 0) 
							SELECT @l_errorMsg = @l_errorMsg + 
								CONCAT('The value of the cost does not match. Summary: ', @l_summaryDebtCost, 
									' Item(s): ', @l_itemDebtCost);
								
						IF COALESCE(@l_summaryDebtTotal, 0) <> COALESCE(@l_itemDebtTotal, 0) 
							SELECT @l_errorMsg = @l_errorMsg + 
								CONCAT('The value of the total does not match. Summary: ', @l_summaryDebtTotal, 
									' Item(s): ', @l_itemDebtTotal);
					END;

					FETCH NEXT FROM contract_summary_cursor
					INTO
						@l_summaryItemCount,
						@l_summaryDebtCapital,
						@l_summaryDebtInterest,
						@l_summaryDebtPenaltyInterest,
						@l_summaryDebtCost, 
						@l_summaryDebtCostLocalCurrency,
						@l_summaryDebtTotal, 
						@l_summaryCurrencyCode;
				END;

				CLOSE contract_summary_cursor;
				DEALLOCATE contract_summary_cursor;
				
				--Szerződés dátum mező ellenőrzése
				/*IF COALESCE(@l_contractDate, '') = CAST('1900-01-01' AS DATE)
					SELECT @l_errorMsg = @l_errorMsg +  'The contract date field is empty.';*/
			
				--Szállító mező ellenőrzése
				IF COALESCE(@l_sellerName, '') = '' AND COALESCE(@l_sellerPartyID, 0) = 0
					SELECT @l_errorMsg = @l_errorMsg +  'The seller party is not specified.'
				ELSE 
				BEGIN
					PRINT CONCAT('Retrieving company: ', @l_sellerName);

					IF COALESCE(@l_sellerPartyID, 0) = 0 
						SELECT TOP 1 @l_sellerPartyID = [Party].[ID]
						FROM [PRT].[Party]
						JOIN [PRT].[Company] ON ([Company].[EntityID] = [Party].[EntityID])
						WHERE [Company].[Name] = @l_sellerName
						AND [Company].[StatusCode] = 'ENTITY_STATUS_COMPANY_ACTIVE';

					PRINT CONCAT('Seller party ID: ', COALESCE(@l_sellerPartyID, 0));
					
					IF COALESCE(@l_sellerPartyID, 0) = 0
						SELECT @l_errorMsg = @l_errorMsg +  'The specified seller party cannot be found.';

					PRINT @l_errorMsg;
				END;
				
				--Vevő mező ellenőrzése
				IF COALESCE(@l_buyerName, '') = '' AND COALESCE(@l_buyerPartyID, 0) = 0
					SELECT @l_errorMsg = @l_errorMsg +  'The buyer party is not specified.'
				ELSE 
				BEGIN
					PRINT CONCAT('Retrieving company: ', @l_buyerName);

					IF COALESCE(@l_buyerPartyID, 0) = 0 
						SELECT TOP 1 @l_buyerPartyID = [Party].[ID]
						FROM [PRT].[Party]
						JOIN [PRT].[Company] ON ([Company].[EntityID] = [Party].[EntityID])
						WHERE [Company].[Name] = @l_buyerName
						AND [Company].[StatusCode] = 'ENTITY_STATUS_COMPANY_ACTIVE';

					PRINT CONCAT('Buyer party ID: ', COALESCE(@l_buyerPartyID, 0));
				
					IF COALESCE(@l_buyerPartyID, 0) = 0
						SELECT @l_errorMsg = @l_errorMsg + 'The specified buyer party cannot be found.';

					PRINT @l_errorMsg;
				END;
			
				--Hivatkozott szerződés mező ellenőrzése
				IF COALESCE(@l_referencedContractID, 0) = 0 AND COALESCE(@l_referencedContractNr, '') <> ''
				BEGIN
					SELECT @l_referencedContractID = [Contract].[ID]
					FROM [CRM].[Contract]
					WHERE [Contract].[ContractNr] = @l_referencedContractNr;
				
					IF COALESCE(@l_referencedContractID, 0) = 0
						SELECT @l_errorMsg = @l_errorMsg +  'The specified referenced contract number cannot be found.';
				END;
			
				--Szerződés típus mező ellenőrzése
				IF COALESCE(@l_contractTypeText, '') = '' AND COALESCE(@l_contractTypeCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The contract type is not specified.'
				ELSE 
				BEGIN
					IF COALESCE(@l_contractTypeCode, '') = ''
						SELECT @l_contractTypeCode = [Code].[ID]
						FROM [GEN].[Code] 
						JOIN [GEN].[Translation] ON ([Translation].[CodeID] = [Code].[ID])
						WHERE [Translation].[Language] = 'HU'
						AND [Translation].[Text] = @l_contractTypeText;
					
					IF COALESCE(@l_contractTypeCode, '') = ''
						SELECT @l_errorMsg = @l_errorMsg +  'The specified contract type cannot be found.';
				END;
				
				--Szerződés fázis mező ellenőrzése
				IF COALESCE(@l_contractPhaseText, '') = '' AND COALESCE(@l_contractPhaseCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The contract phase is not specified.'
				ELSE 
				BEGIN
					IF COALESCE(@l_contractPhaseCode, '') = ''
						SELECT @l_contractPhaseCode = [Code].[ID]
						FROM [GEN].[Code] 
						JOIN [GEN].[Translation] ON ([Translation].[CodeID] = [Code].[ID])
						WHERE [Translation].[Language] = 'HU'
						AND [Translation].[Text] = @l_contractPhaseText;
					
					IF COALESCE(@l_contractPhaseCode, '') = ''
						SELECT @l_errorMsg = @l_errorMsg +  'The specified contract phase cannot be found.';
				END;
				
				--Státusz mező ellenőrzése
				IF COALESCE(@l_statusText, '') = '' AND COALESCE(@l_statusCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The status is not specified.'
				ELSE 
				BEGIN
					IF COALESCE(@l_statusCode, '') = ''
						SELECT @l_statusCode = [Code].[ID]
						FROM [GEN].[Code] 
						JOIN [GEN].[Translation] ON ([Translation].[CodeID] = [Code].[ID])
						WHERE [Translation].[Language] = 'HU'
						AND [Translation].[Text] = @l_statusText;
					
					IF COALESCE(@l_statusCode, '') = ''
						SELECT @l_errorMsg = @l_errorMsg +  'The specified status cannot be found.';
				END;
			
				--Ha nincs hiba, akkor mehet a feldolgozás tovább
				SELECT @l_objectID = 0;
				SELECT @l_contractID = 0;

				IF COALESCE(@l_errorMsg, '') = ''
				BEGIN
					BEGIN TRY
						--CRM.Contract objektum létrehozása
						INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
						SELECT 'OBJECT_TYPE_CRM_CONTRACT', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
							'ADMIN',
							'CRM.Contract object', '1.0';
					
						SELECT @l_objectID = @@IDENTITY;
				
						--CRM.Contract sor létrehozása
						IF COALESCE(@l_objectID, 0) > 0
						BEGIN
							INSERT INTO [CRM].[Contract] ([ObjectID], [ContractNr], [ContractDate], [SellerName], [SellerPartyID], [BuyerName], [BuyerPartyID], 
								[ReferencedContractID], [ContractTypeCode], [ContractPhaseCode], [StatusCode], 
								[RegistrationNr], [ExternalContractNr], [ValidFrom], [ValidUntil], [DecisionNr], [DataOriginCode],[FinancialMilestoneDate], 
								[CreationDate], [CreationTime], [CreationUserName])
							SELECT @l_objectID, COALESCE(@l_contractNr, CAST(CONCAT('SZE-', FORMAT(GETDATE(), 'yyyyMMdd'), '-', @l_objectID) AS NVARCHAR(200))), @l_contractDate,
								(SELECT [PRT].[GetEntityName]([Party].[EntityID])
								FROM [PRT].[Party] 
								WHERE [Party].[ID] = @l_sellerPartyID), @l_sellerPartyID, 
								(SELECT [PRT].[GetEntityName]([Party].[EntityID])
								FROM [PRT].[Party] 
								WHERE [Party].[ID] = @l_buyerPartyID), @l_buyerPartyID, 
								@l_referencedContractID, @l_contractTypeCode, @l_contractPhaseCode, @l_statusCode,
								@l_registrationNr, @l_externalContractNr, @l_validFrom, @l_validUntil, @l_decisionNr, 'DATA_ORIGIN_SRM',
								@l_contractFinancialMilestoneDate, CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
								'ADMIN';

							SELECT @l_contractID = [Contract].[ID]
							FROM [CRM].[Contract] 
							WHERE [Contract].[ObjectID] = @l_objectID;

							IF COALESCE(@l_contractID, 0) > 0
								INSERT INTO #Contracts ([SourceInterfaceType], [SourceID], [PreparationContractID]) 
								VALUES (@l_sourceInterfaceType, @l_sourceID, @l_contractID);

						END;
					END TRY
					
					BEGIN CATCH
						SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
							' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());
					END CATCH
				END;

				IF COALESCE(@l_errorMsg, '') = ''
					UPDATE [IFC].[Contract] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED',
						[ContractID] = @l_contractID,
						[ErrorMessage] = 'OK',
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] = 'ADMIN'
					WHERE [Contract].[ID] = @l_id
				ELSE 
				BEGIN
					UPDATE [IFC].[Contract] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
						[ErrorMessage] = 'An error occurred. More information please see the detailed log.',
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] =  'ADMIN'
					WHERE [Contract].[ID] = @l_id;
					
					SELECT @l_logMsg = CONCAT('##ERROR: ID: ', @l_id, ' Message: ', @l_errorMsg);

					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),				-- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						'ERROR',					-- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;
				END
			END
			ELSE
				UPDATE [IFC].[Contract] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_IDENTIFIED',
					[ContractID] = @l_contractID,
					[ErrorMessage] = 'Identified by contract number',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] = 'ADMIN'
				WHERE [Contract].[ID] = @l_id;

			FETCH NEXT FROM contract_cursor
			INTO 
				@l_id,
				@l_sellerName,
				@l_sellerPartyID,
				@l_buyerName,
				@l_buyerPartyID,
				@l_referencedContractNr,
				@l_referencedContractID,
				@l_contractTypeCode,
				@l_contractTypeText,
				@l_contractPhaseCode,
				@l_contractPhaseText,
				@l_statusCode,
				@l_statusText,
				@l_contractNr,
				@l_registrationNr,
				@l_externalContractNr,
				@l_decisionNr,
				@l_validFrom,
				@l_validUntil,
				@l_contractDate,
				@l_contractFinancialMilestoneDate,
				@l_sourceID,
				@l_operationCode;
		END

		CLOSE contract_cursor;
		DEALLOCATE contract_cursor;
--===========================================================
--BLOCK: END
--TABLE: IFC.Contract
--===========================================================

--===========================================================
--BLOCK: BEGIN
--TABLE: IFC.ContractItem
--===========================================================
		DECLARE contractItem_cursor CURSOR FOR
		SELECT 
			[ContractItem].[ID],
			[ContractItem].[SequenceNr],
			[ContractItem].[ReferenceNr],
			[ContractItem].[NetValue],
			[ContractItem].[VATValue],
			[ContractItem].[GrossValue],
			[ContractItem].[CurrencyCode],
			[ContractItem].[ProductID],
			[ContractItem].[ProductName],
			[ContractItem].[Description],
			[ContractItem].[StatusCode],
			[ContractItem].[StatusText],
			[ContractItem].[ContractItemID],
			[ContractItem].[SourceID],
			[ContractItem].[SourceContractID],
			[ContractItem].[SourceContractNr],
			[ContractItem].[OperationCode]
		FROM [IFC].[ContractItem]
		WHERE [ContractItem].[SourceInterfaceType] = @l_sourceInterfaceType
			AND [ContractItem].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
		ORDER BY [ContractItem].[ID];
		
		OPEN contractItem_cursor;
		FETCH NEXT FROM contractItem_cursor
		INTO 
			@l_id,
			@l_sequenceNr,
			@l_referenceNr,
			@l_netValue,
			@l_vatValue,
			@l_grossValue,
			@l_currencyCode,
			@l_productID,
			@l_productName,
			@l_description,
			@l_statusCode,
			@l_statusText,
			@l_contractItemID,
			@l_sourceID,
			@l_sourceContractID,
			@l_sourceContractNr,
			@l_operationCode;

		WHILE @@FETCH_STATUS = 0 
		BEGIN
			SELECT @l_errorMsg = '';
			SELECT @l_contractID = NULL;

			--Szerződés ellenőrzése
			IF COALESCE(@l_sourceContractID, '') <> '' 
				SELECT @l_contractID = #Contracts.[PreparationContractID]
				FROM #Contracts
				WHERE #Contracts.[SourceInterfaceType] = @l_sourceInterfaceType
				AND #Contracts.[SourceID] = @l_sourceContractID
				AND #Contracts.[PreparationContractID] IS NOT NULL; 
			
			IF COALESCE(@l_contractID, 0) <> 0 
			BEGIN							
				--Pénznem mező ellenőrzése
				IF COALESCE(@l_currencyCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The currency is not specified.';
				
				--Termék mező ellenőrzése
				/*IF COALESCE(@l_productName, '') = '' AND COALESCE(@l_productID, 0) = 0
					SELECT @l_errorMsg = @l_errorMsg +  'The product is not specified.'
				ELSE 
				BEGIN
					IF COALESCE(@l_productID, 0) = 0 
						SELECT TOP 1 @l_productID = [Product].[ID]
						FROM [FIN].[Product]
						JOIN [GEN].[Translation] ON ([Translation].[CodeID] = [Product].[Code])
						WHERE [Translation].[Text] = @l_productName
						AND [Translation].[CodeID] LIKE 'PRODUCT_%';
				
					IF COALESCE(@l_productID, 0) = 0
						SELECT @l_errorMsg = @l_errorMsg +  'The specified product cannot be found.';
				END;*/
			
				--Státusz mező ellenőrzése
				IF COALESCE(@l_statusCode, '') = '' AND COALESCE(@l_statusText, '') <> ''
				BEGIN
					SELECT @l_statusCode = [Translation].[CodeID]
					FROM [GEN].[Translation]
					WHERE [Translation].[Text] = @l_statusText 
					AND [Translation].[CodeID] LIKE 'STATUS_%';
				
					IF COALESCE(@l_statusCode, '') = ''
						SELECT @l_errorMsg = @l_errorMsg +  'The specified status cannot be found.';
				END;
				
				IF COALESCE(@l_statusCode, '') = '' 
					SELECT @l_statusCode = 'STATUS_NORMAL';
			
				--Ha nincs hiba, akkor mehet a feldolgozás tovább
				SELECT @l_objectID = 0;
				SELECT @l_contractItemID = 0;

				IF COALESCE(@l_errorMsg, '') = ''
				BEGIN
					BEGIN TRY
						--CRM.Contract objektum létrehozása
						INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
						SELECT 'OBJECT_TYPE_CRM_CONTRACTITEM', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
							'ADMIN',
							'CRM.ContractItem object', '1.0';
					
						SELECT @l_objectID = @@IDENTITY;
				
						--CRM.Contract sor létrehozása
						IF COALESCE(@l_objectID, 0) > 0
						BEGIN
							INSERT INTO [CRM].[ContractItem] ([ObjectID], [ContractID], [SequenceNr], [ReferenceNr], [NetValue], [VatValue], [GrossValue], [CurrencyID], 
								[ProductID], [Status], [Description], [CreationDate], [CreationTime], [CreationUserName])
							SELECT @l_objectID, @l_contractID, @l_sequenceNr, @l_referenceNr, @l_netValue, @l_vatValue, @l_grossValue, @l_currencyCode, @l_productID,
								@l_statusCode, @l_description, CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
								'ADMIN';

							SELECT @l_contractItemID = [ContractItem].[ID] 
							FROM [CRM].[ContractItem] 
							WHERE [ContractItem].[ObjectID] = @l_objectID;

							IF COALESCE(@l_contractItemID, 0) > 0 
								INSERT INTO #ContractItems ([SourceInterfaceType], [SourceID], [ContractItemID]) 
								VALUES (@l_sourceInterfaceType, @l_sourceID, @l_contractItemID);
						END;
					END TRY
					BEGIN CATCH
						SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
							' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());
					END CATCH
				END;

				IF COALESCE(@l_errorMsg, '') = ''
					UPDATE [IFC].[ContractItem] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED',
						[ContractItemID] = @l_contractItemID,
						[ErrorMessage] = 'OK',
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] =  'ADMIN'
					WHERE [ContractItem].[ID] = @l_id
				ELSE 
				BEGIN
					UPDATE [IFC].[ContractItem] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
						[ErrorMessage] = 'An error occurred. More information please see the detailed log.',
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] = 'ADMIN'
					WHERE [ContractItem].[ID] = @l_id;
					
					SELECT @l_logMsg = CONCAT('##ERROR: ID: ', @l_id, ' Message: ', @l_errorMsg);

					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),				-- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						'ERROR',					        -- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;
				END
			END
			ELSE
				UPDATE [IFC].[ContractItem] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
					[ErrorMessage] = 'Only new contract items can be loaded',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] =  'ADMIN'
				WHERE [ContractItem].[ID] = @l_id;

			FETCH NEXT FROM contractItem_cursor
			INTO 
				@l_id,
				@l_sequenceNr,
				@l_referenceNr,
				@l_netValue,
				@l_vatValue,
				@l_grossValue,
				@l_currencyCode,
				@l_productID,
				@l_productName,
				@l_description,
				@l_statusCode,
				@l_statusText,
				@l_contractItemID,
				@l_sourceID,
				@l_sourceContractID,
				@l_sourceContractNr,
				@l_operationCode;
		END

		CLOSE contractItem_cursor;
		DEALLOCATE contractItem_cursor;
--===========================================================
--BLOCK: END
--TABLE: IFC.ContractItem
--===========================================================

--===========================================================
--BLOCK: BEGIN
--TABLE: IFC.CollectionContractItem
--===========================================================
		DECLARE collectionContractItem_cursor CURSOR FOR
		SELECT 
			[ID],
			[ObjectID],
			[CurrencyCode],
			[DebtCapital],
			[DebtInterest],
			[DebtPenaltyInterest],
			[DebtCost],
			[DebtCostLocalCurrency],
			[DebtTotal],
			[ConstructionCode],
			[DebtorName],
			[PricingMethodCode],
			[PricingMethodText],
			[BusinessPercent],
			[BusinessPrice],
			[ContractNr],
			[DecisionNr],
			[AccountNr],
			[ContractDate],
			[TerminationDate],
			[FinancialMilestoneDate],
			[LegalActionCode],
			[LegalActionText],
			[CollectionContractItemID],
			[SourceID],
			[SourceContractItemID],
			[OperationCode]
		FROM [IFC].[CollectionContractItem]
		WHERE [CollectionContractItem].[SourceInterfaceType] = @l_sourceInterfaceType
			AND [CollectionContractItem].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
		ORDER BY [CollectionContractItem].[ID];
		
		OPEN collectionContractItem_cursor;
		FETCH NEXT FROM collectionContractItem_cursor
		INTO 
			@l_id,
			@l_objectID,
			@l_currencyCode,
			@l_debtCapital,
			@l_debtInterest,
			@l_debtPenaltyInterest,
			@l_debtCost,
			@l_debtCostLocalCurrency,
			@l_debtTotal,
			@l_constructionCode,
			@l_debtorName,
			@l_pricingMethodCode,
			@l_pricingMethodText,
			@l_businessPercent,
			@l_businessPrice,
			@l_contractNr,
			@l_decisionNr,
			@l_accountNr,
			@l_contractDate,
			@l_terminationDate,
			@l_financialMilestoneDate,
			@l_legalActionCode,
			@l_legalActionText,
			@l_collectionContractItemID,
			@l_sourceID,
			@l_sourceContractItemID,	
			@l_operationCode;

		WHILE @@FETCH_STATUS = 0 
		BEGIN
			SELECT @l_errorMsg = '';
			SELECT @l_contractItemID = NULL;

			--Szerződés tétel ellenőrzése
			IF COALESCE(@l_sourceContractItemID, '') <> '' 
				SELECT @l_contractItemID = #ContractItems.[ContractItemID]
				FROM #ContractItems
				WHERE #ContractItems.[SourceInterfaceType] = @l_sourceInterfaceType
				AND #ContractItems.[SourceID] = @l_sourceContractItemID
				AND #ContractItems.[ContractItemID] IS NOT NULL; 
			
			IF COALESCE(@l_contractItemID, 0) > 0 
			BEGIN							
				--Pénznem mező ellenőrzése
				IF COALESCE(@l_currencyCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The currency is not specified.';
					
				--Konstrukctiós kód mező ellenőrzése
				IF COALESCE(@l_constructionCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The construction code is not specified.';
					
				--Adós mező ellenőrzése
				IF COALESCE(@l_debtorName, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The debtor is not specified.';
					
				--Szerződés mező ellenőrzése
				/*IF COALESCE(@l_contractNr, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The contract number is not specified.';*/
					
				--Szerződés dátum mező ellenőrzése
				IF COALESCE(@l_contractDate, '') = '1900-01-01'
					SELECT @l_errorMsg = @l_errorMsg +  'The contract date is not specified.';
					
				--Fizetési mód mező ellenőrzése
				/*IF COALESCE(@l_pricingMethodText, '') = '' AND COALESCE(@l_pricingMethodCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The pricing method is not specified.'
				ELSE 
				BEGIN
					IF COALESCE(@l_pricingMethodCode, '') = ''
						SELECT @l_pricingMethodCode = [Code].[ID]
						FROM [GEN].[Code] 
						JOIN [GEN].[Translation] ON ([Translation].[CodeID] = [Code].[ID])
						WHERE [Translation].[Language] = 'HU'
						AND [Translation].[CodeID] LIKE 'PRICING_METHOD_%'
						AND [Translation].[Text] = @l_pricingMethodText;
					
					IF COALESCE(@l_pricingMethodCode, '') = ''
						SELECT @l_errorMsg = @l_errorMsg +  'The specified pricing method cannot be found.';
				END;*/
				
				--Jogi esemény mező ellenőrzése
				/*IF COALESCE(@l_legalActionText, '') = '' AND COALESCE(@l_legalActionCode, '') = ''
					SELECT @l_errorMsg = @l_errorMsg +  'The legal action is not specified.'
				ELSE 
				BEGIN
					IF COALESCE(@l_legalActionCode, '') = ''
						SELECT @l_legalActionCode = [Code].[ID]
						FROM [GEN].[Code] 
						JOIN [GEN].[Translation] ON ([Translation].[CodeID] = [Code].[ID])
						WHERE [Translation].[Language] = 'HU'
						AND [Translation].[CodeID] LIKE 'LEGAL_ACTION_%'
						AND [Translation].[Text] = @l_legalActionText;
					
					IF COALESCE(@l_pricingMethodCode, '') = ''
						SELECT @l_errorMsg = @l_errorMsg +  'The specified legal action cannot be found.';
				END;*/
			
				--Ha nincs hiba, akkor mehet a feldolgozás tovább
				SELECT @l_objectID = 0;
				SELECT @l_collectionContractItemID = 0;

				IF COALESCE(@l_errorMsg, '') = ''
				BEGIN
					BEGIN TRY
						--CRM.CollectionContractItem objektum létrehozása
						INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
						SELECT 'OBJECT_TYPE_CRM_COLLECTIONCONTRACTITEM', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
							'ADMIN',
							'CRM.CollectionContractItem object', '1.0';
					
						SELECT @l_objectID = @@IDENTITY;
				
						--CRM.Contract sor létrehozása
						IF COALESCE(@l_objectID, 0) > 0 
						BEGIN
							INSERT INTO [CRM].[CollectionContractItem] ([ObjectID], [ContractItemID], [DebtCapital], [DebtInterest], [DebtPenaltyInterest], 
								[DebtCost], [DebtCostLocalCurrency], [DebtTotal], [ConstructionCode], [DebtorName], [PricingMethodID], [BusinessPercent], 
								[BusinessPrice], [ContractNr], [DecisionNr], [AccountNr], [ContractDate], [TerminationDate], [FinancialMilestoneDate], 
								[CurrencyCode], [LegalActionCode], [DaysPastDue], [SourceInterfaceType], [SourceID],   
								[CreationDate], [CreationTime], [CreationUserName])
							SELECT @l_objectID, @l_contractItemID, @l_debtCapital, @l_debtInterest, @l_debtPenaltyInterest, @l_debtCost, 
								@l_debtCostLocalCurrency, @l_debtTotal, @l_constructionCode, @l_debtorName, @l_pricingMethodCode, @l_businessPercent,
								@l_businessPrice, @l_contractNr, @l_decisionNr, @l_accountNr, @l_contractDate, @l_terminationDate, @l_financialMilestoneDate, 
								@l_currencyCode, @l_legalActionCode, NULL, @l_sourceInterfaceType, @l_sourceID,
								CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
								'ADMIN';

							SELECT @l_collectionContractItemID = [CollectionContractItem].[ID]
							FROM [CRM].[CollectionContractItem] 
							WHERE [CollectionContractItem].[ObjectID] = @l_objectID;
						END;
					END TRY
					BEGIN CATCH
						SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
							' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());
					END CATCH
				END;

				IF COALESCE(@l_errorMsg, '') = ''
					UPDATE [IFC].[CollectionContractItem] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED',
						[CollectionContractItemID] = @l_collectionContractItemID,
						[ErrorMessage] = 'OK',
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] =  'ADMIN'
					WHERE [CollectionContractItem].[ID] = @l_id
				ELSE 
				BEGIN
					UPDATE [IFC].[CollectionContractItem] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
						[ErrorMessage] = 'An error occurred. More information please see the detailed log.',
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] =  'ADMIN'
					WHERE [CollectionContractItem].[ID] = @l_id;
					
					SELECT @l_logMsg = CONCAT('##ERROR: ID: ', @l_id, ' Message: ', @l_errorMsg);

					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),				-- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						'ERROR',					        -- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;
				END
			END
			ELSE
				UPDATE [IFC].[CollectionContractItem] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
					[ErrorMessage] = 'Only new contract items can be loaded',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] =  'ADMIN'
				WHERE [CollectionContractItem].[ID] = @l_id;

			FETCH NEXT FROM collectionContractItem_cursor
			INTO 
				@l_id,
				@l_objectID,
				@l_currencyCode,
				@l_debtCapital,
				@l_debtInterest,
				@l_debtPenaltyInterest,
				@l_debtCost,
				@l_debtCostLocalCurrency,
				@l_debtTotal,
				@l_constructionCode,
				@l_debtorName,
				@l_pricingMethodCode,
				@l_pricingMethodText,
				@l_businessPercent,
				@l_businessPrice,
				@l_contractNr,
				@l_decisionNr,
				@l_accountNr,
				@l_contractDate,
				@l_terminationDate,
				@l_financialMilestoneDate,
				@l_legalActionCode,
				@l_legalActionText,
				@l_collectionContractItemID,
				@l_sourceID,
				@l_sourceContractItemID,	
				@l_operationCode;
		END

		CLOSE collectionContractItem_cursor;
		DEALLOCATE collectionContractItem_cursor;
--===========================================================
--BLOCK: END
--TABLE: IFC.CollectionContractItem
--===========================================================

--===========================================================
--BLOCK: BEGIN
--TABLE: IFC.CollectionContractSummary
--===========================================================
		DECLARE collectionContractSummary_cursor CURSOR FOR
		SELECT 
			[ID],
			[ObjectID],
			[CurrencyCode],
			[ItemCount],
			[DebtCapital],
			[DebtInterest],
			[DebtPenaltyInterest],
			[DebtCost],
			[DebtCostLocalCurrency],
			[DebtTotal],
			[PurchasePrice],
			[PurchasePriceCurrencyCode],
			[CollectionContractSummaryID],
			[SourceID],
			[SourceContractID],
			[OperationCode]
		FROM [IFC].[CollectionContractSummary]
		WHERE [CollectionContractSummary].[SourceInterfaceType] = @l_sourceInterfaceType
			AND [CollectionContractSummary].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
		ORDER BY [CollectionContractSummary].[ID];
		
		OPEN collectionContractSummary_cursor;
		FETCH NEXT FROM collectionContractSummary_cursor
		INTO 
			@l_id,
			@l_objectID,
			@l_currencyCode,
			@l_itemCount,
			@l_debtCapital,
			@l_debtInterest,
			@l_debtPenaltyInterest,
			@l_debtCost,
			@l_debtCostLocalCurrency,
			@l_debtTotal,
			@l_purchasePrice,
			@l_purchasePriceCurrencyCode,
			@l_collectionContractSummaryID,
			@l_sourceID,
			@l_sourceContractID,
			@l_operationCode;

		WHILE @@FETCH_STATUS = 0 
		BEGIN
			SELECT @l_errorMsg = '';
			SELECT @l_contractID = NULL;

			--Szerződés ellenőrzése
			IF COALESCE(@l_sourceContractID, '') <> '' 
				SELECT @l_contractID = #Contracts.[PreparationContractID]
				FROM #Contracts
				WHERE #Contracts.[SourceInterfaceType] = @l_sourceInterfaceType
				AND #Contracts.[SourceID] = @l_sourceContractID
				AND #Contracts.[PreparationContractID] IS NOT NULL; 
			
			IF COALESCE(@l_contractID, 0) <> 0 
			BEGIN										
				--Ha nincs hiba, akkor mehet a feldolgozás tovább
				SELECT @l_objectID = 0;
				SELECT @l_collectionContractSummaryID = 0;

				IF COALESCE(@l_errorMsg, '') = ''
				BEGIN
					BEGIN TRY
						--CRM.CollectionContractItem objektum létrehozása
						INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
						SELECT 'OBJECT_TYPE_CRM_COLLECTIONCONTRACTSUMMARY', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
							'ADMIN',
							'CRM.CollectionContractSummary object', '1.0';
					
						SELECT @l_objectID = @@IDENTITY;
				
						--CRM.Contract sor létrehozása
						IF COALESCE(@l_objectID, 0) > 0 
						BEGIN
							INSERT INTO [CRM].[CollectionContractSummary] ([ObjectID], [ContractID], [CurrencyCode], [ItemCount], 
								[DebtCapital], [DebtInterest], [DebtPenaltyInterest], [DebtCost], [DebtCostLocalCurrency], [DebtTotal], 
								[PurchasePrice], [PurchasePriceCurrencyCode], [CreationDate], [CreationTime], [CreationUserName])
							SELECT @l_objectID, @l_contractID, @l_currencyCode, @l_itemCount, 
								@l_debtCapital, @l_debtInterest, @l_debtPenaltyInterest, @l_debtCost, @l_debtCostLocalCurrency, @l_debtTotal, 
								@l_purchasePrice, @l_purchasePriceCurrencyCode,	CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
								'ADMIN';

							SELECT @l_collectionContractSummaryID = [CollectionContractSummary].[ID] 
							FROM [CRM].[CollectionContractSummary] 
							WHERE [CollectionContractSummary].[ObjectID] = @l_objectID;
						END;
					END TRY
					BEGIN CATCH
						SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
							' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());
					END CATCH
				END;

				IF COALESCE(@l_errorMsg, '') = ''
					UPDATE [IFC].[CollectionContractSummary] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED',
						[CollectionContractSummaryID] = @l_collectionContractSummaryID,
						[ErrorMessage] = 'OK',
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] =  'ADMIN'
					WHERE [CollectionContractSummary].[ID] = @l_id
				ELSE 
				BEGIN
					UPDATE [IFC].[CollectionContractSummary] SET 
						[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
						[ErrorMessage] = 'An error occurred. More information please see the detailed log.',
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CAST(GETDATE() AS Time),
						[LastModifiedUserName] =  'ADMIN'
					WHERE [CollectionContractSummary].[ID] = @l_id;
					
					SELECT @l_logMsg = CONCAT('##ERROR: ID: ', @l_id, ' Message: ', @l_errorMsg);

					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),				-- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						'ERROR',					        -- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;
				END
			END
			ELSE
				UPDATE [IFC].[CollectionContractSummary] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
					[ErrorMessage] = 'Only new contract items can be loaded',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] ='ADMIN'
				WHERE [CollectionContractSummary].[ID] = @l_id;

			FETCH NEXT FROM collectionContractSummary_cursor
			INTO 
				@l_id,
				@l_objectID,
				@l_currencyCode,
				@l_itemCount,
				@l_debtCapital,
				@l_debtInterest,
				@l_debtPenaltyInterest,
				@l_debtCost,
				@l_debtCostLocalCurrency,
				@l_debtTotal,
				@l_purchasePrice,
				@l_purchasePriceCurrencyCode,
				@l_collectionContractSummaryID,
				@l_sourceID,
				@l_sourceContractID,
				@l_operationCode;
		END

		CLOSE collectionContractSummary_cursor;
		DEALLOCATE collectionContractSummary_cursor;
--===========================================================
--BLOCK: END
--TABLE: IFC.CollectionContractSummary
--===========================================================

--===========================================================
--BLOCK: BEGIN
--TABLE: CRM.ContractSigner
--===========================================================		
		DECLARE contractSigner_cursor CURSOR FOR
		SELECT #Contracts.[PreparationContractID]
		FROM #Contracts 
		WHERE #Contracts.[PreparationContractID] IS NOT NULL
		ORDER BY #Contracts.[PreparationContractID];

		OPEN contractSigner_cursor;
		FETCH NEXT FROM contractSigner_cursor
		INTO 
			@l_id;

		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT @l_contractID = NULL;

			SELECT @l_contractID = [Contract].[ID]
			FROM [CRM].[Contract] 
			WHERE [Contract].[ID] = @l_id;

			IF COALESCE(@l_contractID, 0) > 0
			BEGIN
				--ContractSigner object
				SELECT @l_objectID = 0;
				SELECT @l_contractSignerID = 0;

				INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
				SELECT 'OBJECT_TYPE_CRM_CONTRACTSIGNER', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
					'ADMIN',
					'CRM.ContractSigner object', '1.0';

				SELECT @l_objectID = @@IDENTITY;

				IF COALESCE(@l_objectID, 0) > 0 
				BEGIN
					INSERT INTO [CRM].[ContractSigner] ([ObjectID], [ContractID], [EntityID], [SignMethod], [SignDate], [SignTime], 
						[CreationDate], [CreationTime], [CreationUserName])
					SELECT @l_objectID, @l_contractID, (SELECT [AppUser].[EntityID] FROM [PRT].[AppUser] WHERE [AppUser].[UserName] = 'ADMIN'),
						CAST('CONTRACT_SIGN_METHOD_AUTOMATIC' AS NVARCHAR(200)), CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
						CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 'ADMIN';

					SELECT @l_contractSignerID = [ContractSigner].[ID] 
					FROM [CRM].[ContractSigner] 
					WHERE [ContractSigner].[ObjectID] = @l_objectID;
				END;

				IF COALESCE(@l_contractSignerID, 0) > 0
				BEGIN
					UPDATE [CRM].[Contract] SET 
						[ValidFrom] = CAST(GETDATE() AS Date) 
					WHERE [Contract].[ID] = @l_contractID;

					SELECT @l_logMsg = CONCAT('The signing of the contract preparation is successful. Contract signer identifier: ', @l_contractSignerID);
					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
						SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),				-- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						'INFO',					        -- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;				    -- LogMessage
				END;
			END
			ELSE
			BEGIN
				SELECT @l_logMsg = CONCAT('The signing of the contract preparation is failed, because the contract is not found with ', @l_id, ' identifier.');
				INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
					CAST( GETDATE() AS Date ),	-- LogDate,	
					CAST( GETDATE() AS Time ),	-- LogTime,
					SUSER_SNAME(),				-- UserName
					@p_CorrelationID,			-- CorrelationID
					'INDECS 3.0',			    -- ApplicationName
					DB_NAME(),					-- Environment
					'BACKEND',					-- Layer
					@l_procedureName,   		-- ServiceName
					'1.0',						-- ServiceVersion
					'INFO',					        -- SeverityLevel
					NULL,						-- MessageCategory
					@l_logMsg;				    -- LogMessage
			END;

			FETCH NEXT FROM contractSigner_cursor
			INTO 
				@l_id;
		END;

		CLOSE contractSigner_cursor;
		DEALLOCATE contractSigner_cursor;

--===========================================================
--BLOCK: END
--TABLE: CRM.ContractSigner
--===========================================================

--===========================================================
--BLOCK: BEGIN
--TABLE: CRM.CopyContract
--===========================================================		
		--Szerződés betöltés esetén csak a szerződés előkészítés (CONTRACT_PHASE_PREPARATION) fázisú
		--szerződésekből készítünk másolatot. (SRM folyamat)
		DECLARE copyContract_cursor CURSOR FOR
		SELECT #Contracts.[PreparationContractID] 
		FROM #Contracts 
		WHERE #Contracts.[PreparationContractID] IS NOT NULL
		ORDER BY #Contracts.[PreparationContractID];

		OPEN copyContract_cursor;
		FETCH NEXT FROM copyContract_cursor
		INTO 
			@l_id;

		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT @l_contractID = NULL;
			SELECT @l_liveContractContractNr = NULL;

			SELECT @l_contractID = [Contract].[ID]
			FROM [CRM].[Contract] 
			WHERE [Contract].[ID] = @l_id;

			IF COALESCE(@l_contractID, 0) > 0
			BEGIN
				--Szerződés előkészítés lezárása
				UPDATE [CRM].[Contract] SET 
					[StatusCode] = 'CONTRACT_STATUS_PREPARATION_VALID'
				WHERE [Contract].[ID] = @l_contractID;

				SELECT @l_liveContractNr = CAST(CONCAT('SZ-', FORMAT(GETDATE(), 'yyyyMMdd-HHMMss')) AS NVARCHAR(200));
				SELECT @l_liveContractPhase = CAST('CONTRACT_PHASE_CONTRACT' AS NVARCHAR(200));
				SELECT @l_liveContractStatus = CAST('CONTRACT_STATUS_CONTRACT_VALID' AS NVARCHAR(200));

				SELECT @l_sqlStatement = 
					'[CRM].[CopyContract] @l_thisContractID, @l_thisContractNr, @l_thisContractPhase, @l_thisContractStatus, @l_thisCopyContractItems, @New_ContractID=@l_thisNewContractIDOUT OUTPUT';;
				SELECT @l_params = 
					N'@l_thisContractID NUMERIC(16), @l_thisContractNr NVARCHAR(200), @l_thisContractPhase NVARCHAR(200), @l_thisContractStatus NVARCHAR(200), @l_thisCopyContractItems BIT, @l_thisNewContractIDOUT NUMERIC(16) OUTPUT';
			
				EXECUTE sp_executesql @l_sqlStatement, 
					@l_params, 
					@l_thisContractID = @l_contractID,  
					@l_thisContractNr = @l_liveContractNr, 
					@l_thisContractPhase = @l_liveContractPhase, 
					@l_thisContractStatus = @l_liveContractStatus, 
					@l_thisCopyContractItems = @l_copyContractItems,
					@l_thisNewContractIDOUT = @l_liveContractID OUTPUT;

				IF COALESCE(@l_liveContractID, 0) > 0
				BEGIN
					UPDATE #Contracts SET 
						[LiveContractID] = @l_liveContractID
					WHERE #Contracts.[PreparationContractID] = @l_id;

					EXECUTE [CRM].[GenerateContractNr] 
						@l_liveContractID,
						'BOOLEAN_TRUE',
						@l_liveContractContractNr OUTPUT;

					UPDATE [CRM].[Contract] SET 
						[ContractNr] = @l_liveContractContractNr 
					WHERE [Contract].[ID] = @l_liveContractID;

					SELECT @l_logMsg = CONCAT(
						'Based on contract preparation, the live contract was completed. Contract identifier: ', @l_liveContractID, 
						' Contract nr.: ', @l_liveContractContractNr)
				END
				ELSE
					SELECT @l_logMsg = 'Based on the contract preparation, the live contract was not completed.'
		
				INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
				SELECT 
					CAST( GETDATE() AS Date ),	-- LogDate,	
					CAST( GETDATE() AS Time ),	-- LogTime,
					SUSER_SNAME(),				-- UserName
					@p_CorrelationID,			-- CorrelationID
					'INDECS 3.0',			    -- ApplicationName
					DB_NAME(),					-- Environment
					'BACKEND',					-- Layer
					@l_procedureName,   		-- ServiceName
					'1.0',						-- ServiceVersion
					'INFO',					        -- SeverityLevel
					NULL,						-- MessageCategory
					@l_logMsg;				    -- LogMessage

			END
			ELSE 
			BEGIN
				SELECT @l_logMsg = CONCAT('The copying of the contract preparation is failed, because the contract is not found with ', @l_id, ' identifier.');
				INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
					CAST( GETDATE() AS Date ),	-- LogDate,	
					CAST( GETDATE() AS Time ),	-- LogTime,
					SUSER_SNAME(),				-- UserName
					@p_CorrelationID,			-- CorrelationID
					'INDECS 3.0',			    -- ApplicationName
					DB_NAME(),					-- Environment
					'BACKEND',					-- Layer
					@l_procedureName,   		-- ServiceName
					'1.0',						-- ServiceVersion
					'INFO',					        -- SeverityLevel
					NULL,						-- MessageCategory
					@l_logMsg;				    -- LogMessage
			END;

			FETCH NEXT FROM copyContract_cursor
			INTO 
				@l_id;
		END;

		CLOSE copyContract_cursor;
		DEALLOCATE copyContract_cursor;

--===========================================================
--BLOCK: END
--TABLE: CRM.CopyContract
--===========================================================

--===========================================================
--BLOCK: BEGIN
--TABLE: COM.Interaction
--===========================================================		
		DECLARE interaction_cursor CURSOR FOR
		SELECT #Contracts.[LiveContractID] 
		FROM #Contracts 
		WHERE #Contracts.[LiveContractID] IS NOT NULL
		ORDER BY #Contracts.[LiveContractID];

		OPEN interaction_cursor;
		FETCH NEXT FROM interaction_cursor
		INTO 
			@l_id;

		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT @l_contractID = NULL;

			SELECT @l_contractID = [Contract].[ID]
			FROM [CRM].[Contract] 
			WHERE [Contract].[ID] = @l_id;

			IF COALESCE(@l_contractID, 0) > 0
			BEGIN
				SELECT @l_sqlStatement = '[COM].[GenerateContractInteraction] @l_thisCorrelationID, @l_thisContractID, @p_interactionID=@l_thisInteractionIDOUT OUTPUT';
				SELECT @l_params = N'@l_thisCorrelationID NVARCHAR(200), @l_thisContractID NUMERIC(16), @l_thisInteractionIDOUT NUMERIC(16) OUTPUT';
				EXECUTE sp_executesql 
					@l_sqlStatement, 
					@l_params, 
					@l_thisCorrelationID = @p_correlationID, 
					@l_thisContractID = @l_contractID, 
					@l_thisInteractionIDOUT=@l_interactionID OUTPUT;

				IF COALESCE(@l_interactionID, 0) > 0
					UPDATE #Contracts SET 
						[InteractionID] = @l_interactionID
					WHERE #Contracts.[LiveContractID] = @l_id;
				ELSE
				BEGIN
					SELECT @l_logMsg = CONCAT('The contract interaction was not created. Contract identifier: ', @l_liveContractID);
					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),				-- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						'INFO',					        -- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;				    -- LogMessage
				END;
			END;

			FETCH NEXT FROM interaction_cursor
			INTO 
				@l_id;
		END;

		CLOSE interaction_cursor;
		DEALLOCATE interaction_cursor;

--===========================================================
--BLOCK: END
--TABLE: COM.Interaction
--===========================================================

--===========================================================
--BLOCK: BEGIN
--TABLE: ORG.ModuleInstance
--===========================================================		
		DECLARE moduleInstance_cursor CURSOR FOR
		SELECT #Contracts.[InteractionID] 
		FROM #Contracts 
		WHERE #Contracts.[InteractionID] IS NOT NULL
		ORDER BY #Contracts.[InteractionID];

		OPEN moduleInstance_cursor;
		FETCH NEXT FROM moduleInstance_cursor
		INTO 
			@l_id;

		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT @l_interactionID = NULL;

			SELECT @l_interactionID = [Interaction].[ID]
			FROM [COM].[Interaction] 
			WHERE [Interaction].[ID] = @l_id;
		
			IF COALESCE(@l_interactionID, 0) > 0
			BEGIN
				--Dokumentum generáló (MODULE_INTERACTION_DOCUMENT_GENERATOR) modul példányosítás
				INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
				SELECT 'OBJECT_TYPE_ORG_MODULEINSTANCE', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
					'ADMIN',
					'ORG.ModuleInstance object', '1.0';

				SELECT @l_objectID = @@IDENTITY;
		
				INSERT INTO [ORG].[ModuleInstance] ([ObjectID], [ModuleID], [StatusCode], [CorrelationID], 
					[CreationDate], [CreationTime], [CreationUserName])
				SELECT @l_objectID, [Module].[ID], CAST('MODULE_INSTANCE_STATUS_PREPARATION' AS NVARCHAR(200)), @p_correlationID, 
					CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
					'ADMIN'
				FROM [ORG].[Module]
				WHERE [Module].[ModuleCode] = 'MODULE_INTERACTION_DOCUMENT_GENERATOR';
		
				SELECT @l_moduleInstanceID = @@IDENTITY;
		
				--Dokumentum generáló modul példány paramétereinek beállítása
				INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
				SELECT 'OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
					'ADMIN',
					'ORG.ModuleInstanceParameter object', '1.0';

				SELECT @l_objectID = @@IDENTITY;
		
				INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterID], 
					[CreationDate], [CreationTime], [CreationUserName])
				SELECT @l_objectID, @l_moduleInstanceID, CAST('MODULE_PARAMETER_INTERACTION_ID' AS NVARCHAR(200)), @l_interactionID,
					CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
					'ADMIN';
		
				--Dokumentum generáló modul példány indítása
				UPDATE [ORG].[ModuleInstance] SET
					[ScheduleDate] = CAST(GETDATE() AS Date),
					[ScheduleTime] = CAST(GETDATE() AS Time),
					[StatusCode] = 'MODULE_INSTANCE_STATUS_READY_TO_RUN'
				WHERE [ModuleInstance].[ID] = @l_moduleInstanceID;

				SELECT @l_moduleInstanceStartDateTime = GETDATE();
		
				SELECT @l_logMsg = CONCAT('The identifier of generated module instance: ', @l_moduleInstanceID);
				INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
				SELECT 
					CAST( GETDATE() AS Date ),	-- LogDate,	
					CAST( GETDATE() AS Time ),	-- LogTime,
					SUSER_SNAME(),				-- UserName
					@p_CorrelationID,			-- CorrelationID
					'INDECS 3.0',			    -- ApplicationName
					DB_NAME(),					-- Environment
					'BACKEND',					-- Layer
					@l_procedureName,   		-- ServiceName
					'1.0',						-- ServiceVersion
					'INFO',					        -- SeverityLevel
					NULL,						-- MessageCategory
					@l_logMsg;				    -- LogMessage
			END

			FETCH NEXT FROM moduleInstance_cursor
			INTO 
				@l_id;
		END;

		CLOSE moduleInstance_cursor;
		DEALLOCATE moduleInstance_cursor;

--===========================================================
--BLOCK: END
--TABLE: ORG.ModuleInstance
--===========================================================

		IF OBJECT_ID('tempdb..#Contracts', 'U') IS NOT NULL
			DROP TABLE #Contracts;

		IF OBJECT_ID('tempdb..#ContractItems', 'U') IS NOT NULL
			DROP TABLE #ContractItems;

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;

		RETURN 1;
	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'contract_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE contract_cursor;

			DEALLOCATE contract_cursor;
		END;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'contract_summary_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE contract_summary_cursor;

			DEALLOCATE contract_summary_cursor;
		END;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'contractItem_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE contractItem_cursor;

			DEALLOCATE contractItem_cursor;
		END;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'collectionContractItem_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE collectionContractItem_cursor;

			DEALLOCATE collectionContractItem_cursor;
		END;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'collectionContractSummary_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE collectionContractSummary_cursor;

			DEALLOCATE collectionContractSummary_cursor;
		END;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'contractSigner_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE contractSigner_cursor;

			DEALLOCATE contractSigner_cursor;
		END;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'copyContract_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE copyContract_cursor;

			DEALLOCATE copyContract_cursor;
		END;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'interaction_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE interaction_cursor;

			DEALLOCATE interaction_cursor;
		END;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'moduleInstance_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE moduleInstance_cursor;

			DEALLOCATE moduleInstance_cursor;
		END;

		IF OBJECT_ID('tempdb..#Contracts', 'U') IS NOT NULL
			DROP TABLE #Contracts;

		IF OBJECT_ID('tempdb..#ContractItems', 'U') IS NOT NULL
			DROP TABLE #ContractItems;

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					-- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage

		RETURN 99;
	END CATCH
END
go

-- =============================================
/*
	Author:		Gábor TÓTH
	Create date: 2022-11-08
	Last modified date: 2022-11-08
						2022-11-22: Errormessage concat javítás: Isnull(@l_errorMsg,'') (T.G.)
						2022-11-22: @l_GrossValueCurrencyCode, @l_ConstructionCode,  (T.G.)
						2022-11-22: Currency, GrossValueCurrency kiegészítése, ha szükséges (T.G.)
						2022-11-23: FETCH NEXT FROM collectionContractItems_cursor
						2022-11-25: RETURN 1, RETURN 99 helyett Select 1, Select 99
						2022-11-25: @l_ErrorExists ( Nem volt hiba: 1, Volt hiba: 99 )
						2022-11-28: Kivéve: collectionContractItems_cursor, ProductName visszatéve
						2022-12-06: ProductName visszatéve
						2023-01-16: Túl hosszú hiba üzenetek kezelése
						2023-01-25: ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE'
*/
-- =============================================
CREATE   PROCEDURE [IFC].[ContractPreparationItemLoader] 
	-- Add the parameters for the stored procedure here
	@p_correlationID NVARCHAR(200), 
	@p_moduleInstanceID NUMERIC(16)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'IFC.ContractPreparationItemLoader'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_contractID NUMERIC(16) = NULL;
	DECLARE @l_contractItemID NUMERIC(16) = NULL;
	--DECLARE @l_productID NUMERIC(16) = NULL;
	DECLARE @l_productID Nvarchar(200) = NULL;

	DECLARE @l_objectID NUMERIC(16) = NULL;
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--Az IFC.ContractPreparationItem változói
	DECLARE @l_id NUMERIC(16) = NULL;
	DECLARE @l_sequenceNr NUMERIC(16) = NULL;
	DECLARE @l_debtorName NVARCHAR(250) = NULL;
	DECLARE @l_accountNr NVARCHAR(200) = NULL;
	DECLARE @l_grossValue MONEY = NULL;
	DECLARE @l_currencyCode NVARCHAR(200) = NULL;
	DECLARE @l_debtCapital MONEY = NULL;
	DECLARE @l_debtTotal MONEY = NULL;
	DECLARE @l_debtInterest MONEY;
	DECLARE @l_debtPenaltyInterest MONEY = NULL;
	DECLARE @l_debtCost MONEY = NULL;
	DECLARE @l_debtCurrencyCode NVARCHAR(200) = NULL;
	DECLARE @l_debtCostLocalCurrency MONEY = NULL;
	DECLARE @l_productName NVARCHAR(200) = NULL;
	DECLARE @l_contractNr NVARCHAR(200) = NULL;
	DECLARE @l_contractDate DATE = NULL;
	DECLARE @l_terminationDate DATE = NULL;
	DECLARE @l_decisionNr NVARCHAR(200) = NULL;
	DECLARE @l_financialMilestoneDate DATE = NULL;
	DECLARE @l_GrossValueCurrencyCode NVARCHAR(200) = NULL;
	DECLARE @l_ConstructionCode NVARCHAR(200) = NULL;
	DECLARE @LoadedRecordNr numeric(16);
	DECLARE @l_itemCount NUMERIC(16) = NULL;

	Declare @l_ErrorExists int; /* Nem volt hiba: 1, Volt hiba: 99 */

	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);
		Set @l_ErrorExists = 1;

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			--AND ModuleInstanceParameter.ParameterCode = 'SOURCE_INTERFACE_TYPE';
			and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END

		/* 2022-11-21
		IF COALESCE(@l_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);
		*/

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		DECLARE preparationItem_cursor CURSOR FOR
		SELECT 
			ID, SequenceNr,	DebtorName,	AccountNr, GrossValue, CurrencyCode, DebtCapital, DebtTotal,
			DebtInterest, DebtPenaltyInterest, DebtCost, DebtCostLocalCurrency, ProductName, ContractNr,
			ContractDate, TerminationDate, DecisionNr, FinancialMilestoneDate,	GrossValueCurrencyCode, ConstructionCode
		FROM IFC.ContractPreparationItem
		WHERE 
			ContractPreparationItem.InterfaceStatusCode = 'INTERFACE_STATUS_NEW'
		ORDER BY ContractPreparationItem.ID;
		
		OPEN preparationItem_cursor;
		FETCH NEXT FROM preparationItem_cursor
		INTO 
			@l_id, @l_sequenceNr, @l_debtorName, @l_accountNr, @l_grossValue, @l_currencyCode, 
			@l_debtCapital, @l_debtTotal, @l_debtInterest, @l_debtPenaltyInterest, @l_debtCost,  
			@l_debtCostLocalCurrency, @l_productName, @l_contractNr, @l_contractDate,
			@l_terminationDate, @l_decisionNr, @l_financialMilestoneDate, @l_GrossValueCurrencyCode, @l_ConstructionCode;

		WHILE @@FETCH_STATUS = 0 
		BEGIN
			Set @l_errorMsg = NULL;

			IF COALESCE(@l_contractNr, '') = ''
				SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The ContractNr field is empty.');
			ELSE 
				SELECT @l_contractID = [Contract].[ID]
				FROM [CRM].[Contract]
				WHERE [Contract].[ContractNr] = @l_contractNr 
				AND [Contract].[ContractPhaseCode] = 'CONTRACT_PHASE_PREPARATION';

-- Currency:
			IF COALESCE(@l_debtTotal, 0) = 0
				SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The DebtTotal field is empty.');

			IF COALESCE(@l_currencyCode, '') = ''
				SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The CurrencyCode field is empty.');

			IF exists (select 1 from GEN.Translation where CodeID Like 'CURRENCY_%' and text = @l_currencyCode)
				SET @l_currencyCode = (select CodeID from GEN.Translation where CodeID like 'CURRENCY_%' and text = @l_currencyCode);

			IF COALESCE(@l_currencyCode, '') <> '' and @l_currencyCode like 'CURRENCY_%'
				and not exists (select 1 from GEN.Code where ID = @l_currencyCode)
				SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The CurrencyCode is not registered.');

			IF COALESCE(@l_currencyCode, '') <> '' and @l_currencyCode not like 'CURRENCY_%'
				and not exists (select 1 from GEN.Code where ID = 'CURRENCY_' + @l_currencyCode)
				SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The CurrencyCode is not registered.');


-- GrossValueCurrency:
			IF COALESCE(@l_grossValue, 0) = 0
				SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The GrossValue field is empty.');

			IF COALESCE(@l_GrossValueCurrencyCode, '') = ''
				SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The GrossValue CurrencyCode field is empty.');


			IF exists (select 1 from GEN.Translation where CodeID Like 'CURRENCY_%' and text = @l_GrossValueCurrencyCode)
				SET @l_GrossValueCurrencyCode = (select CodeID from GEN.Translation where CodeID like 'CURRENCY_%' and text = @l_GrossValueCurrencyCode);

			IF COALESCE(@l_GrossValueCurrencyCode, '') <> '' and @l_GrossValueCurrencyCode like 'CURRENCY_%'
				and not exists (select 1 from GEN.Code where ID = @l_GrossValueCurrencyCode)
				SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The GrossValue CurrencyCode is not registered.');

			IF COALESCE(@l_GrossValueCurrencyCode, '') <> '' and @l_GrossValueCurrencyCode not like 'CURRENCY_%'
				and not exists (select 1 from GEN.Code where ID = 'CURRENCY_' + @l_GrossValueCurrencyCode)
				SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The GrossValue CurrencyCode is not registered.');


-- Productname:
/*
			Set @l_productID = '';
			IF COALESCE(@l_productName, '') = ''
				SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The ProductName field is empty.');
			ELSE 
				BEGIN
					If not exists (select 1 from GEN.Translation WHERE CodeID like 'CREDIT_TYPE_%' and Translation.Text = @l_productName)
						SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The ProductName field is not valid: ' + @l_productName);
					ELSE 
						SET @l_productID = (select Top 1 CodeID from GEN.Translation WHERE CodeID like 'CREDIT_TYPE_%' and Translation.Text = @l_productName order by Id desc);
				END
*/

/*
			IF COALESCE(@l_contractID, 0) = 0
				SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') +  ' The contract not found by ContractNr.');
*/

			IF COALESCE(@l_errorMsg, '') = ''
				SET @l_ErrorExists = 1 else SET @l_ErrorExists = 99;
			
			IF COALESCE(@l_errorMsg, '') = ''
			BEGIN


-- Devizakód javítás:

				IF COALESCE(@l_currencyCode, '') <> '' and @l_currencyCode not like 'CURRENCY_%'
					and exists (select 1 from GEN.Code where ID = 'CURRENCY_' + @l_currencyCode)
					SET @l_currencyCode = 'CURRENCY_' + @l_currencyCode;

				IF COALESCE(@l_GrossValueCurrencyCode, '') <> '' and @l_GrossValueCurrencyCode not like 'CURRENCY_%'
					and exists (select 1 from GEN.Code where ID = 'CURRENCY_' + @l_GrossValueCurrencyCode)
					SET @l_GrossValueCurrencyCode = 'CURRENCY_' + @l_GrossValueCurrencyCode;

/*
				IF exists (select 1 from GEN.Translation where CodeID Like 'CURRENCY_%' and text = @l_GrossValueCurrencyCode)
					SET @l_GrossValueCurrencyCode = (select CodeID from GEN.Translation where CodeID like 'CURRENCY_%' and text = @l_GrossValueCurrencyCode);

				IF exists (select 1 from GEN.Translation where CodeID Like 'CURRENCY_%' and text = @l_currencyCode)
					SET @l_currencyCode = (select CodeID from GEN.Translation where CodeID like 'CURRENCY_%' and text = @l_currencyCode);
*/
				INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
				SELECT 'OBJECT_TYPE_CRM_CONTRACTITEM', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
					'ADMIN',
					'CRM.ContractItem object', '1.0';

				SELECT @l_objectID = @@IDENTITY;

				INSERT INTO [CRM].[ContractItem] ([ObjectID], [ContractID], [SequenceNr], [GrossValue], [CurrencyID], [ProductID], [CreationDate], [CreationTime], [CreationUserName])
				SELECT @l_objectID, @l_contractID, @l_sequenceNr, @l_grossValue, @l_GrossValueCurrencyCode, @l_productID, CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
					'ADMIN';

				SELECT @l_contractItemID = @@IDENTITY;

				INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
				SELECT 'OBJECT_TYPE_CRM_COLLECTIONCONTRACTITEM', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
					'ADMIN',
					'CRM.CollectionContractItem object', '1.0';

				SELECT @l_objectID = @@IDENTITY;

				INSERT INTO [CRM].[CollectionContractItem] ([ObjectID], [ContractItemID], [DebtTotal], [DebtCapital], [DebtInterest], [DebtPenaltyInterest], 
					[DebtCost], [DebtCostLocalCurrency], [DebtorName], [DecisionNr], [AccountNr], [ContractDate], [TerminationDate], [FinancialMilestoneDate],  
					[CreationDate], [CreationTime], [CreationUserName], ConstructionCode, CurrencyCode)
				SELECT @l_objectID, @l_contractItemID, @l_debtTotal, @l_debtCapital, @l_debtInterest, @l_debtPenaltyInterest, 
					@l_debtCost, @l_debtCostLocalCurrency, @l_debtorName, @l_decisionNr, @l_accountNr, @l_contractDate, @l_terminationDate, @l_financialMilestoneDate,  
					CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
					'ADMIN', @l_ConstructionCode, @l_currencyCode;
			END;

			IF COALESCE(@l_errorMsg, '') = ''
			BEGIN
				Set @LoadedRecordNr = @LoadedRecordNr + 1;
				UPDATE [IFC].[ContractPreparationItem] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED',
					[ErrorMessage] = 'OK',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] =  'ADMIN'
				WHERE [ContractPreparationItem].[ID] = @l_id
			END
			ELSE 
			BEGIN
				UPDATE [IFC].[ContractPreparationItem] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
					[ErrorMessage] = 'An error occurred. More information please see the detailed log.',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] = 'ADMIN'
				WHERE [ContractPreparationItem].[ID] = @l_id;

				SELECT @l_logMsg = CONCAT('##ERROR: ID: ', @l_id, ' Message: ', @l_errorMsg);

				INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
				SELECT 
					CAST( GETDATE() AS Date ),	-- LogDate,	
					CAST( GETDATE() AS Time ),	-- LogTime,
					SUSER_SNAME(),				-- UserName
					@p_CorrelationID,			-- CorrelationID
					'INDECS 3.0',			    -- ApplicationName
					DB_NAME(),					-- Environment
					'BACKEND',					-- Layer
					@l_procedureName,   		-- ServiceName
					'1.0',						-- ServiceVersion
					'INFO',					        -- SeverityLevel
					NULL,						-- MessageCategory
					@l_logMsg;
			END;

			FETCH NEXT FROM preparationItem_cursor
			INTO 
			@l_id, @l_sequenceNr, @l_debtorName, @l_accountNr, @l_grossValue, @l_currencyCode, 
			@l_debtCapital, @l_debtTotal, @l_debtInterest, @l_debtPenaltyInterest, @l_debtCost,  
			@l_debtCostLocalCurrency, @l_productName, @l_contractNr, @l_contractDate,
			@l_terminationDate, @l_decisionNr, @l_financialMilestoneDate, @l_GrossValueCurrencyCode, @l_ConstructionCode;

		END

		CLOSE preparationItem_cursor;
		DEALLOCATE preparationItem_cursor;
/*		
		DECLARE collectionContractItems_cursor CURSOR FOR
		SELECT 
			COUNT([CollectionContractItem].[ID]) AS ItemCount,
			SUM([CollectionContractItem].[DebtCapital]) AS DebtCapital,
			SUM([CollectionContractItem].[DebtInterest]) AS DebtInterest,
			SUM([CollectionContractItem].[DebtPenaltyInterest]) AS DebtPenaltyInterest,
			SUM([CollectionContractItem].[DebtCost]) AS DebtCost,
			SUM([CollectionContractItem].[DebtCostLocalCurrency]) AS DebtCostLocalCurrency,
			SUM([CollectionContractItem].[DebtTotal]) AS DebtTotal,
			SUM([ContractItem].[GrossValue]) AS PurchasePrice,
			(SELECT TOP 1 [C1].[CurrencyID]
		   	FROM [CRM].[ContractItem] AS C1
			JOIN [CRM].[CollectionContractItem] AS CCI1 ON ([C1].[ID] = [CCI1].[ContractItemID])
			WHERE [CCI1].[CurrencyCode] = [CollectionContractItem].[CurrencyCode]) AS PurchasePriceCurrencyCode
		FROM [CRM].[CollectionContractItem]
		JOIN [CRM].[ContractItem] ON ([ContractItem].[ID] = [CollectionContractItem].[ContractItemID])
		WHERE [ContractItem].[ContractID] = @l_contractID
		GROUP BY [CollectionContractItem].[CurrencyCode];

		OPEN collectionContractItems_cursor;
		FETCH NEXT FROM collectionContractItems_cursor
		INTO  
			@l_itemCount, 
			@l_debtCapital,  
			@l_debtInterest,
			@l_debtPenaltyInterest, 
			@l_debtCost,  
			@l_debtCostLocalCurrency, 
			@l_debtTotal,
			@l_grossValue, 
			@l_currencyCode;

		WHILE @@FETCH_STATUS = 0 
		BEGIN
			INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
			SELECT 'CRM.CollectionContractSummary', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
				'ADMIN',
				'CRM.CollectionContractSummary object', '1.0';

			SELECT @l_objectID = @@IDENTITY;

			INSERT INTO [CRM].[CollectionContractSummary] ([ObjectID], [ContractID], [ItemCount], 
				[DebtTotal], [DebtCapital], [DebtInterest], [DebtPenaltyInterest], [DebtCost], [DebtCostLocalCurrency], [CurrencyCode], 
				[PurchasePrice], [PurchasePriceCurrencyCode], [CreationDate], [CreationTime], [CreationUserName])
			SELECT @l_objectID, @l_contractID, @l_itemCount, @l_debtTotal, @l_debtCapital, @l_debtInterest, @l_debtPenaltyInterest, @l_debtCost, 
				@l_debtCostLocalCurrency, @l_debtCurrencyCode, @l_grossValue, @l_currencyCode, CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
				'ADMIN';
				
			FETCH NEXT FROM collectionContractItems_cursor
			INTO 
			@l_itemCount, 
			@l_debtCapital,  
			@l_debtInterest,
			@l_debtPenaltyInterest, 
			@l_debtCost,  
			@l_debtCostLocalCurrency, 
			@l_debtTotal,
			@l_grossValue, 
			@l_currencyCode;

				
		END
		CLOSE collectionContractItems_cursor;
		DEALLOCATE collectionContractItems_cursor;
		*/
		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName, + 'Loaded RecordNr: ' + CAST(@LoadedRecordNr as nvarchar(10)));

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;

		--RETURN 1;
		Select @l_ErrorExists;
	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'preparationItem_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE preparationItem_cursor;

			DEALLOCATE preparationItem_cursor;
		END
		
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'collectionContractItems_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE collectionContractItems_cursor;

			DEALLOCATE collectionContractItems_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage

		--RETURN 99;
		Select 99;
	END CATCH
END
go

-- =============================================
/*
-- Author:		Balázs ARANYI
-- Create date: 2022-11-07
--				2022-11-22: Errormessage concat javítás: Isnull(@l_errorMsg,'') (T.G.)
-- Last modified date:	2022-11-07
						2022-11-15: "SourceInterfaceType" <-> "MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE"
						2022-11-15: "tenderItem_cusrsor" <-> "tenderItem_cursor"
						2022-11-21: SourceInterfaceType kikommentezése
						2022-11-23: FETCH NEXT FROM collectionContractItems_cursor
						2022-11-23: Hogy tároljuk a Product-ot ? 
						2022-11-24: Produkt ellenőrzés kivéve
						2022-11-24: Currency, DebtCurrency kiegészítése, ha szükséges (T.G.)
						2022-11-24: LegalActionText ----> LegalActionCode
						2022-11-25: RETURN 1, RETURN 99 helyett Select 1, Select 99
						2022-11-25: @l_ErrorExists ( Nem volt hiba: 1, Volt hiba: 99 )
						2022-11-28: collectionContractItems_cursor kivéve, ProductName visszatéve
						2022-12-06: SequenceNR
						2023-01-16: Túl hosszú hiba üzenetek kezelése
*/
-- =============================================
CREATE   PROCEDURE [IFC].[ContractTenderItemLoader] 
	-- Add the parameters for the stored procedure here
	@p_correlationID NVARCHAR(200), 
	@p_moduleInstanceID NUMERIC(16)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'IFC.ContractTenderItemLoader'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_contractID NUMERIC(16) = NULL;
	DECLARE @l_contractItemID NUMERIC(16) = NULL;
	--DECLARE @l_productID NUMERIC(16) = NULL;
	DECLARE @l_productID Nvarchar(200) = NULL;

	DECLARE @l_objectID NUMERIC(16) = NULL;
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	DECLARE @l_id NUMERIC(16) = NULL;
	DECLARE @l_grossValue MONEY = NULL;
	DECLARE @l_currencyCode NVARCHAR(200) = NULL;
	DECLARE @l_legalActionCode NVARCHAR(200) = NULL;
	DECLARE @l_legalActionText NVARCHAR(200) = NULL;
	DECLARE @l_debtCapital MONEY = NULL;
	DECLARE @l_debtTotal MONEY = NULL;
	DECLARE @l_debtInterest MONEY;
	DECLARE @l_debtPenaltyInterest MONEY = NULL;
	DECLARE @l_debtCost MONEY = NULL;
	DECLARE @l_debtCurrencyCode NVARCHAR(200) = NULL;
	DECLARE @l_debtCostLocalCurrency MONEY = NULL;
	DECLARE @l_daysPastDue NUMERIC(10) = NULL;
	DECLARE @l_productName NVARCHAR(200) = NULL;
	DECLARE @l_contractNr NVARCHAR(200) = NULL;
	DECLARE @l_contractDate DATE = NULL;
	DECLARE @l_terminationDate DATE = NULL;
	DECLARE @l_decisionNr NVARCHAR(200) = NULL;
	DECLARE @l_financialMilestoneDate DATE = NULL;
	DECLARE @l_itemCount NUMERIC(16) = NULL;
	Declare @l_SequenceNR Numeric(16);


	DECLARE @l_ErrorExists int; /* Nem volt hiba: 1, Volt hiba: 99 */

	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);
		SET @l_ErrorExists = 1;

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END
		/* 2022-11-22 T.G.
		IF COALESCE(@l_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);
		*/
		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		DECLARE tenderItem_cursor CURSOR FOR
		SELECT 
			[ContractTenderItem].[ID], 
			[ContractTenderItem].[GrossValue],
			[ContractTenderItem].[CurrencyCode],
			[ContractTenderItem].[LegalActionCode],
			[ContractTenderItem].[LegalActionText],
			[ContractTenderItem].[DebtCapital],
			[ContractTenderItem].[DebtTotal],
			[ContractTenderItem].[DebtInterest],
			[ContractTenderItem].[DebtPenaltyInterest],
			[ContractTenderItem].[DebtCost],
			[ContractTenderItem].[DebtCurrencyCode],
			[ContractTenderItem].[DebtCostLocalCurrency],
			[ContractTenderItem].[DaysPastDue],
			[ContractTenderItem].[ProductName],
			[ContractTenderItem].[ContractNr],
			[ContractTenderItem].[SequenceNR]
		FROM [IFC].[ContractTenderItem]
		WHERE 
			ContractTenderItem.InterfaceStatusCode = 'INTERFACE_STATUS_NEW'
		ORDER BY [ContractTenderItem].[ID];
		
		OPEN tenderItem_cursor;
		FETCH NEXT FROM tenderItem_cursor
		INTO 
			@l_id, 
			@l_grossValue, 
			@l_currencyCode,
			@l_legalActionCode, 
			@l_legalActionText, 
			@l_debtCapital, 
			@l_debtTotal, 
			@l_debtInterest,
			@l_debtPenaltyInterest, 
			@l_debtCost, 
			@l_debtCurrencyCode, 
			@l_debtCostLocalCurrency, 
			@l_daysPastDue, 
			@l_productName, 
			@l_contractNr,
			@l_SequenceNR;

		WHILE @@FETCH_STATUS = 0 
		BEGIN
			Set @l_errorMsg = '';

			IF COALESCE(@l_contractNr, '') = ''
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The ContractNr field is empty.');
			ELSE 
				SELECT @l_contractID = [Contract].[ID]
				FROM [CRM].[Contract]
				WHERE [Contract].[ContractNr] = @l_contractNr 
				AND [Contract].[ContractPhaseCode] = 'CONTRACT_PHASE_OFFER';

			IF COALESCE(@l_grossValue, 0) = 0
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The GrossValue field is empty.');

			IF COALESCE(@l_debtTotal, 0) = 0
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The DebtTotal field is empty.');

-- CurrencyCode: 2022-11-24
			IF COALESCE(@l_currencyCode, '') = ''
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The CurrencyCode field is empty.');

			IF exists (select 1 from GEN.Translation where CodeID Like 'CURRENCY_%' and text = @l_currencyCode)
				SET @l_currencyCode = (select CodeID from GEN.Translation where CodeID like 'CURRENCY_%' and text = @l_currencyCode);

			IF COALESCE(@l_currencyCode, '') <> '' and @l_currencyCode like 'CURRENCY_%'
				and not exists (select 1 from GEN.Code where ID = @l_currencyCode)
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The CurrencyCode is not registered: ' + @l_currencyCode);

			IF COALESCE(@l_currencyCode, '') <> '' and @l_currencyCode not like 'CURRENCY_%'
				and not exists (select 1 from GEN.Code where ID = 'CURRENCY_'+ @l_currencyCode)
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The CurrencyCode is not registered: ' + @l_currencyCode);

-- DebtCurrencyCode: 2022-11-24
			IF COALESCE(@l_debtCurrencyCode, '') = ''
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The DebtCurrencyCode field is empty.');

			IF exists (select 1 from GEN.Translation where CodeID Like 'CURRENCY_%' and text = @l_debtCurrencyCode)
				SET @l_debtCurrencyCode = (select CodeID from GEN.Translation where CodeID like 'CURRENCY_%' and text = @l_debtCurrencyCode);

			IF COALESCE(@l_debtCurrencyCode, '') <> '' and @l_debtCurrencyCode like 'CURRENCY_%'
				and not exists (select 1 from GEN.Code where ID = @l_debtCurrencyCode)
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The DebtCurrencyCode is not registered: ' + @l_debtCurrencyCode);

			IF COALESCE(@l_debtCurrencyCode, '') <> '' and @l_debtCurrencyCode not like 'CURRENCY_%'
				and not exists (select 1 from GEN.Code where ID = 'CURRENCY_' + @l_debtCurrencyCode)
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The DebtCurrencyCode is not registered: ' + @l_debtCurrencyCode);

-- Jogi eljárás jelölő:
			IF Isnull(@l_legalActionCode, '') + Isnull(@l_legalActionText, '') = ''
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The Legalaction True/False field is empty.');

			IF exists (select 1 from GEN.Translation where CodeID Like 'BOOLEAN_%' and text = @l_legalActionText)
				SET @l_legalActionCode = (select CodeID from GEN.Translation where CodeID like 'BOOLEAN_%' and text = @l_legalActionText);

			IF COALESCE(@l_legalActionCode, '') <> '' and @l_legalActionCode like 'BOOLEAN_%'
				and not exists (select 1 from GEN.Code where ID = @l_legalActionCode)
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The Legalaction True/False is not registered: ' + Trim(@l_legalActionCode));

			IF COALESCE(@l_legalActionCode, '') <> '' and @l_legalActionCode not like 'BOOLEAN_%'
				and not exists (select 1 from GEN.Code where ID = 'BOOLEAN_' + @l_legalActionCode)
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The Legalaction True/False is not registered: ' + TRIM(@l_legalActionCode));


-- Productname:
			Set @l_productID = '';
			IF COALESCE(@l_productName, '') = ''
				SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The ProductName field is empty.');
			ELSE 
				BEGIN
					If not exists (select 1 from GEN.Translation WHERE CodeID like 'CREDIT_TYPE_%' and Translation.Text = @l_productName)
						SELECT @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The ProductName field is not valid: ' + @l_productName);
					ELSE 
						SET @l_productID = (select Top 1 CodeID from GEN.Translation WHERE CodeID like 'CREDIT_TYPE_%' and Translation.Text = @l_productName order by Id desc);
				END

			IF COALESCE(@l_contractID, 0) = 0
				SET @l_errorMsg = Trim(Isnull(@l_errorMsg,'') + ' The contract id not found by ContractNr: ' + Isnull(@l_contractNr,''));


			IF COALESCE(@l_errorMsg, '') = ''
				SET @l_ErrorExists = 1 else SET @l_ErrorExists = 99;

			IF COALESCE(@l_errorMsg, '') = ''
			BEGIN

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Devizakód javítás:
				IF COALESCE(@l_currencyCode, '') <> '' and @l_currencyCode not like 'CURRENCY_%'
					and exists (select 1 from GEN.Code where ID = 'CURRENCY_' + @l_currencyCode)
					SET @l_currencyCode = 'CURRENCY_' + @l_currencyCode;

				IF COALESCE(@l_debtCurrencyCode, '') <> '' and @l_debtCurrencyCode not like 'CURRENCY_%'
					and exists (select 1 from GEN.Code where ID = 'CURRENCY_' + @l_debtCurrencyCode)
					SET @l_debtCurrencyCode = 'CURRENCY_' + @l_debtCurrencyCode;
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Legalaction jelölő kód javítás:
				IF COALESCE(@l_legalActionCode, '') <> '' and @l_legalActionCode not like 'BOOLEAN_%'
					and exists (select 1 from GEN.Code where ID = 'BOOLEAN_' + @l_legalActionCode)
					SET @l_legalActionCode = 'BOOLEAN_' + @l_legalActionCode;
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 

				INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
				SELECT 'OBJECT_TYPE_CRM_CONTRACTITEM', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
					'ADMIN',
					'CRM.ContractItem object', '1.0';

				SELECT @l_objectID = @@IDENTITY;

				INSERT INTO [CRM].[ContractItem] (SequenceNR, [ObjectID], [ContractID], [GrossValue], [CurrencyID], [ProductID], [CreationDate], [CreationTime], [CreationUserName])
				SELECT @l_SequenceNR, @l_objectID, @l_contractID, @l_grossValue, @l_currencyCode, @l_productID, CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
					 'ADMIN';

				SELECT @l_contractItemID = @@IDENTITY;

				INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
				SELECT 'OBJECT_TYPE_CRM_COLLECTIONCONTRACTITEM', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
					'ADMIN',
					'CRM.CollectionContractItem object', '1.0';

				SELECT @l_objectID = @@IDENTITY;

				INSERT INTO [CRM].[CollectionContractItem] ([ObjectID], [ContractItemID], [DebtTotal], [DebtCapital], [DebtInterest], [DebtPenaltyInterest], 
					[DebtCost], [CurrencyCode], [DebtCostLocalCurrency], [DaysPastDue], [LegalActionCode], [CreationDate], [CreationTime], [CreationUserName])
				SELECT @l_objectID, @l_contractItemID, @l_debtTotal, @l_debtCapital, @l_debtInterest, @l_debtPenaltyInterest, 
					@l_debtCost, @l_debtCurrencyCode, @l_debtCostLocalCurrency, @l_daysPastDue, @l_legalActionCode, CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
					'ADMIN';
			END;

			IF COALESCE(@l_errorMsg, '') = ''
				UPDATE [IFC].[ContractTenderItem] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED',
					[ErrorMessage] = 'OK',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] = 'ADMIN'
				WHERE [ContractTenderItem].[ID] = @l_id
			ELSE
			BEGIN
				UPDATE [IFC].[ContractTenderItem] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
					[ErrorMessage] = 'An error occurred. More information please see the detailed log.',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] =  'ADMIN'
				WHERE [ContractTenderItem].[ID] = @l_id;

				SELECT @l_logMsg = CONCAT('##ERROR: ID: ', @l_id, ' Message: ', @l_errorMsg);

				INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
				SELECT 
					CAST( GETDATE() AS Date ),	-- LogDate,	
					CAST( GETDATE() AS Time ),	-- LogTime,
					SUSER_SNAME(),				-- UserName
					@p_CorrelationID,			-- CorrelationID
					'INDECS 3.0',			    -- ApplicationName
					DB_NAME(),					-- Environment
					'BACKEND',					-- Layer
					@l_procedureName,   		-- ServiceName
					'1.0',						-- ServiceVersion
					'INFO',					        -- SeverityLevel
					NULL,						-- MessageCategory
					@l_logMsg;
			END;

			FETCH NEXT FROM tenderItem_cursor
			INTO 
				@l_id, 
				@l_grossValue, 
				@l_currencyCode,
				@l_legalActionCode, 
				@l_legalActionText, 
				@l_debtCapital, 
				@l_debtTotal, 
				@l_debtInterest,
				@l_debtPenaltyInterest, 
				@l_debtCost, 
				@l_debtCurrencyCode, 
				@l_debtCostLocalCurrency, 
				@l_daysPastDue, 
				@l_productName, 
				@l_contractNr,
				@l_SequenceNR;
		END

		CLOSE tenderItem_cursor;
		DEALLOCATE tenderItem_cursor;

/*
		DECLARE collectionContractItems_cursor CURSOR FOR
		SELECT 
			COUNT([CollectionContractItem].[ID]) AS ItemCount,
			SUM([CollectionContractItem].[DebtCapital]) AS DebtCapital,
			SUM([CollectionContractItem].[DebtInterest]) AS DebtInterest,
			SUM([CollectionContractItem].[DebtPenaltyInterest]) AS DebtPenaltyInterest,
			SUM([CollectionContractItem].[DebtCost]) AS DebtCost,
			SUM([CollectionContractItem].[DebtCostLocalCurrency]) AS DebtCostLocalCurrency,
			SUM([CollectionContractItem].[DebtTotal]) AS DebtTotal,
			SUM([ContractItem].[GrossValue]) AS PurchasePrice,
			(SELECT TOP 1 [C1].[CurrencyID]
		   	FROM [CRM].[ContractItem] AS C1
			JOIN [CRM].[CollectionContractItem] AS CCI1 ON ([C1].[ID] = [CCI1].[ContractItemID])
			WHERE [CCI1].[CurrencyCode] = [CollectionContractItem].[CurrencyCode]) AS PurchasePriceCurrencyCode
		FROM [CRM].[CollectionContractItem]
		JOIN [CRM].[ContractItem] ON ([ContractItem].[ID] = [CollectionContractItem].[ContractItemID])
		WHERE [ContractItem].[ContractID] = @l_contractID
		GROUP BY [CollectionContractItem].[CurrencyCode];

		OPEN collectionContractItems_cursor;
		FETCH NEXT FROM collectionContractItems_cursor
		INTO  
			@l_itemCount, 
			@l_debtCapital,  
			@l_debtInterest,
			@l_debtPenaltyInterest, 
			@l_debtCost,  
			@l_debtCostLocalCurrency, 
			@l_debtTotal,
			@l_grossValue, 
			@l_currencyCode;

		WHILE @@FETCH_STATUS = 0 
		BEGIN
			INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
			SELECT 'CRM.CollectionContractSummary', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
				'ADMIN',
				'CRM.CollectionContractSummary object', '1.0';

			SELECT @l_objectID = @@IDENTITY;

			INSERT INTO [CRM].[CollectionContractSummary] ([ObjectID], [ContractID], [ItemCount], 
				[DebtTotal], [DebtCapital], [DebtInterest], [DebtPenaltyInterest], [DebtCost], [DebtCostLocalCurrency], [CurrencyCode], 
				[PurchasePrice], [PurchasePriceCurrencyCode], [CreationDate], [CreationTime], [CreationUserName])
			SELECT @l_objectID, @l_contractID, @l_itemCount, @l_debtTotal, @l_debtCapital, @l_debtInterest, @l_debtPenaltyInterest, @l_debtCost, 
				@l_debtCostLocalCurrency, @l_debtCurrencyCode, @l_grossValue, @l_currencyCode, CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
			'ADMIN';

			FETCH NEXT FROM collectionContractItems_cursor
			INTO  
				@l_itemCount, 
				@l_debtCapital,  
				@l_debtInterest,
				@l_debtPenaltyInterest, 
				@l_debtCost,  
				@l_debtCostLocalCurrency, 
				@l_debtTotal,
				@l_grossValue, 
				@l_currencyCode;

		END
		CLOSE collectionContractItems_cursor;
		DEALLOCATE collectionContractItems_cursor;
*/

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;

		--RETURN 1;
		Select @l_ErrorExists;
	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'tenderItem_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE tenderItem_cursor;

			DEALLOCATE tenderItem_cursor;
		END

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'collectionContractItems_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE collectionContractItems_cursor;

			DEALLOCATE collectionContractItems_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage

		--RETURN 99;
		Select 99;
	END CATCH
END
go

-- =============================================
-- Author:		Ozvaldik Krisztina
--              /Csaba Meszaros
-- Creation date: 2022.09.27.
-- Last modified date: 2023.03.09.
-- Description:	Copies contracts' data
-- DataOriginCode beépítése B.D. 2023-06-23
-- =============================================

CREATE   PROCEDURE [CRM].[CopyContract]
	@ContractID NUMERIC(16),
    @New_ContractNr NVARCHAR(200) = NULL,
    @New_ContractPhase NVARCHAR(200) = NULL,
    @New_ContractStatus NVARCHAR(200) = NULL,
    @CopyContractItems BIT = 0,
	@New_ContractID NUMERIC(16) OUTPUT
AS

BEGIN
	PRINT 'Start stored procedure';
	SET NOCOUNT ON

    DECLARE @ErrorMSG NVARCHAR(200)

    DECLARE @New_ObjectID NUMERIC(16,0)
    DECLARE @rowCount INTEGER
    DECLARE @LogMessage NVARCHAR(200)

    DECLARE @ContractSummaryID NUMERIC(16,0)
    DECLARE @ContractItemID NUMERIC(16,0)
    DECLARE @New_ContractItemID NUMERIC(16,0)
    DECLARE @CollectionContractItemID NUMERIC(16,0)

	DECLARE @InteractionObjectID NUMERIC(16) = NULL
    DECLARE @InteractionTag NVARCHAR(50) = NULL
    DECLARE @InteractionID NUMERIC(16)
    DECLARE @New_InteractionID NUMERIC(16)
	DECLARE @l_cursorStatus SMALLINT = NULL
	DECLARE @l_contractPhaseCode NVARCHAR(200)
	DECLARE @l_contractSignerID NUMERIC(16) = NULL;
	DECLARE @l_newObjectID NUMERIC(16) = NULL;

    SET @ErrorMSG = NULL

    BEGIN TRANSACTION

    BEGIN TRY
        SET @LogMessage = 'Search for reference contract'
        PRINT (@LogMessage)
        --Search for reference contract

        SELECT @New_ContractID = ID FROM CRM.Contract WHERE ID = @ContractID

        IF @New_ContractID IS NULL
        BEGIN
            SET @ErrorMSG = 'Reference contract not found'
            PRINT(@ErrorMSG)
            RAISERROR( @ErrorMSG, 16, 1 )
        END

        SET @LogMessage = 'Reference contract found. Creating copy now'
        PRINT (@LogMessage)

		SELECT @l_contractPhaseCode = [Contract].[ContractPhaseCode]
		FROM [CRM].[Contract]
		WHERE [Contract].[ID] = @ContractID;

        --Create new ObjectID for Contract
        SET @LogMessage = 'Creating new Object'
        PRINT (@LogMessage)

        INSERT INTO GEN.Object ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
        SELECT  'OBJECT_TYPE_CRM_CONTRACT', 
                CONVERT(DATE, GETDATE()),
                CONVERT(TIME, GETDATE()), 
                'Admin', 
                CONCAT('Copy of contract with ID: ', @ContractID),
                '1.0'
        
        SELECT @New_ObjectID = @@IDENTITY

		SET @l_newObjectID = @New_ObjectID
                                        
        --Create new contract
        SET @LogMessage = 'Creating new Contract'
        PRINT (@LogMessage)

        IF  @New_ContractNr IS NULL
            SELECT @New_ContractNr = ContractNr FROM CRM.Contract WHERE ID = @ContractID
        IF @New_ContractPhase IS NULL
            SELECT @New_ContractPhase = ContractPhaseCode FROM CRM.Contract WHERE ID = @ContractID
        IF @New_ContractStatus IS NULL
            SELECT @New_ContractStatus = StatusCode FROM CRM.Contract WHERE ID = @ContractID

        INSERT INTO CRM.Contract ( ObjectID, SellerName, SellerPartyID, BuyerName, BuyerPartyID, ReferencedContractID, ContractTypeCode, ContractPhaseCode, StatusCode, 
        ContractNr, RegistrationNr, ExternalContractNr, ValidFrom, ValidUntil, CreationDate, CreationTime, CreationUserName, DataOriginCode, FinancialMilestoneDate)
        SELECT @New_ObjectID, SellerName, SellerPartyID, BuyerName, BuyerPartyID, @ContractID, ContractTypeCode, @New_ContractPhase, @New_ContractStatus, 
        @New_ContractNr, RegistrationNr, ExternalContractNr, ValidFrom, ValidUntil, CONVERT(DATE, GETDATE()), CONVERT(TIME, GETDATE()), CreationUserName, DataOriginCode, FinancialMilestoneDate
        FROM CRM.Contract
        WHERE ID = @ContractID

        SELECT @New_ContractID = @@IDENTITY

        /*v.20230309*/
		IF @New_ContractPhase = 'CONTRACT_PHASE_CONTRACT'
			SELECT @InteractionTag = Tag.Label FROM GEN.Tag
			JOIN GEN.ObjectTag ON Tag.ID = ObjectTag.TagID
			JOIN COM.Interaction ON Interaction.ObjectID = ObjectTag.ReferencedObjectID
			JOIN COM.InteractionDocument ON Interaction.ID = InteractionDocument.InteractionID
			JOIN COM.InteractionObject ON InteractionDocument.InteractionID = InteractionObject.InteractionID
			WHERE InteractionObject.RelatedObjectID = (SELECT ObjectID FROM CRM.Contract WHERE ID = @ContractID)
		BEGIN
		PRINT @InteractionTag

        IF @InteractionTag = 'Szerződés'
        BEGIN

		PRINT 'Belépett a feltételbe'

		SELECT @InteractionID = io.InteractionID, @InteractionObjectID = IO.ID
			FROM com.InteractionObject io 
			LEFT JOIN com.Interaction i ON io.InteractionID = i.ID
			LEFT JOIN GEN.ObjectTag ot ON i.ObjectID = ot.ReferencedObjectID
			LEFT JOIN gen.Tag t ON ot.TagID = t.ID
			WHERE io.RelatedObjectID = (SELECT ObjectID FROM CRM.Contract WHERE ID = @ContractID) AND T.Label = 'Szerződés'

		
		PRINT @InteractionID
		PRINT @InteractionObjectID
		PRINT @l_newObjectID

		PRINT 'Update start'

			UPDATE COM.Interaction
				SET RelatedObjectID = @l_newObjectID
				WHERE COM.Interaction.ID = @InteractionID;

		PRINT 'Masodik Update'
		PRINT @l_newObjectID


			UPDATE COM.InteractionObject
				SET RelatedObjectID = @l_newObjectID
				WHERE ID = @InteractionObjectID;


		PRINT 'Update vége'

            /*INSERT INTO GEN.Object ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
            SELECT  'OBJECT_TYPE_COM_INTERACTION', 
                    CONVERT(DATE, GETDATE()),
                    CONVERT(TIME, GETDATE()), 
                    'Admin', 
                    CONCAT('Copy of interaction with ID: ', @InteractionID),
                    '1.0'
            
            SELECT @New_ObjectID = @@IDENTITY

            INSERT INTO COM.Interaction (EventID, CreationDate, CreationTime, CreationUserName, Comments, DirectionCode, ChannelCode, StatusCode, LanguageCode, RegistrationTypeCode,
            SenderEntityID, RecipientEntityID, Subject, RegistrationNr, ExternalReferenceNr, AnswerRequired, AnswerInDays, InteractionDate, InteractionTime, SendingDate, 
            SendingTime, DeliveryDate, DeliveryTime, DeliveryStatusCode, SenderName, SenderAddressID, SenderContactID, RecipientName, RecipientAddressID, RecipientContactID, ObjectID)
            SELECT EventID, CONVERT(DATE, GETDATE()), CONVERT(TIME, GETDATE()), CreationUserName, Comments, DirectionCode, ChannelCode, StatusCode, LanguageCode, 
            RegistrationTypeCode, SenderEntityID, RecipientEntityID, Subject, RegistrationNr, ExternalReferenceNr, AnswerRequired, AnswerInDays, InteractionDate, 
            InteractionTime, SendingDate, SendingTime, DeliveryDate, DeliveryTime, DeliveryStatusCode, SenderName, SenderAddressID, SenderContactID, RecipientName, 
            RecipientAddressID, RecipientContactID, @New_ObjectID
            FROM COM.Interaction
            WHERE ID = @InteractionID

            SELECT @New_InteractionID = @@IDENTITY

            INSERT INTO COM.InteractionDocument (InteractionID, DocumentTemplateID, DocumentID, SequenceNr, CreationDate, CreationTime, CreationUserName)
            SELECT @New_InteractionID, DocumentTemplateID, DocumentID, SequenceNr, CONVERT(DATE, GETDATE()), CONVERT(TIME, GETDATE()), CreationUserName
            FROM COM.InteractionDocument
            WHERE InteractionID = @InteractionID

            INSERT INTO GEN.Object ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
            SELECT  'OBJECT_TYPE_COM_INTERACTIONOBJECT', 
                    CONVERT(DATE, GETDATE()),
                    CONVERT(TIME, GETDATE()), 
                    'Admin', 
                    CONCAT('Copy of interaction object with ID: ', @InteractionObjectID),
                    '1.0'
            
            SELECT @New_ObjectID = @@IDENTITY

            INSERT INTO COM.InteractionObject (ObjectID, InteractionID, RelatedObjectID, CreationDate, CreationTime, CreationUserName)
            SELECT @New_ObjectID, @New_InteractionID, (SELECT ObjectID FROM CRM.Contract WHERE ID = @ContractID), 
            CONVERT(DATE, GETDATE()), CONVERT(TIME, GETDATE()), CreationUserName
            FROM COM.InteractionObject WHERE ID = @InteractionObjectID*/
		PRINT 'IF vége'

        END

		END


		PRINT 'Kilépett IFből'
        /*end v.20230309*/

        --Create new ContractSigner
        SET @LogMessage = 'Creating new ContractSigner'
        PRINT (@LogMessage)

		DECLARE cursor_contractSigner CURSOR FOR
		SELECT ContractSigner.ID 
		FROM CRM.ContractSigner
		WHERE ContractSigner.ContractID = @ContractID
		ORDER BY ContractSigner.ID ASC;

		OPEN cursor_contractSigner;
		FETCH NEXT FROM cursor_contractSigner INTO 
			@l_contractSignerID;

		WHILE @@FETCH_STATUS = 0
        BEGIN
			INSERT INTO GEN.Object ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
            SELECT  'OBJECT_TYPE_CRM_CONTRACTSIGNER', 
                    CONVERT(DATE, GETDATE()),
                    CONVERT(TIME, GETDATE()), 
                    'Admin', 
                    CONCAT('Copy of ContractSigner: ', @l_contractSignerID),
                    '1.0'
        
            SELECT @New_ObjectID = @@IDENTITY;

			INSERT INTO CRM.ContractSigner (ObjectID, ContractID, PartyID, EntityID, SignMethod, RejectDate, RejectTime, SignDate, SignTime, 
				CreationDate, CreationTime, CreationUserName)
            SELECT @New_ObjectID, @New_ContractID, PartyID, EntityID, SignMethod, RejectDate, RejectTime, SignDate, SignTime, 
				CONVERT(DATE, GETDATE()), CONVERT(TIME, GETDATE()), CreationUserName
            FROM CRM.ContractSigner
            WHERE ContractSigner.ID = @l_contractSignerID;

			FETCH NEXT FROM cursor_contractSigner INTO 
				@l_contractSignerID;
		END 
		CLOSE cursor_contractSigner;  
        DEALLOCATE cursor_contractSigner;

        --Create new CollectionContractSummary
        SET @LogMessage = 'Creating new CollectionContractSummary'
        PRINT (@LogMessage)

        DECLARE contract_summary_cursor CURSOR FOR
        SELECT CollectionContractSummary.ID 
		FROM CRM.CollectionContractSummary
        WHERE CollectionContractSummary.ContractID = @ContractID
        ORDER BY CollectionContractSummary.ID ASC

        OPEN contract_summary_cursor
        FETCH NEXT FROM contract_summary_cursor INTO 
			@ContractSummaryID

        WHILE @@FETCH_STATUS = 0
        BEGIN
			INSERT INTO GEN.Object ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
            SELECT  'OBJECT_TYPE_CRM_COLLECTIONCONTRACTSUMMARY', 
				CONVERT(DATE, GETDATE()),
                CONVERT(TIME, GETDATE()), 
                'Admin', 
                CONCAT('Copy of CollectionContractSummary: ', @ContractSummaryID),
                '1.0';

            SELECT @New_ObjectID = @@IDENTITY

            INSERT INTO CRM.CollectionContractSummary (ObjectID, ContractID, ItemCount, 
				DebtCapital, DebtInterest, DebtCost, DebtCostLocalCurrency, DebtTotal, 
				PurchasePrice, PurchasePriceCurrencyCode, CurrencyCode, DebtPenaltyInterest, 
				CreationDate, CreationTime, CreationUserName)
            SELECT @New_ObjectID, @New_ContractID, ItemCount, 
				DebtCapital, DebtInterest, DebtCost, DebtCostLocalCurrency, DebtTotal,
				PurchasePrice, PurchasePriceCurrencyCode, CurrencyCode, DebtPenaltyInterest,
				CONVERT(DATE, GETDATE()), CONVERT(TIME, GETDATE()), CreationUserName
            FROM CRM.CollectionContractSummary
            WHERE CollectionContractSummary.ID = @ContractSummaryID;

            FETCH NEXT FROM contract_summary_cursor INTO 
				@ContractSummaryID  
        END

		CLOSE contract_summary_cursor  
        DEALLOCATE contract_summary_cursor

        --Ajánlat esetén nincs tétel másolás
		IF COALESCE(@l_contractPhaseCode, '') IN ('CONTRACT_PHASE_PREPARATION', 'CONTRACT_PHASE_CONTRACT')
        BEGIN
            SET @LogMessage = 'Creating new ContractItems'
            PRINT (@LogMessage)

            DECLARE contract_item_cursor CURSOR FOR
            SELECT ContractItem.ID 
			FROM CRM.ContractItem
            WHERE ContractItem.ContractID = @ContractID
            ORDER BY ContractItem.ID ASC

            OPEN contract_item_cursor
            FETCH NEXT FROM contract_item_cursor INTO 
				@ContractItemID

            WHILE @@FETCH_STATUS = 0
            BEGIN
				INSERT INTO GEN.Object ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
                SELECT  'OBJECT_TYPE_CRM_CONTRACTITEM', 
					CONVERT(DATE, GETDATE()),
                    CONVERT(TIME, GETDATE()), 
                    'Admin', 
                    CONCAT('Copy of ContractItem: ', @ContractItemID),
                    '1.0'

				SELECT @New_ObjectID = @@IDENTITY

				INSERT INTO CRM.ContractItem ( ObjectID, ContractID, ReferencedContractItemID, SequenceNr, ReferenceNr, NetValue, VATValue, GrossValue, 
					CurrencyID, ProductID, Description, Status, CreationDate, CreationTime, CreationUserName )
				SELECT @New_ObjectID, @New_ContractID, ReferencedContractItemID, SequenceNr, ReferenceNr, NetValue, VATValue, GrossValue, 
					CurrencyID, ProductID, Description, Status, CONVERT(DATE, GETDATE()), CONVERT(TIME, GETDATE()), CreationUserName
				FROM CRM.ContractItem
				WHERE ContractItem.ID = @ContractItemID

                SELECT @New_ContractItemID = @@IDENTITY;

				INSERT INTO GEN.Object ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
                SELECT  'OBJECT_TYPE_CRM_COLLECTIONCONTRACTITEM', 
					CONVERT(DATE, GETDATE()),
                    CONVERT(TIME, GETDATE()), 
                    'Admin', 
                    CONCAT('Copy of CollectionContractItem with ContractItemID: ', @ContractItemID),
                    '1.0'

                SELECT @New_ObjectID = @@IDENTITY

				INSERT INTO CRM.CollectionContractItem (ObjectID, ContractItemID, DebtCaseID, DebtCapital, DebtInterest, DebtCost, DebtCostLocalCurrency, 
					DebtTotal, ConstructionCode, DebtorName, PricingMethodID, BusinessPercent, BusinessPrice, ContractNr, DecisionNr, AccountNr, 
                    ContractDate, TerminationDate, FinancialMilestoneDate, CurrencyCode, DebtPenaltyInterest, LegalActionCode, DaysPastDue, 
					CreationDate, CreationTime, CreationUserName)
                SELECT @New_ObjectID, @New_ContractItemID, DebtCaseID, DebtCapital, DebtInterest, DebtCost, DebtCostLocalCurrency, 
					DebtTotal, ConstructionCode, DebtorName, PricingMethodID, BusinessPercent, BusinessPrice, ContractNr, DecisionNr, AccountNr, 
                    ContractDate, TerminationDate, FinancialMilestoneDate, CurrencyCode, DebtPenaltyInterest, LegalActionCode, DaysPastDue, 
					CONVERT(DATE, GETDATE()), CONVERT(TIME, GETDATE()), CreationUserName
                FROM CRM.CollectionContractItem
                WHERE CollectionContractItem.ContractItemID = @ContractItemID

                FETCH NEXT FROM contract_item_cursor INTO 
					@ContractItemID    
			END

            CLOSE contract_item_cursor  
            DEALLOCATE contract_item_cursor 
        END

		DECLARE interaction_cursor CURSOR FOR
		SELECT [InteractionObject].[ID] 
		FROM [CRM].[Contract]
		JOIN [COM].[InteractionObject] ON ([InteractionObject].[RelatedObjectID] = [Contract].[ObjectID])
		JOIN [COM].[InteractionDocument] ON ([InteractionDocument].[InteractionID] = [InteractionObject].[InteractionID])
		JOIN [GEN].[DocumentTemplate] ON ([DocumentTemplate].[ID] = [InteractionDocument].[DocumentTemplateID])
		WHERE [Contract].[ID] = @ContractID
		AND [DocumentTemplate].[TemplateCode] IN ('DOCUMENT_TEMPLATE_CONTRACT_B2', 'DOCUMENT_TEMPLATE_CONTRACT_D4')
		ORDER BY [InteractionObject].[ID]

		OPEN interaction_cursor
		FETCH NEXT FROM interaction_cursor INTO @InteractionObjectID
		WHILE @@FETCH_STATUS = 0
        BEGIN
			IF COALESCE(@InteractionObjectID, 0) > 0
				UPDATE [COM].[InteractionObject] SET 
					[RelatedObjectID] = (SELECT [Contract].[ObjectID] FROM [CRM].[Contract] WHERE [Contract].[ID] = @New_ContractID)
				WHERE [InteractionObject].[ID] = @InteractionObjectID;

			FETCH NEXT FROM interaction_cursor INTO @InteractionObjectID
		END

		CLOSE interaction_cursor;
		DEALLOCATE interaction_cursor;

		SELECT @New_ContractID;
	
		COMMIT TRANSACTION

		RETURN;
    END TRY

    BEGIN CATCH
        DECLARE @ErrorMessage NVARCHAR(200) 
        DECLARE @ErrorSeverity INT 
        DECLARE @ErrorState INT
        DECLARE @ErrorLine INT

        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE()

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'cursor_contractSigner');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE cursor_contractSigner;

			DEALLOCATE cursor_contractSigner;
		END;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'contract_summary_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE contract_summary_cursor;

			DEALLOCATE contract_summary_cursor;
		END;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'contract_item_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE contract_item_cursor;

			DEALLOCATE contract_item_cursor;
		END;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'collection_contract_item_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE collection_contract_item_cursor;

			DEALLOCATE collection_contract_item_cursor;
		END;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'interaction_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE interaction_cursor;

			DEALLOCATE interaction_cursor;
		END;

        SET @ErrorMessage = CONCAT('Error occured in line (', ERROR_PROCEDURE(), '): ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage)

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine )

        ROLLBACK TRANSACTION

        SET @New_ContractID = NULL
        SELECT @New_ContractID, @ErrorMSG

    END CATCH

END
go

/*----------------------------------------------------------------------------------------------
  Author: Kiss János
  Create date: 2023.11.28. - DV-1823
  Description:	New FIN.Account creater
  
  Parameters: 
    - @p_calculationID: the ID of the calculation (FIN.Calculation)
    - @p_accountTypeCode: accounttype (FIN.AccountType)
    - @p_currencyCode: currency
    - @p_amount: amount
    - @p_CorrelationID: the correlationID of the caller
    - @p_UserName: the userName of the caller
----------------------------------------------------------------------------------------------*/
CREATE procedure [FIN].[CreateAccount](@p_calculationID Numeric(16), @p_accountTypeCode Nvarchar(200), @p_currencyCode Nvarchar(200), @p_amount Money, @p_CorrelationID NVarChar(200), @p_UserName NVarChar(200))
as
begin
  set NOCOUNT ON
  set XACT_ABORT ON

  
  /*variables for logging*/
	declare @errormsg NVarChar(max),	@logMessage nvarchar(max), @procedureName nvarchar(100) = 'FIN.CreateAccount',
          @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for coding*/ 
	declare @objectID numeric(16), @accountID numeric(16), @accountTypeID Numeric(16)

  begin try
    /*Logging procedure start*/
    set @logMessage = Concat('Start procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    /*Logging parameter check*/
    set @logMessage = 'Checking parameters...'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

		if @p_calculationID is null
			raiserror('The @p_calculationID parameter is compulsory.', 16, 1)

    if not exists(select *
                  from FIN.Calculation c
                  where c.Id = @p_calculationID
                 )   
    begin
      select @errorMessage = Concat('CalculationID ', @p_calculationID, ' does not exist.')
      raiserror(@errorMessage, 16, 1)
    end


		if IsNull(@p_accountTypeCode, '') = ''
			raiserror('The @p_accountTypeCode parameter is compulsory.', 16, 1)

    select @accountTypeID = ac.ID
		from FIN.AccountType ac
		where ac.Code = @p_accountTypeCode   
 
    if @accountTypeID is null
			raiserror('AccountTypeCode %s does not exist.', 16, 1, @p_accountTypeCode)

		if IsNull(@p_currencyCode, '') = ''
			raiserror('The @p_currencyCode parameter is compulsory.', 16, 1)

    if not exists(select *
              from gen.ValueSet vs join gen.Code c on vs.ID = c.ValueSetID
              where vs.Code = 'VALUESET_CURRENCY'
                and c.ID = @p_currencyCode
              )
       raiserror('CurrencyCode %s does not exist.', 16, 1, @p_currencyCode)

		if @p_amount is NULL
			raiserror('The @p_amount parameter is compulsory.', 16, 1)



    /*Logging start processing*/
    set @logMessage = 'Start processing'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    if exists (select a.ID 
						   from FIN.Account a 
						   where a.CalculationID = @p_calculationID 
							   and a.AccountTypeID = @accountTypeID
							   and a.CurrencyCode = @p_currencyCode
             )

    begin
      update FIN.Account
			set Balance = @p_amount, LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @p_UserName
			where FIN.Account.ID = (select a.ID 
										          from FIN.Account a 
										          where a.CalculationID = @p_calculationID 
											          and a.AccountTypeID = @accountTypeID
											          and a.CurrencyCode = @p_currencyCode
                             )
 	  end
		else
		begin
			begin tran 		
        insert into gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
          values((SELECT gen.ObjectType.Code from GEN.ObjectType where TableName = 'FIN.Account') , GetDate(), GetDate(), @p_UserName, Concat('FIN.Account by ', @procedureName, ' procedure'), '1.0.0')

        select @objectID = SCOPE_IDENTITY();

        insert into FIN.Account(ObjectID, CalculationID, AccountTypeID, Balance, CreationDate, CreationTime, CreationUserName, CurrencyCode)
          values(@objectID,
		             @p_calculationID,
		             @accountTypeID,
		             @p_amount,
		             GetDate(), 
		             GetDate(),
		             @p_UserName,
		             @p_currencyCode
                )
      commit
		end


    /*Logging processing end*/
    set @logMessage = Concat('End procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

  end try
  begin catch
    if @@trancount > 0
       rollback

    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage

    ;THROW
  end catch
end
go

/* =============================================
   Author:        Kiss János
   Create date: 2023.03.29
   Description: Creates a new event
     2023.11.02.: terminating event DV-1674
     2023.11.03.: Inkasso sync DV-1592
     2023.11.14.: no resultset needed, @EventID output parameter DV-1680
     2023.11.16.: @ForceInkassoSyncOff parameter DV-1750
     2023.12.12.: Inkasso szinkron ellenőrzés módosítás DV-1775 
*/
CREATE   PROCEDURE [ORG].[CreateEvent]
	@Subject NVARCHAR(200) = NULL,
	@EventDate DATE,
	@EventTime TIME,
	@EventType NVARCHAR(200),
	@Comments NVARCHAR(MAX),
	@UserName NVARCHAR(200) = NULL,
	@RelatedObjectID NUMERIC(16),
	@CreationUserName NVARCHAR(200),
	@ProcessCode NVARCHAR(200),
	@TaskID NUMERIC(16)=null,
	@ProcessID NUMERIC(16)=null,
	@Terminate NVARCHAR(200)='BOOLEAN_TRUE',
  @correlationID NVARCHAR(200) = null,
  @moduleInstanceIDInkasso Numeric(16) = null output /*if the Inkasso sync is active, this is the moduleInstanceID which should process the created tasks*/,
  @EventID NUMERIC(16) = null output /*the ID of the created event*/,
  @ForceInkassoSyncOff int = 0 /*if 1, no Inkasso sync record will be generated (we use this from the Inkasso --> Indecs Event sync)*/,
  @isBatch bit = 0
AS
BEGIN
   /*variables for logging*/
	declare @errormsg NVarChar(max),	@logMessage nvarchar(max), @procedureName nvarchar(100) = 'ORG.CreateEvent',
          @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max),
          @logUserName NVarChar(200) = @UserName



  /*variables for procedure logic*/
  declare @InsertedObjectID Numeric(16), @TerminalCount Numeric(16), @ProcessObjectID Numeric(16),
          @InkassoSyncOn int, @p_TaskProcessID Numeric(16)

  begin try
    /*Logging procedure start*/
    set @logMessage = Concat('Start procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @logUserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

    set @InkassoSyncOn = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'Event', 'insert')

    IF @Terminate is NULL set @Terminate='BOOLEAN_TRUE';

    if @ForceInkassoSyncOff = 1
        set @InkassoSyncOn = 0
  
    select @TerminalCount = COUNT(*)
    from ORG.Process a left join ORG.ProcessDefinition b on b.ID = a.ProcessDefinitionID 
                       left join ORG.ProcessDefinitionTerminalEventType c on b.ID = c.ProcessDefinitionID 
    where a.ReferencedObjectID = @RelatedObjectID 
      AND a.StatusCode = 'PROCESS_INSTANCE_STATUS_PROCESSING' 
      AND c.EventTypeCode = @EventType

	  select @p_TaskProcessID=a.id
    from ORG.Process a left join ORG.ProcessDefinition b on b.ID = a.ProcessDefinitionID 
                       left join ORG.ProcessDefinitionTerminalEventType c on b.ID = c.ProcessDefinitionID 
    where a.ReferencedObjectID = @RelatedObjectID 
      AND a.StatusCode = 'PROCESS_INSTANCE_STATUS_PROCESSING' 
      AND c.EventTypeCode = @EventType



    set @logMessage = 'Event creation start'
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                            @p_UserName = @logUserName,
                            @p_ServiceName = @procedurename, 
                            @p_LogMessage = @logMessage


    IF @UserName is null
         SET @UserName = 'Admin';
    
    begin transaction

      INSERT INTO gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
        VALUES((SELECT GEN.ObjectType.Code
                FROM GEN.ObjectType
                WHERE GEN.ObjectType.TableName = 'ORG.Event'
               ), 
               CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @CreationUserName, 'New Event', '1.0.0'
              )

      SELECT @InsertedObjectID = SCOPE_IDENTITY()

      
      INSERT INTO ORG.Event(ObjectID, EventTypeCode, Subject, Comments, EventDate, EventTime, UserName, CreationDate, CreationTime, CreationUserName, RelatedObjectID, ProcessCode, TaskID, ProcessID)
        VALUES(@InsertedObjectID, @EventType, @Subject, @Comments, @EventDate, @EventTime, @UserName, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @CreationUserName, @RelatedObjectID,@ProcessCode,@TaskID,@ProcessID)

              
      select @EventID = SCOPE_IDENTITY()

      /*DV-1592: insert Inkasso sync record*/
      if @InkassoSyncOn = 1
      begin
        if IFC.IsInkassoSyncSendEvent(@EventType) = 1
        begin
          exec IFC.GenerateSendInkassoSyncData  @syncType = 'Event', 
                                                @syncEventType = 'insert', 
                                                @entityID = null, 
                                                @ID = @EventID, 
                                                @dataChangedUserName = @UserName,
                                                @correlationID = @correlationID,
                                                @moduleInstanceID = @moduleInstanceIDInkasso output,
												@isBatch = @isBatch
        end
      end

      IF @Terminate='BOOLEAN_TRUE' AND @TerminalCount > 0
      BEGIN
        select @ProcessObjectID=ObjectID 
        from ORG.Process 
        where ReferencedObjectID=@RelatedObjectID

        exec ORG.TaskInsert	@p_taskTypeCode = 'TASK_TYPE_TERMINATED',
	                          @p_referencedObjectID = @ProcessObjectID,
                            @p_detailsStatusCode = 'TASK_DETAILED_STATUS_WAITING_TO_BE_PROCESSED',
                            @p_creationUserName = @UserName,
							@p_UserName = 'admin',
	                          @p_correlationID = @correlationID,
                            @p_newTaskID = null
      END



    COMMIT TRANSACTION




    set @logMessage = 'Event creation end'
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                            @p_UserName = @logUserName,
                            @p_ServiceName = @procedurename, 
                            @p_LogMessage = @logMessage
  end try
  begin catch
    if @@TRANCOUNT > 0
       rollback

    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @correlationID,
                            @p_UserName = @logUserName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage

    ;throw
  END CATCH
END
go

/*----------------------------------------------------------------------------------------------
  Author: Gyenese Katalin
  Create date: 2023.12.11. - DV-1966
  Description:	GEN.FlexibleForm creater
  
  Parameters: 
    - @p_ReferencedObjectID: the referenced ObjectID
    - @p_FlexibleFormTemplateID: the ID of the template
    - @p_CorrelationID: the correlationID of the caller
    - @p_UserName: the userName of the caller
    - @p_FlexibleFormID: the ID of the inserted flexible form (output parameter)
----------------------------------------------------------------------------------------------*/
CREATE procedure [GEN].[CreateFlexibleForm](@p_ReferencedObjectID Numeric(16), @p_FlexibleFormTemplateID Numeric(16), @p_CorrelationID NVarChar(200), @p_UserName NVarChar(200), @p_FlexibleFormID Numeric(16) = null output)
as
begin
  set NOCOUNT ON
  set XACT_ABORT ON

  
  /*variables for logging*/
	declare @errormsg NVarChar(max),	@logMessage NVarChar(max), @procedureName NVarChar(100) = 'GEN.CreateFlexibleForm',
          @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for coding*/ 
	declare @objectID numeric(16), @objectTypeCode NVarChar(200), @tableToInsert NVarChar(200) = 'GEN.FlexibleForm', @crUserName NVarChar(200)

  begin try
    /*Logging procedure start*/
    set @logMessage = Concat('Start procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    /*Logging parameter check*/
    set @logMessage = 'Checking parameters...'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

		if @p_ReferencedObjectID is null
			raiserror('The @p_ReferencedObjectID parameter is compulsory.', 16, 1)

    if not exists(select *
                  from GEN.Object o
                  where o.Id = @p_ReferencedObjectID
                 )   
    begin
      select @errorMessage = Concat('ObjectID ', @p_ReferencedObjectID, ' does not exist.')
      raiserror(@errorMessage, 16, 1)
    end

    if @p_FlexibleFormTemplateID is not null
    begin
		  if not exists(select *
                    from GEN.FlexibleFormTemplate t
                    where t.ID = @p_FlexibleFormTemplateID
                   )
      begin
        select @errorMessage = Concat('FlexibleFormTemplateID ', @p_FlexibleFormTemplateID, ' does not exist.')
        raiserror(@errorMessage, 16, 1)
      end
    end

    select @objectTypeCode = ot.Code
    from GEN.ObjectType ot
    where ot.TableName = @tableToInsert

    if IsNull(@objectTypeCode, '') = ''
			raiserror('ObjectTypeCode for tableName %s is missing.', 16, 1, @tableToInsert)

    select @crUserName = IsNull(@p_UserName, 'admin')

    /*Logging start processing*/
    set @logMessage = 'Start processing'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    /*insert new record*/  
		begin tran 		
      insert into gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
        select @objectTypeCode ObjectType, GetDate() CreationDate, GetDate() CreationTime, @crUserName CreationUserName, 
               Concat(@tableToInsert, ' by ', @procedureName, ' procedure') Comments, '1.0.0' VersionNr

      select @objectID = SCOPE_IDENTITY()

      insert into GEN.FlexibleForm(ObjectID, ReferencedObjectID, FlexibleFormTemplateID, CreationDate, CreationTime, CreationUserName)
        select @objectID ObjectID, @p_ReferencedObjectID ReferencedObjectID, @p_FlexibleFormTemplateID FlexibleFormTemplateID, 
		           GetDate() CreationDate, GetDate() CreationTime, @crUserName CreationUserName

      select @p_FlexibleFormID = SCOPE_IDENTITY()   
    commit

    /*Logging processing end*/
    set @logMessage = Concat('End procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

  end try
  begin catch
    if @@trancount > 0
       rollback

    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage

    ;THROW
  end catch
end
go

/*----------------------------------------------------------------------------------------------
  Author: Gyenese Katalin
  Create date: 2023.12.11. - DV-1966
  Description:	GEN.FlexibleForm creater
  
  Parameters: 
    - @p_FlexibleFormID: the ID of the FlexibleForm
    - @p_FlexibleFormFieldTypeID: FlexibleFormFieldTypeID
    - @p_FieldTypeCode: fieldTypeCode (from valueSet VALUESET_FLEXIBLE_FIELD_TYPE)
    - @p_Caption: caption
    - @p_Block: is it a block (from valueSet VALUESET_BOOLEAN)
    - @p_ValueSetCode: valueSetCode (GEN.ValueSet.Code)
    - @p_DataLength: dataLength
    - @p_FieldValue: value 
    - @p_ParentFlexibleFormFieldID: parent FlexibleFormFieldID (for blocks)
    - @p_SequenceNr: Order number in the instance or block 
    - @p_CorrelationID: the correlationID of the caller
    - @p_UserName: the userName of the caller
    - @p_FlexibleFormID: the ID of the inserted flexible form (output parameter)
----------------------------------------------------------------------------------------------*/
CREATE   procedure [GEN].[CreateFlexibleFormField](@p_FlexibleFormID Numeric(16), @p_FlexibleFormFieldTypeID Numeric(16) = null, @p_FieldTypeCode NVarChar(200), @p_Caption NVarChar(200), 
                                                      @p_Block NVarChar(200) = 'BOOLEAN_FALSE', @p_ValueSetCode NVarChar(200), @p_DataLength Numeric(16), @p_FieldValue NVarChar(max), 
                                                      @p_ParentFlexibleFormFieldID Numeric(16) = null, @p_SequenceNr Numeric(3, 0),
                                                      @p_CorrelationID NVarChar(200), @p_UserName NVarChar(200)
                                                     )
as
begin
  set NOCOUNT ON
  set XACT_ABORT ON
  
  /*variables for logging*/
	declare @errormsg NVarChar(max),	@logMessage NVarChar(max), @procedureName NVarChar(100) = 'GEN.CreateFlexibleFormField',
          @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for coding*/ 
	declare @objectID numeric(16), @objectTypeCode NVarChar(200), @tableToInsert NVarChar(200) = 'GEN.FlexibleFormField', @crUserName NVarChar(200), @valueSetID Numeric(16)

  begin try
    /*Logging procedure start*/
    set @logMessage = Concat('Start procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    /*Logging parameter check*/
    set @logMessage = 'Checking parameters...'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

		if @p_FlexibleFormID is null
			raiserror('The @p_FlexibleFormID parameter is compulsory.', 16, 1)

    if not exists(select *
                  from GEN.FlexibleForm f
                  where f.ID = @p_FlexibleFormID
                 )   
    begin
      select @errorMessage = Concat('FlexibleFormID ', @p_FlexibleFormID, ' does not exist.')
      raiserror(@errorMessage, 16, 1)
    end

    if @p_FlexibleFormFieldTypeID is not null
    begin
		  if not exists(select *
                    from GEN.FlexibleFormFieldType t
                    where t.ID = @p_FlexibleFormFieldTypeID
                   )
      begin
        select @errorMessage = Concat('FlexibleFormFieldType ', @p_FlexibleFormFieldTypeID, ' does not exist.')
        raiserror(@errorMessage, 16, 1)
      end
    end

    if IsNull(@p_FieldTypeCode, '') = ''
			raiserror('The @p_FieldTypeCode parameter is compulsory.', 16, 1)

    if not exists(select *
                  from gen.ValueSet vs join gen.Code c on vs.ID = c.ValueSetID
                  where vs.Code = 'VALUESET_FLEXIBLE_FIELD_TYPE'
                    and c.ID = @p_FieldTypeCode
                 )
      raiserror('FieldTypeCode %s does not exist.', 16, 1, @p_FieldTypeCode)


    if @p_Block is null
       set @p_Block = 'BOOLEAN_FALSE'

    if IsNull(@p_Block, '') = ''
			raiserror('The @p_Block parameter is compulsory.', 16, 1)

    if not exists(select *
                  from gen.ValueSet vs join gen.Code c on vs.ID = c.ValueSetID
                  where vs.Code = 'VALUESET_BOOLEAN'
                    and c.ID = @p_Block
                 )
      raiserror('Boolean value %s for parameter @p_Block does not exist.', 16, 1, @p_Block)


    if @p_ValueSetCode is not null
    begin
      select @valueSetID = vs.ID
      from GEN.ValueSet vs
      where vs.Code = @p_ValueSetCode

		  if @valueSetID is null
        raiserror('ValueSetCode %s does not exist.', 16, 1, @p_ValueSetCode)
    end
 
    if @p_ParentFlexibleFormFieldID is not null
    begin
		  if not exists(select *
                    from GEN.FlexibleFormField f
                    where f.ID = @p_ParentFlexibleFormFieldID
                   )
      begin
        select @errorMessage = Concat('ParentFlexibleFormFieldID ', @p_ParentFlexibleFormFieldID, ' does not exist.')
        raiserror(@errorMessage, 16, 1)
      end
    end
   
    select @objectTypeCode = ot.Code
    from GEN.ObjectType ot
    where ot.TableName = @tableToInsert

    if IsNull(@objectTypeCode, '') = ''
			raiserror('ObjectTypeCode for tableName %s is missing.', 16, 1, @tableToInsert)

    select @crUserName = IsNull(@p_UserName, 'admin')

    /*Logging start processing*/
    set @logMessage = 'Start processing'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    /*insert new record*/  
		begin tran 		
      insert into gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
        select @objectTypeCode ObjectType, GetDate() CreationDate, GetDate() CreationTime, @crUserName CreationUserName, 
               Concat(@tableToInsert, ' by ', @procedureName, ' procedure') Comments, '1.0.0' VersionNr

      select @objectID = SCOPE_IDENTITY()

      insert into GEN.FlexibleFormField(ObjectID, FlexibleFormID, FlexibleFormFieldTypeID, FieldValue, ParentFlexibleFormFieldID, SequenceNr, FieldTypeCode, Caption, Block, ValueSetID, DataLength,
                                        CreationDate, CreationTime, CreationUserName  
                                       )
        select @objectID ObjectID, @p_FlexibleFormID FlexibleFormID, @p_FlexibleFormFieldTypeID FlexibleFormFieldTypeID, @p_FieldValue FieldValue, @p_ParentFlexibleFormFieldID ParentFlexibleFormFieldID,
               @p_SequenceNr SequenceNr, @p_FieldTypeCode FieldTypeCode, @p_Caption Caption, @p_Block Block, @valueSetID ValueSetID, @p_DataLength DataLength,
		           GetDate() CreationDate, GetDate() CreationTime, @crUserName CreationUserName
    commit

    /*Logging processing end*/
    set @logMessage = Concat('End procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

  end try
  begin catch
    if @@trancount > 0
       rollback

    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage

    ;THROW
  end catch
end
go




/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
CREATE   PROCEDURE [IFC].[CreateNewModuleInstance](@p_correlationID NVARCHAR(200), @p_ModuleId NUMERIC(16))
-- =============================================
/*
 Author:				Tóth Gábor
 Creation date:			2022.11.23.
 Last modified date:	
Description:	Create a New ModuleInstance from ORG.Module with Parameteres
*/
-- =============================================


AS

BEGIN

declare @ParameterCode nvarchar(200);
declare @DefaultType nvarchar(200);
declare @DefaultValue nvarchar(max);
declare @Required nvarchar(200);
declare @Visiblen varchar(200); 
declare @ReadOnly nvarchar(200);
declare @l_ObjectID numeric(18);

declare @l_ModuleInstanceID numeric(18);

	Declare @CurrentUserID nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUser = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));

	Set @CurrentUserID = 'Admin';
	If exists (select 1 from PRT.AppUser where UserName = @CurrentUser)
		Set @CurrentUserID = (select Top 1 ID from PRT.AppUser where UserName = @CurrentUser order by ID);
	ELSE
		Select 'Current user id not defined (' + @CurrentUser + ')';

-- New ModuleInstance:
	INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
	SELECT 'Org.ModuleInstance' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserID, '1.0.0';
	SET @l_ObjectID = @@Identity;

	Insert into Org.ModuleInstance (ObjectID, ModuleID, StatusCode, CorrelationID, CreationDate, CreationTime, CreationUserName)
	Select @l_ObjectID, @p_ModuleId, 'MODULE_INSTANCE_STATUS_FINISHED', @p_CorrelationID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserID
	SET @l_ModuleInstanceID = @@Identity;

-- New ModuleInstanceParameter:

		DECLARE db_cursor CURSOR FOR 
		SELECT ParameterCode, DefaultType, DefaultValue/*, [Required], Visible, [ReadOnly]*/
		FROM Org.ModuleParameter
		where ModuleParameter.ModuleId = @p_ModuleId

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor 
		INTO @ParameterCode, @DefaultType, @DefaultValue/*, @Required, @Visible, @ReadOnly*/

		WHILE @@FETCH_STATUS = 0  
		BEGIN  
		-- New ModuleInstance:
			INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr/*  PortfolioID*/)
			SELECT 'Org.ModuleInstance' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserID, '1.0.0'/*, @l_PortfolioID*/;
			SET @l_ObjectID = @@Identity;

			Insert into Org.ModuleInstanceParameter (ObjectID, ModuleInstanceID, ParameterCode, ParameterId, ParameterValue, CreationDate, CreationTime, CreationUserName)
			Select @l_ObjectID, @l_ModuleInstanceID, @ParameterCode, NULL, @DefaultValue, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserID;

			FETCH NEXT FROM db_cursor 
			INTO  @ParameterCode, @DefaultType, @DefaultValue/*, @Required, @Visible, @ReadOnly*/
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;

		Print 'ModuleInstenceId: ' + Cast(@l_ModuleInstanceID as nvarchar(18));
END;

go

/*----------------------------------------------------------------------------------------------
  Author: Kiss János
  Create date: 2023.11.28. - DV-1823
  Description:	New FIN.Transaction creater
  
  Parameters: 
    - @p_calculationID:  the ID of the calculation (FIN.Calculation)
    - @p_accountTypeCode: accounttype (FIN.AccountType)
    - @p_currencyCode: currency
    - @p_accountingDate: accountingDate
    - @p_transactionTypeCode: transaction type (from VALUESET_TRANSACTION_TYPE valueSet)
    - @p_pretenseCode: pretense (from VALUESET_PRETENSE valueSet)
    - @p_creationDate: creationDate
    - @p_creationTime: creationTime
    - @p_amount: amount in @p_currencyCode
    - @p_amountLocalCurrency: amount in local currency
    - @p_CorrelationID: the correlationID of the caller
    - @p_UserName: the userName of the caller
    - @p_transactionID: the ID of the created transaction (output parameter)
*/
CREATE procedure [FIN].[CreateTransaction](@p_calculationID Numeric(16), @p_accountTypeCode Nvarchar(200), @p_currencyCode Nvarchar(200), 
                                          @p_accountingDate Date, @p_transactionTypeCode NVarChar(200), @p_pretenseCode NVarchar(200),
                                          @p_creationDate Date, @p_creationTime Time, @p_amount Money, @p_amountLocalCurrency Money, 
                                          @p_CorrelationID NVarChar(200), @p_UserName NVarChar(200),
                                          @p_transactionID Numeric(16) = null output 
                                         )
as
begin
  set NOCOUNT ON
  set XACT_ABORT ON

  
  /*variables for logging*/
	declare @errormsg NVarChar(max),	@logMessage nvarchar(max), @procedureName nvarchar(100) = 'FIN.CreateTransaction',
          @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for coding*/ 
	declare @objectID numeric(16), @accountID numeric(16), @accountTypeID Numeric(16)

  begin try
    /*Logging procedure start*/
    set @logMessage = Concat('Start procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    /*Logging parameter check*/
    set @logMessage = 'Checking parameters...'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage
 
		if @p_calculationID is null
			raiserror('The @p_calculationID parameter is compulsory.', 16, 1)

    if not exists(select *
                  from FIN.Calculation c
                  where c.Id = @p_calculationID
                 )
    begin
      select @errorMessage = Concat('CalculationID ', @p_calculationID, ' does not exist.')
      raiserror(@errorMessage, 16, 1)
    end

		if IsNull(@p_accountTypeCode, '') = ''
			raiserror('The @p_accountTypeCode parameter is compulsory.', 16, 1)

    select @accountTypeID = ac.ID
		from FIN.AccountType ac
		where ac.Code = @p_accountTypeCode   
 
    if @accountTypeID is null
			raiserror('AccountTypeCode %s does not exist.', 16, 1, @p_accountTypeCode)

		if IsNull(@p_currencyCode, '') = ''
			raiserror('The @p_currencyCode parameter is compulsory.', 16, 1)

    if not exists(select *
                  from gen.ValueSet vs join gen.Code c on vs.ID = c.ValueSetID
                  where vs.Code = 'VALUESET_CURRENCY'
                    and c.ID = @p_currencyCode
                 )
      raiserror('CurrencyCode %s does not exist.', 16, 1, @p_currencyCode)
    

    if IsNull(@p_transactionTypeCode, '') = ''
			  raiserror('The @p_transactionTypeCode parameter is compulsory.', 16, 1)

    if not exists(select *
                  from gen.ValueSet vs join gen.Code c on vs.ID = c.ValueSetID
                  where vs.Code = 'VALUESET_TRANSACTION_TYPE'
                    and c.ID = @p_transactionTypeCode
                  )
    begin
      raiserror('TransactionType %s does not exist.', 16, 1, @p_transactionTypeCode)
    end

    if IsNull(@p_pretenseCode, '') = ''
		   raiserror('The @p_pretenseCode parameter is compulsory.', 16, 1)

    if not exists(select *
                  from gen.ValueSet vs join gen.Code c on vs.ID = c.ValueSetID
                  where vs.Code = 'VALUESET_PRETENSE'
                    and c.ID = @p_pretenseCode
                 )
    begin
      raiserror('PretenseCode %s does not exist.', 16, 1, @p_pretenseCode)
    end

		if @p_amount is null
			raiserror('The @p_amount parameter is compulsory.', 16, 1)

		if @p_creationDate is null
			raiserror('The @p_creationDate parameter is compulsory.', 16, 1)


    /*Logging start processing*/
    set @logMessage = 'Start processing'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage
		


    select @accountID = a.ID
		from FIN.Account a 
		where a.CalculationID = @p_calculationID 
			and a.AccountTypeID = @accountTypeID
			and a.CurrencyCode = @p_currencyCode 

    /*create account*/  
    if @accountID is null
	  begin
      begin tran
        insert into gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
						  values((SELECT gen.ObjectType.Code from GEN.ObjectType where TableName = 'FIN.Account') , GetDate(), GetDate(), @p_UserName, Concat('FIN.Account by ', @procedureName, ' procedure'), '1.0.0')

				select @objectID = SCOPE_IDENTITY();

				insert into FIN.Account(ObjectID, CalculationID, AccountTypeID, CreationDate, CreationTime, CreationUserName, CurrencyCode)
					values(@objectID, @p_calculationID, @accountTypeID, GetDate(), GetDate(), @p_UserName, @p_currencyCode)

				select @accountID = SCOPE_IDENTITY()  
      commit
    end

    /*create transaction*/
    begin tran
      insert into gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
					  values((SELECT gen.ObjectType.Code from GEN.ObjectType where TableName = 'FIN.Transaction') , GetDate(), GetDate(), @p_UserName, Concat('FIN.Transaction by ', @procedureName, ' procedure'), '1.0.0')

			select @objectID = SCOPE_IDENTITY()

			insert into FIN.[Transaction](ObjectID, AccountID, Amount, AccountingDate, PretenseCode, TransactionTypeCode, AmountLocalCurrency, CreationDate, CreationTime, CreationUserName)
				VALUES(@objectID, @accountID, @p_amount, @p_accountingDate, @p_pretenseCode, @p_transactionTypeCode, @p_amountLocalCurrency, @p_creationDate, @p_creationTime, @p_UserName)

      select @p_transactionID = SCOPE_IDENTITY()
    commit


    /*Logging processing end*/
    set @logMessage = Concat('End procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


  end try
  begin catch
    if @@trancount > 0
       rollback

    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage

    ;THROW
  end catch
end
go

-- =============================================
-- Author:		Bognár Dávid
-- Create date: 2023-06-22
-- Last modified date: 2023-06-22
-- Description:	Deploy Script
-- =============================================
CREATE PROCEDURE [GEN].[DatabaseDeploy]
	-- Tárolt eljárás bemenő paraméterei
  @p_correlationID NVARCHAR(200), --Kötelező paraméter a Session kezelés miatt 
	--További szükséges bemenő paraméterek
  @p_UserName nvarchar(200), 
  @p_Environment nvarchar(200)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'LOG.GetDataChange'; --Naplózás miatt a tárolt eljárás neve
	DECLARE @l_ObjectType NVARCHAR(100);
    DECLARE @l_EntityID numeric(16);
    DECLARE @l_AddressObjectID numeric(16);
    DECLARE @l_ContactObjectID numeric(16);
	--Specifikus változók definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-okat, akkor azok definiálása (opcionális)
	--...
	--Feldolgozás kezdete (kötelező)
	--BEGIN TRAN

    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,           -- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Paraméterek ellenőrzése

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Feldolgozás. 
		--Amennyiben példányosított modul, akkor a példány feldolgozottságának frissítése az ORG.ModuleInstance.Progress mező módosítása
			

			INSERT INTO LOG.DeployLog (UserName, Environment, Version, CreationDate, CreationTime)
		SELECT 
		    @p_UserName,
			@p_Environment,
			null,
			CAST( GETDATE() AS Date ),
			CAST( GETDATE() AS Time );

			

------------------------------------
------------Törzs-------------------
------------------------------------
------------------------------------

--Settings
--VIR
--DDL
--DML















------------------------------------
------------Törzs vége--------------
------------------------------------
------------------------------------



		
		--Naplóbejegyzés a befejezésről (kötelező)
		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;                  --LogMessage
			
		--COMMIT TRAN

		RETURN 1;

	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'cursor neve');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE tenderItem_cursor;

			DEALLOCATE tenderItem_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
			
		--ROLLBACK TRAN

		SELECT 99;

	END CATCH
END
go

-- =======================================================
-- Author:		GURBAN
-- Create date: 2022,10.04
-- Description:	Return the date in the givan language form.
--		The date MUST be passed.
--		The languge is defined by either AppUserID or LAngDesc
--		If both are given, the AppUser's language will be used.
--		If no languge code is given Hungarioan will be used by default.
-- IMPORTANT:	New languages should be inserted in this funciton
-- =======================================================

CREATE   FUNCTION [GEN].[DateFormatter]
(
   @pDate		DATE,
   @pAppUserID NUMERIC(16,0) = 0,
   @pLangDesc	NVARCHAR(5) = 'HU'
)
RETURNS NVARCHAR(15)
AS
BEGIN

   DECLARE @lResult	NVARCHAR(15) ;
   DECLARE @lCodeLang	NVARCHAR(5)  ;  -- this should be enough
   DECLARE @lCulture	NVARCHAR(5)  ;

   SET @lResult = '-----' ;

   IF @pAppUserID = 0
      SET @lCodeLang = @pLangDesc
   ELSE
      SELECT @lCodeLang = PRT.AppUser.Language
      FROM PRT.AppUser WHERE PRT.AppUser.ID = @pAppUserID

   SELECT @lCulture =
      CASE  WHEN @lCodeLang = 'HU' THEN 'hu-HU'
	    WHEN @lCodeLang = 'EN' THEN 'en-US'
	    ELSE '--' END ;

   SET @lResult = FORMAT (@pDate, 'd', @lCulture) ;

   RETURN (@lResult) ;
END

GO

CREATE       PROCEDURE [IFC].[DebtCaseLoader](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16), @p_moduleInstanceIDInkasso Numeric(16) = null output)

/*
==========================================================================================
 Author:		Tóth Gábor
 Creation date:			2022.10.31.
 Last modified date:	2022.11.07, ObjectType, AppUser = CreationUserName, INTO Gen.Object(DCS.DebtCase)
						2022.11.08, LOG
						2022-11-09: @p_moduleInstanceID, Átnevezés, 999 -> 99
						2022-11-13: "Demo" mód törlése, "SourceInterfaceType" <-> "MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE" csere, SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
						2022-11-18: Ellenőrzések
						2022-11-19: Portfolio insertálása, Error-viszgálat javítása
						2022-11-20: Identified by existing DebtCaseID: + @l_DebtCaseID
						2022-11-22: Identified by existing DebtCaseID: + Cast(@l_DebtCaseID as nvarchar(18))
						2022-11-22: "BEGIN TRANSACTION" ki-kommentelése
						2022-11-25, Azonosságvizsgálat kiterjesztése a PortfolioID-val
						2022-11-28, @PortfolioID
						2022-12-06, @PurchaseDate
						2022-12-07, @PackageID as PackageID, @PartyID as PartyID
						2022-12-07, CRM.Contract ellenőrzés
						2022-12-08, BankAccountNumber
						2022-12-09: @l_contractCheck
						2022-12-09: Összegellenőrzés kivéve 14:55 T.G.
						2022-12-16: CreationUserName
						2023-01-10: declare @CreationUserName NVARCHAR(200);
						2023-01-10: @CreditorEntityID
						2023-01-10: Org.Task.UserId
						2023-01-11: Org.Task.UserId = NULL, Task + ObjectTask
						2023-01-24: @OwnProperty as OwnProperty
						2023.01.27, Set @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
						2023.02.07: @l_ContractId
						2023.02.15: @CurrencyCode and @Currency Empty
						2023.02.22: Hibakezelés
						2023.03.01: Errormessage vesszővel lettek elválasztva
						2023.03.06: ValueSet ellenőrzés: CURRENCY, TASK_MAIN_STATUS, TASK_TYPE_STATUS_DEBT_CASE, DEPARTMENT_TYPE, CREDIT_TYPE, CASE_SECTION, CASE_PHASE
						2023.03.08: @CreditorName / @CreditorEntityID <-- Portfolio.TreatmentTypeCode ='TREATMENT_TYPE_TECHNICAL'
						2023.03.16: ErrorCode-ok
						2023.03.23: CodePrefix like 'CURRENCY%'
						2023.03.27: ErrorCode-ok, ObjectType
						2023.03.27: @CreditorEntityID exists
						2023.03.29: @OwnProperty ellenőrzésének kivétele
						2023.04.17: CreditorCrefoID, ErrorCount
						2023.05.10: If Isnull(@PortfolioID,0) = 0
						2023.05.23: Dcs.DebtCase.DebtNr = (NEXT VALUE FOR IFC.CounterDebtNr)
						2023.05.23: Dcs.DebtCase.MainStatusCode = CASE_MAIN_STATUS_OPEN
						2023.06.01: START WITH 3000000000, RESTART WITH 3000000000
						2023.06.14: DV-631, ORG.Task.DetailsStatusCode helyett Dcs.DebtCase.DetailedStatusCode
						2023.08.29: Contract ellenőrzés paraméterhez kötés
						2023.09.04: select * from IFC.debtcase order by ID desc komment-elése
						2023.10.16: "CreditorEntityID is not Valid, " helyett "EntitiID is not in technical portfolio"
						2023.10.30: @l_AllRowCounts
						2023.11.17: If @CreditTypeCode like 'TAFK55/%'
						2023.11.21: If not exists @..Code..
						2023.11.22: CreditTypeCode --> @CreditTypeCode
						2023.11.29: 'CASE_SECTION_14500' as SectionCode,  -- DV-1837
						2023.12.02: Kritikus és Blokkoló hibák kezelése
						2023.12.07: Konstrukciós kód ellenőrzés DV-1818
						2023.12.09: Kritikus és Blokkoló hibák kezelése DV-1956 - Betöltő eljárás módosítása a IFC.InterfaceError.Errormessage mező töltésére
						2023.12.10: "InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'",  DV-1956
            2023.12.18: CreditTypeCode változás DV-2005 és ConsolidatedProductCode bevezetése DV-1980
                        ConstructionCode létrehozása, ha nincs még DV-2013
            2023.12.18: konstrukciós kód szinkron (+ a precontrol miatt variálás, hogy hibásakra is fusson a létrehozás), az eventkiírás ne itt legyen DV-1920
						2023.12.20: LoanGuaranteedCode, DV-2019
						2023.12.21: OriginalAccountingSystemCode, PartyID, DV-2030
						2023.12.22: DepartmentTypeCode visszahelyezése a kódba, DV-2066
						2023.12.30: Set @CreditorEntityID = (Select top 1 EntityID from IFC.AccountingSystem where code = @AccountingSystemCode order by id desc);, DV-2030 (+ új igény)
						2023.12.30: 'ERR_GENERAL' DV-2006
						2023.12.30: nem kellett változtatni DV-2002, DV-1962
						2023.01.02: @ConstructionCode, DV-2072
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(MAX);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	DECLARE @l_BlockerError nvarchar(1);
	-- ha van blokkoló hiba, akkor @l_BlockerError = 'T',
	-- InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_BLOCKING', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	-- ha csak kritikus hiba van, akkor @l_BlockerError = 'T',
	-- InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	--DECLARE @l_Prev_ModuleInstanceID Numeric(16);
	DECLARE @l_ErrorMessage nvarchar(MAX);


	SET @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
	--SET @l_Prev_ModuleInstanceID = (Select Top 1 ModuleInstanceID from IFC.InterfaceError where TableName = 'IFC.Company' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' order by id desc);

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtCaseLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);


    BEGIN TRY
        SET @LogMessage = 'DebtCaseLoader Started at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;

		Declare @l_DebtCase nvarchar(1); -- DebtCase = 'T'
-----------------------------------------------
		Declare @ID NUMERIC(16);
		Declare @SourceInterfaceType NVARCHAR(200);
		Declare @SourceID NVARCHAR(200);
		Declare @PackageName NVARCHAR(100);
		Declare @PackageCode NVARCHAR(100);
		Declare @PackageID NUMERIC(16);
		Declare @DebtNr NVARCHAR(100);
		Declare @PartyName NVARCHAR(200);
		Declare @PartyID NUMERIC(16);
		Declare @PartyBankAccountNr NVARCHAR(50);
		Declare @CreditorName NVARCHAR(200);
		Declare @CreditorEntityID NUMERIC(16);
		Declare @OwnProperty NVARCHAR(200);
		Declare @PurchasePrice MONEY;
		Declare @PurchasePriceCurrency NVARCHAR(200);
		Declare @PurchasePriceCurrencyCode NVARCHAR(200);
		Declare @PurchaseDate DATE;
		Declare @SalesUserID NVARCHAR(50);
		Declare @UserID NVARCHAR(50);
		--Declare @TaskMainStatusCode NVARCHAR(200);
		--Declare @TaskStatusCode NVARCHAR(200);
		Declare @Currency NVARCHAR(200);
		Declare @CurrencyCode NVARCHAR(200);
		Declare @Comments NVARCHAR(250);
		Declare @Field1 NVARCHAR(200);
		Declare @Field2 NVARCHAR(200);
		Declare @Field3 NVARCHAR(200);
		Declare @Field4 NVARCHAR(200);
		Declare @Field5 NVARCHAR(200);
		Declare @OperationCode NVARCHAR(200);
		Declare @DebtCaseID NUMERIC(16);
		Declare @InterfaceStatusCode NVARCHAR(200);
		Declare @InterfaceTableID NUMERIC(16);
		Declare @MainDebtorID NUMERIC(16);
		Declare @Section NVARCHAR(200);
		Declare @SectionCode NVARCHAR(200);
		Declare @Phase NVARCHAR(200);
		Declare @PhaseCode NVARCHAR(200);
		Declare @CloseReason NVARCHAR(200);
		Declare @CloseDate DATE;
		Declare @OfficeID NUMERIC(16);
		Declare @Office NVARCHAR(200);
		Declare @ClientNr NVARCHAR(200);
		Declare @CreationDate DATE;
		Declare @CreationTime TIME;
		Declare @CreationUserName NVARCHAR(200);
		Declare @DepartmentType NVARCHAR(200);
		Declare @DepartmentTypeCode NVARCHAR(200);
		Declare @CreditType NVARCHAR(200);
		Declare @CreditTypeCode NVARCHAR(200);
		Declare @PortfolioID numeric(18);
		--DECLARE @l_contractCheck NVARCHAR(200) = NULL;
		DECLARE @l_collectionContractItemID NUMERIC(16) = NULL;
		DECLARE @l_invoiceDebtCapital MONEY = NULL;
		DECLARE @l_invoiceDebtInterest MONEY = NULL;
		DECLARE @l_invoiceDebtPenaltyInterest MONEY = NULL;
		DECLARE @l_invoiceDebtCost MONEY = NULL;
		DECLARE @l_invoiceDebtTotal MONEY = NULL;
		DECLARE @l_invoiceDebtCostLocalCurrency MONEY = NULL;
		DECLARE @l_invoiceCurrencyCode NVARCHAR(200) = NULL;
		DECLARE @l_contractItemDebtCapital MONEY = NULL;
		DECLARE @l_contractItemDebtInterest MONEY = NULL;
		DECLARE @l_contractItemDebtPenaltyInterest MONEY = NULL;
		DECLARE @l_contractItemDebtCost MONEY = NULL;
		DECLARE @l_contractItemDebtTotal MONEY = NULL;
		DECLARE @l_contractItemDebtCostLocalCurrency MONEY = NULL;
		DECLARE @l_contractItemCurrencyCode NVARCHAR(200) = NULL;
		Declare @BankAccountNumber NVARCHAR(200);
		Declare @PortfolioName NVARCHAR(200);
		Declare @ConstructionCode NVARCHAR(200);
	    Declare @ConstructionCode_Level1 NVARCHAR(200), @ConstructionCode_Level2 NVARCHAR(200), @ConstructionCode_Level3 NVARCHAR(200), @ConstructionCode_Level4 NVARCHAR(200),
            @ConstructionCode_Level5 NVARCHAR(200), @ConstructionCode_Level6 NVARCHAR(200), @ConstructionCode_Level7 NVARCHAR(200), @ConstructionCodeID Numeric(16)
		Declare @CaseTypeCode NVARCHAR(200);
		Declare @EventTypeCode NVARCHAR(200);
		Declare @ConsolidatedProductID Numeric(16);
		Declare @ConsolidatedProductCode NVARCHAR(200);
		Declare @LoanGuaranteedCode Nvarchar(200);
		Declare @AccountingSystem Nvarchar(200);
		Declare @AccountingSystemCode Nvarchar(200);

		Declare @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		Declare @l_EntityID numeric(18);
		Declare @l_ObjectID numeric(18);
		Declare @l_CalculationID numeric(18);

		Declare @l_DebtCaseObjectID numeric(18);
		Declare	@l_OrgTaskID numeric(18);
		Declare @l_ContractId numeric(18);



		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ExisingRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);
		Declare @l_DebtCaseID numeric(18);
		Declare @l_CurrencyCode nvarchar(100);

		DECLARE @ValueSetId numeric(16);
		DECLARE @FieldCodeOut nvarchar(200);


		DECLARE @FINCalculation nVarchar(500);
		DECLARE @DCSDebtCase nVarchar(500);
		DECLARE @ORGTask nVarchar(500);
		DECLARE @ORGObjectTask nVarchar(500);

		--DECLARE @l_MappingId numeric(18);

		DECLARE @ERR_SIFTYPE_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SIFTYPE_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_SID_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SID_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_COLLECTIONCONTRACTITEMID_IS_NOT_FOUND nvarchar(200);
			SET @ERR_COLLECTIONCONTRACTITEMID_IS_NOT_FOUND = 'ERR_GENERAL';
		DECLARE @ERR_NOT_FOUND_ASSIGNED_PARTY nvarchar(200);
			SET @ERR_NOT_FOUND_ASSIGNED_PARTY = 'ERR_GENERAL';
		DECLARE @ERR_PARTY_NAME_IS_NOT_VALID nvarchar(200);
			SET @ERR_PARTY_NAME_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_PARTY_ID_IS_NOT_VALID nvarchar(200);
			SET @ERR_PARTY_ID_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_PORTFOLIO_NAME_IS_EMPTY nvarchar(200);
			SET @ERR_PORTFOLIO_NAME_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_PORTFOLIO_ID_IS_EMPTY nvarchar(200);
			SET @ERR_PORTFOLIO_ID_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_PORTFOLIO_NAME_IS_NOT_EXIST nvarchar(200);
			SET @ERR_PORTFOLIO_NAME_IS_NOT_EXIST = 'ERR_GENERAL';
		DECLARE @ERR_PORTFOLIO_ID_IS_NOT_EXIST nvarchar(200);
			SET @ERR_PORTFOLIO_ID_IS_NOT_EXIST = 'ERR_GENERAL';
		DECLARE @ERR_PURCHASEPRICECURRENCY_IS_EMPTY nvarchar(200);
			SET @ERR_PURCHASEPRICECURRENCY_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_PURCHASEPRICECURRENCY_ID_IS_EMPTY nvarchar(200);
			SET @ERR_PURCHASEPRICECURRENCY_ID_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_PURCHASEPRICECURRENCY_IS_NOT_VALID nvarchar(200);
			SET @ERR_PURCHASEPRICECURRENCY_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_PURCHASEPRICECURRENCYCODE_IS_NOT_VALID nvarchar(200);
			SET @ERR_PURCHASEPRICECURRENCYCODE_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_CURRENCY_IS_EMPTY nvarchar(200);
			SET @ERR_CURRENCY_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_CURRENCY_CODE_IS_EMPTY nvarchar(200);
			SET @ERR_CURRENCY_CODE_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_CURRENCY_IS_NOT_VALID nvarchar(200);
			SET @ERR_CURRENCY_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_CURRENCYCODE_IS_NOT_VALID nvarchar(200);
			SET @ERR_CURRENCYCODE_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_ORIGINALCREDITORENTITYID_CANNOT_BE_NULL nvarchar(200);
			SET @ERR_ORIGINALCREDITORENTITYID_CANNOT_BE_NULL = 'ERR_GENERAL';
		DECLARE @ERR_ORIGINALCREDITORNAME_NOT_VALID nvarchar(200);
			SET @ERR_ORIGINALCREDITORNAME_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_ORIGINALCREDITORENTITY_NOT_TECHNICAL_PORTFOLIO nvarchar(200);
			SET @ERR_ORIGINALCREDITORENTITY_NOT_TECHNICAL_PORTFOLIO = 'ERR_GENERAL';
		DECLARE @GENERAL nvarchar(200);
			SET @GENERAL = 'ERR_GENERAL';
		DECLARE @ERR_CREDITTYPE_IS_NOT_VALID nvarchar(200);
			SET @ERR_CREDITTYPE_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_CREDITTYPECODE_IS_NOT_VALID nvarchar(200);
			SET @ERR_CREDITTYPECODE_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_DEPARTMENTTYPE_IS_NOT_VALID nvarchar(200);
			SET @ERR_DEPARTMENTTYPE_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_DEPARTMENTTYPECODE_IS_NOT_VALID nvarchar(200);
			SET @ERR_DEPARTMENTTYPECODE_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_ConsolidatedProductCode_IS_NOT_VALID nvarchar(200);
			SET @ERR_ConsolidatedProductCode_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_ConsolidatedProductCaseTypeCode_IS_NOT_VALID nvarchar(200);
			SET @ERR_ConsolidatedProductCaseTypeCode_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_ConsolidatedProductEventTypeCode_IS_NOT_VALID nvarchar(200);
			SET @ERR_ConsolidatedProductEventTypeCode_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_LoanGuaranteedCode_IS_EMPTY nvarchar(200);
			SET @ERR_LoanGuaranteedCode_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_LoanGuaranteedCode_IS_NOT_VALID nvarchar(200);
			SET @ERR_LoanGuaranteedCode_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_AccountingSystem_IS_EMPTY nvarchar(200);
			SET @ERR_AccountingSystem_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_AccountingSystem_IS_NOT_VALID nvarchar(200);
			SET @ERR_AccountingSystem_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_AccountingSystem_ID_IS_EMPTY nvarchar(200);
			SET @ERR_AccountingSystem_ID_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_AccountingSystemCODE_IS_NOT_VALID nvarchar(200);
			SET @ERR_AccountingSystemCODE_IS_NOT_VALID = 'ERR_GENERAL';


    DECLARE @l_InkassoSyncOnConstructionCode int = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'ConstructionCode', 'insert')

		SET @FINCalculation = (Select Top 1 Code from GEN.ObjectType where TableName = 'FIN.CALCULATION' order by TableName desc);
		SET @DCSDebtCase = (Select Top 1 Code from GEN.ObjectType where TableName = 'DCS.DEBTCASE' order by TableName desc);
		SET @ORGTask = (Select Top 1 Code from GEN.ObjectType where TableName = 'ORG.TASK' order by TableName desc);
		SET @ORGObjectTask = (Select Top 1 Code from GEN.ObjectType where TableName = 'ORG.OBJECTTASK' order by TableName desc);


/* *************************************************************************************************************** */
		--Set @l_PortfolioID = (Select Portfolio.ID from GEN.Portfolio where Portfolio.[Name] = 'Portfolio3');
/* *************************************************************************************************************** */




		SET @l_AllRowCounts = 0;
		SET @l_ImportedRowCounts = 0;
		SET @l_ExisingRowCounts = 0;
		SET @l_ErrorRowCounts = 0;

		--Set @l_MappingId = (Select Top 1 Id from IFC.Mapping where Mapping.Name = 'Konstrukciós kód alapján termék típus meghatározás(TA)' order by Mapping.Id desc);

-- Számláló létrehozása:
		If Not exists(select 1 from sys.sequences where name = 'CounterDebtNr')
		Begin
			CREATE SEQUENCE IFC.CounterDebtNr
			START WITH 3000000000
			INCREMENT BY 1 ;
		End;
-- Számláló beállítása:
		If (SELECT start_value FROM sys.sequences WHERE name = 'CounterDebtNr') <> 3000000000
		Begin
			ALTER SEQUENCE IFC.CounterDebtNr
			RESTART WITH 3000000000;
		End;

		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
				AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END;

		IF COALESCE(@l_sourceInterfaceType, '') = ''
			RAISERROR('The SourceInterfaceType field in ParameterValue is not defined!', 16, 1);


    /*hiányzó constructionCode-ok létrehozása (a hibásak között is keresünk, mert ha a PreControl is futott, akkor már hibáson lesz a státusz).
      maga a létrehozás azért itt van, hogy az Inkasso szinkront könnyen tudjuk kezelni
    */
    declare cur cursor local fast_forward for
      SELECT distinct dc.ConstructionCode, dc.Level1, dc.Level2, dc.Level3, dc.Level4, dc.Level5, dc.Level6, dc.Level7
		  FROM IFC.DebtCase dc
		  where dc.SourceInterfaceType = @l_sourceInterfaceType
        and dc.ConstructionCode is not null
        and not exists(select *
                       from FIN.ConstructionCode c
                       where c.Code = dc.ConstructionCode
                      )
    open cur
    while 1 = 1
    begin
      fetch next from cur into @ConstructionCode, @ConstructionCode_Level1, @ConstructionCode_Level2, @ConstructionCode_Level3, @ConstructionCode_Level4, @ConstructionCode_Level5, @ConstructionCode_Level6, @ConstructionCode_Level7
      if @@fetch_status <> 0
         break

      begin tran
        insert into FIN.ConstructionCode(Code, Level1, Level2, Level3, Level4, Level5, Level6, Level7, CreationDate, CreationTime, CreationUsername)
  			  select @ConstructionCode Code, @ConstructionCode_Level1, @ConstructionCode_Level2, @ConstructionCode_Level3, @ConstructionCode_Level4, @ConstructionCode_Level5,
                 @ConstructionCode_Level6, @ConstructionCode_Level7, GetDate() CreationDate, GetDate() CreationTime, @CurrentUserName CreationUsername
	  		  where not exists(select *
                           from FIN.ConstructionCode
                           where ConstructionCode.Code = @ConstructionCode
                          )

        if @l_InkassoSyncOnConstructionCode = 1
        begin
          select @ConstructionCodeID = SCOPE_IDENTITY()

          if @ConstructionCodeID is not null
              exec IFC.GenerateSendInkassoSyncData @syncType = 'ConstructionCode',
                                                   @syncEventType = 'insert',
                                                   @entityID = null,
                                                   @ID = @ConstructionCodeID,
                                                   @debtCaseID = null,
                                                   @dataChangedUserName = @CurrentUserName,
                                                   @correlationID = @p_correlationID,
                                                   @moduleInstanceID = @p_moduleInstanceIDInkasso output,
                                                   @isBatch = 1
        end
      commit
    end

    close cur
    deallocate cur
    /*constructionCode-ok létrehozásának vége*/


		SET @l_AllRowCounts = (Select Count(*) FROM IFC.DebtCase where SourceInterfaceType = @l_sourceInterfaceType
					and
					(
					(DebtCase.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and DebtCase.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.DebtCase' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));

		DECLARE db_cursor CURSOR FOR
		SELECT ID,
			SourceInterfaceType, SourceID, PackageName, PackageCode, PackageID, DebtNr, PartyName, PartyID, PartyBankAccountNr, CreditorName, CreditorEntityID, OwnProperty,
			PurchasePrice, PurchasePriceCurrency, PurchasePriceCurrencyCode, PurchaseDate, SalesUserID, UserID, /*TaskMainStatusCode,*/ /*TaskStatusCode,*/ Currency, CurrencyCode,
			Comments, Field1, Field2, Field3, Field4, Field5, OperationCode, /*DebtCaseID,*/ InterfaceStatusCode, ErrorMessage, InterfaceTableID, MainDebtorID, Section,
			SectionCode, Phase, PhaseCode, CloseReason, CloseDate, OfficeID, Office, ClientNr, CreationDate, CreationTime, CreationUserName, DepartmentType, DepartmentTypeCode,
			CreditType, CreditTypeCode, PortfolioID, PortfolioName, BankAccountNumber, ConstructionCode, LoanGuaranteedCode
		FROM IFC.DebtCase
		where SourceInterfaceType = @l_sourceInterfaceType
					and
					(
					(DebtCase.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and DebtCase.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.DebtCase' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
		order by id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID,
			@SourceInterfaceType, @SourceID, @PackageName, @PackageCode, @PackageID, @DebtNr, @PartyName, @PartyID, @PartyBankAccountNr, @CreditorName, @CreditorEntityID, @OwnProperty,
			@PurchasePrice, @PurchasePriceCurrency, @PurchasePriceCurrencyCode, @PurchaseDate, @SalesUserID, @UserID, /*@TaskMainStatusCode,*/ /*@TaskStatusCode,*/ @Currency, @CurrencyCode,
			@Comments, @Field1, @Field2, @Field3, @Field4, @Field5, @OperationCode, /*@DebtCaseID,*/ @InterfaceStatusCode, @ErrorMessage, @InterfaceTableID, @MainDebtorID, @Section,
			@SectionCode, @Phase, @PhaseCode, @CloseReason, @CloseDate, @OfficeID, @Office, @ClientNr, @CreationDate, @CreationTime, @CreationUserName, @DepartmentType, @DepartmentTypeCode,
			@CreditType, @CreditTypeCode, @PortfolioID, @PortfolioName, @BankAccountNumber, @ConstructionCode, @LoanGuaranteedCode


		WHILE @@FETCH_STATUS = 0
		BEGIN

		Set @SourceID = Trim(@SourceID);

---------------------------------------------------------------------------------------------------------------------------------------------
	BEGIN TRY /* Belső-1 */
-- Error Section:
			SET @ErrorMessage = NULL;
			SET @l_BlockerError = '';
      SET @ConsolidatedProductID = null;
			SET @ConsolidatedProductCode = null;
			SET @CaseTypeCode = null;
			SET	@EventTypeCode = null;

---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceInterfaceType:
			IF Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceInterfaceType is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'sourceInterfaceType', @ERR_SIFTYPE_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceID:
			IF Trim(Isnull(@SourceID,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'sourceID', @ERR_SID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
--Check contract:
		SELECT @l_collectionContractItemID = NULL;

-- ContractID beolvasása kézi (excel-es) betöltés esetén:
		Set @l_ContractId = NULL;
		If Exists (Select 1 From IFC.InterfacePackage where SourceInterfaceType = @l_sourceInterfaceType)
		Begin
			Set @l_ContractId = (Select Top 1 ContractId From IFC.InterfacePackage where SourceInterfaceType = @l_sourceInterfaceType order by id desc);
		End;

		IF COALESCE(@ErrorMessage, '') = ''
		BEGIN
			IF Exists (Select 1 from ORG.ModuleInstanceParameter
			where ModuleInstanceID = @p_moduleInstanceID
			and ParameterValue = 'BOOLEAN_TRUE'
			and ParameterCode = 'MODULE_PARAMETER_IFC_CONTRACT_CHECK')
			--IF COALESCE(@l_contractCheck, 'BOOLEAN_FALSE') = 'BOOLEAN_TRUE'
			BEGIN
				IF @l_ContractId is NULL /* TA-s betöltés */
				Begin
					SELECT @l_collectionContractItemID = [CollectionContractItem].[ID]
					FROM [CRM].[CollectionContractItem]
					JOIN [CRM].[ContractItem] ON ([ContractItem].[ID] = [CollectionContractItem].[ContractItemID])
					JOIN [CRM].[Contract] ON ([Contract].[ID] = [ContractItem].[ContractID])
					WHERE [Contract].[ContractPhaseCode] = 'CONTRACT_PHASE_CONTRACT'
					AND [Contract].[StatusCode] = 'CONTRACT_STATUS_CONTRACT_VALID'
					AND [CollectionContractItem].[AccountNr] = @BankAccountNumber
					AND COALESCE([CollectionContractItem].[DebtCaseID], 0) = 0;
				End
				Else /* Kézi, Excel-es betöltés */
				Begin
					SELECT @l_collectionContractItemID = [CollectionContractItem].[ID]
					FROM [CRM].[CollectionContractItem]
					JOIN [CRM].[ContractItem] ON ([ContractItem].[ID] = [CollectionContractItem].[ContractItemID])
					JOIN [CRM].[Contract] ON ([Contract].[ID] = [ContractItem].[ContractID])
					WHERE [Contract].[ContractPhaseCode] = 'CONTRACT_PHASE_CONTRACT'
					AND [Contract].[StatusCode] = 'CONTRACT_STATUS_CONTRACT_VALID'
					AND [CollectionContractItem].[AccountNr] = @BankAccountNumber
					AND COALESCE([CollectionContractItem].[DebtCaseID], 0) = 0
					AND [Contract].[ID] = @l_ContractId;
				End;

				IF COALESCE(@l_collectionContractItemID, 0) = 0
					Begin
						Set @l_ErrorMessage = 'Contract item is not found';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'sourceID', @ERR_COLLECTIONCONTRACTITEMID_IS_NOT_FOUND, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
					End
				ELSE
				BEGIN
					SELECT
						@l_contractItemDebtCapital = [CollectionContractItem].[DebtCapital],
						@l_contractItemDebtInterest = [CollectionContractItem].[DebtInterest],
						@l_contractItemDebtPenaltyInterest = [CollectionContractItem].[DebtPenaltyInterest],
						@l_contractItemDebtCost = [CollectionContractItem].[DebtCost],
						@l_contractItemDebtTotal = [CollectionContractItem].[DebtTotal],
						@l_contractItemDebtCostLocalCurrency = [CollectionContractItem].[DebtCostLocalCurrency],
						@l_contractItemCurrencyCode = [CollectionContractItem].[CurrencyCode]
					FROM [IFC].[CollectionContractItem]
					WHERE [CollectionContractItem].[ID] = @l_collectionContractItemID;

					SELECT
						@l_invoiceDebtCapital = SUM([Invoice].[ArrearsCapital]),
						@l_invoiceDebtInterest = SUM([Invoice].[ArrearsInterest]),
						@l_invoiceDebtPenaltyInterest = SUM([Invoice].[ArrearsPenaltyInterest]),
						@l_invoiceDebtCost = SUM([Invoice].[ArrearsCost]),
						@l_invoiceDebtTotal = SUM([Invoice].[ArrearsCapital]) +
							SUM([Invoice].[ArrearsInterest]) +
							SUM([Invoice].[ArrearsPenaltyInterest]) +
							SUM([Invoice].[ArrearsCost]),
						@l_invoiceDebtCostLocalCurrency = SUM([Invoice].[ArrearsCostLocalCurrency]),
						@l_invoiceCurrencyCode = (SELECT TOP 1 [Inv].[CurrencyCode]
						FROM [IFC].[Invoice] AS Inv
						WHERE [Inv].[SourceInterfaceType] = @SourceInterfaceType
							AND [Inv].[SourceDebtCaseID] = [Invoice].[SourceDebtCaseID]
						ORDER BY [Inv].[ID])
					FROM [IFC].[DebtCase]
					JOIN [IFC].[Invoice] ON
						([Invoice].[SourceInterfaceType] = [DebtCase].[SourceInterfaceType] AND [Invoice].[SourceDebtCaseID] = [DebtCase].[SourceID])
					WHERE [DebtCase].[SourceInterfaceType] = @SourceInterfaceType
						AND [DebtCase].[SourceID] = @SourceID
						AND [Invoice].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
					GROUP BY [Invoice].[SourceDebtCaseID];

/* Teszteléshez kivéve 2022-12-09, 14:54 T.G.
					IF COALESCE(@l_contractItemDebtCapital, 0) <> COALESCE(@l_invoiceDebtCapital, 0)
						SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') +
							' The capital amount specified in the contract does not match the capital amount of the case,')

					IF COALESCE(@l_contractItemDebtInterest, 0) <> COALESCE(@l_invoiceDebtInterest, 0)
						SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') +
							' The interest amount specified in the contract does not match the interest amount of the case,')

					IF COALESCE(@l_contractItemDebtPenaltyInterest, 0) <> COALESCE(@l_invoiceDebtPenaltyInterest, 0)
						SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') +
							' The penalty interest amount specified in the contract does not match the penalty interest amount of the case,')

					IF COALESCE(@l_contractItemDebtCost, 0) <> COALESCE(@l_invoiceDebtCost, 0)
						SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') +
							' The cost amount specified in the contract does not match the cost amount of the case,')

					IF COALESCE(@l_contractItemDebtTotal, 0) <> COALESCE(@l_invoiceDebtTotal, 0)
						SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') +
							' The total amount specified in the contract does not match the total amount of the case,')

					IF COALESCE(@l_contractItemDebtCostLocalCurrency, 0) <> COALESCE(@l_invoiceDebtCostLocalCurrency, 0)
						SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') +
							' The cost local currency amount specified in the contract does not match the cost local currency amount of the case,')

					IF COALESCE(@l_contractItemCurrencyCode, '') <> COALESCE(@l_invoiceCurrencyCode, '')
						SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') +
							' The currency specified in the contract does not match the currency of the case,')
*/
				END
			END
		END;
---------------------------------------------------------------------------------------------------------------------------------------------


/*
PackageName
*/

-- @Phase,@PhaseCode:
/* Nem kell, ki lehet hagyni, nincs rá külső kulcs  (2023-12-02)
			-- 0 - NULL:
			If Trim(Isnull(@Phase,'')) = ''
				Set @Phase = NULL;
			If Trim(Isnull(@PhaseCode,'')) = ''
				Set @PhaseCode = NULL;
			Set @Phase = Trim(@Phase);
			Set @PhaseCode = Trim(@PhaseCode);

			-- 1 - Üres:
			If @Phase is NULL and @PhaseCode is NULL
			BEGIN
				SET @ErrorMessage = @ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			If @Phase is NOT NULL and @PhaseCode is NULL
			BEGIN
				If Not exists (
						select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'PHASE_%'
						and Translation.Text = @Phase)
					Begin
						Set @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Phase is not Valid,');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
						Select 'IFC.DEBTCASE', @ID, 'phase', @ERR_CODE_NAME_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
						Set @Phase = NULL;
					End;
				Else
					Set @PhaseCode = (select Top 1 Code.Id
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'PHASE_%'
						and Translation.Text = @Phase order by Code.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @Phase is NULL and @PhaseCode is not NULL
			and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'PHASE_%'
						and Code.Id = @PhaseCode)
			BEGIN
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' PhaseCode is not Valid,');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select 'IFC.DEBTCASE', @ID, 'phaseCode', @ERR_CODE_CODE_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				Set @PhaseCode = NULL;
			END;
*/


---------------------------------------------------------------------------------------------------------------------------------------------
-- @AccountingSystem,@AccountingSystemCode:
IF @SourceInterfaceType like 'OTPTA_%'
Begin
			-- 0 - NULL:
			If Trim(Isnull(@AccountingSystem,'')) = ''
				Set @AccountingSystem = NULL;
			If Trim(Isnull(@AccountingSystemCode,'')) = ''
				Set @AccountingSystemCode = NULL;
			Set @AccountingSystem = Trim(@AccountingSystem);
			Set @AccountingSystemCode = Trim(@AccountingSystemCode);

			-- 1 - Üres:
			If @AccountingSystem is NULL and @AccountingSystemCode is NULL
			BEGIN
						Set @l_ErrorMessage = 'AccountingSystem/AccountingSystemCode is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'accountingSystem', @ERR_AccountingSystem_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'accountingSystemCode', @ERR_AccountingSystem_ID_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
			-- 2 - Text-NotValid:
			If @AccountingSystem is NOT NULL and @AccountingSystemCode is NULL
			BEGIN
				If Not exists (
						select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'ACCOUNTING_SYSTEM'
						and Translation.Text = @AccountingSystem)
					Begin
						Set @l_ErrorMessage = 'AccountingSystem is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'accountingSystem', @ERR_AccountingSystem_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @AccountingSystem = NULL;
					End;
				Else
					Set @AccountingSystemCode = (select Top 1 Code.Id
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'ACCOUNTING_SYSTEM'
						and Translation.Text = @AccountingSystem order by Code.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @AccountingSystem is NULL and @AccountingSystemCode is not NULL
			and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'ACCOUNTING_SYSTEM'
						and Code.Id = @AccountingSystemCode)
			BEGIN
						Set @l_ErrorMessage = 'AccountingSystemCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'accountingSystemCode', @ERR_AccountingSystemCODE_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @AccountingSystemCode = NULL;
			END;

	Set @PartyID = (Select top 1 PartyID from IFC.AccountingSystem where code = @AccountingSystemCode order by id desc);
	Set @CreditorEntityID = (Select top 1 EntityID from IFC.AccountingSystem where code = @AccountingSystemCode order by id desc);
	Set @CreditorName = NULL;
			IF Isnull(@CreditorEntityID, 0) = 0
			BEGIN
						Set @l_ErrorMessage = 'EntityId In IFC.AccountingSystem is not Exists';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'accountingSystemCode', @ERR_AccountingSystemCODE_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @AccountingSystemCode = NULL;
			END;

End; --IF @SourceInterfaceType like 'OTPTA_%'
---------------------------------------------------------------------------------------------------------------------------------------------
-- @PartyName,@PartyID:
			-- 0 - NULL:
			If Trim(Isnull(@PartyName,'')) = ''
				Set @PartyName = NULL;
			If Isnull(@PartyID,0) = 0
				Set @PartyID = NULL;
			Set @PartyName = Trim(@PartyName);

			-- 1 - Üres:
			If @PartyName is NULL and @PartyID is NULL
			BEGIN
						Set @l_ErrorMessage = 'PartyName/ID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'partyName', @ERR_NOT_FOUND_ASSIGNED_PARTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'partyID', @ERR_NOT_FOUND_ASSIGNED_PARTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
			-- 2 - Text-NotValid:
			If @PartyName is NOT NULL and @PartyID is NULL
			BEGIN
				If Not exists (Select 1 from Prt.Party join Prt.Company on Company.EntityID = Party.EntityID where Company.Name = @PartyName)
					Begin
						Set @l_ErrorMessage = 'PartyName is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'partyName', @ERR_PARTY_NAME_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @PartyName = NULL;
					End;
				Else
					Set @PartyID = (select Top 1 Party.Id from Prt.Party join Prt.Company on Company.EntityID = Party.EntityID where Company.Name = @PartyName order by Party.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @PartyName is NULL and @PartyID is not NULL
			and Not exists (Select 1 from Prt.Party join Prt.Company on Company.EntityID = Party.EntityID where Party.Id = @PartyID)
			BEGIN
						Set @l_ErrorMessage = 'PartyID is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'partyID', @ERR_PARTY_ID_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @PartyID = NULL;
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
-- @PortfolioName,@PortfolioID:
			-- 0 - NULL:
			If Trim(Isnull(@PortfolioName,'')) = ''
				Set @PortfolioName = NULL;
			If Isnull(@PortfolioID,0) = 0
				Set @PortfolioID = NULL;
			Set @PortfolioName = Trim(@PortfolioName);

			-- 1 - Üres:
			If @PortfolioName is NULL and @PortfolioID is NULL
			BEGIN
						Set @l_ErrorMessage = 'PortfolioName and ID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'portfolioName', @ERR_PORTFOLIO_NAME_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'portfolioID', @ERR_PORTFOLIO_ID_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
			-- 2 - Text-NotValid:
			If @PortfolioName is NOT NULL and @PortfolioID is NULL
			BEGIN
				If Not exists (select 1 from Gen.Portfolio where Name = @PortfolioName)
				BEGIN
						Set @l_ErrorMessage = 'PortfolioName is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'portfolioName', @ERR_PORTFOLIO_NAME_IS_NOT_EXIST, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @PortfolioName = NULL;
				END;
				Else
					Set @PortfolioID = (select Top 1 Id from Gen.Portfolio where Name = @PortfolioName order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @PortfolioName is NULL and @PortfolioID is not NULL
			and Not exists (select 1 from Gen.Portfolio where Id = @PortfolioID)
			BEGIN
						Set @l_ErrorMessage = 'PortfolioID is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'portfolioID', @ERR_PORTFOLIO_ID_IS_NOT_EXIST, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @PortfolioID = NULL;
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
-- @PurchasePriceCurrency,@PurchasePriceCurrencyCode:
			-- 0 - NULL:
			If Trim(Isnull(@PurchasePriceCurrency,'')) = ''
				Set @PurchasePriceCurrency = NULL;
			If Trim(Isnull(@PurchasePriceCurrencyCode,'')) = ''
				Set @PurchasePriceCurrencyCode = NULL;
			Set @PurchasePriceCurrency = Trim(@PurchasePriceCurrency);
			Set @PurchasePriceCurrencyCode = Trim(@PurchasePriceCurrencyCode);

			-- 1 - Üres:
			If @PurchasePriceCurrency is NULL and @PurchasePriceCurrencyCode is NULL
			BEGIN
						Set @l_ErrorMessage = 'PurchasePriceCurrency/PurchasePriceCurrencyCode is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'purchasePriceCurrency', @ERR_PURCHASEPRICECURRENCY_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'purchasePriceCurrencyCode', @ERR_PURCHASEPRICECURRENCY_ID_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
			-- 2 - Text-NotValid:
			If @PurchasePriceCurrency is NOT NULL and @PurchasePriceCurrencyCode is NULL
			BEGIN
				If Not exists (
						select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CURRENCY%'
						and Translation.Text = @PurchasePriceCurrency)
					Begin
						Set @l_ErrorMessage = 'PurchasePriceCurrency is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'purchasePriceCurrency', @ERR_PURCHASEPRICECURRENCY_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @PurchasePriceCurrency = NULL;
					End;
				Else
					Set @PurchasePriceCurrencyCode = (select Top 1 Code.Id
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CURRENCY%'
						and Translation.Text = @PurchasePriceCurrency order by Code.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @PurchasePriceCurrency is NULL and @PurchasePriceCurrencyCode is not NULL
			and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CURRENCY%'
						and Code.Id = @PurchasePriceCurrencyCode)
			BEGIN
						Set @l_ErrorMessage = 'PurchasePriceCurrencyCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'purchasePriceCurrencyCode', @ERR_PURCHASEPRICECURRENCYCODE_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @PurchasePriceCurrencyCode = NULL;
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
    IF Trim(Isnull(@ConstructionCode,'')) = ''
		BEGIN
			set @l_ErrorMessage = 'ConstructionCode is empty'
      SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
			Select 'IFC.DEBTCASE', @ID, 'constructionCode', @ERR_ConsolidatedProductCode_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
     	SET @l_BlockerError = 'T';
		END

		Select @ConsolidatedProductID = fx.ConsolidatedProductID,
           @ConsolidatedProductCode = ConsolidatedProduct.Code,
				   @CaseTypeCode = ConsolidatedProduct.CaseTypeCode,
				   @EventTypeCode = ConsolidatedProduct.EventTypeCode
		from FIN.ConstructionCode fx
				join FIN.ConsolidatedProduct on ConsolidatedProduct.Id = fx.ConsolidatedProductID
		where fx.Code = @ConstructionCode and Isnull(fx.ConsolidatedProductID,0) <> 0;

		If not exists (Select 1 from Gen.Code where Id = @ConsolidatedProductCode)
		BEGIN
					select @l_ErrorMessage = Case when @ConsolidatedProductID is null then 'ConsolidatedProductID not found in FIN.ConstructionCode' else 'ConsolidatedProductCode is not Valid in FIN.ConsolidatedProduct' end;
					SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
					Select 'IFC.DEBTCASE', @ID, 'constructionCode', @ERR_ConsolidatedProductCode_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
          set @ConsolidatedProductID = null
					Set @ConsolidatedProductCode = NULL;
					SET @l_BlockerError = 'T';
		END;
		If not exists (Select 1 from Gen.Code where Id = @CaseTypeCode)
			BEGIN
						Set @l_ErrorMessage = 'CaseTypeCode is not Valid in FIN.ConsolidatedProduct';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'constructionCode', @ERR_ConsolidatedProductCaseTypeCode_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @CaseTypeCode = NULL;
						SET @l_BlockerError = 'T';
			END;
		If not exists (Select 1 from Gen.Code where Id = @EventTypeCode)
			BEGIN
						Set @l_ErrorMessage = 'EventTypeCode is not Valid in FIN.ConsolidatedProduct';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'constructionCode', @ERR_ConsolidatedProductEventTypeCode_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @EventTypeCode = NULL;
						SET @l_BlockerError = 'T';
			END;

---------------------------------------------------------------------------------------------------------------------------------------------
-- @LoanGuaranteedCode:

			-- 0 - NULL: ide..
			If Trim(Isnull(@LoanGuaranteedCode,'')) = ''
				Set @LoanGuaranteedCode = NULL;
			Set @LoanGuaranteedCode = Trim(@LoanGuaranteedCode);

			-- 1 - Üres:
			If @LoanGuaranteedCode is NULL
			BEGIN
						Set @l_ErrorMessage = 'LoanGuaranteedCode is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'loanGuaranteedCode', @ERR_LoanGuaranteedCode_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			If Trim(@LoanGuaranteedCode) not in ('I', 'N')
			BEGIN
						Set @l_ErrorMessage = 'LoanGuaranteedCode is not Valid (I/N)';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'loanGuaranteedCode', @ERR_LoanGuaranteedCode_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @LoanGuaranteedCode = NULL;
			END;


---------------------------------------------------------------------------------------------------------------------------------------------

-- Hibakiírás:
		IF @l_BlockerError = 'T'
		BEGIN
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			UPDATE IFC.DebtCase SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = Trim(Isnull(@ErrorMessage,'')), LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName  WHERE ID = @ID;
		END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Betöltés:
		IF @l_BlockerError = ''
		BEGIN
---------------------------------------------------------------------------------------------------------------------------------------------
			If Trim(@LoanGuaranteedCode) = 'I'
			Begin
				Set @LoanGuaranteedCode = 'BOOLEAN_TRUE';
			End
			Else
			Begin
				If Trim(@LoanGuaranteedCode) = 'N'
				Begin
					Set @LoanGuaranteedCode = 'BOOLEAN_FALSE';
				End;
			End;

---------------------------------------------------------------------------------------------------------------------------------------------
-- @Currency,@CurrencyCode:
			-- 0 - NULL:
			If Trim(Isnull(@Currency,'')) = ''
				Set @Currency = NULL;
			If Trim(Isnull(@CurrencyCode,'')) = ''
				Set @CurrencyCode = NULL;
			Set @Currency = Trim(@Currency);
			Set @CurrencyCode = Trim(@CurrencyCode);

			-- 1 - Üres:
			If @Currency is NULL and @CurrencyCode is NULL
			BEGIN
						Set @l_ErrorMessage = 'Currency/CurrencyCode is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'currency', @ERR_CURRENCY_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'currencyCode', @ERR_CURRENCY_CODE_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			If @Currency is NOT NULL and @CurrencyCode is NULL
			BEGIN
				If Not exists (
						select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CURRENCY%'
						and Translation.Text = @Currency)
					Begin
						Set @l_ErrorMessage = 'Currency is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'currency', @ERR_CURRENCY_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @Currency = NULL;
					End;
				Else
					Set @CurrencyCode = (select Top 1 Code.Id
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CURRENCY%'
						and Translation.Text = @Currency order by Code.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @Currency is NULL and @CurrencyCode is not NULL
			and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CURRENCY%'
						and Code.Id = @CurrencyCode)
			BEGIN
						Set @l_ErrorMessage = 'CurrencyCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'currencyCode', @ERR_CURRENCYCODE_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @CurrencyCode = NULL;
			END;

	---------------------------------------------------------------------------------------------------------------------------------------------
-- @CreditorName,@CreditorEntityID:
			-- 0 - NULL:
			If Trim(Isnull(@CreditorName,'')) = ''
				Set @CreditorName = NULL;
			If Isnull(@CreditorEntityID,0) = 0
				Set @CreditorEntityID = NULL;
			Set @CreditorName = Trim(@CreditorName);

			-- 1 - Üres:
			If @CreditorName is NULL and @CreditorEntityID is NULL
			BEGIN
						Set @l_ErrorMessage = 'CreditorName/ID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'creditorName', @ERR_ORIGINALCREDITORENTITYID_CANNOT_BE_NULL, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'creditorEntityID', @ERR_ORIGINALCREDITORENTITYID_CANNOT_BE_NULL, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			If @CreditorName is NOT NULL and @CreditorEntityID is NULL
			BEGIN
				If not exists (select 1 from PRT.Company
								Join PRT.Entity on Entity.ID = Company.EntityID
								Join GEN.Object on Object.ID = Entity.ObjectID
								Join GEN.Portfolio on Portfolio.ID = Object.PortfolioID
								where Portfolio.TreatmentTypeCode = 'TREATMENT_TYPE_TECHNICAL'
								and Company.Name = @CreditorName)
					Begin
						Set @l_ErrorMessage = 'CreditorName is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'creditorName', @ERR_ORIGINALCREDITORNAME_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @CreditorName = NULL;
					End;
				Else
					Set @CreditorEntityID = (select Top 1 Entity.ID from PRT.Company
								Join PRT.Entity on Entity.ID = Company.EntityID
								Join GEN.Object on Object.ID = Entity.ObjectID
								Join GEN.Portfolio on Portfolio.ID = Object.PortfolioID
								where Portfolio.TreatmentTypeCode ='TREATMENT_TYPE_TECHNICAL'
								and Company.Name = @CreditorName order by Company.ID);
			END;
			-- 3 - Code-NotValid:
			If @CreditorName is NULL and @CreditorEntityID is not NULL
			and exists (select 1 from PRT.Company
								Join PRT.Entity on Entity.ID = Company.EntityID
								Join GEN.Object on Object.ID = Entity.ObjectID
								Join GEN.Portfolio on Portfolio.ID = Object.PortfolioID
								where Portfolio.TreatmentTypeCode <> 'TREATMENT_TYPE_TECHNICAL'
								and Company.EntityID = @CreditorEntityID)
			BEGIN
						Set @l_ErrorMessage = 'EntityID is not in technical portfolio';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTCASE', @ID, 'creditorEntityID', @ERR_ORIGINALCREDITORENTITY_NOT_TECHNICAL_PORTFOLIO, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @CreditorEntityID = NULL;
			END;

			/* 2023-11-17 */
      /*
			If @CreditTypeCode like 'TAFK55/%'
			begin
				If not Exists (select 1 Code from IFC.MappingCode where MappingCode.ExternalCode = Replace(@CreditTypeCode,'TAFK55/','') and Isnull(ValidFrom,CAST( GETDATE() AS Date )) >= CAST( GETDATE() AS Date ) and Isnull(ValidUntil, CAST( GETDATE() AS Date )) <= CAST( GETDATE() AS Date )
							and MappingCode.MappingId = @l_MappingId)
				Begin
						SET @ErrorMessage = Concat(@ErrorMessage, ' CreditTypeCode is not exists in IFC.MappingCode,');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
						Select 'IFC.DEBTCASE', @ID, 'creditTypeCode', @GENERAL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN';
				End
				Else
				Begin
					Set @CreditTypeCode = (select top 1 Code from IFC.MappingCode where MappingCode.ExternalCode = Replace(@CreditTypeCode,'TAFK55/','') and Isnull(ValidFrom,CAST( GETDATE() AS Date )) >= CAST( GETDATE() AS Date ) and Isnull(ValidUntil, CAST( GETDATE() AS Date )) <= CAST( GETDATE() AS Date )
					and MappingCode.MappingId = @l_MappingId order by MappingCode.Id desc);
				End;
			end;
      */

-- @CreditType,@CreditTypeCode:
			-- 0 - NULL:
			If Trim(Isnull(@CreditType,'')) = ''
				Set @CreditType = NULL;
			If Trim(Isnull(@CreditTypeCode,'')) = ''
				Set @CreditTypeCode = NULL;
			Set @CreditType = Trim(@CreditType);
			Set @CreditTypeCode = Trim(@CreditTypeCode);

			-- 1 - Üres:
			If @CreditType is NULL and @CreditTypeCode is NULL
			BEGIN
				SET @ErrorMessage = @ErrorMessage;
				/*  (2023-12-02)
				SET @ErrorMessage = Concat(@ErrorMessage, ' CreditType/CreditTypeCode is Empty,');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
				Select 'IFC.DEBTCASE', @ID, 'creditType', @ERR_CREDITTYPE_IS_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN';
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
				Select 'IFC.DEBTCASE', @ID, 'creditTypeCode', @ERR_CREDITTYPECODE_IS_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN';
				*/
			END;
			-- 2 - Text-NotValid:
			If @CreditType is NOT NULL and @CreditTypeCode is NULL
			BEGIN
				If Not exists (
						select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CREDIT_TYPE%'
						and Translation.Text = @CreditType)
					Begin
						SET @ErrorMessage = Concat(@ErrorMessage, ' CreditType is not Valid,');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
						Select 'IFC.DEBTCASE', @ID, 'creditType', @ERR_CREDITTYPE_IS_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN';
						Set @CreditType = NULL;
					End;
				Else
					Set @CreditTypeCode = (select Top 1 Code.Id
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CREDIT_TYPE%'
						and Translation.Text = @CreditType order by Code.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @CreditType is NULL and @CreditTypeCode is not NULL
			and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CREDIT_TYPE%'
						and Code.Id = @CreditTypeCode)
			BEGIN
						SET @ErrorMessage = Concat(@ErrorMessage, ' CreditTypeCode is not Valid,');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
						Select 'IFC.DEBTCASE', @ID, 'creditTypeCode', @ERR_CREDITTYPECODE_IS_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN';
						Set @CreditType = NULL;
						Set @CreditTypeCode = NULL;
			END;



-- @DepartmentType,@DepartmentTypeCode:
			-- 0 - NULL:
			If Trim(Isnull(@DepartmentType,'')) = ''
				Set @DepartmentType = NULL;
			If Trim(Isnull(@DepartmentTypeCode,'')) = ''
				Set @DepartmentTypeCode = NULL;
			Set @DepartmentType = Trim(@DepartmentType);
			Set @DepartmentTypeCode = Trim(@DepartmentTypeCode);

			-- 1 - Üres:
			If @DepartmentType is NULL and @DepartmentTypeCode is NULL
			BEGIN
				SET @ErrorMessage = @ErrorMessage;
				/*  (2023-12-02)
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' DepartmentType/DepartmentTypeCode is Empty,');;
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
				Select 'IFC.DEBTCASE', @ID, 'departmentType', @ERR_CREDITTYPE_IS_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN';
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
				Select 'IFC.DEBTCASE', @ID, 'departmentTypeCode', @ERR_CREDITTYPECODE_IS_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN';
				*/
			END;
			-- 2 - Text-NotValid:
			If @DepartmentType is NOT NULL and @DepartmentTypeCode is NULL
			BEGIN
				If Not exists (
						select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'DEPARTMENT_TYPE%'
						and Translation.Text = @DepartmentType)
					Begin
						SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' DepartmentType is not Valid,');;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
						Select 'IFC.DEBTCASE', @ID, 'departmentType', @ERR_DEPARTMENTTYPE_IS_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN';
						Set @DepartmentType = NULL;
					End;
				Else
					Set @DepartmentTypeCode = (select Top 1 Code.Id
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'DEPARTMENT_TYPE%'
						and Translation.Text = @DepartmentType order by Code.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @DepartmentType is NULL and @DepartmentTypeCode is not NULL
			and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'DEPARTMENT_TYPE%'
						and Code.Id = @DepartmentTypeCode)
			BEGIN
						SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' DepartmentTypeCode is not Valid,');;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
						Select 'IFC.DEBTCASE', @ID, 'departmentType', @ERR_DEPARTMENTTYPECODE_IS_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN';
						Set @DepartmentTypeCode = NULL;
			END;


-- @TaskStatus,@TaskStatusCode:
/* Nem töltjük be sehová (2023-12-02)
			-- 0 - NULL:
			If Trim(Isnull(@TaskStatusCode,'')) = ''
				Set @TaskStatusCode = NULL;
			Set @TaskStatusCode = Trim(@TaskStatusCode);

			-- 1 - Üres:
			If @TaskStatusCode is NULL
			BEGIN
				SET @ErrorMessage = @ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			-- 3 - Code-NotValid:
			If @TaskStatusCode is not NULL
			and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'TASK_TYPE_STATUS_DEBT_CASE%'
						and Code.Id = @TaskStatusCode)
			BEGIN
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' TaskStatusCode is not Valid,');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select 'IFC.DEBTCASE', @ID, 'taskStatusCode', @ERR_CODE_CODE_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				Set @TaskStatusCode = NULL;
			END;
*/


-- @TaskMainStatus,@TaskMainStatusCode:
/* Nem töltjük be sehová (2023-12-02)
			-- 0 - NULL:
			If Trim(Isnull(@TaskMainStatusCode,'')) = ''
				Set @TaskMainStatusCode = NULL;
			Set @TaskMainStatusCode = Trim(@TaskMainStatusCode);

			-- 1 - Üres:
			If @TaskMainStatusCode is NULL
			BEGIN
				SET @ErrorMessage = @ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			-- 3 - Code-NotValid:
			If @TaskMainStatusCode is not NULL
			and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'TASK_MAIN_STATUS%'
						and Code.Id = @TaskMainStatusCode)
			BEGIN
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' TaskMainStatusCode is not Valid,');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select 'IFC.DEBTCASE', @ID, 'taskMainStatusCode', @ERR_CODE_CODE_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				Set @TaskMainStatusCode = NULL;
			END;
*/

-- OwnProperty:
/*
		If Trim(Isnull(@OwnProperty,'')) <> ''
		and Not exists (Select 1 from GEN.Translation where CodeID LIKE 'BOOLEAN_%' and Text = Trim(@OwnProperty))
		and Not exists (Select 1 from GEN.Code where ID LIKE 'BOOLEAN_%' and Id = Trim(@OwnProperty))
		BEGIN
			SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' OwnProperty not Valid,');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select 'IFC.DEBTCASE', @ID, 'ownProperty', @ERR_CODE_CODE_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
		END
		Else
		Begin
			If exists (Select 1 from GEN.Translation where CodeID LIKE 'BOOLEAN_%' and Text = Trim(@OwnProperty))
				SET @OwnProperty = (Select Top 1 CodeID from GEN.Translation where CodeID LIKE 'BOOLEAN_%' and Text = Trim(@OwnProperty) order by ID desc);
			If exists (Select 1 from GEN.Code where ID LIKE 'BOOLEAN_%' and ID = Trim(@OwnProperty))
				SET @OwnProperty = (Select Top 1 ID from GEN.Code where ID LIKE 'BOOLEAN_%' and ID = Trim(@OwnProperty) order by id desc);
		End;
*/


			Set @l_DebtCaseID = 0;

			If exists (SELECT 1 FROM DCS.DebtCase WHERE SourceInterfaceType = @SourceInterfaceType and SourceID = @SourceID)
			-- Létezik a DebtCase:
				BEGIN
---------------------------------------------------------------------------------------------------------------------------------------------
					SET @l_DebtCaseID = (SELECT Top 1 DebtCase.ID FROM DCS.DebtCase
							Join Gen.Object on Object.Id = DebtCase.ObjectId
							where
								Object.PortfolioID = @PortfolioID
							and SourceInterfaceType = @SourceInterfaceType and SourceID = @SourceID order by DebtCase.ID);
					SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
					UPDATE IFC.DebtCase SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED', ErrorMessage = 'Identified by existing DebtCaseID: ' + Cast(@l_DebtCaseID as nvarchar(18)), DebtCaseId = @l_DebtCaseID, LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
				END;
			ELSE
			-- Nem létezik a DebtCase:
				BEGIN
---------------------------------------------------------------------------------------------------------------------------------------------
-- FIN.Calculation létrehozása:
					-- New ObjectID:
					INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr,  PortfolioID)
						SELECT @FINCalculation as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @PortfolioID;
					SET @l_ObjectID = @@Identity;

					Insert Into FIN.Calculation(ObjectID, RelationObjectID, CreationDate, CreationTime, CreationUserName)
					Select @l_ObjectID, NULL, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName;
					SET @l_CalculationID = @@Identity;

---------------------------------------------------------------------------------------------------------------------------------------------
					-- New ObjectID:
					Set @l_DebtCaseObjectID = 0;
					INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr,  PortfolioID)
						SELECT @DCSDebtCase as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @PortfolioID;
					SET @l_DebtCaseObjectID = @@Identity;
-- Portfólió:
/*
					Insert Into GEN.PortfolioSystemObject(SystemObjectID, PortfolioID, CreationDate, CreationTime, CreationUserName)
					Select @l_ObjectID, @l_PortfolioID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName;
*/
---------------------------------------------------------------------------------------------------------------------------------------------
					-- New ObjectID:
					INSERT INTO DCS.DebtCase(
						ObjectID,
						DebtNr,
						SourceInterfaceType,
						PackageID,
						CurrencyCode,
						MainDebtorID,
						PhaseID,
						SectionCode,
						/*--CustomerID, */
						PartyID,
						OriginalCreditorEntityID,
						OfficeID,
						SourceID,
						OwnProperty,
						PurchaseDate,
						CutOffDate,
						CloseDate,
						AccountID,
						MainCalculationID,
						StrategyTypeID,
						CreationDate,
						CreationTime,
						CreationUserName,
						CreditTypeCode,
						BankAccountNumber,
						DepartmentTypeCode,
						MainStatusCode,
						OperatorUserName,
						DetailedStatusCode,
						CaseTypeCode,
						ConsolidatedProductCode,
						LoanGuaranteedCode,
						OriginalAccountingSystemCode,
						ConstructionCode)

					SELECT
						@l_DebtCaseObjectID as ObjectID,
						--@DebtNr as DebtNr,
						(NEXT VALUE FOR IFC.CounterDebtNr) as DebtNr,
						@SourceInterfaceType as SourceInterfaceType,
						@PackageID as PackageID,
						@CurrencyCode as CurrencyCode,
						NULL as MainDebtorID,
						@PhaseCode PhaseID,
						'CASE_SECTION_14500' as SectionCode,  -- DV-1837
						/*@CreditorName as CustomerID, */
						@PartyID as PartyID,
						@CreditorEntityID as OriginalCreditorEntityID,
						/*@Office, @OfficeID*/ NULL as OfficeID,

						@SourceID as SourceID,
						@OwnProperty as OwnProperty,
						@PurchaseDate as PurchaseDate,
						NULL as CutOffDate,
						@CloseDate as CloseDate,
						NULL as AccountID,
						@l_CalculationID as MainCalculationID,
						NULL as StrategyTypeID,
						CAST( GETDATE() AS Date ),
						CAST( GETDATE() AS Time ),
						@CurrentUserName,
						@CreditTypeCode,
						@BankAccountNumber,
						@DepartmentTypeCode,
						'CASE_MAIN_STATUS_OPEN',
						NULL as OperatorUserName,
						'CASE_DETAILED_STATUS_ACTIVE',
						@CaseTypeCode,
						@ConsolidatedProductCode,
						@LoanGuaranteedCode,
						@AccountingSystemCode,
						@ConstructionCode;

					SET @l_ImportID = @@Identity;
					SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
					If ISNULL(@ErrorMessage,'') = ''
						Set @ErrorMessage = NULL;
					UPDATE IFC.DebtCase SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage = @ErrorMessage,  DebtCaseId = @@Identity, LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;

					--Szerződéssel összekötés
					--IF COALESCE(@l_contractCheck, 'BOOLEAN_FALSE') = 'BOOLEAN_TRUE'
					IF Exists (Select 1 from ORG.ModuleInstanceParameter
					where ModuleInstanceID = @p_moduleInstanceID
					and ParameterValue = 'BOOLEAN_TRUE'
					and ParameterCode = 'MODULE_PARAMETER_IFC_CONTRACT_CHECK')
					AND COALESCE(@l_collectionContractItemID, 0) > 0
						UPDATE [CRM].[CollectionContractItem] SET
							[DebtCaseID] = @l_ImportID,
							[LastModifiedDate] = CAST( GETDATE() AS Date ),
							[LastModifiedTime] = CAST( GETDATE() AS Time ),
							[LastModifiedUserName] = @CurrentUserName
						WHERE [CollectionContractItem].[ID] = @l_collectionContractItemID;

			/* DV-631, 2023-06-14, T.Gábor
					Set @l_OrgTaskID = 0;
					-- New ObjectID:
					INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr,  PortfolioID)
						SELECT @ORGTask as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @PortfolioID;
					SET @l_ObjectID = @@Identity;

					Insert Into Org.Task(ObjectID, TaskTypeID, ReferencedObjectID, UserId, StatusCode, DetailsStatusCode, CreationDate, CreationTime, CreationUserName)
					Select @l_ObjectID, 'DebtCase', @l_DebtCaseObjectID, NULL, 'TASKSTATUS_NEW', 'TASKSTATUSID_NEWDEBTCASE', CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName;
					SET @l_OrgTaskID = @@Identity;
			*/


					-- New ObjectID:
					INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr,  PortfolioID)
						SELECT @ORGObjectTask as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @PortfolioID;
					SET @l_ObjectID = @@Identity;

					Insert Into Org.ObjectTask(ObjectID, TaskID, ReferencedObjectID, CreationDate, CreationTime, CreationUserName)
					Select @l_ObjectID, @l_OrgTaskID, @l_DebtCaseObjectID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName;

          /*az eventkiírás az IFC.InvoiceLoaderbe kerül át, mert ott íródik csak ki a debtcase-re a szinkronesemény és ez az utánra való.
            + a CreateEvent tároltat kell rá használni (és nem jó az objectType és a portfólió sem itt lentebb)
					IF @EventTypeCode <> ''
					Begin
						-- New ObjectID:
						INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr,  PortfolioID)
							SELECT @ORGObjectTask as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @PortfolioID;
						SET @l_ObjectID = @@Identity;

						Insert Into ORG.Event(ObjectID, EventTypeCode, EventDate, EventTime, CreationDate, CreationTime, CreationUserName, RelatedObjectID)
						Select @l_ObjectID, @EventTypeCode, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, @l_DebtCaseObjectID;
					End;
          */
				END;

---------------------------------------------------------------------------------------------------------------------------------------------

		END;  /*@ErrorMessage = NULL*/

		END TRY /*Belső-1*/
		BEGIN CATCH /*Belső-1*/
			SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			UPDATE IFC.DebtCase SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = Trim(Isnull(@ErrorMessage,'')), LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName  WHERE ID = @ID;
		END CATCH /*Belső-1*/


			FETCH NEXT FROM db_cursor INTO @ID,
			@SourceInterfaceType, @SourceID, @PackageName, @PackageCode, @PackageID, @DebtNr, @PartyName, @PartyID, @PartyBankAccountNr, @CreditorName, @CreditorEntityID, @OwnProperty,
			@PurchasePrice, @PurchasePriceCurrency, @PurchasePriceCurrencyCode, @PurchaseDate, @SalesUserID, @UserID, /*@TaskMainStatusCode,*/ /*@TaskStatusCode,*/ @Currency, @CurrencyCode,
			@Comments, @Field1, @Field2, @Field3, @Field4, @Field5, @OperationCode, /*@DebtCaseID,*/ @InterfaceStatusCode, @ErrorMessage, @InterfaceTableID, @MainDebtorID, @Section,
			@SectionCode, @Phase, @PhaseCode, @CloseReason, @CloseDate, @OfficeID, @Office, @ClientNr, @CreationDate, @CreationTime, @CreationUserName, @DepartmentType, @DepartmentTypeCode,
			@CreditType, @CreditTypeCode, @PortfolioID, @PortfolioName, @BankAccountNumber, @ConstructionCode, @LoanGuaranteedCode

		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    -- ide.. 2022-11-22: COMMIT TRANSACTION;

    END TRY


    BEGIN CATCH
      if @@trancount > 0
         rollback

        SELECT
        @ErrorMessage = ERROR_MESSAGE(),
        @ErrorSeverity = ERROR_SEVERITY(),
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtCaseLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;						-- LogMessage

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        -- ide.. 2022-11-22: ROLLBACK TRANSACTION;

        SELECT @ErrorMessage;

    END CATCH;

------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------

	SET @LogMessage = @LogMessage + 'DebtCaseLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;

	SET @l_ImportedRowCounts = (Select Count(*) FROM IFC.DebtCase where SourceInterfaceType = @l_sourceInterfaceType and InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED');
	SET @l_ExisingRowCounts = (Select Count(*) FROM IFC.DebtCase where SourceInterfaceType = @l_sourceInterfaceType and InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED');
	SET @l_ErrorRowCounts = (Select Count(*) FROM IFC.DebtCase where SourceInterfaceType = @l_sourceInterfaceType and InterfaceStatusCode = 'INTERFACE_STATUS_ERROR');


	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtCaseLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ExistingRowsCount: ' + CAST(@l_ExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ @LogMessage;



	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT
		CAST( GETDATE() AS Date ),	-- LogDate,
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtCaseLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If Isnull(@ErrorMessage,'') <> ''
		Return 99;
	else
		Return 1;


END;

go

-- =============================================
-- Author:		Bognár Dávid
-- Create date: 2023-03-06
-- Last modified date: YYYY-MM-DD
-- Description:	Update Account data
-- =============================================
CREATE PROCEDURE [DCS].[DebtCaseSum]
	-- Tárolt eljárás bemenő paraméterei
  @p_correlationID NVARCHAR(200), --Kötelező paraméter a Session kezelés miatt
	--További szükséges bemenő paraméterek
  @p_sqltext NVARCHAR(max)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'LOG.GetDataChange'; --Naplózás miatt a tárolt eljárás neve
	DECLARE @l_ObjectType NVARCHAR(100);
    DECLARE @l_EntityID numeric(16);
    DECLARE @l_AddressObjectID numeric(16);
    DECLARE @l_ContactObjectID numeric(16);
	--Specifikus változók definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-okat, akkor azok definiálása (opcionális)
	--...
	--Feldolgozás kezdete (kötelező)
	--BEGIN TRAN

    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT
			CAST( GETDATE() AS Date ),	-- LogDate,
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,           -- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés.
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT
			CAST( GETDATE() AS Date ),	-- LogDate,
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Paraméterek ellenőrzése

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT
			CAST( GETDATE() AS Date ),	-- LogDate,
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Feldolgozás.
		--Amennyiben példányosított modul, akkor a példány feldolgozottságának frissítése az ORG.ModuleInstance.Progress mező módosítása

          declare @l_sqltext nvarchar(max);


		  select @l_sqltext=concat('select count(*) from (',@p_sqltext,') a');
		  select @l_sqltext=REPLACE(@l_sqltext,'ORDER BY [DebtCase].[ID] desc','')
		  select @l_sqltext=REPLACE(@l_sqltext,'ORDER BY [Contract].[ID] desc','')
		  EXEC(@l_sqltext);
		  --PRINT(@l_sqltext)

		--Naplóbejegyzés a befejezésről (kötelező)
		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT
			CAST( GETDATE() AS Date ),	-- LogDate,
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;                  --LogMessage

		--COMMIT TRAN

		RETURN 1;

	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'cursor neve');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE tenderItem_cursor;

			DEALLOCATE tenderItem_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(),
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT
			CAST( GETDATE() AS Date ),	-- LogDate,
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage

		--ROLLBACK TRAN

		SELECT 99;

	END CATCH
END
go

CREATE   PROCEDURE [IFC].[DebtorLoader](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16))

/*
==========================================================================================
 Author:		Tóth Gábor
 Creation date:			2022.10.17.
 Last modified date:	2022.11.01
						2022.11.07: ObjectType, AppUser, InterfaceStatus, Return, Errormessage
						2022.11.09: @p_moduleInstanceID, Átnevezés, 999 .> 99
						2022.11.13: "Demo" mód törlése, "SourceInterfaceType" <.> "MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE" csere, SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
						2022.11.14: DEBTOR_STATUS_ACTIVE
						2022.11.18: "DEBTOR_ROLE_"
						2022.11.20: DebtCase.MainDebtorID
						2022.11.22: "BEGIN TRANSACTION" ki.kommentelése
						2022.11.22: "@l_ActRole nvarchar(200)"
						2022.11.22: "DEALLOCATE db_cursor"
						2022.11.29: @l_EntityID az IFCtáblák alapján
						2022.11.29: ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED')
						2022.11.30: @SourceCompanyID
						2022.11.30: PersonID <.> CrefoId
						2022.12.16: @CurrentUserName
						2023.01.10: RoleCode, StatusCode
						2023.01.27: Set @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
						2023.02.22: Hibakezelés
						2023.03.01: Errormessage vesszővel lettek elválasztva
						2023.03.15: IFCError-tábla töltése
						2023.03.27: ErrorCode-ok, ObjectType
						2023.05.11: Set @l_ActRole = Isnull(...,'999999')
						2023.11.21: If not exists @..Code..
						2023.12.03: Kritikus és Blokkoló hibák kezelése
						2023.12.03: Update, LastModification..
						2023.12.09: Kritikus és Blokkoló hibák kezelése DV-1956 - Betöltő eljárás módosítása a IFC.InterfaceError.Errormessage mező töltésére
						2023.12.10: "InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'",  DV-1956
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(MAX);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve
		
	DECLARE @ValueSetId numeric(16);
	DECLARE @CurrentUser nvarchar(50);
	DECLARE @FieldCodeOut nvarchar(200);
	DECLARE @l_ErrorMessage nvarchar(MAX);
	DECLARE @CurrentUserName nvarchar(200);

	DECLARE @l_BlockerError nvarchar(1);  
	-- ha van blokkoló hiba, akkor @l_BlockerError = 'T', 
	-- InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_BLOCKING', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	-- ha csak kritikus hiba van, akkor @l_BlockerError = 'T', 
	-- InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	--DECLARE @l_Prev_ModuleInstanceID Numeric(16);


	SET @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
	--SET @l_Prev_ModuleInstanceID = (Select Top 1 ModuleInstanceID from IFC.InterfaceError where TableName = 'IFC.Company' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' order by id desc);

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);


    BEGIN TRY
        SET @LogMessage = 'DebtorLoader Started at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
		
		DECLARE @l_Debtor nvarchar(1); -- Debtor = 'T'
-----------------------------------------------
		DECLARE @ID NUMERIC(16);
		DECLARE @SourceInterfaceType NVARCHAR(200);
		DECLARE @SourceID NVARCHAR(200);
		DECLARE @SourceDebtCaseID NVARCHAR(200);
		DECLARE @SourcePersonID NVARCHAR(200);
		DECLARE @SourceCompanyID NVARCHAR(200);
		DECLARE @RoleText NVARCHAR(250);
		DECLARE @RoleCode NVARCHAR(200);
		DECLARE @DebtorID NUMERIC(16);
		DECLARE @InterfaceStatusCode NVARCHAR(200);

		DECLARE @OperationCode NVARCHAR(200);
		DECLARE @InterfaceTableID NUMERIC(16);

	
		DECLARE @l_ImportID numeric(16); -- Az újonnan beszúrt IFC rekordok ID-ja
		DECLARE @l_EntityID numeric(18);
		DECLARE @l_ObjectID numeric(18);
		
		DECLARE @l_AllRowCounts numeric(18);
		DECLARE @l_ImportedRowCounts numeric(18);
		DECLARE @l_ExisingRowCounts numeric(18);
		DECLARE @l_ErrorRowCounts numeric(18);
		DECLARE @l_DebtorID numeric(18);
		DECLARE @l_DebtCaseID numeric(18);
		DECLARE @l_ActRole nvarchar(200);

		DECLARE @DCSDebtor nVarchar(500);

		SET @l_AllRowCounts = 0;
		SET @l_ImportedRowCounts = 0;
		SET @l_ExisingRowCounts = 0;
		SET @l_ErrorRowCounts = 0;

		DECLARE @ERR_CODE_NAME_NOT_VALID nvarchar(200);
			SET @ERR_CODE_NAME_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_CODE_CODE_NOT_VALID nvarchar(200);
			SET @ERR_CODE_CODE_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_SIFTYPE_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SIFTYPE_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_SID_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SID_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_SourceDebtCaseID_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SourceDebtCaseID_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_DebtCaseID_IS_NOT_FOUND nvarchar(200);
			SET @ERR_DebtCaseID_IS_NOT_FOUND = 'ERR_GENERAL';
		DECLARE @ERR_SourceCompanyID_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SourceCompanyID_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_SourcePersonID_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SourcePersonID_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_SourceCompanyEntityID_IS_NOT_VALID nvarchar(200);
			SET @ERR_SourceCompanyEntityID_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_SourcePersonEntityID_IS_NOT_VALID nvarchar(200);
			SET @ERR_SourcePersonEntityID_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_RoleText_IS_EMPTY nvarchar(200);
			SET @ERR_RoleText_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_RoleCode_IS_EMPTY nvarchar(200);
			SET @ERR_RoleCode_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_RoleText_IS_NOT_VALID nvarchar(200);
			SET @ERR_RoleText_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_RoleCode_IS_NOT_VALID nvarchar(200);
			SET @ERR_RoleCode_IS_NOT_VALID = 'ERR_GENERAL';



		SET @DCSDebtor = (Select Top 1 Code from GEN.ObjectType where TableName = 'DCS.DEBTOR' order by TableName desc);

		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END

		IF COALESCE(@l_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);


		SET @l_AllRowCounts = (Select Count(*) FROM IFC.Debtor where Debtor.SourceInterfaceType = @l_sourceInterfaceType
					and 
					(
					(Debtor.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or 
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Debtor.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Debtor' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));

		DECLARE db_cursor CURSOR FOR 
		SELECT ID, 
			SourceInterfaceType, SourceID, SourceDebtCaseID, SourcePersonID, SourceCompanyID, RoleText, RoleCode, DebtorID, InterfaceStatusCode, 
			/*ErrorMessage, */ OperationCode, InterfaceTableID /*, CreationDate, CreationTime, CreationUserName */
		FROM IFC.Debtor
		where SourceInterfaceType = @l_sourceInterfaceType 
							and 
					(
					(Debtor.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or 
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Debtor.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Debtor' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
		Order by Id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID, 
			@SourceInterfaceType, @SourceID, @SourceDebtCaseID, @SourcePersonID, @SourceCompanyID, @RoleText, @RoleCode, @DebtorID, @InterfaceStatusCode, 
			/*@ErrorMessage, */ @OperationCode, @InterfaceTableID

		WHILE @@FETCH_STATUS = 0  
		BEGIN  

			SET @l_ImportID = 0;
			SET @l_DebtCaseID = 0;


			---------------------------------------------------------------------------------------------------------------------------------------------
	BEGIN TRY /* Belső-1 */

-- Error Section:
			SET @ErrorMessage = NULL;
			SET @l_BlockerError = '';
-- @SourceInterfaceType:
			IF Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceInterfaceType is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTOR', @ID, 'sourceInterfaceType', @ERR_SIFTYPE_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
-- @SourceID:
			IF Trim(Isnull(@SourceID,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTOR', @ID, 'sourceID', @ERR_SID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;

-- @SourceDebtCaseID:
		If Trim(Isnull(@SourceDebtCaseID,'')) = ''
		BEGIN
						Set @l_ErrorMessage = 'SourceDebtCaseID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTOR', @ID, 'sourceDebtCaseID', @ERR_SourceDebtCaseID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;

		SET @l_DebtCaseID = NULL;
		If not exists (SELECT 1 FROM DCS.DebtCase WHERE DebtCase.SourceInterfaceType = @SourceInterfaceType and DebtCase.SourceID = @SourceDebtCaseID)
		BEGIN
						Set @l_ErrorMessage = 'DebtCase is not found';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTOR', @ID, 'sourceDebtCaseID', @ERR_DebtCaseID_IS_NOT_FOUND, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;
		Else
			SET @l_DebtCaseID = (SELECT Top 1 DebtCase.ID FROM DCS.DebtCase WHERE DebtCase.SourceInterfaceType = @SourceInterfaceType and DebtCase.SourceID = @SourceDebtCaseID order by DebtCase.ID);
-- @SourceCompanyID + @SourcePersonID:
		If Trim(Isnull(@SourceCompanyID,'')) = '' and Trim(Isnull(@SourcePersonID,'')) = ''
		BEGIN
						Set @l_ErrorMessage = 'SourceCompanyID and SourcePersonID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTOR', @ID, 'sourceCompanyID', @ERR_SourceCompanyID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTOR', @ID, 'sourcePersonID', @ERR_SourcePersonID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;

		SET @l_EntityID = 0;

		If exists (Select 1 from IFC.Person WHERE SourceInterfaceType = @SourceInterfaceType and Person.SourceID = @SourcePersonID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED'))
			Set @l_EntityID = (Select Top 1 Person.CrefoId from IFC.Person WHERE SourceInterfaceType = @SourceInterfaceType and Person.SourceID = @SourcePersonID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by Id desc);

		If exists (Select 1 from IFC.Company WHERE SourceInterfaceType = @SourceInterfaceType and Company.SourceID = @SourceCompanyID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED'))
			Set @l_EntityID = (Select Top 1 Company.CrefoId from IFC.Company WHERE SourceInterfaceType = @SourceInterfaceType and Company.SourceID = @SourceCompanyID and InterfaceStatusCode in ('INTERFACE_STATUS_IDENTIFIED','INTERFACE_STATUS_PROCESSED') order by Id desc);

		If @l_EntityID = 0
		BEGIN
						Set @l_ErrorMessage = 'SourceEntity is not exixts';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTOR', @ID, 'sourceCompanyID', @ERR_SourceCompanyEntityID_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTOR', @ID, 'sourcePersonID', @ERR_SourcePersonEntityID_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;

-- @RoleText,@RoleCode:
			-- 0 - NULL:
			If Trim(Isnull(@RoleText,'')) = ''
				Set @RoleText = NULL;
			If Trim(Isnull(@RoleCode,'')) = ''
				Set @RoleCode = NULL;
			Set @RoleText = Trim(@RoleText);
			Set @RoleCode = Trim(@RoleCode);
			
			-- 1 - Üres:
			If @RoleText is NULL and @RoleCode is NULL
			BEGIN
						Set @l_ErrorMessage = 'RoleText/Code is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTOR', @ID, 'roleText', @ERR_RoleText_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTOR', @ID, 'roleCode', @ERR_RoleCode_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
			-- 2 - Text-NotValid:
			If @RoleText is NOT NULL and @RoleCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'DEBTOR_ROLE_%' and Text = @RoleText)
				Begin
						Set @l_ErrorMessage = 'RoleText is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTOR', @ID, 'roleText', @ERR_RoleText_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @RoleText = NULL;
				End;
				Else
					Set @RoleCode = (select Top 1 CodeId from Gen.Translation where codeid like 'DEBTOR_ROLE_%' and Text = @RoleText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @RoleText is NULL and @RoleCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'DEBTOR_ROLE_%' and Id = @RoleCode)
			BEGIN
						Set @l_ErrorMessage = 'RoleCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.DEBTOR', @ID, 'roleCode', @ERR_RoleCode_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @RoleCode = NULL;
			END;



-- Hibakiírás:

		IF @l_BlockerError = 'T'
		BEGIN
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			UPDATE IFC.DEBTOR SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage,
				LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
		END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Betöltés:
		IF @l_BlockerError = ''
		BEGIN
---------------------------------------------------------------------------------------------------------------------------------------------

------------------------------------------------------------------
-- Debtor:
------------------------------------------------------------------
			
			-- Már létezik a Debtor:
			SET @l_DebtorID = 0;
			IF EXISTS (SELECT 1 FROM DCS.DebtCase
				Join Dcs.Debtor on Debtor.DebtCaseID = DebtCase.ID
				WHERE DebtCaseID = @l_DebtCaseID
					and Debtor.EntityID = @l_EntityID
					and Debtor.RoleCode = @RoleCode)
			BEGIN
				Set @l_DebtorID = (SELECT Top 1 Debtor.ID FROM DCS.DebtCase
					Join Dcs.Debtor on Debtor.DebtCaseID = DebtCase.ID
					WHERE DebtCaseID = @l_DebtCaseID
						and Debtor.EntityID = @l_EntityID
						and Debtor.RoleCode = @RoleCode order by Debtor.ID);
				SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
				UPDATE IFC.Debtor SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED', DebtorID = @l_DebtorID,
					LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
			END;
			ELSE
			BEGIN
				-- New ObjectID:
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				SELECT @DCSDebtor as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				SET @l_ObjectID = @@Identity;

				-- Új Debtor felvitele:
				INSERT INTO DCS.Debtor(
					ObjectID, ParentDebtorID, RoleCode, StatusCode, DebtCaseID, EntityID, 
					StatusID, AccountID, OperatorUserID, 
					CreationDate, CreationTime, CreationUserName)
				SELECT
					@l_ObjectID, NULL as ParentDebtorID, @RoleCode, 'DEBTOR_STATUS_ACTIVE' as [Status],  @l_DebtCaseID, @l_EntityID,
					NULL as StatusID, NULL as AccountID, NULL as OperatorUserID,
					CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName;


				SET @l_ImportID = @@Identity;
				SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
				--SET @LogMessage = @LogMessage + 'IFC.Debtor.ID ' + @ID + ' Inserted new DebtorID: ' + @l_ImportID + @CRLF;
				UPDATE IFC.Debtor SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage = @ErrorMessage, DebtorID = @l_ImportID, 
					LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;


-- Főadós beállítása:
/* Mindig az erősebb -azaz a kisebb számú- lesz beállítva:
	'DEBTOR_ROLE_1' /* Adós */
	'DEBTOR_ROLE_2' /* Adóstárs */
	'DEBTOR_ROLE_4' /* Dologi adós */
	'DEBTOR_ROLE_3' /* Kezes */
	'DEBTOR_ROLE_15' /* cég (tulajdonos) */
	'DEBTOR_ROLE_16' /* cég (ügyvezető) */
	'DEBTOR_ROLE_17' /* cég (ügyintéző)  ---- Inaktív-Cég (ügyintéző) */
	'DEBTOR_ROLE_20'  /* Egyéb */
*/
				Set @l_ActRole = Isnull(
								(Select Top 1 Debtor.RoleCode 
								From Dcs.DebtCase
								Join Dcs.Debtor on Debtor.Id = DebtCase.MainDebtorId
								Where DebtCase.Id = @l_DebtCaseID order by Debtor.Id)
								,'999999');
				If Cast(Replace(@RoleCode,'DEBTOR_ROLE_','') as Numeric(6)) < Cast(Replace(@l_ActRole,'DEBTOR_ROLE_','') as Numeric(6))
				Begin
					Update DCS.DebtCase Set DebtCase.MainDebtorID = @l_ImportID,
						LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName where DebtCase.ID = @l_DebtCaseID;
				End;
				

			END; /* Már létezik a Debtor */

		END;  /*@ErrorMessage = NULL*/

		END TRY /*Belső-1*/
		BEGIN CATCH /*Belső-1*/
			SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			UPDATE IFC.Debtor SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage,
				LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
		END CATCH /*Belső-1*/

			
			FETCH NEXT FROM db_cursor INTO @ID, 
				@SourceInterfaceType, @SourceID, @SourceDebtCaseID, @SourcePersonID, @SourceCompanyID, @RoleText, @RoleCode, @DebtorID, @InterfaceStatusCode, 
				/*@ErrorMessage, */@OperationCode, @InterfaceTableID
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    -- ide.. 2022-11-22: COMMIT TRANSACTION;

    END TRY


    BEGIN CATCH

        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'db_cursor');
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE db_cursor;

			DEALLOCATE db_cursor;
		END;

		INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',				-- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			'IFC.DebtorLoader',			-- ServiceName
			'1.0',						-- ServiceVersion
			'FATAL',					-- SeverityLevel
			NULL,						-- MessageCategory
			@ErrorMessage;				-- LogMessage

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        SELECT @ErrorMessage

    END CATCH;


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	
	SET @LogMessage = @LogMessage + 'DebtorLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ExistingRowsCount: ' + CAST(@l_ExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ @LogMessage



	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If Isnull(@ErrorMessage,'') <> ''
		Return 99;
	else
		Return 1;


END;

go








/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
CREATE   PROCEDURE [IFC].[DeleteExcelData](
	@p_SourceInterfaceType nvarchar(200),
	@p_moduleInstanceID NUMERIC(16)=NULL,
	@p_result INT OUTPUT)
-- =============================================
/*
 Author:				Tóth Gábor
 Creation date:			2022.11.28.
 Last modified date:	2022.12.09, Commit
						2023.02.14
Description:
  A program kitöröl minden megadott @p_SourceInterfaceType ú betöltéssel létrejött adatot.

*/
-- =============================================

AS

BEGIN

DECLARE @id NUMERIC(16), @objectID NUMERIC(16), @contractID NUMERIC(16), @contractItemID NUMERIC(16)

--DECLARE CURSORS

DECLARE fin_transaction_cursor CURSOR FOR
	select FIN.[Transaction].ID, FIN.[Transaction].ObjectID
from DCS.DebtCase
	Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
	join FIN.InvoiceArrears on InvoiceArrears.InvoiceID = Invoice.ID
	Join FIN.Account on Account.InvoiceArrearsID = InvoiceArrears.ID
	Join FIN.[Transaction] on [Transaction].AccountID = Account.ID
where DebtCase.SourceInterFaceType IN
	(Select ModuleInstanceParameter.ParameterValue
	from ORG.ModuleInstance
	Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
	where
	ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
	and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
	and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
	and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
	);
DECLARE fin_account_cursor CURSOR FOR
	select FIN.Account.ID, FIN.Account.ObjectID
	from DCS.DebtCase
		Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
		join FIN.InvoiceArrears on InvoiceArrears.InvoiceID = Invoice.ID
		Join FIN.Account on Account.InvoiceArrearsID = InvoiceArrears.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE fin_invoicearrears_cursor CURSOR FOR
	select FIN.InvoiceArrears.ID
from DCS.DebtCase
	Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
	join FIN.InvoiceArrears on InvoiceArrears.InvoiceID = Invoice.ID
where DebtCase.SourceInterFaceType IN
	(Select ModuleInstanceParameter.ParameterValue
	from ORG.ModuleInstance
	Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
	where
	ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
	and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
	and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
	and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
	);
DECLARE fin_invoicetotal_cursor CURSOR FOR
	select FIN.InvoiceTotal.ID
	from DCS.DebtCase
		Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
		join FIN.InvoiceTotal on InvoiceTotal.InvoiceID = Invoice.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE fin_invoice_cursor CURSOR FOR
	select FIN.Invoice.ID, FIN.Invoice.ObjectID
	from DCS.DebtCase
		Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_address_cursor CURSOR FOR
	Select PRT.Address.ID, PRT.Address.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join PRT.[Address] on [Address].EntityID = Entity.ID
		Join GEN.[Object] on [Object].ID = [Address].ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_contact_cursor CURSOR FOR
	Select PRT.Contact.ID, PRT.Contact.ObjectID
	from
	DCS.DebtCase
	Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
	Join PRT.Entity on Entity.ID = Debtor.EntityID
	join PRT.Contact on Contact.EntityID = Entity.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_name_cursor CURSOR FOR
	Select PRT.Name.ID, PRT.Name.ObjectID
	from
	DCS.DebtCase
	Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
	Join PRT.Entity on Entity.ID = Debtor.EntityID
	join PRT.[Name] on [Name].EntityID = Entity.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_assetvaluationvalue_cursor CURSOR FOR
	Select AST.AssetValuationValue.ID, AST.AssetValuationValue.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtorAsset on DebtorAsset.DebtorID = Debtor.Id
		Join AST.Asset on Asset.ID = DebtorAsset.AssetID
		Join AST.AssetValuation on AssetValuation.AssetID = Asset.Id
		Join AST.AssetValuationValue on AssetValuationValue.AssetValuationID = AssetValuation.ID
		Join GEN.[Object] on [Object].ID = AssetValuationValue.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_assetvaluationvalue2_cursor CURSOR FOR
	Select AST.AssetValuationValue.ID, AST.AssetValuationValue.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtCaseAsset on DebtCaseAsset.DebtCaseID = DebtCase.Id
		Join AST.Asset on Asset.ID = DebtCaseAsset.AssetID
		Join AST.AssetValuation on AssetValuation.AssetID = Asset.Id
		Join AST.AssetValuationValue on AssetValuationValue.AssetValuationID = AssetValuation.ID
		Join GEN.[Object] on [Object].ID = AssetValuationValue.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_assetvaluation_cursor CURSOR FOR
	Select AST.AssetValuation.ID, AST.AssetValuation.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtorAsset on DebtorAsset.DebtorID = Debtor.Id
		Join AST.Asset on Asset.ID = DebtorAsset.AssetID
		Join AST.AssetValuation on AssetValuation.AssetID = Asset.Id
		Join GEN.[Object] on [Object].ID = AssetValuation.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_assetvaluation2_cursor CURSOR FOR
	Select AST.AssetValuation.ID, AST.AssetValuation.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtCaseAsset on DebtCaseAsset.DebtCaseID = DebtCase.Id
		Join AST.Asset on Asset.ID = DebtCaseAsset.AssetID
		Join AST.AssetValuation on AssetValuation.AssetID = Asset.Id
		Join GEN.[Object] on [Object].ID = AssetValuation.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_debtorasset_cursor CURSOR FOR
	Select AST.DebtorAsset.ID, AST.DebtorAsset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtorAsset on DebtorAsset.DebtorID = Debtor.Id
		Join GEN.[Object] on [Object].ID = DebtorAsset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_entityasset_cursor CURSOR FOR
	Select AST.EntityAsset.ID, AST.EntityAsset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.EntityAsset on EntityAsset.EntityID = Entity.Id
		Join GEN.[Object] on [Object].ID = EntityAsset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_debtcaseasset_cursor CURSOR FOR
	Select AST.DebtCaseAsset.ID, AST.DebtCaseAsset.ObjectID
	from
		DCS.DebtCase
		left Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		left Join PRT.Entity on Entity.ID = Debtor.EntityID
		left join AST.DebtCaseAsset on DebtCaseAsset.DebtCaseID = DebtCase.Id
		left Join GEN.[Object] on [Object].ID = DebtCaseAsset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_asset_cursor CURSOR FOR
	Select AST.Asset.ID, AST.Asset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtorAsset on DebtorAsset.DebtorID = Debtor.Id
		Join AST.Asset on Asset.ID = DebtorAsset.AssetID
		Join GEN.[Object] on [Object].ID = Asset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_asset2_cursor CURSOR FOR
	Select AST.Asset.ID, AST.Asset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtCaseAsset on DebtCaseAsset.DebtCaseID = DebtCase.Id
		Join AST.Asset on Asset.ID = DebtCaseAsset.AssetID
		Join GEN.[Object] on [Object].ID = Asset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_person_cursor CURSOR FOR
	Select PRT.Person.ID
	from
	DCS.DebtCase
	Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
	Join PRT.Entity on Entity.ID = Debtor.EntityID
	join PRT.Person on Person.EntityID = Entity.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_company_cursor CURSOR FOR
	Select PRT.Company.ID
	from
	DCS.DebtCase
	Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
	Join PRT.Entity on Entity.ID = Debtor.EntityID
	join PRT.Company on Company.EntityID = Entity.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE dcs_debtcase_cursor CURSOR FOR
	Select DCS.DebtCase.ID, DCS.DebtCase.ObjectID
	from
		DCS.DebtCase
		Join GEN.[Object] on [Object].ID = DebtCase.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE dcs_debtor_cursor CURSOR FOR
	Select DCS.Debtor.ID, DCS.Debtor.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join GEN.[Object] on [Object].ID = Debtor.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_entityidentifier_cursor CURSOR FOR
	Select PRT.EntityIdentifier.ID, PRT.EntityIdentifier.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join PRT.EntityIdentifier on EntityIdentifier.EntityID = Entity.ID
		Join GEN.[Object] on [Object].ID = EntityIdentifier.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_entitynegativeevent CURSOR FOR
	Select PRT.EntityNegativeEvent.ID, PRT.EntityNegativeEvent.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join PRT.EntityNegativeEvent on EntityNegativeEvent.EntityID = Entity.ID
		Join GEN.[Object] on [Object].ID = EntityNegativeEvent.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_entityrelation_cursor CURSOR FOR
	Select PRT.EntityRelation.ID, PRT.EntityRelation.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join PRT.EntityRelation on (EntityRelation.FromEntityID = Entity.ID or EntityRelation.ToEntityID = EntityID)
		Join GEN.[Object] on [Object].ID = EntityRelation.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_entity_cursor CURSOR FOR
	Select PRT.Entity.ID, PRT.Entity.ObjectID
		from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		Join GEN.[Object] on [Object].ID = Entity.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue = @p_SourceInterfaceType
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);

-- 7 Storage to IFC

Truncate Table IFC.OTP_TA_FC;
Truncate Table IFC.OTP_TA_FF;
Truncate Table IFC.OTP_TA_FK;
Truncate Table IFC.OTP_TA_FU;

BEGIN TRAN
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 1 - Delete FIN.[Transaction]:
Print 'FIN.Transaction';

OPEN fin_transaction_cursor

FETCH NEXT FROM fin_transaction_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.[Transaction]
	WHERE FIN.[Transaction].ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM fin_transaction_cursor
	INTO @id, @objectID

END
CLOSE fin_transaction_cursor
DEALLOCATE fin_transaction_cursor


------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 2 - Delete FIN.Account:
Print 'FIN.Account';

OPEN fin_account_cursor

FETCH NEXT FROM fin_account_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.Account
	WHERE FIN.Account.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM fin_account_cursor
	INTO @id, @objectID

END
CLOSE fin_account_cursor
DEALLOCATE fin_account_cursor


------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 3 - Delete FIN.InvoiceArrears:
Print 'FIN.InvoiceArrears';

OPEN fin_invoicearrears_cursor

FETCH NEXT FROM fin_invoicearrears_cursor
	INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.InvoiceArrears
	WHERE FIN.InvoiceArrears.ID = @id;


FETCH NEXT FROM fin_invoicearrears_cursor
	INTO @id

END
CLOSE fin_invoicearrears_cursor
DEALLOCATE fin_invoicearrears_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 4 - FIN.InvoiceTotal:
Print 'FIN.InvoiceTotal';

OPEN fin_invoicetotal_cursor

FETCH NEXT FROM fin_invoicetotal_cursor
	INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.InvoiceTotal
	WHERE FIN.InvoiceTotal.ID = @id;


FETCH NEXT FROM fin_invoicetotal_cursor
	INTO @id

END
CLOSE fin_invoicetotal_cursor
DEALLOCATE fin_invoicetotal_cursor;

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 5 - FIN.Calculation
--Print 'FIN.Calculation';

--??


------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 6 - Delete FIN.Invoice:
Print 'FIN.Invoice';

OPEN fin_invoice_cursor

FETCH NEXT FROM fin_invoice_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.Invoice
	WHERE FIN.Invoice.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM fin_invoice_cursor
	INTO @id, @objectID

END
CLOSE fin_invoice_cursor
DEALLOCATE fin_invoice_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 7 - PRT.Address
Print 'PRT.Address';

OPEN prt_address_cursor

FETCH NEXT FROM prt_address_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Address
	WHERE PRT.Address.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_address_cursor
	INTO @id, @objectID

END
CLOSE prt_address_cursor
DEALLOCATE prt_address_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 8 - PRT.Contact:
Print 'PRT.Contact';

OPEN prt_contact_cursor

FETCH NEXT FROM prt_contact_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Contact
	WHERE PRT.Contact.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_contact_cursor
	INTO @id, @objectID

END
CLOSE prt_contact_cursor
DEALLOCATE prt_contact_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 9 - PRT.Name:
Print 'PRT.Name';

OPEN prt_name_cursor

FETCH NEXT FROM prt_name_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Name
	WHERE PRT.Name.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_name_cursor
	INTO @id, @objectID

END
CLOSE prt_name_cursor
DEALLOCATE prt_name_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 10 - AST.AssetValuationValue (Debtor):
Print 'AST.AssetValuationValue (Debtor)';

OPEN ast_assetvaluationvalue_cursor

FETCH NEXT FROM ast_assetvaluationvalue_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.AssetValuationValue
	WHERE AST.AssetValuationValue.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_assetvaluationvalue_cursor
	INTO @id, @objectID

END
CLOSE ast_assetvaluationvalue_cursor
DEALLOCATE ast_assetvaluationvalue_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 11 - AST.AssetValuationValue (DebtCase):
Print 'AST.AssetValuationValue (DebtCase)';

OPEN ast_assetvaluationvalue2_cursor

FETCH NEXT FROM ast_assetvaluationvalue2_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.AssetValuationValue
	WHERE AST.AssetValuationValue.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_assetvaluationvalue2_cursor
	INTO @id, @objectID

END
CLOSE ast_assetvaluationvalue2_cursor
DEALLOCATE ast_assetvaluationvalue2_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 12 - AST.AssetValuation (Debtor):
Print 'AST.AssetValuation (Debtor)';

OPEN ast_assetvaluation_cursor

FETCH NEXT FROM ast_assetvaluation_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.AssetValuation
	WHERE AST.AssetValuation.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_assetvaluation_cursor
	INTO @id, @objectID

END
CLOSE ast_assetvaluation_cursor
DEALLOCATE ast_assetvaluation_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 15 - AST.AssetValuation (DebtCase):
Print 'AST.AssetValuation (DebtCase)';

OPEN ast_assetvaluation2_cursor

FETCH NEXT FROM ast_assetvaluation2_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.AssetValuation
	WHERE AST.AssetValuation.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_assetvaluation2_cursor
	INTO @id, @objectID

END
CLOSE ast_assetvaluation2_cursor
DEALLOCATE ast_assetvaluation2_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 14 - AST.DebtorAsset (Debtor):
Print 'AST.DebtorAsset (Debtor)';

OPEN ast_debtorasset_cursor

FETCH NEXT FROM ast_debtorasset_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.DebtorAsset
	WHERE AST.DebtorAsset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_debtorasset_cursor
	INTO @id, @objectID

END
CLOSE ast_debtorasset_cursor
DEALLOCATE ast_debtorasset_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 14 - AST.EntityAsset (Debtor):
Print 'AST.EntityAsset (Debtor)';

OPEN ast_entityasset_cursor

FETCH NEXT FROM ast_entityasset_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.EntityAsset
	WHERE AST.EntityAsset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_entityasset_cursor
	INTO @id, @objectID

END
CLOSE ast_entityasset_cursor
DEALLOCATE ast_entityasset_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 17 - AST.DebtCaseAsset (DebtCase):
Print 'AST.DebtCaseAsset (DebtCase)';

OPEN ast_debtcaseasset_cursor

FETCH NEXT FROM ast_debtcaseasset_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.DebtCaseAsset
	WHERE AST.DebtCaseAsset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_debtcaseasset_cursor
	INTO @id, @objectID

END
CLOSE ast_debtcaseasset_cursor
DEALLOCATE ast_debtcaseasset_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 13 - AST.Asset (Debtor):
Print 'AST.Asset (Debtor)';

OPEN ast_asset_cursor

FETCH NEXT FROM ast_asset_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.Asset
	WHERE AST.Asset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_asset_cursor
	INTO @id, @objectID

END
CLOSE ast_asset_cursor
DEALLOCATE ast_asset_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 16 - AST.Asset (DebtCase):
Print 'AST.Asset (DebtCase)';

OPEN ast_asset2_cursor

FETCH NEXT FROM ast_asset2_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.Asset
	WHERE AST.Asset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_asset2_cursor
	INTO @id, @objectID

END
CLOSE ast_asset2_cursor
DEALLOCATE ast_asset2_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 18 - PRT.Person
Print 'PRT.Person';
-- Nincs PRT.Person.ObjectID mező

OPEN prt_person_cursor

FETCH NEXT FROM prt_person_cursor
	INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Person
	WHERE PRT.Person.ID = @id;

FETCH NEXT FROM prt_person_cursor
	INTO @id

END
CLOSE prt_person_cursor
DEALLOCATE prt_person_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 18 - PRT.Company
Print 'PRT.Company';
-- Nincs PRT.Company.ObjectID mező

OPEN prt_company_cursor

FETCH NEXT FROM prt_company_cursor
	INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Company
	WHERE PRT.Company.ID = @id;

FETCH NEXT FROM prt_company_cursor
	INTO @id

END
CLOSE prt_company_cursor
DEALLOCATE prt_company_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 21 - DCS.Debtor:
Print 'PRT.Debtor';

Print 'DCS.DebtCAse update';

OPEN dcs_debtcase_cursor

FETCH NEXT FROM dcs_debtcase_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

UPDATE DCS.DebtCase
	SET MainDebtorID = NULL
	WHERE ID = @id

FETCH NEXT FROM dcs_debtcase_cursor
	INTO @id, @objectID

END
CLOSE dcs_debtcase_cursor
--DEALLOCATE dcs_debtcase_cursor

OPEN dcs_debtor_cursor

FETCH NEXT FROM dcs_debtor_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM DCS.Debtor
	WHERE DCS.Debtor.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM dcs_debtor_cursor
	INTO @id, @objectID

END
CLOSE dcs_debtor_cursor
DEALLOCATE dcs_debtor_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 22 - DCS.DebtCase:
Print 'DCS.DebtCase';

OPEN dcs_debtcase_cursor

FETCH NEXT FROM dcs_debtcase_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

DECLARE crm_contract_cursor CURSOR FOR
	SELECT CRM.Contract.ID
		FROM CRM.Contract
			JOIN CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
			JOIN CRM.CollectionContractItem ON CRM.CollectionContractItem.ContractItemID = CRM.ContractItem.ID
		WHERE CRM.CollectionContractItem.DebtCaseID = @id

OPEN crm_contract_cursor

FETCH NEXT FROM crm_contract_cursor
	INTO @contractID

WHILE @@FETCH_STATUS = 0
BEGIN

DELETE FROM CRM.CollectionContractItem
WHERE CRM.CollectionContractItem.ID IN (SELECT CRM.CollectionContractItem.ID
											FROM CRM.Contract
												JOIN CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
												JOIN CRM.CollectionContractItem ON CRM.CollectionContractItem.ContractItemID = CRM.ContractItem.ID
											WHERE CRM.Contract.ID = @contractID)

DELETE FROM CRM.ContractItem
WHERE CRM.ContractItem.ID IN (SELECT CRM.ContractItem.ID
											FROM CRM.Contract
												JOIN CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
												JOIN CRM.CollectionContractItem ON CRM.CollectionContractItem.ContractItemID = CRM.ContractItem.ID
											WHERE CRM.Contract.ID = @contractID)

DELETE FROM CRM.Contract
WHERE CRM.Contract.ID = @contractID

FETCH NEXT FROM crm_contract_cursor
	INTO @contractID

END
CLOSE crm_contract_cursor
DEALLOCATE crm_contract_cursor

Delete FROM DCS.DebtCase
	WHERE DCS.DebtCase.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM dcs_debtcase_cursor
	INTO @id, @objectID

END
CLOSE dcs_debtcase_cursor
DEALLOCATE dcs_debtcase_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 19 - PRT.EntityIdentifier:
Print 'PRT.EntityIdentifier';

OPEN prt_entityidentifier_cursor

FETCH NEXT FROM prt_entityidentifier_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.EntityIdentifier
	WHERE PRT.EntityIdentifier.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_entityidentifier_cursor
	INTO @id, @objectID

END
CLOSE prt_entityidentifier_cursor
DEALLOCATE prt_entityidentifier_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 20 - PRT.EntityNegativeEvent:
Print 'PRT.EntityNegativeEvent';

OPEN prt_entitynegativeevent

FETCH NEXT FROM prt_entitynegativeevent
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.EntityNegativeEvent
	WHERE PRT.EntityNegativeEvent.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_entitynegativeevent
	INTO @id, @objectID

END
CLOSE prt_entitynegativeevent
DEALLOCATE prt_entitynegativeevent

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 21 - PRT.EntityRelation:
Print 'PRT.EntityRelation';

OPEN prt_entityrelation_cursor

FETCH NEXT FROM prt_entityrelation_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.EntityRelation
	WHERE PRT.EntityRelation.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_entityrelation_cursor
	INTO @id, @objectID

END
CLOSE prt_entityrelation_cursor
DEALLOCATE prt_entityrelation_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 22 - PRT.Entity:
Print 'PRT.Entity';

OPEN prt_entity_cursor

FETCH NEXT FROM prt_entity_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Entity
	WHERE PRT.Entity.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_entity_cursor
	INTO @id, @objectID

END
CLOSE prt_entity_cursor
DEALLOCATE prt_entity_cursor




/*

exec ifc.DeleteExcelData 'SourceInterFaceType', @p_result = 1
*/

commit tran;

SELECT @p_result = 1;
		RETURN;

END;
go








/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
CREATE           PROCEDURE [IFC].[DeleteInterfaceData](@p_ModuleInstanceId NUMERIC(16) = NULL)
-- =============================================
/*
 Author:				Tóth Gábor
 Creation date:			2022.11.28.
 Last modified date:
Description:
  A program kitöröl minden @p_ModuleInstanceId-jú betöltéssel létrejött és "MODULE_INTERFACE_LOADER"-al betöltött adatot.
  Ha nincs megadva paraméter, akkor minden olyan adatot töröl, amit a "MODULE_INTERFACE_LOADER" modul tötltött be.
*/
-- =============================================

AS

BEGIN

DECLARE @id NUMERIC(16), @objectID NUMERIC(16), @contractID NUMERIC(16)

--DECLARE CURSORS

DECLARE fin_transaction_cursor CURSOR FOR
	select FIN.[Transaction].ID, FIN.[Transaction].ObjectID
from DCS.DebtCase
	Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
	join FIN.InvoiceArrears on InvoiceArrears.InvoiceID = Invoice.ID
	Join FIN.Account on Account.InvoiceArrearsID = InvoiceArrears.ID
	Join FIN.[Transaction] on [Transaction].AccountID = Account.ID
where DebtCase.SourceInterFaceType IN
	(Select ModuleInstanceParameter.ParameterValue
	from ORG.ModuleInstance
	Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
	where
	ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
	--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
	and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
	and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
	);
DECLARE fin_account_cursor CURSOR FOR
	select FIN.Account.ID, FIN.Account.ObjectID
	from DCS.DebtCase
		Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
		join FIN.InvoiceArrears on InvoiceArrears.InvoiceID = Invoice.ID
		Join FIN.Account on Account.InvoiceArrearsID = InvoiceArrears.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE fin_invoicearrears_cursor CURSOR FOR
	select FIN.InvoiceArrears.ID
from DCS.DebtCase
	Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
	join FIN.InvoiceArrears on InvoiceArrears.InvoiceID = Invoice.ID
where DebtCase.SourceInterFaceType IN
	(Select ModuleInstanceParameter.ParameterValue
	from ORG.ModuleInstance
	Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
	where
	ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
	--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
	and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
	and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
	);
DECLARE fin_invoicetotal_cursor CURSOR FOR
	select FIN.InvoiceTotal.ID
	from DCS.DebtCase
		Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
		join FIN.InvoiceTotal on InvoiceTotal.InvoiceID = Invoice.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE fin_invoice_cursor CURSOR FOR
	select FIN.Invoice.ID, FIN.Invoice.ObjectID
	from DCS.DebtCase
		Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_address_cursor CURSOR FOR
	Select PRT.Address.ID, PRT.Address.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join PRT.[Address] on [Address].EntityID = Entity.ID
		Join GEN.[Object] on [Object].ID = [Address].ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_contact_cursor CURSOR FOR
	Select PRT.Contact.ID, PRT.Contact.ObjectID
	from
	DCS.DebtCase
	Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
	Join PRT.Entity on Entity.ID = Debtor.EntityID
	join PRT.Contact on Contact.EntityID = Entity.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_name_cursor CURSOR FOR
	Select PRT.Name.ID, PRT.Name.ObjectID
	from
	DCS.DebtCase
	Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
	Join PRT.Entity on Entity.ID = Debtor.EntityID
	join PRT.[Name] on [Name].EntityID = Entity.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_assetvaluationvalue_cursor CURSOR FOR
	Select AST.AssetValuationValue.ID, AST.AssetValuationValue.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtorAsset on DebtorAsset.DebtorID = Debtor.Id
		Join AST.Asset on Asset.ID = DebtorAsset.AssetID
		Join AST.AssetValuation on AssetValuation.AssetID = Asset.Id
		Join AST.AssetValuationValue on AssetValuationValue.AssetValuationID = AssetValuation.ID
		Join GEN.[Object] on [Object].ID = AssetValuationValue.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_assetvaluationvalue2_cursor CURSOR FOR
	Select AST.AssetValuationValue.ID, AST.AssetValuationValue.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtCaseAsset on DebtCaseAsset.DebtCaseID = DebtCase.Id
		Join AST.Asset on Asset.ID = DebtCaseAsset.AssetID
		Join AST.AssetValuation on AssetValuation.AssetID = Asset.Id
		Join AST.AssetValuationValue on AssetValuationValue.AssetValuationID = AssetValuation.ID
		Join GEN.[Object] on [Object].ID = AssetValuationValue.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_assetvaluation_cursor CURSOR FOR
	Select AST.AssetValuation.ID, AST.AssetValuation.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtorAsset on DebtorAsset.DebtorID = Debtor.Id
		Join AST.Asset on Asset.ID = DebtorAsset.AssetID
		Join AST.AssetValuation on AssetValuation.AssetID = Asset.Id
		Join GEN.[Object] on [Object].ID = AssetValuation.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_assetvaluation2_cursor CURSOR FOR
	Select AST.AssetValuation.ID, AST.AssetValuation.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtCaseAsset on DebtCaseAsset.DebtCaseID = DebtCase.Id
		Join AST.Asset on Asset.ID = DebtCaseAsset.AssetID
		Join AST.AssetValuation on AssetValuation.AssetID = Asset.Id
		Join GEN.[Object] on [Object].ID = AssetValuation.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_debtorasset_cursor CURSOR FOR
	Select AST.DebtorAsset.ID, AST.DebtorAsset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtorAsset on DebtorAsset.DebtorID = Debtor.Id
		Join GEN.[Object] on [Object].ID = DebtorAsset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_entityasset_cursor CURSOR FOR
	Select AST.EntityAsset.ID, AST.EntityAsset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.EntityAsset on EntityAsset.EntityID = Entity.Id
		Join GEN.[Object] on [Object].ID = EntityAsset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_debtcaseasset_cursor CURSOR FOR
	Select AST.DebtCaseAsset.ID, AST.DebtCaseAsset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtCaseAsset on DebtCaseAsset.DebtCaseID = DebtCase.Id
		Join GEN.[Object] on [Object].ID = DebtCaseAsset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_asset_cursor CURSOR FOR
	Select AST.Asset.ID, AST.Asset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtorAsset on DebtorAsset.DebtorID = Debtor.Id
		Join AST.Asset on Asset.ID = DebtorAsset.AssetID
		Join GEN.[Object] on [Object].ID = Asset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_asset2_cursor CURSOR FOR
	Select AST.Asset.ID, AST.Asset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtCaseAsset on DebtCaseAsset.DebtCaseID = DebtCase.Id
		Join AST.Asset on Asset.ID = DebtCaseAsset.AssetID
		Join GEN.[Object] on [Object].ID = Asset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_person_cursor CURSOR FOR
	Select PRT.Person.ID
	from
	DCS.DebtCase
	Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
	Join PRT.Entity on Entity.ID = Debtor.EntityID
	join PRT.Person on Person.EntityID = Entity.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_company_cursor CURSOR FOR
	Select PRT.Company.ID
	from
	DCS.DebtCase
	Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
	Join PRT.Entity on Entity.ID = Debtor.EntityID
	join PRT.Company on Company.EntityID = Entity.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE dcs_debtcase_cursor CURSOR FOR
	Select DCS.DebtCase.ID, DCS.DebtCase.ObjectID
	from
		DCS.DebtCase
		Join GEN.[Object] on [Object].ID = DebtCase.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE dcs_debtor_cursor CURSOR FOR
	Select DCS.Debtor.ID, DCS.Debtor.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join GEN.[Object] on [Object].ID = Debtor.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_entityidentifier_cursor CURSOR FOR
	Select PRT.EntityIdentifier.ID, PRT.EntityIdentifier.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join PRT.EntityIdentifier on EntityIdentifier.EntityID = Entity.ID
		Join GEN.[Object] on [Object].ID = EntityIdentifier.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_entitynegativeevent CURSOR FOR
	Select PRT.EntityNegativeEvent.ID, PRT.EntityNegativeEvent.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join PRT.EntityNegativeEvent on EntityNegativeEvent.EntityID = Entity.ID
		Join GEN.[Object] on [Object].ID = EntityNegativeEvent.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_entityrelation_cursor CURSOR FOR
	Select PRT.EntityRelation.ID, PRT.EntityRelation.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join PRT.EntityRelation on (EntityRelation.FromEntityID = Entity.ID or EntityRelation.ToEntityID = EntityID)
		Join GEN.[Object] on [Object].ID = EntityRelation.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_entity_cursor CURSOR FOR
	Select PRT.Entity.ID, PRT.Entity.ObjectID
		from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		Join GEN.[Object] on [Object].ID = Entity.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE crm_collectioncontractsummary CURSOR FOR
select CRM.CollectionContractSummary.ID, CRM.CollectionContractSummary.ObjectID
	from CRM.CollectionContractSummary
	where CRM.CollectionContractSummary.ContractID IN (
		select CRM.Contract.ID
	from CRM.Contract
		join IFC.Contract IC on IC.ContractID = CRM.Contract.ID
	where IC.SourceInterfaceType IN (Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		)
	)
DECLARE crm_contractsigner CURSOR FOR
	select CRM.ContractSigner.ID, CRM.ContractSigner.ObjectID
	from CRM.ContractSigner
	where CRM.ContractSigner.ContractID IN (
		select CRM.Contract.ID
	from CRM.Contract
		join IFC.Contract IC on IC.ContractID = CRM.Contract.ID
	where IC.SourceInterfaceType IN (Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		)
	)
DECLARE crm_collectioncontractitem CURSOR FOR
	select CRM.CollectionContractItem.ID, CRM.CollectionContractItem.ObjectID
	from CRM.CollectionContractItem
	where CRM.CollectionContractItem.ContractItemID IN (
		select CRM.ContractItem.ID
	from CRM.Contract
		join IFC.Contract IC on IC.ContractID = CRM.Contract.ID
		join CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
	where IC.SourceInterfaceType IN (Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		)
	)
DECLARE crm_contractitem CURSOR FOR
	select CRM.ContractItem.ID, CRM.ContractItem.ObjectID
	from CRM.ContractItem
	where CRM.ContractItem.ID IN (
		select CRM.ContractItem.ID
	from CRM.Contract
		join IFC.Contract IC on IC.ContractID = CRM.Contract.ID
		join CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
	where IC.SourceInterfaceType IN (Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		)
	)
DECLARE crm_contract CURSOR FOR
	select CRM.Contract.ID, CRM.Contract.ObjectID
	from CRM.Contract
	where CRM.Contract.ID IN (
		select CRM.Contract.ID
	from CRM.Contract
		join IFC.Contract IC on IC.ContractID = CRM.Contract.ID
	where IC.SourceInterfaceType IN (Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		)
	)

-- 7 Storage to IFC

Truncate Table IFC.OTP_TA_FC;
Truncate Table IFC.OTP_TA_FF;
Truncate Table IFC.OTP_TA_FK;
Truncate Table IFC.OTP_TA_FU;


BEGIN TRAN


------------------------------------------------------------------------------------------------------------------------------------------------------------------
--- Delete CRM.CollectionContractSummary:

Print 'CRM.CollectionContractSummary';

OPEN crm_collectioncontractsummary

FETCH NEXT FROM crm_collectioncontractsummary
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM CRM.CollectionContractSummary
	WHERE CRM.CollectionContractSummary.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM crm_collectioncontractsummary
	INTO @id, @objectID

END
CLOSE crm_collectioncontractsummary
DEALLOCATE crm_collectioncontractsummary

------------------------------------------------------------------------------------------------------------------------------------------------------------------
--- Delete CRM.ContractSigner:

Print 'CRM.ContractSigner';

OPEN crm_contractsigner

FETCH NEXT FROM crm_contractsigner
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM CRM.ContractSigner
	WHERE CRM.ContractSigner.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM crm_contractsigner
	INTO @id, @objectID

END
CLOSE crm_contractsigner
DEALLOCATE crm_contractsigner

------------------------------------------------------------------------------------------------------------------------------------------------------------------
--- Delete CRM.CollectionContractItem:

Print 'CRM.CollectionContractItem';

OPEN crm_collectioncontractitem

FETCH NEXT FROM crm_collectioncontractitem
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM CRM.CollectionContractItem
	WHERE CRM.CollectionContractItem.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM crm_collectioncontractitem
	INTO @id, @objectID

END
CLOSE crm_collectioncontractitem
DEALLOCATE crm_collectioncontractitem

------------------------------------------------------------------------------------------------------------------------------------------------------------------
--- Delete CRM.ContractItem:

Print 'CRM.ContractItem';

OPEN crm_contractitem

FETCH NEXT FROM crm_contractitem
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM CRM.ContractItem
	WHERE CRM.ContractItem.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM crm_contractitem
	INTO @id, @objectID

END
CLOSE crm_contractitem
DEALLOCATE crm_contractitem

------------------------------------------------------------------------------------------------------------------------------------------------------------------
--- Delete CRM.Contract:

Print 'CRM.Contract';

OPEN crm_contract

FETCH NEXT FROM crm_contract
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM CRM.Contract
	WHERE CRM.Contract.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM crm_contract
	INTO @id, @objectID

END
CLOSE crm_contract
DEALLOCATE crm_contract
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 1 - Delete FIN.[Transaction]:
Print 'FIN.Transaction';

OPEN fin_transaction_cursor

FETCH NEXT FROM fin_transaction_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.[Transaction]
	WHERE FIN.[Transaction].ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM fin_transaction_cursor
	INTO @id, @objectID

END
CLOSE fin_transaction_cursor
DEALLOCATE fin_transaction_cursor


------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 2 - Delete FIN.Account:
Print 'FIN.Account';

OPEN fin_account_cursor

FETCH NEXT FROM fin_account_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.Account
	WHERE FIN.Account.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM fin_account_cursor
	INTO @id, @objectID

END
CLOSE fin_account_cursor
DEALLOCATE fin_account_cursor


------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 3 - Delete FIN.InvoiceArrears:
Print 'FIN.InvoiceArrears';

OPEN fin_invoicearrears_cursor

FETCH NEXT FROM fin_invoicearrears_cursor
	INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.InvoiceArrears
	WHERE FIN.InvoiceArrears.ID = @id;


FETCH NEXT FROM fin_invoicearrears_cursor
	INTO @id

END
CLOSE fin_invoicearrears_cursor
DEALLOCATE fin_invoicearrears_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 4 - FIN.InvoiceTotal:
Print 'FIN.InvoiceTotal';

OPEN fin_invoicetotal_cursor

FETCH NEXT FROM fin_invoicetotal_cursor
	INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.InvoiceTotal
	WHERE FIN.InvoiceTotal.ID = @id;


FETCH NEXT FROM fin_invoicetotal_cursor
	INTO @id

END
CLOSE fin_invoicetotal_cursor
DEALLOCATE fin_invoicetotal_cursor;

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 5 - FIN.Calculation
--Print 'FIN.Calculation';

--??


------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 6 - Delete FIN.Invoice:
Print 'FIN.Invoice';

OPEN fin_invoice_cursor

FETCH NEXT FROM fin_invoice_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.Invoice
	WHERE FIN.Invoice.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM fin_invoice_cursor
	INTO @id, @objectID

END
CLOSE fin_invoice_cursor
DEALLOCATE fin_invoice_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 7 - PRT.Address
Print 'PRT.Address';

OPEN prt_address_cursor

FETCH NEXT FROM prt_address_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Address
	WHERE PRT.Address.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_address_cursor
	INTO @id, @objectID

END
CLOSE prt_address_cursor
DEALLOCATE prt_address_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 8 - PRT.Contact:
Print 'PRT.Contact';

OPEN prt_contact_cursor

FETCH NEXT FROM prt_contact_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Contact
	WHERE PRT.Contact.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_contact_cursor
	INTO @id, @objectID

END
CLOSE prt_contact_cursor
DEALLOCATE prt_contact_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 9 - PRT.Name:
Print 'PRT.Name';

OPEN prt_name_cursor

FETCH NEXT FROM prt_name_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Name
	WHERE PRT.Name.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_name_cursor
	INTO @id, @objectID

END
CLOSE prt_name_cursor
DEALLOCATE prt_name_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 10 - AST.AssetValuationValue (Debtor):
Print 'AST.AssetValuationValue (Debtor)';

OPEN ast_assetvaluationvalue_cursor

FETCH NEXT FROM ast_assetvaluationvalue_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.AssetValuationValue
	WHERE AST.AssetValuationValue.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_assetvaluationvalue_cursor
	INTO @id, @objectID

END
CLOSE ast_assetvaluationvalue_cursor
DEALLOCATE ast_assetvaluationvalue_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 11 - AST.AssetValuationValue (DebtCase):
Print 'AST.AssetValuationValue (DebtCase)';

OPEN ast_assetvaluationvalue2_cursor

FETCH NEXT FROM ast_assetvaluationvalue2_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.AssetValuationValue
	WHERE AST.AssetValuationValue.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_assetvaluationvalue2_cursor
	INTO @id, @objectID

END
CLOSE ast_assetvaluationvalue2_cursor
DEALLOCATE ast_assetvaluationvalue2_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 12 - AST.AssetValuation (Debtor):
Print 'AST.AssetValuation (Debtor)';

OPEN ast_assetvaluation_cursor

FETCH NEXT FROM ast_assetvaluation_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.AssetValuation
	WHERE AST.AssetValuation.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_assetvaluation_cursor
	INTO @id, @objectID

END
CLOSE ast_assetvaluation_cursor
DEALLOCATE ast_assetvaluation_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 15 - AST.AssetValuation (DebtCase):
Print 'AST.AssetValuation (DebtCase)';

OPEN ast_assetvaluation2_cursor

FETCH NEXT FROM ast_assetvaluation2_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.AssetValuation
	WHERE AST.AssetValuation.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_assetvaluation2_cursor
	INTO @id, @objectID

END
CLOSE ast_assetvaluation2_cursor
DEALLOCATE ast_assetvaluation2_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 14 - AST.DebtorAsset (Debtor):
Print 'AST.DebtorAsset (Debtor)';

OPEN ast_debtorasset_cursor

FETCH NEXT FROM ast_debtorasset_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.DebtorAsset
	WHERE AST.DebtorAsset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_debtorasset_cursor
	INTO @id, @objectID

END
CLOSE ast_debtorasset_cursor
DEALLOCATE ast_debtorasset_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 14 - AST.EntityAsset (Debtor):
Print 'AST.EntityAsset (Debtor)';

OPEN ast_entityasset_cursor

FETCH NEXT FROM ast_entityasset_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.EntityAsset
	WHERE AST.EntityAsset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_entityasset_cursor
	INTO @id, @objectID

END
CLOSE ast_entityasset_cursor
DEALLOCATE ast_entityasset_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 17 - AST.DebtCaseAsset (DebtCase):
Print 'AST.DebtCaseAsset (DebtCase)';

OPEN ast_debtcaseasset_cursor

FETCH NEXT FROM ast_debtcaseasset_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.DebtCaseAsset
	WHERE AST.DebtCaseAsset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_debtcaseasset_cursor
	INTO @id, @objectID

END
CLOSE ast_debtcaseasset_cursor
DEALLOCATE ast_debtcaseasset_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 13 - AST.Asset (Debtor):
Print 'AST.Asset (Debtor)';

OPEN ast_asset_cursor

FETCH NEXT FROM ast_asset_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.Asset
	WHERE AST.Asset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_asset_cursor
	INTO @id, @objectID

END
CLOSE ast_asset_cursor
DEALLOCATE ast_asset_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 16 - AST.Asset (DebtCase):
Print 'AST.Asset (DebtCase)';

OPEN ast_asset2_cursor

FETCH NEXT FROM ast_asset2_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.Asset
	WHERE AST.Asset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_asset2_cursor
	INTO @id, @objectID

END
CLOSE ast_asset2_cursor
DEALLOCATE ast_asset2_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 18 - PRT.Person
Print 'PRT.Person';
-- Nincs PRT.Person.ObjectID mező

OPEN prt_person_cursor

FETCH NEXT FROM prt_person_cursor
	INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Person
	WHERE PRT.Person.ID = @id;

FETCH NEXT FROM prt_person_cursor
	INTO @id

END
CLOSE prt_person_cursor
DEALLOCATE prt_person_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 18 - PRT.Company
Print 'PRT.Company';
-- Nincs PRT.Company.ObjectID mező

OPEN prt_company_cursor

FETCH NEXT FROM prt_company_cursor
	INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Company
	WHERE PRT.Company.ID = @id;

FETCH NEXT FROM prt_company_cursor
	INTO @id

END
CLOSE prt_company_cursor
DEALLOCATE prt_company_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 21 - DCS.Debtor:
Print 'dCS.Debtor';

Print 'DCS.DebtCAse update';

OPEN dcs_debtcase_cursor

FETCH NEXT FROM dcs_debtcase_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

UPDATE DCS.DebtCase
	SET MainDebtorID = NULL
	WHERE ID = @id

FETCH NEXT FROM dcs_debtcase_cursor
	INTO @id, @objectID

END
CLOSE dcs_debtcase_cursor
--DEALLOCATE dcs_debtcase_cursor

OPEN dcs_debtor_cursor

FETCH NEXT FROM dcs_debtor_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM DCS.Debtor
	WHERE DCS.Debtor.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM dcs_debtor_cursor
	INTO @id, @objectID

END
CLOSE dcs_debtor_cursor
DEALLOCATE dcs_debtor_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 22 - DCS.DebtCase:
Print 'DCS.DebtCase';

OPEN dcs_debtcase_cursor

FETCH NEXT FROM dcs_debtcase_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

DECLARE crm_contract_cursor CURSOR FOR
	SELECT CRM.Contract.ID
		FROM CRM.Contract
			JOIN CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
			JOIN CRM.CollectionContractItem ON CRM.CollectionContractItem.ContractItemID = CRM.ContractItem.ID
		WHERE CRM.CollectionContractItem.DebtCaseID = @id

OPEN crm_contract_cursor

FETCH NEXT FROM crm_contract_cursor
	INTO @contractID

WHILE @@FETCH_STATUS = 0
BEGIN

DELETE FROM CRM.CollectionContractItem
WHERE CRM.CollectionContractItem.ID IN (SELECT CRM.CollectionContractItem.ID
											FROM CRM.Contract
												JOIN CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
												JOIN CRM.CollectionContractItem ON CRM.CollectionContractItem.ContractItemID = CRM.ContractItem.ID
											WHERE CRM.Contract.ID = @contractID)

DELETE FROM CRM.ContractItem
WHERE CRM.ContractItem.ID IN (SELECT CRM.ContractItem.ID
											FROM CRM.Contract
												JOIN CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
												JOIN CRM.CollectionContractItem ON CRM.CollectionContractItem.ContractItemID = CRM.ContractItem.ID
											WHERE CRM.Contract.ID = @contractID)

DELETE FROM CRM.Contract
WHERE CRM.Contract.ID = @contractID

FETCH NEXT FROM crm_contract_cursor
	INTO @contractID

END
CLOSE crm_contract_cursor
DEALLOCATE crm_contract_cursor

Delete FROM DCS.DebtCase
	WHERE DCS.DebtCase.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM dcs_debtcase_cursor
	INTO @id, @objectID

END
CLOSE dcs_debtcase_cursor
DEALLOCATE dcs_debtcase_cursor
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 19 - PRT.EntityIdentifier:
Print 'PRT.EntityIdentifier';

OPEN prt_entityidentifier_cursor

FETCH NEXT FROM prt_entityidentifier_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.EntityIdentifier
	WHERE PRT.EntityIdentifier.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_entityidentifier_cursor
	INTO @id, @objectID

END
CLOSE prt_entityidentifier_cursor
DEALLOCATE prt_entityidentifier_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 20 - PRT.EntityNegativeEvent:
Print 'PRT.EntityNegativeEvent';

OPEN prt_entitynegativeevent

FETCH NEXT FROM prt_entitynegativeevent
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.EntityNegativeEvent
	WHERE PRT.EntityNegativeEvent.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_entitynegativeevent
	INTO @id, @objectID

END
CLOSE prt_entitynegativeevent
DEALLOCATE prt_entitynegativeevent

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 21 - PRT.EntityRelation:
Print 'PRT.EntityRelation';

OPEN prt_entityrelation_cursor

FETCH NEXT FROM prt_entityrelation_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.EntityRelation
	WHERE PRT.EntityRelation.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_entityrelation_cursor
	INTO @id, @objectID

END
CLOSE prt_entityrelation_cursor
DEALLOCATE prt_entityrelation_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 22 - PRT.Entity:
Print 'PRT.Entity';

OPEN prt_entity_cursor

FETCH NEXT FROM prt_entity_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Entity
	WHERE PRT.Entity.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_entity_cursor
	INTO @id, @objectID

END
CLOSE prt_entity_cursor
DEALLOCATE prt_entity_cursor


Truncate Table IFC.OTP_SRM_F;
Truncate Table IFC.OTP_SRM_M;


--Delete FROM IFC.DebtCase where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Debtor where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Contact where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.[Address] where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Person where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Company where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Invoice where SourceInterfaceType like 'OTPTA_%';


/*
select * from ORG.ModuleParameter where ModuleID = 7-- 7 Storage to IFC
select * from ORG.ModuleParameter where ModuleID = 9-- 9 IFC to PRT
select * from ORG.Module where ID = 9-- 9 IFC to PRT

exec IFC.DeleteTAData 1
*/
COMMIT tran

END;
go









/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
CREATE             PROCEDURE [IFC].[DeleteSRMData](
	@p_moduleInstanceID NUMERIC(16)=NULL
	/*@p_result INT OUTPUT*/)
-- =============================================
/*
 Author:				Tóth Gábor
 Creation date:			2022.11.28.
 Last modified date:	2022.12.09, Commit
Description:
  A program kitöröl minden @p_ModuleInstanceId-jú betöltéssel létrejött és "MODULE_INTERFACE_LOADER"-al betöltött adatot.
  Ha nincs megadva paraméter, akkor minden olyan adatot töröl, amit a "MODULE_INTERFACE_LOADER" modul tötltött be.
*/
-- =============================================

AS

BEGIN

DECLARE @id NUMERIC(16), @objectID NUMERIC(16), @contractID NUMERIC(16), @contractItemID NUMERIC(16)

--DECLARE CURSORS

DECLARE crm_collectioncontractsummary CURSOR FOR
select CRM.CollectionContractSummary.ID, CRM.CollectionContractSummary.ObjectID
	from CRM.CollectionContractSummary
	where CRM.CollectionContractSummary.ContractID IN (
		select CRM.Contract.ID
	from CRM.Contract
		join IFC.Contract IC on IC.ContractID = CRM.Contract.ID
	where IC.SourceInterfaceType IN (Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		)
	)
DECLARE crm_contractsigner CURSOR FOR
	select CRM.ContractSigner.ID, CRM.ContractSigner.ObjectID
	from CRM.ContractSigner
	where CRM.ContractSigner.ContractID IN (
		select CRM.Contract.ID
	from CRM.Contract
		join IFC.Contract IC on IC.ContractID = CRM.Contract.ID
	where IC.SourceInterfaceType IN (Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		)
	)
DECLARE crm_collectioncontractitem CURSOR FOR
	select CRM.CollectionContractItem.ID, CRM.CollectionContractItem.ObjectID
	from CRM.CollectionContractItem
	where CRM.CollectionContractItem.ContractItemID IN (
		select CRM.ContractItem.ID
	from CRM.Contract
		join IFC.Contract IC on IC.ContractID = CRM.Contract.ID
		join CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
	where IC.SourceInterfaceType IN (Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		)
	)
DECLARE crm_contractitem CURSOR FOR
	select CRM.ContractItem.ID, CRM.ContractItem.ObjectID
	from CRM.ContractItem
	where CRM.ContractItem.ID IN (
		select CRM.ContractItem.ID
	from CRM.Contract
		join IFC.Contract IC on IC.ContractID = CRM.Contract.ID
		join CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
	where IC.SourceInterfaceType IN (Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		)
	)
DECLARE crm_contract CURSOR FOR
	select CRM.Contract.ID, CRM.Contract.ObjectID
	from CRM.Contract
	where CRM.Contract.ID IN (
		select CRM.Contract.ID
	from CRM.Contract
		join IFC.Contract IC on IC.ContractID = CRM.Contract.ID
	where IC.SourceInterfaceType IN (Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		--and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		)
	)

-- 7 Storage to IFC


BEGIN TRAN

------------------------------------------------------------------------------------------------------------------------------------------------------------------
--- Delete CRM.CollectionContractSummary:

Print 'CRM.CollectionContractSummary';

OPEN crm_collectioncontractsummary

FETCH NEXT FROM crm_collectioncontractsummary
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM CRM.CollectionContractSummary
	WHERE CRM.CollectionContractSummary.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM crm_collectioncontractsummary
	INTO @id, @objectID

END
CLOSE crm_collectioncontractsummary
DEALLOCATE crm_collectioncontractsummary

------------------------------------------------------------------------------------------------------------------------------------------------------------------
--- Delete CRM.ContractSigner:

Print 'CRM.ContractSigner';

OPEN crm_contractsigner

FETCH NEXT FROM crm_contractsigner
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM CRM.ContractSigner
	WHERE CRM.ContractSigner.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM crm_contractsigner
	INTO @id, @objectID

END
CLOSE crm_contractsigner
DEALLOCATE crm_contractsigner

------------------------------------------------------------------------------------------------------------------------------------------------------------------
--- Delete CRM.CollectionContractItem:

Print 'CRM.CollectionContractItem';

OPEN crm_collectioncontractitem

FETCH NEXT FROM crm_collectioncontractitem
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM CRM.CollectionContractItem
	WHERE CRM.CollectionContractItem.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM crm_collectioncontractitem
	INTO @id, @objectID

END
CLOSE crm_collectioncontractitem
DEALLOCATE crm_collectioncontractitem

------------------------------------------------------------------------------------------------------------------------------------------------------------------
--- Delete CRM.ContractItem:

Print 'CRM.ContractItem';

OPEN crm_contractitem

FETCH NEXT FROM crm_contractitem
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM CRM.ContractItem
	WHERE CRM.ContractItem.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM crm_contractitem
	INTO @id, @objectID

END
CLOSE crm_contractitem
DEALLOCATE crm_contractitem

------------------------------------------------------------------------------------------------------------------------------------------------------------------
--- Delete CRM.Contract:

Print 'CRM.Contract';

OPEN crm_contract

FETCH NEXT FROM crm_contract
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM CRM.Contract
	WHERE CRM.Contract.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM crm_contract
	INTO @id, @objectID

END
CLOSE crm_contract
DEALLOCATE crm_contract

--Delete FROM IFC.DebtCase where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Debtor where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Contact where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.[Address] where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Person where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Company where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Invoice where SourceInterfaceType like 'OTPTA_%';


/*
select * from ORG.ModuleParameter where ModuleID = 7-- 7 Storage to IFC
select * from ORG.ModuleParameter where ModuleID = 9-- 9 IFC to PRT
select * from ORG.Module where ID = 9-- 9 IFC to PRT

exec IFC.DeleteTAData 1
*/

Truncate Table IFC.OTP_SRM_F;
Truncate Table IFC.OTP_SRM_M;

commit tran;

/*SELECT @p_result = 1;
		RETURN;*/

END;
go


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
CREATE PROCEDURE [IFC].[DeleteSeleniumData] 
-- =============================================
/*
 Author:				Bognár Dávid
 Creation date:			2023.09.12.
 Last modified date:	
*/
-- =============================================

AS
BEGIN
    BEGIN TRY
        BEGIN TRAN

        -- Itt jönnek a törlési műveletek
		DELETE FROM gen.object WHERE CreationUserName = 'indecs_selenium' AND ObjectType = 'OBJECT_TYPE_PRT_ADDRESS';
        DELETE FROM gen.object WHERE CreationUserName = 'indecs_selenium' AND ObjectType = 'OBJECT_TYPE_PRT_ENTITY' AND ID in (select ObjectId from PRT.Entity where  CreationUserName = 'indecs_selenium');
        DELETE FROM gen.object WHERE CreationUserName = 'indecs_selenium' AND ObjectType = 'OBJECT_TYPE_DCS_DEBTCASE';
        -- Ha minden rendben van, akkor commitáljuk a tranzakciót
        COMMIT TRAN
    END TRY
    BEGIN CATCH
        -- Ha hiba történik, akkor visszavonjuk a tranzakciót és kezeljük a hibát
        ROLLBACK TRAN;

        -- Itt kezeljük a hibát
        PRINT 'Hiba történt a tranzakció során: ' + ERROR_MESSAGE();
    END CATCH
END;
go


/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/
CREATE   PROCEDURE [IFC].[DeleteTAData](
	@p_moduleInstanceID NUMERIC(16)=NULL,
	@p_result nvarchar(200) OUTPUT)
-- =============================================
/*
 Author:				Tóth Gábor
 Creation date:			2022.11.28.
 Last modified date:	2022.12.09, Commit
Description:
  A program kitöröl minden @p_ModuleInstanceId-jú betöltéssel létrejött és "MODULE_INTERFACE_LOADER"-al betöltött adatot.
  Ha nincs megadva paraméter, akkor minden olyan adatot töröl, amit a "MODULE_INTERFACE_LOADER" modul tötltött be.
*/
-- =============================================

AS

BEGIN

DECLARE @id NUMERIC(16), @objectID NUMERIC(16), @contractID NUMERIC(16), @contractItemID NUMERIC(16)

--DECLARE CURSORS

DECLARE fin_transaction_cursor CURSOR FOR
	select FIN.[Transaction].ID, FIN.[Transaction].ObjectID
from DCS.DebtCase
	Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
	join FIN.InvoiceArrears on InvoiceArrears.InvoiceID = Invoice.ID
	Join FIN.Account on Account.InvoiceArrearsID = InvoiceArrears.ID
	Join FIN.[Transaction] on [Transaction].AccountID = Account.ID
where DebtCase.SourceInterFaceType IN
	(Select ModuleInstanceParameter.ParameterValue
	from ORG.ModuleInstance
	Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
	where
	ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
	and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
	and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
	and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
	);
DECLARE fin_account_cursor CURSOR FOR
	select FIN.Account.ID, FIN.Account.ObjectID
	from DCS.DebtCase
		Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
		join FIN.InvoiceArrears on InvoiceArrears.InvoiceID = Invoice.ID
		Join FIN.Account on Account.InvoiceArrearsID = InvoiceArrears.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE fin_invoicearrears_cursor CURSOR FOR
	select FIN.InvoiceArrears.ID
from DCS.DebtCase
	Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
	join FIN.InvoiceArrears on InvoiceArrears.InvoiceID = Invoice.ID
where DebtCase.SourceInterFaceType IN
	(Select ModuleInstanceParameter.ParameterValue
	from ORG.ModuleInstance
	Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
	where
	ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
	and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
	and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
	and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
	);
DECLARE fin_invoicetotal_cursor CURSOR FOR
	select FIN.InvoiceTotal.ID
	from DCS.DebtCase
		Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
		join FIN.InvoiceTotal on InvoiceTotal.InvoiceID = Invoice.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE fin_calculationinvoice_cursor CURSOR FOR
	select FIN.CalculationInvoice.ID, FIN.CalculationInvoice.ObjectID
	from DCS.DebtCase
		Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
		join FIN.CalculationInvoice on FIN.CalculationInvoice.InvoiceID = FIN.Invoice.ID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE fin_invoice_cursor CURSOR FOR
	select FIN.Invoice.ID, FIN.Invoice.ObjectID
	from DCS.DebtCase
		Join FIN.Invoice on DebtCase.ID = Invoice.DebtCaseID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_address_cursor CURSOR FOR
	Select PRT.Address.ID, PRT.Address.ObjectID
	from PRT.Entity
		join PRT.[Address] on [Address].EntityID = Entity.ID
		Join GEN.[Object] on [Object].ID = [Address].ObjectID
	where Entity.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_contact_cursor CURSOR FOR
	Select PRT.Contact.ID, PRT.Contact.ObjectID
	from
		PRT.Entity
	join PRT.Contact on Contact.EntityID = Entity.ID
	where Entity.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_name_cursor CURSOR FOR
	Select PRT.Name.ID, PRT.Name.ObjectID
	from PRT.Entity
	join PRT.[Name] on [Name].EntityID = Entity.ID
	where Entity.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_assetvaluationvalue_cursor CURSOR FOR
	Select AST.AssetValuationValue.ID, AST.AssetValuationValue.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.EntityAsset on EntityAsset.EntityID = Debtor.EntityId
		Join AST.Asset on Asset.ID = EntityAsset.AssetID
		Join AST.AssetValuation on AssetValuation.AssetID = Asset.Id
		Join AST.AssetValuationValue on AssetValuationValue.AssetValuationID = AssetValuation.ID
		Join GEN.[Object] on [Object].ID = AssetValuationValue.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_assetvaluationvalue2_cursor CURSOR FOR
	Select AST.AssetValuationValue.ID, AST.AssetValuationValue.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtCaseAsset on DebtCaseAsset.DebtCaseID = DebtCase.Id
		Join AST.Asset on Asset.ID = DebtCaseAsset.AssetID
		Join AST.AssetValuation on AssetValuation.AssetID = Asset.Id
		Join AST.AssetValuationValue on AssetValuationValue.AssetValuationID = AssetValuation.ID
		Join GEN.[Object] on [Object].ID = AssetValuationValue.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_assetvaluation_cursor CURSOR FOR
	Select AST.AssetValuation.ID, AST.AssetValuation.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.EntityAsset on EntityAsset.EntityID = Debtor.EntityId
		Join AST.Asset on Asset.ID = EntityAsset.AssetID
		Join AST.AssetValuation on AssetValuation.AssetID = Asset.Id
		Join GEN.[Object] on [Object].ID = AssetValuation.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_assetvaluation2_cursor CURSOR FOR
	Select AST.AssetValuation.ID, AST.AssetValuation.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtCaseAsset on DebtCaseAsset.DebtCaseID = DebtCase.Id
		Join AST.Asset on Asset.ID = DebtCaseAsset.AssetID
		Join AST.AssetValuation on AssetValuation.AssetID = Asset.Id
		Join GEN.[Object] on [Object].ID = AssetValuation.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
/*DECLARE ast_debtorasset_cursor CURSOR FOR
	Select AST.DebtorAsset.ID, AST.DebtorAsset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtorAsset on DebtorAsset.DebtorID = Debtor.Id
		Join GEN.[Object] on [Object].ID = DebtorAsset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);*/
DECLARE ast_entityasset_cursor CURSOR FOR
	Select AST.EntityAsset.ID, AST.EntityAsset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.EntityAsset on EntityAsset.EntityID = Entity.Id
		Join GEN.[Object] on [Object].ID = EntityAsset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_debtcaseasset_cursor CURSOR FOR
	Select AST.DebtCaseAsset.ID, AST.DebtCaseAsset.ObjectID
	from
		DCS.DebtCase
		left Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		left Join PRT.Entity on Entity.ID = Debtor.EntityID
		left join AST.DebtCaseAsset on DebtCaseAsset.DebtCaseID = DebtCase.Id
		left Join GEN.[Object] on [Object].ID = DebtCaseAsset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_asset_cursor CURSOR FOR
	Select AST.Asset.ID, AST.Asset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.EntityAsset on EntityAsset.EntityID = Debtor.EntityId
		Join AST.Asset on Asset.ID = EntityAsset.AssetID
		Join GEN.[Object] on [Object].ID = Asset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE ast_asset2_cursor CURSOR FOR
	Select AST.Asset.ID, AST.Asset.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join PRT.Entity on Entity.ID = Debtor.EntityID
		join AST.DebtCaseAsset on DebtCaseAsset.DebtCaseID = DebtCase.Id
		Join AST.Asset on Asset.ID = DebtCaseAsset.AssetID
		Join GEN.[Object] on [Object].ID = Asset.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_person_cursor CURSOR FOR
	Select PRT.Person.ID
	from PRT.Entity
	join PRT.Person on Person.EntityID = Entity.ID
	where Entity.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_company_cursor CURSOR FOR
	Select PRT.Company.ID
	from PRT.Entity
	join PRT.Company on Company.EntityID = Entity.ID
	where Entity.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE dcs_debtcase_cursor CURSOR FOR
	Select DCS.DebtCase.ID, DCS.DebtCase.ObjectID
	from
		DCS.DebtCase
		Join GEN.[Object] on [Object].ID = DebtCase.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE dcs_debtor_cursor CURSOR FOR
	Select DCS.Debtor.ID, DCS.Debtor.ObjectID
	from
		DCS.DebtCase
		Join DCS.Debtor on Debtor.DebtCaseID = DebtCase.Id
		Join GEN.[Object] on [Object].ID = Debtor.ObjectID
	where DebtCase.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_entityidentifier_cursor CURSOR FOR
	Select PRT.EntityIdentifier.ID, PRT.EntityIdentifier.ObjectID
	from PRT.Entity
		join PRT.EntityIdentifier on EntityIdentifier.EntityID = Entity.ID
		Join GEN.[Object] on [Object].ID = EntityIdentifier.ObjectID
	where Entity.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_entitynegativeevent CURSOR FOR
	Select PRT.EntityNegativeEvent.ID, PRT.EntityNegativeEvent.ObjectID
	from PRT.Entity
		join PRT.EntityNegativeEvent on EntityNegativeEvent.EntityID = Entity.ID
		Join GEN.[Object] on [Object].ID = EntityNegativeEvent.ObjectID
	where Entity.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_entityrelation_cursor CURSOR FOR
	Select PRT.EntityRelation.ID, PRT.EntityRelation.ObjectID
	from PRT.Entity
		join PRT.EntityRelation on (EntityRelation.FromEntityID = Entity.ID or EntityRelation.ToEntityID = Entity.ID)
		Join GEN.[Object] on [Object].ID = EntityRelation.ObjectID
	where Entity.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);
DECLARE prt_entity_cursor CURSOR FOR
	Select PRT.Entity.ID, PRT.Entity.ObjectID
		from PRT.Entity
		Join GEN.[Object] on [Object].ID = Entity.ObjectID
	where Entity.SourceInterFaceType IN
		(Select ModuleInstanceParameter.ParameterValue
		from ORG.ModuleInstance
		Join ORG.ModuleInstanceParameter on ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID
		where
		ModuleInstance.ModuleID = 9 /*MODULE_INTERFACE_LOADER */
		and ModuleInstanceParameter.ParameterValue like 'OTPTA_%'
		and ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE '
		and ModuleInstanceID = (Case when @p_ModuleInstanceId is not null then @p_ModuleInstanceId else ModuleInstanceID end)
		);

-- 7 Storage to IFC

--Truncate Table IFC.OTP_TA_FC;
--Truncate Table IFC.OTP_TA_FF;
--Truncate Table IFC.OTP_TA_FK;
--Truncate Table IFC.OTP_TA_FU;

BEGIN TRAN
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 1 - Delete FIN.[Transaction]:
Print 'FIN.Transaction';

OPEN fin_transaction_cursor

FETCH NEXT FROM fin_transaction_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.[Transaction]
	WHERE FIN.[Transaction].ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM fin_transaction_cursor
	INTO @id, @objectID

END
CLOSE fin_transaction_cursor
DEALLOCATE fin_transaction_cursor


------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 2 - Delete FIN.Account:
Print 'FIN.Account';

OPEN fin_account_cursor

FETCH NEXT FROM fin_account_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.Account
	WHERE FIN.Account.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM fin_account_cursor
	INTO @id, @objectID

END
CLOSE fin_account_cursor
DEALLOCATE fin_account_cursor


------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 3 - Delete FIN.InvoiceArrears:
Print 'FIN.InvoiceArrears';

OPEN fin_invoicearrears_cursor

FETCH NEXT FROM fin_invoicearrears_cursor
	INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.InvoiceArrears
	WHERE FIN.InvoiceArrears.ID = @id;


FETCH NEXT FROM fin_invoicearrears_cursor
	INTO @id

END
CLOSE fin_invoicearrears_cursor
DEALLOCATE fin_invoicearrears_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 4 - FIN.InvoiceTotal:
Print 'FIN.InvoiceTotal';

OPEN fin_invoicetotal_cursor

FETCH NEXT FROM fin_invoicetotal_cursor
	INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.InvoiceTotal
	WHERE FIN.InvoiceTotal.ID = @id;


FETCH NEXT FROM fin_invoicetotal_cursor
	INTO @id

END
CLOSE fin_invoicetotal_cursor
DEALLOCATE fin_invoicetotal_cursor;

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 5 - FIN.Calculation
--Print 'FIN.Calculation';
-- Delete FIN.CalculationInvoice:
Print 'FIN.CalculationInvoice';

OPEN fin_calculationinvoice_cursor

FETCH NEXT FROM fin_calculationinvoice_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.CalculationInvoice
	WHERE FIN.CalculationInvoice.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM fin_calculationinvoice_cursor
	INTO @id, @objectID

END
CLOSE fin_calculationinvoice_cursor
DEALLOCATE fin_calculationinvoice_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 6 - Delete FIN.Invoice:
Print 'FIN.Invoice';

OPEN fin_invoice_cursor

FETCH NEXT FROM fin_invoice_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM FIN.Invoice
	WHERE FIN.Invoice.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM fin_invoice_cursor
	INTO @id, @objectID

END
CLOSE fin_invoice_cursor
DEALLOCATE fin_invoice_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 7 - PRT.Address
Print 'PRT.Address';

OPEN prt_address_cursor

FETCH NEXT FROM prt_address_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Address
	WHERE PRT.Address.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_address_cursor
	INTO @id, @objectID

END
CLOSE prt_address_cursor
DEALLOCATE prt_address_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 8 - PRT.Contact:
Print 'PRT.Contact';

OPEN prt_contact_cursor

FETCH NEXT FROM prt_contact_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Contact
	WHERE PRT.Contact.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_contact_cursor
	INTO @id, @objectID

END
CLOSE prt_contact_cursor
DEALLOCATE prt_contact_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 9 - PRT.Name:
Print 'PRT.Name';

OPEN prt_name_cursor

FETCH NEXT FROM prt_name_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Name
	WHERE PRT.Name.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_name_cursor
	INTO @id, @objectID

END
CLOSE prt_name_cursor
DEALLOCATE prt_name_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 10 - AST.AssetValuationValue (Debtor):
Print 'AST.AssetValuationValue (Debtor)';

OPEN ast_assetvaluationvalue_cursor

FETCH NEXT FROM ast_assetvaluationvalue_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.AssetValuationValue
	WHERE AST.AssetValuationValue.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_assetvaluationvalue_cursor
	INTO @id, @objectID

END
CLOSE ast_assetvaluationvalue_cursor
DEALLOCATE ast_assetvaluationvalue_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 11 - AST.AssetValuationValue (DebtCase):
Print 'AST.AssetValuationValue (DebtCase)';

OPEN ast_assetvaluationvalue2_cursor

FETCH NEXT FROM ast_assetvaluationvalue2_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.AssetValuationValue
	WHERE AST.AssetValuationValue.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_assetvaluationvalue2_cursor
	INTO @id, @objectID

END
CLOSE ast_assetvaluationvalue2_cursor
DEALLOCATE ast_assetvaluationvalue2_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 12 - AST.AssetValuation (Debtor):
Print 'AST.AssetValuation (Debtor)';

OPEN ast_assetvaluation_cursor

FETCH NEXT FROM ast_assetvaluation_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.AssetValuation
	WHERE AST.AssetValuation.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_assetvaluation_cursor
	INTO @id, @objectID

END
CLOSE ast_assetvaluation_cursor
DEALLOCATE ast_assetvaluation_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 15 - AST.AssetValuation (DebtCase):
Print 'AST.AssetValuation (DebtCase)';

OPEN ast_assetvaluation2_cursor

FETCH NEXT FROM ast_assetvaluation2_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.AssetValuation
	WHERE AST.AssetValuation.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_assetvaluation2_cursor
	INTO @id, @objectID

END
CLOSE ast_assetvaluation2_cursor
DEALLOCATE ast_assetvaluation2_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
/*-- 14 - AST.DebtorAsset (Debtor):
Print 'AST.DebtorAsset (Debtor)';

OPEN ast_debtorasset_cursor

FETCH NEXT FROM ast_debtorasset_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.DebtorAsset
	WHERE AST.DebtorAsset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_debtorasset_cursor
	INTO @id, @objectID

END
CLOSE ast_debtorasset_cursor
DEALLOCATE ast_debtorasset_cursor*/

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 14 - AST.EntityAsset (Debtor):
Print 'AST.EntityAsset (Debtor)';

OPEN ast_entityasset_cursor

FETCH NEXT FROM ast_entityasset_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.EntityAsset
	WHERE AST.EntityAsset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_entityasset_cursor
	INTO @id, @objectID

END
CLOSE ast_entityasset_cursor
DEALLOCATE ast_entityasset_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 17 - AST.DebtCaseAsset (DebtCase):
Print 'AST.DebtCaseAsset (DebtCase)';

OPEN ast_debtcaseasset_cursor

FETCH NEXT FROM ast_debtcaseasset_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.DebtCaseAsset
	WHERE AST.DebtCaseAsset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_debtcaseasset_cursor
	INTO @id, @objectID

END
CLOSE ast_debtcaseasset_cursor
DEALLOCATE ast_debtcaseasset_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 13 - AST.Asset (Debtor):
Print 'AST.Asset (Debtor)';

OPEN ast_asset_cursor

FETCH NEXT FROM ast_asset_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.Asset
	WHERE AST.Asset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_asset_cursor
	INTO @id, @objectID

END
CLOSE ast_asset_cursor
DEALLOCATE ast_asset_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 16 - AST.Asset (DebtCase):
Print 'AST.Asset (DebtCase)';

OPEN ast_asset2_cursor

FETCH NEXT FROM ast_asset2_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM AST.Asset
	WHERE AST.Asset.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM ast_asset2_cursor
	INTO @id, @objectID

END
CLOSE ast_asset2_cursor
DEALLOCATE ast_asset2_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 18 - PRT.Person
Print 'PRT.Person';
-- Nincs PRT.Person.ObjectID mező

OPEN prt_person_cursor

FETCH NEXT FROM prt_person_cursor
	INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Person
	WHERE PRT.Person.ID = @id;

FETCH NEXT FROM prt_person_cursor
	INTO @id

END
CLOSE prt_person_cursor
DEALLOCATE prt_person_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 18 - PRT.Company
Print 'PRT.Company';
-- Nincs PRT.Company.ObjectID mező

OPEN prt_company_cursor

FETCH NEXT FROM prt_company_cursor
	INTO @id

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Company
	WHERE PRT.Company.ID = @id;

FETCH NEXT FROM prt_company_cursor
	INTO @id

END
CLOSE prt_company_cursor
DEALLOCATE prt_company_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 21 - DCS.Debtor:
Print 'PRT.Debtor';

Print 'DCS.DebtCAse update';

OPEN dcs_debtcase_cursor

FETCH NEXT FROM dcs_debtcase_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

UPDATE DCS.DebtCase
	SET MainDebtorID = NULL
	WHERE ID = @id

FETCH NEXT FROM dcs_debtcase_cursor
	INTO @id, @objectID

END
CLOSE dcs_debtcase_cursor
--DEALLOCATE dcs_debtcase_cursor

OPEN dcs_debtor_cursor

FETCH NEXT FROM dcs_debtor_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM DCS.Debtor
	WHERE DCS.Debtor.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM dcs_debtor_cursor
	INTO @id, @objectID

END
CLOSE dcs_debtor_cursor
DEALLOCATE dcs_debtor_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 22 - DCS.DebtCase:
Print 'DCS.DebtCase';

OPEN dcs_debtcase_cursor

FETCH NEXT FROM dcs_debtcase_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

DECLARE crm_contract_cursor CURSOR FOR
	SELECT CRM.Contract.ID
		FROM CRM.Contract
			JOIN CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
			JOIN CRM.CollectionContractItem ON CRM.CollectionContractItem.ContractItemID = CRM.ContractItem.ID
		WHERE CRM.CollectionContractItem.DebtCaseID = @id

OPEN crm_contract_cursor

FETCH NEXT FROM crm_contract_cursor
	INTO @contractID

WHILE @@FETCH_STATUS = 0
BEGIN

DELETE FROM CRM.CollectionContractItem
WHERE CRM.CollectionContractItem.ID IN (SELECT CRM.CollectionContractItem.ID
											FROM CRM.Contract
												JOIN CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
												JOIN CRM.CollectionContractItem ON CRM.CollectionContractItem.ContractItemID = CRM.ContractItem.ID
											WHERE CRM.Contract.ID = @contractID)

DELETE FROM CRM.ContractItem
WHERE CRM.ContractItem.ID IN (SELECT CRM.ContractItem.ID
											FROM CRM.Contract
												JOIN CRM.ContractItem on CRM.ContractItem.ContractID = CRM.Contract.ID
												JOIN CRM.CollectionContractItem ON CRM.CollectionContractItem.ContractItemID = CRM.ContractItem.ID
											WHERE CRM.Contract.ID = @contractID)

DELETE FROM CRM.Contract
WHERE CRM.Contract.ID = @contractID

FETCH NEXT FROM crm_contract_cursor
	INTO @contractID

END
CLOSE crm_contract_cursor
DEALLOCATE crm_contract_cursor

Delete FROM DCS.DebtCase
	WHERE DCS.DebtCase.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM dcs_debtcase_cursor
	INTO @id, @objectID

END
CLOSE dcs_debtcase_cursor
DEALLOCATE dcs_debtcase_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 19 - PRT.EntityIdentifier:
Print 'PRT.EntityIdentifier';

OPEN prt_entityidentifier_cursor

FETCH NEXT FROM prt_entityidentifier_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.EntityIdentifier
	WHERE PRT.EntityIdentifier.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_entityidentifier_cursor
	INTO @id, @objectID

END
CLOSE prt_entityidentifier_cursor
DEALLOCATE prt_entityidentifier_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 20 - PRT.EntityNegativeEvent:
Print 'PRT.EntityNegativeEvent';

OPEN prt_entitynegativeevent

FETCH NEXT FROM prt_entitynegativeevent
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.EntityNegativeEvent
	WHERE PRT.EntityNegativeEvent.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_entitynegativeevent
	INTO @id, @objectID

END
CLOSE prt_entitynegativeevent
DEALLOCATE prt_entitynegativeevent

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 21 - PRT.EntityRelation:
Print 'PRT.EntityRelation';

OPEN prt_entityrelation_cursor

FETCH NEXT FROM prt_entityrelation_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.EntityRelation
	WHERE PRT.EntityRelation.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_entityrelation_cursor
	INTO @id, @objectID

END
CLOSE prt_entityrelation_cursor
DEALLOCATE prt_entityrelation_cursor

------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 22 - PRT.Entity:
Print 'PRT.Entity';

OPEN prt_entity_cursor

FETCH NEXT FROM prt_entity_cursor
	INTO @id, @objectID

WHILE @@FETCH_STATUS = 0
BEGIN

Delete FROM PRT.Entity
	WHERE PRT.Entity.ID = @id;

Delete FROM GEN.Object
--select *
WHERE GEN.Object.ID = @objectID;

FETCH NEXT FROM prt_entity_cursor
	INTO @id, @objectID

END
CLOSE prt_entity_cursor
DEALLOCATE prt_entity_cursor




--Delete FROM IFC.DebtCase where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Debtor where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Contact where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.[Address] where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Person where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Company where SourceInterfaceType like 'OTPTA_%';
--Delete FROM IFC.Invoice where SourceInterfaceType like 'OTPTA_%';


/*
select * from ORG.ModuleParameter where ModuleID = 7-- 7 Storage to IFC
select * from ORG.ModuleParameter where ModuleID = 9-- 9 IFC to PRT
select * from ORG.Module where ID = 9-- 9 IFC to PRT

exec IFC.DeleteTAData 1
*/

commit tran;

SELECT @p_result = 0;
SELECT @p_result;
		RETURN;

END;
go

-- =============================================
-- Author:		Kiss János
-- Create date: 2022-11-18
-- Last modified date: 2022-11-18
-- Description:	PRT.Entity copy procedure
-- =============================================
CREATE PROCEDURE [PRT].[EntityCopy]
	@EntityID NUMERIC(16)

AS

BEGIN

	DECLARE @ErrorMSG NVARCHAR(200)
	DECLARE @LogMessage NVARCHAR(200)
	DECLARE @ObjectID NUMERIC(16)
	DECLARE @index NUMERIC(16)

	SET @ErrorMSG = NULL

	BEGIN TRANSACTION
		
		BEGIN TRY
			SET @LogMessage = 'Starting procedure...'
			PRINT (@LogMessage)

			IF (SELECT PRT.Entity.EntityType
					FROM PRT.Entity
					WHERE PRT.Entity.ID = @EntityID) = 'C'
			BEGIN
				SET @LogMessage = 'Copy company...'
				PRINT (@LogMessage)

				INSERT INTO GEN.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr, PortfolioID)
					VALUES('OBJECT_TYPE_PRT_ENTITY', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', cast(@EntityID as NVARCHAR(50)) + ' entity id copy', '1.0.0',
							(SELECT GEN.Object.PortfolioID 
								FROM GEN.Object
								WHERE GEN.Object.ID = (SELECT PRT.Entity.ObjectID
															FROM PRT.Entity
															WHERE PRT.Entity.ID = @EntityID)))

				SELECT @ObjectID = @@IDENTITY

				INSERT INTO PRT.Entity(ObjectID, EntityType, CreationDate, CreationTime, CreationUserName, Comments, SourceID, SourceInterfaceType)
					SELECT @ObjectID,
							PRT.Entity.EntityType,
							CAST( GETDATE() AS Date),
							CONVERT(VARCHAR(8), GETDATE(),108),
							'Admin',
							PRT.Entity.Comments,
							PRT.Entity.SourceID,
							PRT.Entity.SourceInterfaceType
						FROM PRT.Entity 
						WHERE PRT.Entity.ID = @EntityID

				SELECT @index = @@IDENTITY

				INSERT INTO PRT.Company(Name, RegistrationNr, TaxNr, StatisticalNr, LegalFormCode, LegalStatusCode, EntityID, CreationDate, CreationTime, CreationUserName, Comments, RegistrationDate, StatusCode)
					SELECT PRT.Company.Name,
							PRT.Company.RegistrationNr,
							PRT.Company.TaxNr,
							PRT.Company.StatisticalNr,
							PRT.Company.LegalFormCode,
							PRT.Company.LegalStatusCode,
							@index,
							CAST( GETDATE() AS Date),
							CONVERT(VARCHAR(8), GETDATE(),108),
							'Admin',
							PRT.Company.Comments,
							PRT.Company.RegistrationDate,
							PRT.Company.StatusCode
						FROM PRT.Company 
						WHERE PRT.Company.EntityID = @EntityID

				SET @LogMessage = 'Copy company finished...'
				PRINT (@LogMessage)
			END

			IF (SELECT PRT.Entity.EntityType
					FROM PRT.Entity
					WHERE PRT.Entity.ID = @EntityID) = 'P'
			BEGIN

				SET @LogMessage = 'Copy person...'
				PRINT (@LogMessage)

				INSERT INTO GEN.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr, PortfolioID)
					VALUES('OBJECT_TYPE_PRT_ENTITY', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', cast(@EntityID as NVARCHAR(50)) + ' entity id copy', '1.0.0',
							(SELECT GEN.Object.PortfolioID 
								FROM GEN.Object
								WHERE GEN.Object.ID = (SELECT PRT.Entity.ObjectID
															FROM PRT.Entity
															WHERE PRT.Entity.ID = @EntityID)))

				SELECT @ObjectID = @@IDENTITY

				INSERT INTO PRT.Entity(ObjectID, EntityType, CreationDate, CreationTime, CreationUserName, Comments, SourceID, SourceInterfaceType)
					SELECT @ObjectID,
							PRT.Entity.EntityType,
							CAST( GETDATE() AS Date),
							CONVERT(VARCHAR(8), GETDATE(),108),
							'Admin',
							PRT.Entity.Comments,
							PRT.Entity.SourceID,
							PRT.Entity.SourceInterfaceType
						FROM PRT.Entity 
						WHERE PRT.Entity.ID = @EntityID

				SELECT @index = @@IDENTITY

				INSERT INTO PRT.Person(LastName, MiddleName, FirstName, Title, MotherLastName, MotherFirstName, BirthPlace, BirthDate, Sex, MaidenLastName,MaidenFirstName, FathersName, EntityID, CreationDate, CreationTime, CreationUserName,
										NationalityCode, BirthCountryCode, DeathDate, DeathCountryCode, DeathZipCode, DeathPlace, StatusCode)
					SELECT PRT.Person.LastName,
							PRT.Person.MiddleName,
							PRT.Person.FirstName,
							PRT.Person.Title,
							PRT.Person.MotherLastName,
							PRT.Person.MotherFirstName,
							PRT.Person.BirthPlace,
							PRT.Person.BirthDate,
							PRT.Person.Sex,
							PRT.Person.MaidenLastName,
							PRT.Person.MaidenFirstName,
							PRT.Person.FathersName,
							@index,
							CAST( GETDATE() AS Date),
							CONVERT(VARCHAR(8), GETDATE(),108),
							2,
							PRT.Person.NationalityCode,
							PRT.Person.BirthCountryCode,
							PRT.Person.DeathDate,
							PRT.Person.DeathCountryCode,
							PRT.Person.DeathZipCode,
							PRT.Person.DeathPlace,
							PRT.Person.StatusCode
						FROM PRT.Person
						WHERE PRT.Person.EntityID = @EntityID

				SET @LogMessage = 'Copy person finished'
				PRINT (@LogMessage);
			/*bERAKTAM, MERT KELL MCS 20221119*/
			PRINT  'bla';


		
			END

			COMMIT TRANSACTION

			IF (SELECT PRT.Entity.EntityType
					FROM PRT.Entity
					WHERE PRT.Entity.ID = @EntityID) = 'P'
				BEGIN
				SELECT PRT.Person.ID
					FROM PRT.Person
					WHERE PRT.Person.EntityID = @index
				END

			IF (SELECT PRT.Entity.EntityType
					FROM PRT.Entity
					WHERE PRT.Entity.ID = @EntityID) = 'C'
				BEGIN
				SELECT PRT.Company.ID
					FROM PRT.Company
					WHERE PRT.Company.EntityID = @index
				END


			
		END TRY
		BEGIN CATCH
				SELECT  
            ERROR_NUMBER() AS ErrorNumber  
            ,ERROR_SEVERITY() AS ErrorSeverity  
            ,ERROR_STATE() AS ErrorState  
            ,ERROR_PROCEDURE() AS ErrorProcedure  
            ,ERROR_LINE() AS ErrorLine  
            ,ERROR_MESSAGE() AS ErrorMessage;
				SET @LogMessage = 'ERROR'
				PRINT (@LogMessage)
				ROLLBACK TRANSACTION

		END CATCH

end 
go

-- =============================================
-- Author:		<Csaba Meszaros>
-- Create date: <2022-11-28>
-- LastModified date: <2022-11-28>
-- Description:	<Sp returns the EntityRelation table
-- Input parameters: EntityID
--					LanguageID
-- >
-- =============================================
CREATE PROCEDURE [PRT].[EntityRelationData]
	@p_EntityID NUMERIC(16,0),
	@p_Language NVARCHAR(5) = 'HU'
AS
BEGIN
	SET NOCOUNT ON;
		SELECT 
        deb.[DebtCaseID] AS "DebtCaseID",
        dc.[DebtNr] AS "DebtNr",
        (
            SELECT tra.[Text] 
                FROM GEN.Translation tra 
                    WHERE tra.[Language] = @p_Language
                    AND tra.[CodeID] = deb.[RoleCode]
        ) AS "Role",
        NULL AS "Status",
        NULL AS "Stage",
        (
            SELECT tra.[Text] 
                FROM GEN.Translation tra 
                    WHERE tra.[Language] = @p_Language
                    AND tra.[CodeID] = dc.[PhaseID]
        ) AS "Phase",
        dc.[PurchaseDate] AS "PurchaseDate",
        COALESCE((
            SELECT SUM(acc.Balance)
                FROM FIN.Calculation calc 
                JOIN FIN.Account acc ON acc.[CalculationID] = calc.[ID]
                    WHERE calc.[ID] = dc.[MainCalculationID]
                    AND acc.[CurrencyCode] = dc.[CurrencyCode]
        ), 0) 
        *
        COALESCE((
            SELECT TOP 1 Rate
                FROM FIN.ExchangeRate
                    WHERE SourceCurrencyCode = dc.[CurrencyCode] 
                    AND TargetCurrencyCode = 'CURRENCY_HUF'
                        ORDER BY ExchangeDate DESC
        ), 1)
        +
        COALESCE((
            SELECT SUM(acc.Balance)
                FROM FIN.Calculation calc 
                JOIN FIN.Account acc ON acc.[CalculationID] = calc.[ID]
                    WHERE calc.[ID] = dc.[MainCalculationID]
                    AND acc.[CurrencyCode] <> dc.[CurrencyCode]
                    AND acc.[CurrencyCode] = 'CURRENCY_HUF'
        ), 0) 
        AS "RemainingDebt",
        (
            SELECT tra.[Text] 
                FROM GEN.Translation tra 
                    WHERE tra.[Language] = @p_Language
                    AND tra.[CodeID] = 
                        (
                            SELECT TOP 1 ev.[EventTypeCode]
                                FROM COM.[Event] ev
                                JOIN COM.[Interaction] inter ON inter.[EventID] = ev.[ID]
                                JOIN COM.[InteractionObject] interobj ON interobj.[InteractionID] = inter.[ID]
                                JOIN GEN.[Object] obj ON obj.[ID] = interobj.[RelatedObjectID]
                                    WHERE obj.[ID] = dc.[ObjectID]
                                        ORDER BY inter.[CreationDate] DESC
                        )
        ) AS "LastInteractionType"
            FROM PRT.[Entity] ent
            JOIN DCS.Debtor deb ON ent.[ID] = deb.[EntityID]
            JOIN DCS.[DebtCase] dc ON deb.[DebtCaseID] = dc.[ID]
                WHERE ent.[ID] = @p_EntityID
    
    RETURN;
END
go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2022-11-21
-- Last modified date: 2023.04.17
-- Description:	Run stored procedures as a module.
-- 
-- Added @p_Result OUT param Csaba Meszaros
-- 
-- Inner @l_Result is passed to outer @p_Result
-- =============================================
CREATE   PROCEDURE [ORG].[ExecuteModuleProcedure] 
	-- Add the parameters for the stored procedure here
	@p_correlationID NVARCHAR(200), 
	@p_moduleInstanceID NUMERIC(16),
	@p_Result NUMERIC(16,0) OUT
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'ORG.ExecuteModuleProcedure'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_sqlStatement NVARCHAR(MAX) = NULL;
	DECLARE @l_params NVARCHAR(200) = NULL;
	DECLARE @l_result INT = NULL;
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--
	--Amennyiben alkalmazunk cursor-okat, akkor azok definiálása (opcionális)
	--
	
	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);
		PRINT @l_logMsg;

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';
		PRINT @l_logMsg;

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sqlStatement = [ModuleProcedure].[SQLStatement] 
			FROM [ORG].[ModuleProcedure]
			JOIN [ORG].[ModuleInstance] ON ([ModuleInstance].[ModuleID] = [ModuleProcedure].[ModuleID])
			WHERE [ModuleInstance].[ID] = @p_moduleInstanceID;
		END

		IF COALESCE(@l_sqlStatement, '') = '' 
			RAISERROR('The SQL statement field is not defined!', 16, 1);

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';
		PRINT @l_logMsg;

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
		
		SELECT @l_logMsg = CONCAT('The value of SQL statement variable: ', @l_sqlStatement);
		PRINT @l_logMsg;

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
		
		SELECT @l_logMsg = 'Executing of SQL statement...';
		PRINT @l_logMsg;

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		SELECT @l_params = N'@l_correlationID NVARCHAR(200), @l_moduleInstanceID NUMERIC(16), @l_resultOUT INT OUTPUT';

		PRINT CONCAT('EXECUTE sp_executesql '
			, @l_sqlStatement, ', '
			, @l_params, ', '
			, @p_correlationID, ', '
			, @p_moduleInstanceID, ', '
			, '@l_resultOUT=@l_result OUTPUT');

		EXECUTE sp_executesql 
			@l_sqlStatement, 
			@l_params, 
			@l_correlationID = @p_correlationID, 
			@l_moduleInstanceID = @p_moduleInstanceID, 
			@l_resultOUT=@l_result OUTPUT;

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);
		PRINT @l_logMsg;

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;
		COMMIT TRANSACTION LOG_TRANSACTION;

		SELECT @p_Result = (SELECT ISNULL(@l_result, 1));
		RETURN @p_Result;
	END TRY

	BEGIN CATCH
		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());
		PRINT CONCAT('CATCH ERROR: ', @l_errorMsg);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;

		SELECT @p_Result = 99;
		RETURN @p_Result;
	END CATCH
END
go

/*----------------------------------------------------------------------------------------------
  Author: Gyenese Katalin
  Create date: 2023.08.16. - DV-1104
  Last modified date: 2023.08.16.
  Description:	Exports MIS forms to .json file
  
  Parameters: 
    - @p_formIDs: table containing the formID-s which have to be exported
    - @p_CorrelationID: the correlationID of the caller
    - @p_UserName: the userName of the caller
    - @p_json (output): the exported json data
----------------------------------------------------------------------------------------------*/
CREATE   procedure [MIS].[ExportJsonMis](@p_formIDs GEN.NumericType READONLY, @p_CorrelationID NVarChar(200), @p_UserName NVarChar(200), @p_json NVarChar(max) output)
as
begin
  set NOCOUNT ON
  set XACT_ABORT ON

  
  /*variables for logging*/
	declare @errormsg NVarChar(max),	@logMessage nvarchar(max), @procedureName nvarchar(100) = 'MIS.ExportJsonMis',
          @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*table variables for folders, filterFolders, filterCatalogFolders hierarchy*/ 
  declare @Folders table(formID Numeric(16, 0), folderID Numeric(16, 0), parentFolderID Numeric(16, 0), Level int)
  declare @FilterFolders table(formID Numeric(16, 0), folderID Numeric(16, 0), parentFolderID Numeric(16, 0), Level int)
  declare @FilterCatalogFolders table(formID Numeric(16, 0), folderID Numeric(16, 0), parentFolderID Numeric(16, 0), Level int)

  declare @defaultLanguageISO NVarChar(2) = 'HU' /*this will be the first language when generating translation json parts */


  begin try
    /*Logging procedure start*/
    set @logMessage = Concat('Start procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    /*Logging parameter check*/
    set @logMessage = 'Checking parameters...'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    if not exists(select *  
                  from @p_formIDs
                 )
       raiserror('The @p_formIDs table parameter contains no records.', 16, 1)

    if exists(select *
              from @p_formIDs p
              where not exists(select *
                               from MIS.Form f
                               where f.ID = p.id
                              )
             )
       raiserror('The @p_formIDs table parameter contains not existing formID(s).', 16, 1)


    if IsNull(@p_UserName, '') = ''
       raiserror('The @p_UserName parameter is compulsory.', 16, 1)


    ------------------------------------------------------------------------------------------------------------------------
    /*Logging start processing*/
    set @logMessage = 'Start processing - constructing folder hierarchy'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    /*construct folder hierarchy (folders used in MIS.Form)*/
    ;with folders_CTE(formID, folderID, parentFolderID, level)
    as (
        select f.ID formID, o.ID folderID, o.parentFolderID, 1 level
        from MIS.Form f join GEN.Folder o on f.FolderID = o.ID
        where exists(select *
                     from @p_formIDs ids
                     where ids.id = f.id
                    )
        union all
        select child.formID, o.ID folderID, o.parentFolderID, child.level + 1 level
        from GEN.Folder o join folders_CTE child on o.ID = child.ParentFolderID
        where o.ID <> child.folderID
       )
    insert into @Folders(formID, folderID, parentFolderID, Level)
       select folders_CTE.formID, folders_CTE.folderID, folders_CTE.parentFolderID, folders_CTE.Level
       from folders_CTE


    ------------------------------------------------------------------------------------------------------------------------

    set @logMessage = 'Constructing filterFolder hierarchy'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

    /*construct filterFolder hierarchy (folders used in MIS.FormFilter)*/
    ;with filterFolders_CTE(formID, folderID, parentFolderID, level)
    as (select f.FormID, o.ID folderID, o.parentFolderID, 1 level
        from MIS.FormFilter f join GEN.Folder o on f.FolderID = o.ID
        where exists(select *
                     from @p_formIDs ids
                     where ids.id = f.FormID
                    )
        group by f.FormID, o.ID, o.ParentFolderID
        union all
        select child.formID, o.ID folderID, o.parentFolderID, child.level + 1 level
        from GEN.Folder o join filterFolders_CTE child on o.ID = child.ParentFolderID
        where o.ID <> child.folderID
       )
    insert into @FilterFolders(formID, folderID, parentFolderID, Level)
       select distinct filterFolders_CTE.formID, filterFolders_CTE.folderID, filterFolders_CTE.parentFolderID, filterFolders_CTE.Level
       from filterFolders_CTE

    ------------------------------------------------------------------------------------------------------------------------

    set @logMessage = 'Constructing filterCatalogFolder hierarchy'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

    /*construct filterCatalogFolder hierarchy (folders used in MIS.Filter)*/
    ;with filterCatalogFolders_CTE(formID, folderID, parentFolderID, level)
    as (select ffi.FormID, o.ID folderID, o.parentFolderID, 1 level
        from MIS.Filter fi join GEN.Folder o on fi.FolderID = o.ID
                          join MIS.FormFilter ffi on  fi.ID = ffi.FilterID
        where exists(select *
                     from @p_formIDs ids
                     where ids.id = ffi.FormID
                    )
        group by ffi.FormID, o.ID, o.ParentFolderID
        union all
        select child.formID, o.ID folderID, o.parentFolderID, child.level + 1 level
        from GEN.Folder o join filterCatalogFolders_CTE child on o.ID = child.ParentFolderID
        where o.ID <> child.folderID
       )
    insert into @FilterCatalogFolders(formID, folderID, parentFolderID, Level)
       select distinct filterCatalogFolders_CTE.formID, filterCatalogFolders_CTE.folderID, filterCatalogFolders_CTE.parentFolderID, filterCatalogFolders_CTE.Level
       from filterCatalogFolders_CTE


    ------------------------------------------------------------------------------------------------------------------------

    set @logMessage = 'Constructing final JSON'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

    select @p_json = (   select /*header*/  
                                 JSON_QUERY((select 'INDECS' system, '3' version, 'MIS_FORM' type, @p_UserName userID, null userEmail, Cast(GetDate() AS Date) /*this is the date of the export*/ lastModDate, 'UTF-8' encoding, 
                                                    (select COUNT(*) from @p_formIDs) itemCount
                                             for JSON PATH, INCLUDE_NULL_VALUES, WITHOUT_ARRAY_WRAPPER
                                            ) 
                                           ) header,
                                 /*misForms*/ 
                                 (select f.CodeID code,

                                         /*translations*/
                                         (select tr.Language language, tr.Text text
                                          from GEN.Translation tr
                                          where tr.CodeID = f.CodeID
                                          order by Case when tr.Language = @defaultLanguageISO then 0 else 1 end
                                          for JSON PATH, INCLUDE_NULL_VALUES
                                         ) translations,

                                         /*folders*/
                                         (select o.Code code, parent.Code parentCode, 
                                                 (select tr.Language language, tr.Text text
                                                  from GEN.Translation tr
                                                  where tr.CodeID = o.Code
                                                  order by Case when tr.Language = @defaultLanguageISO then 0 else 1 end
                                                  for JSON PATH, INCLUDE_NULL_VALUES
                                                 ) translations
                                          from @Folders folders join GEN.Folder o on folders.folderID = o.ID
                                                          left join GEN.Folder parent on folders.parentFolderID = parent.ID
                                          where folders.formID = f.ID
                                          order by folders.level desc
                                          FOR JSON PATH, INCLUDE_NULL_VALUES
                                         ) folders,

                                         '1.0.0' version /*no other versions yet*/,
                                         f.SQLText,
                                     
                                         /*listingModes*/
                                         (select lm.ListingModeCode listingModeCode, lm.DefaultListingModeCode defaultListingModeCode, lm.SQLText, 
                                                 (select tr.Language language, tr.Text text
                                                  from GEN.Translation tr
                                                  where tr.CodeID = lm.ListingModeCode
                                                  order by Case when tr.Language = @defaultLanguageISO then 0 else 1 end
                                                  for JSON PATH, INCLUDE_NULL_VALUES
                                                 ) translations
                                          from MIS.FormListingMode lm
                                          where lm.FormID = f.ID
                                          for JSON PATH, INCLUDE_NULL_VALUES
                                         ) listingModes, 

                                         /*filterCatalogFolders*/
                                         (select o.Code code, parent.Code parentCode, o.IconName iconName, 
                                                 (select tr.Language language, tr.Text text
                                                  from GEN.Translation tr
                                                  where tr.CodeID = o.Code
                                                  order by Case when tr.Language = @defaultLanguageISO then 0 else 1 end
                                                  for JSON PATH, INCLUDE_NULL_VALUES
                                                 ) translations
                                          from @FilterCatalogFolders folders join GEN.Folder o on folders.folderID = o.ID
                                                                             left join GEN.Folder parent on folders.parentFolderID = parent.ID
                                          where folders.formID = f.ID
                                          order by folders.level desc
                                          FOR JSON PATH, INCLUDE_NULL_VALUES
                                         )  filterCatalogFolders,
                                    
                                         /*filterFolders*/
                                         (select o.Code code, parent.Code parentCode, o.IconName iconName, 
                                                 (select tr.Language language, tr.Text text
                                                  from GEN.Translation tr
                                                  where tr.CodeID = o.Code
                                                  order by Case when tr.Language = @defaultLanguageISO then 0 else 1 end
                                                  for JSON PATH, INCLUDE_NULL_VALUES
                                                 ) translations
                                          from @FilterFolders folders join GEN.Folder o on folders.folderID = o.ID
                                                                      left join GEN.Folder parent on folders.parentFolderID = parent.ID
                                          where folders.formID = f.ID
                                          order by folders.level desc
                                          FOR JSON PATH, INCLUDE_NULL_VALUES
                                         )  filterFolders,

                                     
                                         /*filters*/
                                         (select ffi.code, 
                                                  (select tr.Language language, tr.Text text
                                                   from GEN.Translation tr
                                                   where tr.CodeID = ffi.Code
                                                   order by Case when tr.Language = @defaultLanguageISO then 0 else 1 end
                                                   for JSON PATH, INCLUDE_NULL_VALUES
                                                  ) translations,
                                                  vs.CodePrefix valueSetCodePrefix,
                                                  ffi.DefaultType defaultType,
                                                  ffi.DefaultValue defaultValue,
                                                  ffi.OrdNr ordNr,
                                                  ffi.DisableFilterMode disableFilterMode,
                                                  fi.FilterType filterType,
                                                  ffiFolder.Code folder,
                                                  fi.SQLText filterCatalogSQLStatement,
                                                  fi.IntervalLowerSQLText filterCatalogLower,
                                                  fi.IntervalUpperSQLText filterCatalogUpper,
                                                  fi.FilterMode filterCatalogFilterMode,
                                                  fiFolder.Code filterCatalogFolder,
                                                  ffi.SQLText SQLStatement,
                                                  ffi.IntervalLowerSQLText lower,
                                                  ffi.IntervalUpperSQLText upper,
                                                  (select flm.listingModeCode, flm.SQLText SQLStatement, flm.IntervalLowerSQLText lower, flm.IntervalUpperSQLText upper 
                                                   from MIS.FormFilterListingMode flm
                                                   where flm.FormFilterID = ffi.ID
                                                   for JSON PATH, INCLUDE_NULL_VALUES
                                                  ) listingModes
                                          from MIS.Filter fi join MIS.FormFilter ffi on fi.ID = ffi.FilterID
                                                             left join GEN.ValueSet vs on fi.ValueSetID = vs.ID
                                                             left join GEN.Folder ffiFolder on ffi.FolderID = ffiFolder.ID
                                                             left join GEN.Folder fiFolder on fi.FolderID = fiFolder.ID
                                          where ffi.FormID = f.ID
                                          order by ffi.OrdNr
                                          for JSON PATH, INCLUDE_NULL_VALUES
                                         ) filters,

                                         /*columns*/
                                         (select c.ColumnName code, c.ColumnTitleCode title, c.DisplayWidth displayWidth, c.Alignment alignment, c.FormatMask formatMask, c.OrdNr ordNr, c.Area area, c.AllowedArea allowedArea, c.ColumnVisible columnVisible,
                                                 (select tr.Language language, tr.Text text
                                                  from GEN.Translation tr
                                                  where tr.CodeID = c.ColumnTitleCode
                                                  order by Case when tr.Language = @defaultLanguageISO then 0 else 1 end
                                                  for JSON PATH, INCLUDE_NULL_VALUES
                                                 ) translations
                                          from MIS.FormColumn c
                                          where c.FormID = f.ID
                                          for JSON PATH, INCLUDE_NULL_VALUES
                                         ) columns,

                                         /*actions*/
                                         (select a.FunctionName code, a.FunctionTitleCode title, a.FunctionType functionType, a.DefaultAction defaultAction, 
                                                 (select tr.Language language, tr.Text text
                                                  from GEN.Translation tr
                                                  where tr.CodeID = a.FunctionTitleCode
                                                  order by Case when tr.Language = @defaultLanguageISO then 0 else 1 end
                                                  for JSON PATH, INCLUDE_NULL_VALUES
                                                 ) translations
                                          from MIS.FormAction a
                                          where a.FormID = f.ID
                                          for JSON PATH, INCLUDE_NULL_VALUES 
                                         ) actions
                                  from MIS.Form f  
                                  where exists(select *
                                               from @p_formIDs ids
                                               where ids.id = f.ID
                                              )
                                  for JSON PATH, INCLUDE_NULL_VALUES
                                 ) misForms
                          for JSON PATH, WITHOUT_ARRAY_WRAPPER
                         )


    /*Logging processing end*/
    set @logMessage = Concat('End procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

  end try
  begin catch

    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage

    ;throw
  end catch
end
go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2022-11-29
-- Last modified date:	2023-01-26
--                      2023-05-19 Interaction megkapja a 'Szerződés taget' /Bognár Dávid/
-- Description:	Generate contract interaction
-- =============================================
CREATE     PROCEDURE [COM].[GenerateContractInteraction] 
	-- Add the parameters for the stored procedure here
	@p_correlationID NVARCHAR(200), 
	@p_contractID NUMERIC(16),
	@p_interactionID NUMERIC(16) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'COM.GenerateContractInteraction'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_objectTagID NUMERIC(16) = NULL;
	DECLARE @l_interactionID NUMERIC(16) = NULL;
	DECLARE @l_contractNrPart NVARCHAR(10) = NULL;
	DECLARE @l_documentTemplateID NUMERIC(16) = NULL;
	DECLARE @l_moduleInstanceID NUMERIC(16) = NULL;
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--Amennyiben alkalmazunk cursor-okat, akkor azok definiálása (opcionális)
	
	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
			
		IF COALESCE(@p_contractID, 0) = 0
			RAISERROR('The contract identifier is not defined!', 16, 1);

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		
		SELECT @l_logMsg = CONCAT('The value of contract identifier: ', @p_contractID);
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		
		--Szerződésszám alapján a sablonhoz szükséges érték megszerzése
		SELECT @l_contractNrPart = REVERSE(LEFT(REVERSE([Contract].[ExternalContractNr]), PATINDEX('%-%', REVERSE([Contract].[ExternalContractNr])) - 1)) 
		FROM [CRM].[Contract] 
		WHERE [Contract].[ID] = @p_contractID
		AND COALESCE([Contract].[ExternalContractNr], '') <> '';
		
		--Szerződés sablon azonosító lekérdezése
		IF COALESCE(@l_contractNrPart, '') <> ''
		BEGIN
			SELECT @l_logMsg = CONCAT('The value of contract number part: ', @l_contractNrPart);
			INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				@p_CorrelationID,			-- CorrelationID
				'INDECS 3.0',			    -- ApplicationName
				DB_NAME(),					-- Environment
				'BACKEND',					-- Layer
				@l_procedureName,   		-- ServiceName
				'1.0',						-- ServiceVersion
				'INFO',					        -- SeverityLevel
				NULL,						-- MessageCategory
				@l_logMsg;

			SELECT @l_documentTemplateID = [DocumentTemplate].[ID] 
			FROM [GEN].[DocumentTemplate] 
			WHERE [DocumentTemplate].[TemplateCode] = CONCAT('DOCUMENT_TEMPLATE_CONTRACT_', @l_contractNrPart)
			AND COALESCE([DocumentTemplate].[ValidFrom], CAST(GETDATE() AS Date)) <= CAST(GETDATE() AS Date) 
			AND COALESCE([DocumentTemplate].[ValidUntil], CAST(GETDATE() AS Date)) >= CAST(GETDATE() AS Date);
		
			SELECT @l_errorMsg = CONCAT('The document template not found! Template code: DOCUMENT_TEMPLATE_CONTRACT_', @l_contractNrPart);
			IF COALESCE(@l_documentTemplateID, 0) = 0
				RAISERROR(@l_errorMsg, 16, 1);

			SELECT @l_errorMsg = '';
		
			SELECT @l_logMsg = CONCAT('The value of document template identifier: ', @l_documentTemplateID);
			INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				@p_CorrelationID,			-- CorrelationID
				'INDECS 3.0',			    -- ApplicationName
				DB_NAME(),					-- Environment
				'BACKEND',					-- Layer
				@l_procedureName,   		-- ServiceName
				'1.0',						-- ServiceVersion
				'INFO',					        -- SeverityLevel
				NULL,						-- MessageCategory
				@l_logMsg;
		END;
			
		--Üzenetáltás (COM.Interaction) alapadatok létrehozása
		INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
		SELECT 'OBJECT_TYPE_COM_INTERACTION', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
			 'ADMIN',
			'COM.Interaction object', '1.0';

		SELECT @l_objectID = @@IDENTITY;
		
		INSERT INTO [COM].[Interaction] ([ObjectID], [DirectionCode], [ChannelCode], [StatusCode], [LanguageCode], 
			[SenderEntityID], [RecipientEntityID], [Subject], [InteractionDate], [InteractionTime], 
			[SenderName], [SenderAddressID], [SenderContactID], 
			[RecipientName], [RecipientAddressID], [RecipientContactID],
			[CreationDate], [CreationTime], [CreationUserName],[RelatedObjectID])
		SELECT @l_objectID, CAST('INTERACTION_DIRECTION_OUTGOING' AS NVARCHAR(200)), CAST('CHANNEL_POST' AS NVARCHAR(200)), 
			CAST('INTERACTION_STATUS_12' AS NVARCHAR(200)), NULL, [BuyerParty].[EntityID], [SellerParty].[EntityID],
			CAST(CONCAT('Szerződés ', [Contract].[ContractNr]) AS NVARCHAR(200)), CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
			[PRT].[GetEntityName]([BuyerParty].[EntityID]), 
			(SELECT TOP 1 [Addresses].[ID]
			 FROM 
				(SELECT [Address].[ID], 1 AS OrdNr 
				FROM [PRT].[Address] 
				WHERE [Address].[EntityID] = [BuyerParty].[EntityID]
				AND [Address].[StatusCode] = 'STATUS_NORMAL'
				AND [Address].[AddressType] = 'ADDRESS_TYPE_COMPANY_MAILING'
				UNION 
				SELECT [Address].[ID], 2 AS OrdNr 
				FROM [PRT].[Address] 
				WHERE [Address].[EntityID] = [BuyerParty].[EntityID]
				AND [Address].[StatusCode] = 'STATUS_NORMAL'
				AND [Address].[AddressType] = 'ADDRESS_TYPE_COMPANY_HEADQUARTERS') AS Addresses
			 ORDER BY [Addresses].[OrdNr]), NULL,
			[PRT].[GetEntityName]([SellerParty].[EntityID]),
			(SELECT TOP 1 [Addresses].[ID]
			 FROM 
				(SELECT [Address].[ID], 1 AS OrdNr 
				FROM [PRT].[Address] 
				WHERE [Address].[EntityID] = [SellerParty].[EntityID]
				AND [Address].[StatusCode] = 'STATUS_NORMAL'
				AND [Address].[AddressType] = 'ADDRESS_TYPE_COMPANY_MAILING'
				UNION 
				SELECT [Address].[ID], 2 AS OrdNr 
				FROM [PRT].[Address] 
				WHERE [Address].[EntityID] = [SellerParty].[EntityID]
				AND [Address].[StatusCode] = 'STATUS_NORMAL'
				AND [Address].[AddressType] = 'ADDRESS_TYPE_COMPANY_HEADQUARTERS') AS Addresses
			 ORDER BY [Addresses].[OrdNr]), NULL,
				CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
				 'ADMIN',[CRM].[Contract].[ObjectID]
		FROM [CRM].[Contract]
		JOIN [PRT].[Party] AS SellerParty ON ([SellerParty].[ID] = [Contract].[SellerPartyID])
		JOIN [PRT].[Party] AS BuyerParty ON ([BuyerParty].[ID] = [Contract].[BuyerPartyID])
		WHERE [Contract].[ID] = @p_contractID;
			
		SELECT @l_interactionID = @@IDENTITY;
		
		SELECT @l_logMsg = CONCAT('The value of generated interaction identifier: ', @l_interactionID);
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		
		
		--Tag hozzáadása
		INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
		SELECT 'OBJECT_TYPE_GEN_OBJECTTAG', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
			'ADMIN',
			'GEN.Object object', '1.0';

		SELECT @l_objectTagID = @@IDENTITY;

		INSERT INTO [GEN].[ObjectTag]
		(
		    [ObjectID],
		    [TagID],
		    [ReferencedObjectID],
		    [CreationDate],
		    [CreationTime],
		    [CreationUserName],
		    [LastModifiedDate],
		    [LastModifiedTime],
		    [LastModifiedUserName]
		)
		VALUES
		(   @l_objectTagID, -- ObjectID - numeric(16, 0)
		    (SELECT ID FROM gen.tag WHERE label='Szerződés' ), -- TagID - numeric(16, 0)
		    @l_objectID, -- ReferencedObjectID - numeric(16, 0)
		    CAST( GETDATE() AS Date ), -- CreationDate - date
		    CAST( GETDATE() AS Time ), -- CreationTime - time(7)
		    SUSER_SNAME(), -- CreationUserName - nvarchar(200)
		    NULL, -- LastModifiedDate - date
		    NULL, -- LastModifiedTime - time(7)
		    NULL  -- LastModifiedUserName - nvarchar(200)
		    );





		--Üzenetváltás objektum (COM.InteractionObject) rögzítése - Szerződés azonosító
		INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
		SELECT 'OBJECT_TYPE_COM_INTERACTIONOBJECT', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
			'ADMIN',
			'COM.InteractionObject object', '1.0';

		SELECT @l_objectID = @@IDENTITY;
		
		INSERT INTO [COM].[InteractionObject] ([ObjectID], [InteractionID], [RelatedObjectID], [CreationDate], [CreationTime], [CreationUserName])
		SELECT @l_objectID, @l_interactionID, [Contract].[ObjectID], CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
			'ADMIN'
		FROM [CRM].[Contract] 
		WHERE [Contract].[ID] = @p_contractID;
		
		IF COALESCE(@l_documentTemplateID, 0) > 0
		BEGIN
			--Üzenetváltás dokumentum (COM.InteractionDocument) rögzítése - Szerződés sablon
			INSERT INTO [COM].[InteractionDocument] ([InteractionID], [DocumentTemplateID], [SequenceNr], [CreationDate], [CreationTime], [CreationUserName])
			SELECT @l_interactionID, @l_documentTemplateID, 1, CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
				'ADMIN';

			--Üzenetváltás MIME típus beállítása
			INSERT INTO [COM].[InteractionProperty] ([InteractionID], [PropertyCode], [PropertyValue], [SequenceNr], 
				[CreationDate], [CreationTime], [CreationUserName])
			SELECT @l_interactionID, CAST('INTERACTION_PROPERTY_MIME_TYPE' AS NVARCHAR(200)), 
				CAST('.pdf' AS NVARCHAR(200)), 1, CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
				 'ADMIN';
		END;
			
		SELECT @p_interactionID = @l_interactionID;
		RETURN;
	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage

		SELECT @p_interactionID = 0;
		RETURN;
	END CATCH
END
go

-- =============================================
-- Author:		Aranyi Balázs
-- Create date: 2023.03.08.
-- Last modified date: 2023.03.10.
-- Description:	Generate contract number. 
-- =============================================
CREATE PROCEDURE [CRM].[GenerateContractNr] 
	-- Add the parameters for the stored procedure here
	@p_contractID NUMERIC(16),
	@p_srmContract NVARCHAR(200),
	@p_result NVARCHAR(200) OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;

    -- Declare the return variable here
	DECLARE @l_liveContractContractNr NVARCHAR(200) = NULL;
	--További változók
	DECLARE @l_errorMsg NVARCHAR(MAX) = ''; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_liveContractConstructionCode NVARCHAR(200) = NULL;
	DECLARE @l_liveContractTIP NVARCHAR(200) = NULL;
	DECLARE @l_liveContractSequenceCode NVARCHAR(200) = NULL;
	DECLARE @l_sellerEntityID NUMERIC(16) = NULL;
	DECLARE @l_sellerName NVARCHAR(200) = NULL;
	DECLARE @l_settingOTPGroupCompanyID NUMERIC(16) = NULL;
	DECLARE @l_OTPGroupEntityID NUMERIC(16) = NULL;

	BEGIN TRY
		IF COALESCE(@p_contractID, 0) = 0 
			RAISERROR('The p_contractID parameter is not defined!', 16, 1);

		SELECT 
			@l_sellerEntityID = [Entity].[ID],
			@l_sellerName = [Contract].[SellerName] 
		FROM [CRM].[Contract] 
		JOIN [PRT].[Party] ON ([Party].[ID] = [Contract].[SellerPartyID])
		JOIN [PRT].[Entity] ON ([Entity].[ID] = [Party].[EntityID])
		WHERE [Contract].[ID] = @p_contractID;

		BEGIN TRY
			SELECT @l_settingOTPGroupCompanyID = CAST(COALESCE([Setting].[SettingValue], '0') AS NUMERIC(16))
			FROM [GEN].[Setting] 
			WHERE [Setting].[Schema] = 'CRM'
			AND [Setting].[SettingCode] = 'SETTING_OTPCSOPORT_COMPANY_ID';
		END TRY
		BEGIN CATCH
			RAISERROR('The setting SETTING_OTPCSOPORT_COMPANY_ID is not a number.', 16, 1);	
		END CATCH

		IF COALESCE(@l_settingOTPGroupCompanyID, 0) > 0
			SELECT @l_OTPGroupEntityID = [Entity].[ID]
			FROM [PRT].[Entity] 
			JOIN [PRT].[Company] ON ([Company].[EntityID] = [Entity].[ID])
			WHERE [Company].[ID] = @l_settingOTPGroupCompanyID;

		SELECT @l_liveContractConstructionCode = 
			(SELECT TOP 1 [CollectionContractItem].[ConstructionCode]
			 FROM [CRM].[CollectionContractItem] 
			 JOIN [CRM].[ContractItem] ON ([ContractItem].[ID] = [CollectionContractItem].[ContractItemID]) 
			 WHERE [ContractItem].[ContractID] = @p_contractID 
			 AND COALESCE([CollectionContractItem].[ConstructionCode], '') <> ''
			 ORDER BY [ContractItem].[ID]);

		SELECT @l_liveContractConstructionCode = LEFT('00', LEN('00') - LEN(@l_liveContractConstructionCode)) + @l_liveContractConstructionCode;

		PRINT CONCAT('Construction code: ', @l_liveContractConstructionCode);

		IF COALESCE(@l_liveContractConstructionCode, '') <> ''
		BEGIN
			SELECT @l_liveContractTIP = 
				(SELECT TOP 1 [CreditTypeConcessionLogic].[TIP] 
				 FROM [TMP].[CreditTypeConcessionLogic]
				 WHERE [CreditTypeConcessionLogic].[KOD] = @l_liveContractConstructionCode
				 AND [CreditTypeConcessionLogic].[DTIP] = 'HT'
				 ORDER BY [CreditTypeConcessionLogic].[ID]);
		END;

		PRINT CONCAT('TIP: ', @l_liveContractTIP);

		IF COALESCE(@l_liveContractTIP, '') <> ''
		BEGIN
			IF COALESCE(@l_liveContractTIP, '') LIKE '%Lakossági%'
			BEGIN
				IF COALESCE(@p_srmContract, 'BOOLEAN_FALSE') = 'BOOLEAN_TRUE'
					SELECT @l_liveContractSequenceCode = 'SEQUENCE_CONTRACT_531'
				ELSE IF @l_sellerName IN ('OTP Bank Nyrt.', 'OTP Jelzálogbank Zrt.', 'OTP Lakástakarék Zrt.')
					SELECT @l_liveContractSequenceCode = 'SEQUENCE_CONTRACT_532'
				ELSE IF COALESCE(@l_OTPGroupEntityID, 0) > 0 AND COALESCE(@l_sellerEntityID, 0) > 0 AND @l_OTPGroupEntityID = @l_sellerEntityID
					SELECT @l_liveContractSequenceCode = 'SEQUENCE_CONTRACT_532'
				ELSE 
					SELECT @l_liveContractSequenceCode = 'SEQUENCE_CONTRACT_533';
			END
			ELSE IF COALESCE(@l_liveContractTIP, '') LIKE '%Vállalati%'
			BEGIN
				IF COALESCE(@p_srmContract, 'BOOLEAN_FALSE') = 'BOOLEAN_TRUE'
					SELECT @l_liveContractSequenceCode = 'SEQUENCE_CONTRACT_541'
				ELSE IF @l_sellerName IN ('OTP Bank Nyrt.', 'OTP Jelzálogbank Zrt.', 'OTP Lakástakarék Zrt.')
					SELECT @l_liveContractSequenceCode = 'SEQUENCE_CONTRACT_542'
				ELSE IF COALESCE(@l_OTPGroupEntityID, 0) > 0 AND COALESCE(@l_sellerEntityID, 0) > 0 AND @l_OTPGroupEntityID = @l_sellerEntityID
					SELECT @l_liveContractSequenceCode = 'SEQUENCE_CONTRACT_542'
				ELSE 
					SELECT @l_liveContractSequenceCode = 'SEQUENCE_CONTRACT_543';
			END;
		END;

		PRINT CONCAT('Sequence code: ', @l_liveContractSequenceCode);

		IF COALESCE(@l_liveContractSequenceCode, '') <> ''
		BEGIN
			EXECUTE [GEN].[GetNextSequenceValue] 
				@l_liveContractSequenceCode, 
				@l_liveContractContractNr OUTPUT;
		END;

		SELECT @p_result = @l_liveContractContractNr;

		RETURN 1;
	END TRY

	BEGIN CATCH
		SELECT @p_result = NULL;

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());
		PRINT @l_errorMsg;

		RETURN 99;
	END CATCH
END
go

/*Author: Gyenese Katalin
  Create date: 2023.10.09. - DV-1524
  Last modified date: 2023.11.06.
  Description: it is used to generate a "snapshot" of the current data for the Indecs --> Inkasso synchronization. It is called from the backend code when a relevant data change occurs.
                  1. generates an InkassoSync record
                  2. generates a snapshot to the corresponding IFC.InkassoSyncSendXYZ table
                  3. creates a task with the needed task type. The ReferencedObjectID of the task is null, because in the IFC table there's no ObjectID.
                  4. sets the value of the TaskID field of the InkassoSync record to the id of the created Task
                  5. creates a new ModuleInstance of the MODULE_INDECS_INKASSO_SYNC module /
                     uses an already existing ModuleInstance of the MODULE_INDECS_INKASSO_SYNC module received in the @moduleInstanceID parameter
                  
                  After receiving the moduleInstanceID:
                    a. the backend querys all tasks with the proper type and does the actual synchronization (Company/Person/Address/Phone/Event/Document/ConstructionCode)
                    b. the debtcase IFC loader stored procedures receive the moduleInstanceID (for the second call they can use it)
                       and finally the IFC.MainIFCLoader returns the moduleInstanceID to the backend and it does the actual synchronization (DebtCase) 

  Parameters:
    - @syncType: the type of the synchronization: Company/Person/Address/Phone/Event/Document/ConstructionCode/DebtCase/Debtor/Asset
    - @syncEventType: the type of the event that indicated the synchronization: insert/update
                      if data has to be sent based on more tables, the event regarding the main table counts
    - @entityID: the entityID of the Company/Person
    - @ID: the ID of the Address/Contact (for phone sync)/Event/Document/ConstructionCode/Debtor/Asset that has to be synchronized
    - @debtCaseID: the ID of the DebtCase (for DebtCase and for Asset synchronization. We don't synchronize Assets separately, just together with the DebtCase, only once)
    - @dataChangedDateTime: the datetime of the change that indicated the synchronization
    - @dataChangedUserName: the user who made the change that indicated the synchronization
    - @correlationID: the correlationID of the caller
    - @moduleInstanceID: the ID of the moduleInstance to use (creates a new, if null)
    - @isBatch: @isBatch = 0 (when called from the backend code) --> the StatusCode of the created moduleInstance is immediately MODULE_INSTANCE_STATUS_READY_TO_RUN
                @isBatch = 1 (when called from stored procedures in connection with debtcase import) --> the StatusCode of the created moduleInstance is MODULE_INSTANCE_STATUS_PREPARATION
*/
CREATE   procedure [IFC].[GenerateSendInkassoSyncData](@syncType NVarChar(200), @syncEventType NVarChar(200), 
                                                    @entityID Numeric(16) = null, @ID Numeric(16) = null, @dataChangedDateTime DateTime = null, @dataChangedUserName NVarChar(200),
                                                    @correlationID NVarChar(200) = null,
                                                    @moduleInstanceID Numeric(16) = null output,
                                                    @isBatch bit = 0, @debtCaseID Numeric(16) = null
                                                   )

as
begin
  set NOCOUNT ON
  set XACT_ABORT ON

  
  /*variables for logging*/
	declare @errormsg NVarChar(max),	@logMessage nvarchar(max), @procedureName nvarchar(100) = 'IFC.GenerateSendInkassoSyncData',
          @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for the procedure logic*/
  declare @indecsInkassoSyncID Numeric(16),
          @syncEventTypeInsert NVarChar(200) = 'insert', @syncEventTypeUpdate NVarChar(200) = 'update',
          @moduleCode NVarChar(200) = 'MODULE_INDECS_INKASSO_SYNC', @moduleStatusCode NVarChar(200),
          @objectID Numeric(16), @taskTypeCode NVarChar(200), @taskID Numeric(16), @taskUserName NVarChar(200), @today Date
  declare @modificationType NVarChar(200) =  Upper(@syncEventType), @localCurrencyCode NVarChar(200) = 'CURRENCY_HUF'

  begin try 
    if @dataChangedDateTime is null
       set @dataChangedDateTime = GetDate()


    /*Logging procedure start*/
    set @logMessage = Concat('Start procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @dataChangedUserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    /*Logging parameter check*/
    set @logMessage = 'Checking parameters...'
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @dataChangedUserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    if IsNull(@syncType, '') = ''
       raiserror('The @syncType parameter is compulsory.', 16, 1)

    if @syncType not in('Company', 'Person', 'Address', 'Phone', 'Event', 'Document', 'ConstructionCode', 'DebtCase', 'Asset', 'Debtor')
       raiserror('The value of the @syncType parameter is invalid. (Accepted values: Company / Person / Address / Phone / Event / Document / ConstructionCode / DebtCase / Asset / Debtor).', 16, 1)

    if IsNull(@syncEventType, '') = ''
       raiserror('The @syncEventType parameter is compulsory.', 16, 1)

    if @syncEventType not in('insert', 'update')
       raiserror('The value of the @syncEventType parameter is invalid. (Accepted values: insert / update)', 16, 1)

    if @syncType in('Company', 'Person') and (@entityID is null or @ID is not null or @debtCaseID is not null)
       raiserror('With @syncType Company / Person: @entityID is compulsory; @ID and @debtCaseID must be empty.', 16, 1)

    if @syncType not in('Company', 'Person', 'DebtCase') and (@entityID is not null or @ID is null)
       raiserror('With @syncType different from Company / Person / DebtCase: @ID is compulsory; @entityID must be empty.', 16, 1)

    if @syncType in('DebtCase', 'Asset') and @debtCaseID is null
       raiserror('With @syncType DebtCase / Asset: @debtCaseID is compulsory.', 16, 1)

    if @syncType not in('DebtCase', 'Asset') and @debtCaseID is not null
       raiserror('With @syncType different from DebtCase / Asset: @debtCaseID must be empty.', 16, 1)
    

    /*Logging start processing*/
    set @logMessage = Concat('Start processing - @syncType: ', @syncType, ', @syncEventType: ', @syncEventType, ', @entityID: ', IsNull(Cast(@entityID as NVarChar(100)), 'null'), ', @ID: ', IsNull(Cast(@ID as NVarChar(100)), 'null'))
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @dataChangedUserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

    /*DV-1775*/ 
    if IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', @syncType, @syncEventType) = 0
       return

    begin tran 

      insert into IFC.IndecsInkassoSync(SyncDirectionCode, WebserviceName, InterfaceStatusCode, CreationDate, CreationTime, CreationUserName)
        select 'SYNC_DIRECTION_INKASSO' SyncDirectionCode, 
               Case when @syncType in('Company', 'Person') then 'INK031_PartyBase'
                    when @syncType = 'Address' then 'INK032_PartyAddr'
                    when @syncType = 'Phone' then 'INK033_PhoneNumber'
                    when @syncType = 'Event' then 'INK004_workflowChanged'
                    when @syncType = 'Document' then 'INK005_documentChanged'
                    when @syncType = 'ConstructionCode' then 'INK006_constructionCode'
                    when @syncType = 'DebtCase' then 'INK001_dealChanged'
                    when @syncType = 'Asset' then 'INK002_collateralChanged'
                    when @syncType = 'Debtor' then 'INK034_PartyMap'
               end,   
               'INTERFACE_STATUS_NEW' InterfaceStatusCode, GetDate() CreationDate, GetDate() CreationDate, @dataChangedUserName CreationUserName
  
      select @indecsInkassoSyncID = SCOPE_IDENTITY()


      if @syncType = 'Company' /*OK*/
      begin
        set @taskTypeCode = 'TASK_TYPE_DATA_SYNC_ENTITY_INK'

        /*Megjegyzések:
            - nem nézzük, hogy az adott rekord aktív-e (Entity.Status)
            - nem figyelünk az EntityID (vagy a rajta lévő mezők) módosulására
            - nem kezeljük a fizikai törlést
            - a Contact, Name adatoknak nem figyeljük sehogy, hogy lejárt-e a dátum szerint az érvényességük
            - sok mezőben, amelyek nálunk még nincsenek meg/nem tudjuk, hogy fognak-e kelleni egyáltalán, drót null-t adunk át
        */
        insert into IFC.InkassoSyncSendCompany(IndecsInkassoSyncID, CompanyID, ExternalCompanyID, Name, ShortName, LegalFormCode, InkLegalFormCode, InkCompanyFormCode, ChamberMembershipBeginDate, ShortNameCegkapu, Email, 
                                               RegistrationNr, TaxNr, LEICode, PartyBankID, SourceID, Crefo, GWBCustomerNr, URBISID, DataLastModDateTime, DataLastModUser, DataCreationUser, DataCreationDateTime, DataVersionDateTime, DataVersionNr, 
                                               ModificationType, InterfaceStatusCode, CreationDate, CreationTime, CreationUserName
                                              )
          select  @indecsInkassoSyncID IndecsInkassoSyncID, 
                  comp.ID CompanyID, 
                  IFC.GetInkassoExternalEntityID(e.ID, e.SourceInterfaceType, e.SourceID) ExternalCompanyID,
                  comp.Name, 
                  PRT.GetEntityNameByType(comp.entityID, 'NAME_TYPE_COMPANY_SHORT', null /*@date*/) ShortName,
                  comp.LegalFormCode, /*Indecs cégforma (még ha a mező neve az is, hogy LegalFormCode)*/
                  IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, comp.LegalFormCode, 'VALUESET_INKASSO_LEGAL_FORM', null /*@date*/) InkLegalFormCode /*Inkasso jogi forma*/,
                  IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, comp.LegalFormCode, 'VALUESET_LEGAL_FORM', null /*@date*/) InkCompanyFormCode /*Inkasso cégforma*/,
                  null ChamberMembershipBeginDate /*comp.ChamberMembershipBeginDate - hiányzik ez a mező. Karesszal egyeztetve: ha szükség lesz rá, akkor majd felvesszük egyéb azonosítónak. Egyelőre nem kell.*/,
                  null ShortNameCegkapu /*ez is egy PRT.GetEntityNameByType hívás, de nincs még meg hozzá a NameType*/,
                  PRT.GetEntityContactData(comp.entityID, 'CONTACT_TYPE_EMAIL', null /*@date*/) Email,
                  comp.RegistrationNr,
                  comp.TaxNr,
                  null /*Az Excelben sárga*/ LEICode,
                  null /*Az Excelben piros*/ PartyBankID,
                  Case when e.SourceInterfaceType = 'ECOLLECT' then null else e.SourceID end SourceID /*Amennyiben a PRT.Entity.SourceInterfaceType értéke = 'ECOLLECT', akkor NULL-t kell átadni*/,
                  e.ID Crefo,
                  Case when e.SourceInterfaceType = 'ECOLLECT' then null else e.SourceID end GWBCustomerNr /*Amennyiben a PRT.Entity.SourceInterfaceType értéke = 'ECOLLECT', akkor NULL-t kell átadni*/,
                  null /*'Az Excelben piros'*/ URBISID,
                  Case when @syncEventType = @syncEventTypeUpdate then @dataChangedDateTime else null end DataLastModDateTime /*the last modification date (based on more tables)*/, 
                  Case when @syncEventType = @syncEventTypeUpdate then @dataChangedUserName else null end DataLastModUser /*the user of the last modification (based on more tables)*/, 
                  comp.CreationUserName DataCreationUser,
                  Cast(comp.CreationDate as DateTime) + Cast(comp.CreationTime as DateTime) DataCreationDateTime, 
                  null /*Mikori a partnerverzió dátuma ? (KÜT) Az Excelben piros*/ DataVersionDateTime,
                  null /*Melyik partnerverzió ez? (KÜT) Az Excelben piros*/ DataVersionNr,
                  @modificationType ModificationType,
                  'INTERFACE_STATUS_NEW' InterfaceStatusCode,
                  GetDate() CreationDate,
                  GetDate() CreationTime,
                  @dataChangedUserName CreationUserName
          from PRT.Company comp with(nolock) join PRT.Entity e with(nolock) on comp.EntityID = e.ID
          where e.ID = @entityID  
      end
      else if @syncType = 'Person' /*OK*/
      begin
        set @taskTypeCode = 'TASK_TYPE_DATA_SYNC_ENTITY_INK'

        /*Megjegyzések:
            - nem nézzük, hogy az adott rekord aktív-e (Entity.Status)
            - nem figyelünk az EntityID (vagy a rajta lévő mezők) módosulására
            - nem kezeljük a fizikai törlést
            - a Contact, ObjectIdentifier adatoknak nem figyeljük sehogy, hogy lejárt-e a dátum szerint az érvényességük
            - sok mezőben, amelyek nálunk még nincsenek meg/nem tudjuk, hogy fognak-e kelleni egyáltalán, drót null-t adunk át
        */
        insert into IFC.InkassoSyncSendPerson(IndecsInkassoSyncID, PersonID, ExternalPersonID, Title, LastName, FirstName, InkNationalityCode, NationalityCode, InkDeceasedCode, DeceasedCode, DeceasedDate, Email, 
                                              MaidenName, BirthLastName, BirthFirstName, BirthPlace, BirthDate, MothersFullName, MothersLastName, MothersFirstName, IDNumber, PassportNumber, LicenseNumber, RetiredIDNumber, 
                                              LEICode, PartyBankID, SourceID, Crefo, GWBCustomerNr, URBISID, GDPRPreDeleteMarkingDateTime, GDPRPreDeleteDateTime, GDPRDepersonalizationDateTime, DataLastModDateTime, DataLastModUser, 
                                              DataCreationUser, DataCreationDateTime, DataVersionDateTime, DataVersionNr, ModificationType, InterfaceStatusCode, 
                                              CreationDate, CreationTime, CreationUserName
                                             )
          select @indecsInkassoSyncID IndecsInkassoSyncID, 
                 p.ID PersonID, 
                 IFC.GetInkassoExternalEntityID(e.ID, e.SourceInterfaceType, e.SourceID) ExternalPersonID,
                 GEN.TranslateCode(p.Title, 'HU') Title, 
                 p.LastName, p.FirstName,
                 IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, p.NationalityCode, 'VALUESET_NATIONALITY', null /*@date*/) InkNationalityCode, p.NationalityCode, 
                 IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, Case when p.DeathDate is not null then 'BOOLEAN_TRUE' else 'BOOLEAN_FALSE' end, 'VALUESET_BOOLEAN', null /*@date*/) InkDeceasedCode,
                 Case when p.DeathDate is not null then 'BOOLEAN_TRUE' else 'BOOLEAN_FALSE' end DeceasedCode, 
                 p.DeathDate DeceasedDate,
                 PRT.GetEntityContactData(p.entityID, 'CONTACT_TYPE_EMAIL', null /*@date*/) Email,
                 Case when IsNull(p.MaidenLastName, '') <> '' and IsNull(p.MaidenFirstName, '') <> '' then Concat(p.MaidenLastName, ' ', p.MaidenFirstName) 
                      else IsNull(p.MaidenFirstName, p.MaidenLastName)
                 end MaidenName,
                 p.MaidenLastName BirthLastName, p.MaidenFirstName BirthFirstName,
                 p.BirthPlace, p.BirthDate,
                 Case when IsNull(p.MotherLastName, '') <> '' and IsNull(p.MotherFirstName, '') <> '' then Concat(p.MotherLastName, ' ', p.MotherFirstName) 
                      else IsNull(p.MotherLastName, p.MotherFirstName)
                 end MothersFullName,
                 p.MotherLastName MothersLastName, p.MotherFirstName MothersFirstName,
                 GEN.GetObjectIdentifierByType(e.ObjectID, 'IDENTIFIER_TYPE_PERSON_ID_CARD_NR', null /*@date*/) IDNumber,
                 GEN.GetObjectIdentifierByType(e.ObjectID, 'IDENTIFIER_TYPE_PERSON_PASSPORT_NR', null /*@date*/) PassportNumber,
                 GEN.GetObjectIdentifierByType(e.ObjectID, 'IDENTIFIER_TYPE_PERSON_LICENSE_NR', null /*@date*/) LicenseNumber,
                 GEN.GetObjectIdentifierByType(e.ObjectID, 'IDENTIFIER_TYPE_PERSON_PENSIONER_ID', null /*@date*/) RetiredIDNumber,
                 null /*Az Excelben sárga*/ LEICode,
                 null /*Az Excelben piros*/ PartyBankID,
                 Case when e.SourceInterfaceType = 'ECOLLECT' then null else e.SourceID end SourceID /*Amennyiben a PRT.Entity.SourceInterfaceType értéke = 'ECOLLECT', akkor NULL-t kell átadni*/,
                 e.ID Crefo,
                 Case when e.SourceInterfaceType = 'ECOLLECT' then null else e.SourceID end GWBCustomerNr /*Amennyiben a PRT.Entity.SourceInterfaceType értéke = 'ECOLLECT', akkor NULL-t kell átadni*/,
                 null /*'Az Excelben piros'*/ URBISID,
                 null /*Azt a dátumot (YYYY.MM.DD. HH24:MI:SS) jelöli amikor a partnert GDPR előtörölni kell majd. Az Excelben üres*/ GDPRPreDeleteMarkingDateTime,
                 null /* GDPR előtörlés dátuma (YYYY.MM.DD. HH24:MI:SS). Az Excelben üres*/ GDPRPreDeleteDateTime,
                 null /*'GDRP elévülés adattörlés dátuma. Az Excelben üres*/ GDPRDepersonalizationDateTime,
                 Case when @syncEventType = @syncEventTypeUpdate then @dataChangedDateTime else null end DataLastModDateTime /*the last modification date (based on more tables)*/, 
                 Case when @syncEventType = @syncEventTypeUpdate then @dataChangedUserName else null end DataLastModUser /*the user of the last modification (based on more tables)*/, 
                 p.CreationUserName DataCreationUser,
                 Cast(p.CreationDate as DateTime) + Cast(p.CreationTime as DateTime) DataCreationDateTime,
                 null /*Mikori a partnerverzió dátuma ? (KÜT) Az Excelben piros*/ DataVersionDateTime,
                 null /*Melyik partnerverzió ez? (KÜT) Az Excelben piros*/ DataVersionNr,
                 @modificationType ModificationType,
                 'INTERFACE_STATUS_NEW' InterfaceStatusCode,
                 GetDate() CreationDate,
                 GetDate() CreationTime,
                 @dataChangedUserName CreationUserName
          from PRT.Person p with(nolock) join PRT.Entity e with(nolock) on p.EntityID = e.ID
          where e.ID = @entityID 
      end
      else if @syncType = 'Address' /*OK*/
      begin
        set @taskTypeCode = 'TASK_TYPE_DATA_SYNC_ENTITY_ADDRESS_INK'

        /*Megjegyzések:
            - nem figyelünk az EntityID (vagy a rajta lévő mezők) módosulására
            - nem kezeljük a fizikai törlést
            - ValidUntil mező a túloldalon nincs
            - a CountryText-et visszaadó Translation változására nem figyelünk
            - PublicPlaceType: Inkasso oldalon simán szövegesen van tárolva, nincs rá kódtábla. A PublicPlaceTypeText mezőben mi is eltároljuk a szöveges adatot (magyarul) és azt küldjük majd.
        */
        insert into IFC.InkassoSyncSendAddress(IndecsInkassoSyncID, AddressID, EntityID, ExternalEntityID, StatusCode, InkStatusCode, MailingAddressCode, InkMailingAddressCode, PostalAddressCode, InkPostalAddressCode, ValidFrom, 
                                               UnsuccessfulDeliveryCode, AddressTypeCode, InkAddressTypeCode, CountryText, CountryCode, InkCountryCode, ZipCode, Settlement, 
                                               PublicPlaceName, SearchablePublicPlaceName, PublicPlaceTypeCode, PublicPlaceTypeText, HouseNr, Building, Staircase, Floor, Door, Description, 
                                               DataCreationUser, DataCreationDateTime, DataLastModUser, DataLastModDateTime, ModificationType, InterfaceStatusCode, CreationDate, CreationTime, CreationUserName
                                              )
          select  @indecsInkassoSyncID IndecsInkassoSyncID, 
                  a.AddressID, 
                  a.EntityID, 
                  IFC.GetInkassoExternalEntityID(a.EntityID, a.EntitySourceInterfaceType, a.EntitySourceID) ExternalEntityID,
                  a.StatusCode,
                  IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, a.StatusCode, 'VALUESET_STATUS', null /*@date*/) InkStatusCode,
                  a.MailingAddressCode,
                  IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, a.MailingAddressCode, 'VALUESET_BOOLEAN', null /*@date*/) InkMailingAddressCode,         
                  a.MailingAddressCode PostalAddressCode,
                  /*PostalAddressCode (ami jelen állás szerint = MailingAddressCode) és StatusCode alapján: 
                      a. ha a cím inaktív = F; 
                      b. különben, ha levelezési, akkor T
                      c. egyébként null
                  */
                  Case when a.StatusCode = 'STATUS_DELETED' then 'F'
                       when a.MailingAddressCode = 'BOOLEAN_TRUE' then 'T'
                       else null
                  end InkPostalAddressCode,
                  a.ValidFrom,
                  null /*az Excelben piros*/ UnsuccessfulDeliveryCode,
                  a.AddressType AddressTypeCode,
                  IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, a.AddressType, 
                                            Case when a.EntityType = 'P' /*Person*/ then 'VALUESET_ADDRESS_TYPE_PERSON'
                                                 when a.EntityType = 'C' /*Company*/ then 'VALUESET_ADDRESS_TYPE_COMPANY' 
                                            end, null /*@date*/
                                           ) InkAddressTypeCode, 
                  (select tr.Text
                   from GEN.Translation tr with(nolock)
                   where tr.CodeID = a.CountryID
                     and tr.Language = 'HU'
                  ) CountryText,
                  a.CountryID CountryCode,
                  c.Alpha2Code InkCountryCode /*ISO2 kód*/,
                  a.ZipCode,
                  a.Settlement,
                  a.PublicPlaceName,
                  /*A PublicPlaceName mező ékezetlenített változata*/
                  GEN.RemoveAccents(a.PublicPlaceName) SearchablePublicPlaceName,
                  a.PublicPlaceType PublicPlaceTypeCode,
                  GEN.TranslateCode(a.PublicPlaceType, 'HU') PublicPlaceTypeText,
                  a.HouseNr,
                  a.Building,
                  a.Staircase,
                  a.Floor,
                  a.Door,
                  a.Comments Description,
                  a.CreationUserName DataCreationUser,
                  Cast(a.CreationDate as DateTime) + Cast(a.CreationTime as DateTime) DataCreationDateTime,
                  Case when @syncEventType = @syncEventTypeUpdate then @dataChangedUserName else null end DataLastModUser /*the user of the last modification*/, 
                  Case when @syncEventType = @syncEventTypeUpdate then @dataChangedDateTime else null end DataLastModDateTime /*the last modification date*/, 
                  @modificationType ModificationType,
                  'INTERFACE_STATUS_NEW' InterfaceStatusCode,
                  GetDate() CreationDate,
                  GetDate() CreationTime,
                  @dataChangedUserName CreationUserName
          from (select a.ID AddressID, 
                       a.EntityID,
                       e.EntityType,
                       e.SourceInterfaceType EntitySourceInterfaceType, 
                       e.SourceID EntitySourceID,
                       a.StatusCode,
                       /*Ha a cím céghez tartozik és a cím típusa (PRT.Address.AddressType) ADDRESS_TYPE_COMPANY_MAILING, akkor 'BOOLEAN_TRUE', külonben 'BOOLEAN_FALSE'.
                         Ha a cím magánszemélyhez tartozik és a cím típusa (PRT.Address.AddressType) ADDRESS_TYPE_PERSON_RESIDENCE, akkor 'BOOLEAN_TRUE', különben 'BOOLEAN_FALSE'."			
                       */
                       Case when e.EntityType = 'C' /*company*/ and a.AddressType = 'ADDRESS_TYPE_COMPANY_MAILING' then 'BOOLEAN_TRUE' 
                            when e.EntityType = 'P' /*person*/ and a.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE' then 'BOOLEAN_TRUE' 
                            else 'BOOLEAN_FALSE' 
                       end MailingAddressCode,
                       a.ValidFrom,
                       a.AddressType,
                       a.CountryID,
                       a.ZipCode,
                       a.Settlement,
                       a.PublicPlaceName,
                       a.PublicPlaceType,
                       a.HouseNr,
                       a.Building,
                       a.Staircase,
                       a.Floor,
                       a.Door,
                       a.Comments,
                       a.CreationUserName,
                       a.CreationDate,
                       a.CreationTime
                from PRT.Address a with(nolock) join PRT.Entity e with(nolock) on a.EntityID = e.ID
                where a.ID = @ID
               ) a left join GEN.Country c with(nolock) on a.CountryID = c.CountryCode
      end
      else if @syncType = 'Phone' /*OK*/
      begin
        set @taskTypeCode = 'TASK_TYPE_DATA_SYNC_ENTITY_PHONE_INK'

        insert into IFC.InkassoSyncSendPhone(IndecsInkassoSyncID, ContactID, EntityID, ExternalEntityID, StatusCode, InkStatusCode, Classification, ContactTypeCode, InkContactTypeCode, ValidatedCode, Contact, CountryCode, Prefix, Extension, 
                                             DataOriginCode, InkDataOriginCode, ValidFrom, Comments, MaskingModeCode, MaskingDateTime, ContributionCode, ContributionDateTime, ContributionCancellationDateTime, 
                                             DataCreationUser, DataCreationDateTime, DataLastModUser, DataLastModDateTime, ModificationType, InterfaceStatusCode, CreationDate, CreationTime, CreationUserName
                                            )
          select  @indecsInkassoSyncID IndecsInkassoSyncID, c.ID ContactID, 
                  c.EntityID, 
                  IFC.GetInkassoExternalEntityID(e.ID, e.SourceInterfaceType, e.SourceID) ExternalEntityID,
                  c.StatusCode,
                  IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, c.StatusCode, 'VALUESET_PHONE_STATUS', null /*@date*/) InkStatusCode,
                  null /*az Excelben piros*/ Classification,                 
                  c.ContactType ContactTypeCode,
                  IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, c.StatusCode, 'VALUESET_CONTACT_TYPE', null /*@date*/) InkContactTypeCode,
                  null /*az Excelben piros*/ ValidatedCode,
                  sepPhone.phoneNumber Contact /*Telefonszám előhívó nélkül*/,
                  null /*az Excelben piros*/ CountryCode,
                  sepPhone.prefix Prefix /*Telefonszám előhívó része.*/,
                  null /*az Excelben piros*/ Extension,
                  c.DataOriginCode,
                  IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, c.DataOriginCode, 'VALUESET_DATA_ORIGIN', null /*@date*/) InkDataOriginCode,
                  c.ValidFrom,
                  c.Comments,
                  null /*az Excelben piros*/ MaskingModeCode,
                  null /*az Excelben piros*/ MaskingDateTime,
                  null /*az Excelben piros*/ ContributionCode,
                  null /*az Excelben piros*/ ContributionDateTime,
                  null /*az Excelben piros*/ ContributionCancellationDateTime,
                  c.CreationUserName DataCreationUser,
                  Cast(c.CreationDate as DateTime) + Cast(c.CreationTime as DateTime) DataCreationDateTime,
                  Case when @syncEventType = @syncEventTypeUpdate then @dataChangedUserName else null end DataLastModUser /*the user of the last modification*/, 
                  Case when @syncEventType = @syncEventTypeUpdate then @dataChangedDateTime else null end DataLastModDateTime /*the last modification date*/, 
                  @modificationType ModificationType,
                  'INTERFACE_STATUS_NEW' InterfaceStatusCode,
                  GetDate() CreationDate,
                  GetDate() CreationTime,
                  @dataChangedUserName CreationUserName
                from PRT.Contact c with(nolock) join PRT.Entity e with(nolock) on c.EntityID = e.ID
                                   cross apply GEN.PhoneNumberSeparate(c.Contact) sepPhone
                where c.ID = @ID
                  and c.ContactType in('CONTACT_TYPE_FOREIGNPHONE', 'CONTACT_TYPE_MOBILE', 'CONTACT_TYPE_PHONE')
      end
      else if @syncType = 'Event' /*OK*/
      begin
        set @taskTypeCode = 'TASK_TYPE_DATA_SYNC_EVENT_INK'

        /*Megjegyzések:
            - bizonyos mezőkben, amelyek nálunk még nincsenek meg/nem tudjuk, hogy fognak-e kelleni egyáltalán, drót null-t adunk át
            - csak bizonyos eseménytípusokat kell szinkronizálni, de a szűkítést a hívó végzi (IFC.IsInkassoSyncSendEvent alapján, ld. ORG.CreateEvent tárolt)
            - ha az esemény debtorhoz kapcsolódik, akkor cselesen előkeressük az EntityID-ját és a DebtCaseID-ját is és mindkettőt küldjük a szinkron során
            - a FŐ kapcsolódás mellett másodlagosan az ORG.ObjectEvent táblát is figyelembe vesszük (a top 1 sort típusonként, ha a Fő kapcsolódásnál nem szerepelt)
        */
        insert into IFC.InkassoSyncSendEvent(IndecsInkassoSyncID, EventID, Description, DebtCaseID, EntityID, ExternalEntityID, AssetID, EventTypeCode, InkEventTypeCode, ArrangeDateTime, 
                                             EventCreationDateTime, EventCreationUser, ModificationType, EventArrangeUser, InterfaceStatusCode, CreationDate, CreationTime, CreationUserName
                                            )
          select  @indecsInkassoSyncID IndecsInkassoSyncID, e.ID EventID, e.Comments Desciption, 
                  Coalesce(dcs.ID, d.DebtCaseID, ov.DebtCaseID, ov_d.DebtCaseID) DebtCaseID, 
                  entityFinal.ID EntityID, 
                  IFC.GetInkassoExternalEntityID(entityFinal.ID, entityFinal.SourceInterfaceType, entityFinal.SourceID) ExternalEntityID,
                  IsNull(a.ID, ov.AssetID) AssetID, 
                  e.EventTypeCode, 
                  IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, e.EventTypeCode, 'VALUESET_EVENT_TYPE', null /*@date*/) InkEventTypeCode,
                  null /*az Excelben piros*/ ArrangeDateTime, 
                  Cast(e.CreationDate as DateTime) + Cast(e.CreationTime as DateTime) EventCreationDateTime, 
                  e.CreationUserName EventCreationUser,
                  @modificationType ModificationType,
                  null /*az Excelben piros*/ EventArrangeUser,
                  'INTERFACE_STATUS_NEW' InterfaceStatusCode,
                  GetDate() CreationDate,
                  GetDate() CreationTime,
                  @dataChangedUserName CreationUserName
          from ORG.Event e with(nolock) left join DCS.DebtCase dcs with(nolock) on e.RelatedObjectID = dcs.ObjectID
                                        left join PRT.Entity ent with(nolock) on e.RelatedObjectID = ent.ObjectID
                                        left join AST.Asset a with(nolock) on e.RelatedObjectID = a.ObjectID
                                        left join DCS.Debtor d with(nolock) on e.RelatedObjectID = d.ObjectID
                                        outer apply (select Min(ov_dcs.ID) DebtCaseID, Min(ov_ent.ID) EntityID, Min(ov_a.ID) AssetID, Min(ov_d.ID) DebtorID
                                                     from ORG.ObjectEvent ov with(nolock) left join DCS.DebtCase ov_dcs with(nolock) on ov.ObjectID = ov_dcs.ObjectID
                                                                                          left join PRT.Entity ov_ent with(nolock) on ov.ObjectID = ov_ent.ObjectID
                                                                                          left join AST.Asset ov_a with(nolock) on ov.ObjectID = ov_a.ObjectID
                                                                                          left join DCS.Debtor ov_d with(nolock) on ov.ObjectID = ov_d.ObjectID
                                                             
                                                     where ov.EventID = e.ID 
                                                       and (   IsNull(ov_dcs.ID, ov_d.DebtCaseID) is not null
                                                            or IsNull(ov_ent.ID, ov_d.EntityID) is not null
                                                            or ov_a.ID is not null
                                                          )
                                                   ) ov
                                        left join DCS.Debtor ov_d with(nolock) on ov.DebtorID = ov_d.ID
                                        left join PRT.Entity entityFinal with(nolock) on Coalesce(ent.ID, d.EntityID, ov.EntityID, ov_d.EntityID) = entityFinal.ID
          where e.ID = @ID
      end
      else if @syncType = 'Document'
      begin
        set @taskTypeCode = 'TASK_TYPE_DATA_SYNC_OUTGOING_DOCUMENT_INK'

        /*Megjegyzések:
            - csak a kivonatgyári dokumentumokat kell szinkronizálni
            - EntityID, DebtorEntityID közül nekünk mindig csak a DebtorEntityID-t kell tölteni és azt simán az Interaction.RecipientEntityID-ból kell venni (küldeni majd az ExternalDebtorEntityID-t kell)
              (Inkasso oldalon a sima EntityID a feladót jelenti)               
        */

        insert into IFC.InkassoSyncSendDocument(IndecsInkassoSyncID, DocumentLastModDateTime, DocumentLastModUserName, InkModificationTypeCode, DocumentID, DocumentCreationUserName, InkDocumentTypeID, 
                                                InkDocumentID, DocumentPath, Barcode, PostalRegNr, DebtCaseID, EntityID, DebtorEntityID, DebtorExternalEntityID, EntityAddressID, 
                                                RelatedDocumentID, DocumentCreationDateTime, InkDocumentStatusID, InkMediaID, DocumentMailingDate, DocumentPrintDate, 
                                                InterfaceStatusCode, CreationDate, CreationTime, CreationUserName
                                               )
          select  @indecsInkassoSyncID IndecsInkassoSyncID, 
                  Cast(d.LastModifiedDate as DateTime) + Cast(d.LastModifiedTime as DateTime) DocumentLastModDateTime, 
                  d.LastModifiedUserName DocumentLastModUserName,
                  Case when @syncEventType = @syncEventTypeInsert then 'I' else 'U' end InkModificationTypeCode /*I/U/D - nálunk D nincs egyelőre*/,
                  d.ID DocumentID, 
                  d.CreationUserName DocumentCreationUserName, 
                  null /*az Excelben piros*/ InkDocumentTypeID,
                  d.ID /*?*/ InkDocumentID,
                  d.FileName DocumentPath,
                  null /*az Excelben piros*/ Barcode, 
                  null /*az Excelben piros*/ PostalRegNr, 
                  interactionDebtCase.ID DebtCaseID,
                  null EntityID /*ez Inkasso oldalon a feladó, nem kell tölteni*/,
                  recipientEntity.ID DebtorEntityID /*ez Inkasso oldalon a címzett, ezt kell tölteni*/, 
                  IFC.GetInkassoExternalEntityID(recipientEntity.ID, recipientEntity.SourceInterfaceType, recipientEntity.SourceID) DebtorExternalEntityID /*ez Inkasso oldalon a címzett, ezt kell tölteni*/, 
                  interaction.RecipientAddressID EntityAddressID,
                  null /*az Excelben piros*/ RelatedDocumentID,
                  Cast(d.CreationDate as DateTime) + Cast(d.CreationTime as DateTime) DocumentCreationDateTime,
                  null /*az Excelben piros*/ InkDocumentStatusID,
                  null /*az Excelben piros*/ InkMediaID,
                  interaction.SendingDate DocumentMailingDate,
                  null /*az Excelben piros*/ DocumentPrintDate,
                  'INTERFACE_STATUS_NEW' InterfaceStatusCode,
                  GetDate() CreationDate,
                  GetDate() CreationTime,
                  @dataChangedUserName CreationUserName
          from GEN.Document d with(nolock) outer apply (select top 1 i.ID InteractionID, i.RecipientAddressID, i.SendingDate, i.DeliveryDate, i.RecipientName, i.RecipientEntityID
                                                        from COM.InteractionDocument id with(nolock) join COM.Interaction i with(nolock) on id.InteractionID = i.ID
                                                        where id.DocumentID = d.ID
                                                        order by i.ID
                                                      ) interaction 
                                           outer apply (select top 1 d.ID
                                                        from COM.InteractionObject io with(nolock) join GEN.Object o with(nolock) on io.RelatedObjectID = o.ID
                                                                                                   join DCS.DebtCase d with(nolock) on o.ID = d.ObjectID
                                                        where interaction.InteractionID = io.InteractionID
                                                       ) interactionDebtCase
                                           left join PRT.Entity recipientEntity with(nolock) on interaction.RecipientEntityID = recipientEntity.ID  
                                           left join PRT.Address recipientAddress with(nolock) on interaction.RecipientAddressID = recipientAddress.ID 
          where d.ID = @ID
      end
      else if @syncType = 'ConstructionCode'  
      begin
        set @taskTypeCode = 'TASK_TYPE_DATA_SYNC_CONSTRUCTION_CODE_INK'


        insert into IFC.InkassoSyncSendConstructionCode(IndecsInkassoSyncID, ConstructionCode, Level1, Level2, Level3, Level4, Level5, Level6, Level7, 
                                                        ConsolidatedProductCode, InkConsolidatedProductID, RbProd, IFRSProductCode,  CurrencyCode, InkCurrencyCode, 
                                                        DataCreationUser, DataCreationDateTime, DataLastModUser, DataLastModDateTime, 
                                                        ModificationType, InterfaceStatusCode, CreationDate, CreationTime, CreationUserName
                                                       )
          select  @indecsInkassoSyncID IndecsInkassoSyncID, c.Code ConstructionCode, c.Level1, c.Level2, c.Level3, c.Level4, c.Level5, c.Level6, c.Level7,
                  p.Code ConsolidatedProductCode, 
                  IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, p.Code, 'VALUESET_CONSOLIDATED_PRODUCT', null /*@date*/) InkConsolidatedProductID,
                  c.RbProd, c.IFRSProductCode,
                  c.CurrencyCode, 
                  IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, c.CurrencyCode, 'VALUESET_CURRENCY', null /*@date*/)  InkCurrencyCode,
                  c.CreationUserName DataCreationUser,
                  Cast(c.CreationDate as DateTime) + Cast(c.CreationTime as DateTime) DataCreationDateTime,
                  Case when @syncEventType = @syncEventTypeUpdate then @dataChangedUserName else null end DataLastModUser /*the user of the last modification*/, 
                  Case when @syncEventType = @syncEventTypeUpdate then @dataChangedDateTime else null end DataLastModDateTime /*the last modification date*/, 
                  @modificationType ModificationType,
                  'INTERFACE_STATUS_NEW' InterfaceStatusCode,
                  GetDate() CreationDate,
                  GetDate() CreationTime,
                  @dataChangedUserName CreationUserName
        from FIN.ConstructionCode c with(nolock) left join FIN.ConsolidatedProduct p with(nolock) on c.ConsolidatedProductID = p.ID
        where c.ID = @ID
      end
      else if @syncType = 'DebtCase'
      begin
        set @taskTypeCode = 'TASK_TYPE_DATA_SYNC_DEBT_CASE_INK'

        insert into IFC.InkassoSyncSendDebtCase(IndecsInkassoSyncID, DebtCaseID, OriginalCreditorEntityID, ExternalOriginalCreditorEntityID, MainDebtorID, PurchaseDate, CurrencyCode, InkCurrencyCode, PurchasePrice, DebtCapital, DebtInterest, 
                                                DebtPenaltyInterest, DebtCost, DebtCostLocalCurrency, AccountNr, SubAccountNr, URBISAccountNr, ContractID, ContractNr, PricingID, DebtTypeCode,
                                                DepartmentTypeCode, InkDepartmentTypeCode, ContractTypeCode, InkContractTypeCode, ContractSignDate, CreditTypeCode, InkCreditTypeCode, DebtorName, BalanceDate, OfficeID, 
                                                SourceSystemID, InkSourceSystemID, NormalInterestRate, PenaltyInterestRate, CostRate, TerminationDate, IssueDate, FulfillmentDate, RiskPool, ProductSegment, HousingSaving, HousingSavingDefaultStopDate, 
                                                HPV, CostMin, CostMax, CostMinMaxPeriodTypeCode, CreditGuarantee, DebtTotal, KHR, KHRPenaltyDate, KHRDunningLetterDate, KHROmissionDate, IncomeTransactionAmount, KHRContractID, 
                                                ContractDataOriginCode, InkContractDataOriginCode, ConsolidatedSource, ConsolidatedProduct, ConstructionCode, ConsolidatedProductID, EVQualifyCode, EVQualifyGroup, Method, 
                                                Level5ID, Level7ID, ProductCategory, CollectorRelatedDebtCaseID, CollectorRelatedDebtCaseType, DebtCaseCreationDateTime, OperatorUserName, ModificationType,
                                                InterfaceStatusCode, CreationDate, CreationTime, CreationUserName
                                               )
            select  @indecsInkassoSyncID IndecsInkassoSyncID, 
                    DebtCase.ID DebtCaseID /*Ügy egyedi azonosító*/, 
                    DebtCase.OriginalCreditorEntityID /*Engedményező cég egyedi azonosítója (Indecs)*/, 
                    IFC.GetInkassoExternalEntityID(creditorEntity.ID, creditorEntity.SourceInterfaceType, creditorEntity.SourceID) ExternalOriginalCreditorEntityID,
                    DebtCase.MainDebtorID /*Adós egyedi azonosítója*/, 
                    DebtCase.PurchaseDate /*Megbízás dátuma*/, 
                    DebtCase.CurrencyCode /*Ügy devizája – FK14*/, 
                    IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, DebtCase.CurrencyCode, 'VALUESET_CURRENCY', null /*@date*/) InkCurrencyCode,
                    Account.Balance PurchasePrice /*Vételár – F26*/,
                    InvoiceArrearsDebtCapital.Amount /*Vásárolt tőketartozás – FK10*/,
                    InvoiceArrearsDebtInterest.Amount /*Vásárolt ügyleti kamattartozás – FK11*/,
                    InvoiceArrearsDebtPenaltyInterest.Amount /*Vásárolt késedelmi kamattartozás – FK12*/,
                    InvoiceArrearsDebtCost.Amount /*Vásárolt költségtartozás – FK13*/,
                    InvoiceArrearsDebtCostLocalCurrency.Amount /*Vásárolt HUF költségtartozás – FK60*/,
                    DebtCase.BankAccountNumber /*Eredeti bankszámlaszám – FK02*/,
                    null SubAccountNr /*Alszámlaszám – FK03. Nem tároljuk*/,
                    DebtCase.RepaymentBankAccountNr URBISAccountNr /*Követelés URBIS számlaszáma (Ha létezik).*/,
                    null ContractID /*Szerződés egyedi azonosító (Ha ez Ecollect képez egyedi azonosítót a szerződéshez)*/,
                    null ContractNr /*Szerződésszám az Interfészből – FK05*/,
                    null PricingID /*Árazás azonosító– FK24. Nem tároljuk.*/,
                    null DebtTypeCode /*Lakossági fedezetlen (01), Lakossági fedezetes (02), Vállalati (03).*/,
                    DebtCase.DepartmentTypeCode /*Üzletág kód – FK07 (Indecs)*/,
                    IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, DebtCase.DepartmentTypeCode, 'VALUESET_DEPARTMENT_TYPE', null /*@date*/) InkDepartmentTypeCode,
                    null ContractTypeCode /*Szerződéstípus (Indecs)*/,
                    null InkContractTypeCode /*Szerződéstípus (Inkasso). E = engedményezett, B = behajtásra átadott – FK28*/,
                    null ContractSignDate /*Szerződés aláírás dátuma – FK30. Több ContractSigner is lehet - a legkésőbbi dátum számít*/,
                    DebtCase.CreditTypeCode /*Hiteltípus – FK08 (Indecs)*/,
                    IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, DebtCase.CreditTypeCode, 'VALUESET_CREDIT_TYPE', null /*@date*/) InkCreditTypeCode /*Hiteltípus – FK08 (Inkasso)*/,
                    PRT.GetEntityName(MainDebtor.EntityID) DebtorName /*Adós neve*/,
                    null BalanceDate /*Vásárlás fordulónapja. – FK25. Nem tároljuk.*/,
                    null OfficeID /*Fiókkód  – FK01. Szándékosan nem küldjük.*/,
                    DebtCase.OriginalAccountingSystemCode SourceSystemID /*Forrásrendszer azonosítója – FK04 (Indecs)*/,
                    IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, DebtCase.OriginalAccountingSystemCode, 'VALUESET_ACCOUNTING_SYSTEM', null /*@date*/) InkSourceSystemID /*Forrásrendszer azonosítója – FK04 (Inkasso)*/,
                    (select top 1 /*top 1: just in case*/ f.FeeRate
                     from FIN.Calculation c join FIN.FeeList fl on c.FeeListId = fl.ID
                                            join FIN.Fee f on fl.ID = f.FeeListID
                     where c.ID = DebtCase.MainCalculationId
                       and f.Code = 'FEE_INTEREST'
                       and f.TypeCode = 'FEE_TYPE_INTEREST_PERCENT'
                       and IsNull(f.ValidFrom, DebtCase.PurchaseDate) <= DebtCase.PurchaseDate
                       and DebtCase.PurchaseDate <= IsNull(f.ValidUntil, DebtCase.PurchaseDate)
                     order by f.ID desc 
                    ) NormalInterestRate /*Ügyleti kamat % – FK16.*/,
                    (select top 1 /*top 1: just in case*/ f.FeeRate
                     from FIN.Calculation c join FIN.FeeList fl on c.FeeListId = fl.ID
                                            join FIN.Fee f on fl.ID = f.FeeListID
                     where c.ID = DebtCase.MainCalculationId
                       and f.Code = 'FEE_PENALTY_INTEREST'
                       and f.TypeCode = 'FEE_TYPE_INTEREST_PERCENT'
                       and IsNull(f.ValidFrom, DebtCase.PurchaseDate) <= DebtCase.PurchaseDate
                       and DebtCase.PurchaseDate <= IsNull(f.ValidUntil, DebtCase.PurchaseDate)
                     order by f.ID desc 
                    ) PenaltyInterestRate /*Késedelmi kamat % – FK17.*/,
                    CostFeeData.FeeRate CostRate /*Kezelési költség%  – FK18*/,
                    Invoice.TerminationDate /*Felmondás dátuma – FK19*/,
                    Invoice.IssueDate /*Hitelkihelyezés dátuma – FK20*/,
                    Invoice.FulfillmentDate /*Késedelembe esés dátuma – FK21*/,
                    null RiskPool /*Kockázati pool azonosító – FK31. Nem tároljuk.*/,
                    null ProductSegment /*Termékszegmens azonosító, ha az Ecollect ezt meghatározza. Nem tároljuk.*/,
                    null HousingSaving /*Speciális felmondott jelző – Késedelmi kamat leállítandó – FK54. Nem tároljuk.*/,
                    null HousingSavingDefaultStopDate /*Késedelmi kamat leállításnak dátuma. Nem tároljuk.*/,
                    null HPV /*HVP jelző – FK53. Nem tároljuk.*/,
                    CostFeeData.PeriodMinimumValue CostMin /*Kezelési költség minimuma – FK43.*/,
                    CostFeeData.PeriodMaximumValue CostMax /*Kezelési költség maximuma – FK44.*/,
                    CostFeeData.PeriodTypeCode CostMinMaxPeriodTypeCode /*ez csak nap lehet elvileg - ha van megadva CostMin/CostMax és nem nap, akkor küldéskor hibát jelzünk*/,
                    null CreditGuarantee /*Hitelgarancia jelző – FK61. Nem tároljuk.*/,
                    null DebtTotal /*Szerződés összege – FK38*/,
                    null KHR /*A BAR-ba felkerülés lehetőségét szerződésben elfogadta – FK39. Nem tároljuk.*/,
                    null KHRPenaltyDate /*Az ügylet 90 napos figyelésének kezdő dátuma – FK40. Nem tároljuk*/,
                    null KHRDunningLetterDate /*Az ügyfélnek küldött figyelmeztető levél dátuma – FK41. Nem tároljuk*/,
                    null KHROmissionDate /*Amikor a forrásrendzser BAR-ba feladta – FK4. Nem tároljuk*/,
                    null IncomeTransactionAmount /*Ügyfél által befizetett összeg – FK62. Nem tároljuk.*/,
                    null KHRContractID /*KHR szerződés azonosító – FK63.  Nem tároljuk*/,
                    null ContractDataOriginCode /*Milyen forrásból lett betöltve az ügy (Indecs)*/,
                    null InkContractDataOriginCode /*Milyen forrásból lett betöltve az ügy (Inkasso). I = interfész, E = excel*/ ,
                    null ConsolidatedSource /*Konszolidált forrás - elég a konstrukciós kód átadása.*/,
                    null ConsolidatedProduct /*Konszolidált termék - elég a konstrukciós kód átadása*/,
                    DebtCase.ConstructionCode /*Konstrukció – FK55*/,
                    null ConsolidatedProductID /*Konszolidált termék azonosító - elég a konstrukciós kód átadása*/,
                    null EVQualifyCode /*EV minősítés. Nem tároljuk.*/,
                    null EVQualifyGroup /*EV minősítés csoport. Nem tároljuk.*/,
                    null Method /*Nem tároljuk.*/,
                    null Level5ID /*Nem tároljuk - elég a konstrukciós kód átadása*/,
                    null Level7ID /*Nem tároljuk - elég a konstrukciós kód átadása*/,
                    null ProductCategory /*Nem tároljuk.*/,
                    null CollectorRelatedDebtCaseID /*Gyűjtőszámla kapcsolódó ügy. Nem tároljuk.*/,
                    null CollectorRelatedDebtCaseType /*Kapcsolódó ügy típusa. (GYGY- gyűjtő, FOGY- főszámla). Nem tároljuk.*/,
                    Cast(DebtCase.CreationDate as DateTime) + Cast(DebtCase.CreationTime as DateTime) DebtCaseCreationDateTime /*Rögzítés dátuma – a követelés betöltésének dátuma*/,
                    null OperatorUserName /*Kezelő ügyintéző. Szándékosan nem küldjük.*/,
                    @modificationType ModificationType  /*Amennyiben új rekord létrehozása történik a DCS.DebtCase táblába, akkor 'INSERT', 
                                                          ha meglévő DCS.DebtCase rekord módosítása történik, akkor 'UPDATE', 
                                                          ha meglévő DCS.DebtCase rekord törlése történik, akkor 'DELETE' (nálunk delete az nincs).
                                                        */,
                    'INTERFACE_STATUS_NEW' InterfaceStatusCode,
                    GetDate() CreationDate,
                    GetDate() CreationTime,
                    @dataChangedUserName CreationUserName
            from DCS.DebtCase with(nolock) left join PRT.Entity creditorEntity with(nolock) on DebtCase.OriginalCreditorEntityID = creditorEntity.ID
                                           join DCS.Debtor MainDebtor with(nolock) on DebtCase.MainDebtorID = MainDebtor.ID
                                           join FIN.Calculation on DebtCase.MainCalculationID = Calculation.ID
                                           join FIN.CalculationInvoice on Calculation.ID = CalculationInvoice.CalculationID
                                           join FIN.Invoice on CalculationInvoice.InvoiceID = Invoice.ID
                                                        /*top 1: just in case*/   
                                           outer apply (select top 1 InvoiceArrears.Amount
                                                        from FIN.InvoiceArrears
                                                        where Invoice.ID = InvoiceArrears.InvoiceID
                                                          and exists(select *
                                                                     from FIN.AccountType 
                                                                     where InvoiceArrears.AccountTypeID = AccountType.ID
                                                                       and AccountType.MainClass = 'ACCOUNT_MAIN_CLASS_CAPITAL'
                                                                       and AccountType.Code in('ACCOUNT_TYPE_DEBT_CAPITAL_MANAGED' , 'ACCOUNT_TYPE_DEBT_CAPITAL')
                                                                       and AccountType.Pending = 'BOOLEAN_FALSE'
                                                                    )
                                                       ) InvoiceArrearsDebtCapital
                                                        /*top 1: just in case*/   
                                           outer apply (select top 1 InvoiceArrears.Amount
                                                        from FIN.InvoiceArrears
                                                        where Invoice.ID = InvoiceArrears.InvoiceID
                                                          and exists(select *
                                                                     from FIN.AccountType 
                                                                     where InvoiceArrears.AccountTypeID = AccountType.ID
                                                                       and AccountType.MainClass = 'ACCOUNT_MAIN_CLASS_INTEREST'
                                                                       and AccountType.Code in('ACCOUNT_TYPE_DEBT_INTEREST_MANAGED', 'ACCOUNT_TYPE_DEBT_INTEREST')
                                                                       and AccountType.Pending = 'BOOLEAN_FALSE'
                                                                    )
                                                       ) InvoiceArrearsDebtInterest
                                                        /*top 1: just in case*/   
                                           outer apply (select top 1 InvoiceArrears.Amount
                                                        from FIN.InvoiceArrears
                                                        where Invoice.ID = InvoiceArrears.InvoiceID
                                                          and exists(select *
                                                                     from FIN.AccountType 
                                                                     where InvoiceArrears.AccountTypeID = AccountType.ID
                                                                       and AccountType.MainClass = 'ACCOUNT_MAIN_CLASS_PENALTY_INTEREST'
                                                                       and AccountType.Code in('ACCOUNT_TYPE_DEBT_PENALTY_INTEREST_MANAGED' , 'ACCOUNT_TYPE_DEBT_PENALTY_INTEREST')
                                                                       and AccountType.Pending = 'BOOLEAN_FALSE'
                                                                    )
                                                       ) InvoiceArrearsDebtPenaltyInterest
                                                         /*if there's only HUF debtcost, we have to find that record;
                                                           if there's another currency as well (or just another), we have to find that record
                                                         */   
                                           outer apply (select top 1 InvoiceArrears.Amount, InvoiceArrears.CurrencyCode
                                                        from FIN.InvoiceArrears
                                                        where Invoice.ID = InvoiceArrears.InvoiceID
                                                          and exists(select *
                                                                     from FIN.AccountType 
                                                                     where InvoiceArrears.AccountTypeID = AccountType.ID
                                                                       and AccountType.MainClass = 'ACCOUNT_MAIN_CLASS_COST'
                                                                       and AccountType.Code in('ACCOUNT_TYPE_DEBT_COST_MANAGED' , 'ACCOUNT_TYPE_DEBT_COST')
                                                                       and AccountType.Pending = 'BOOLEAN_FALSE'
                                                                    )
                                                        order by Case when InvoiceArrears.CurrencyCode <> @localCurrencyCode then 0 else 1 end
                                                       ) InvoiceArrearsDebtCost
                                                         /*if there are 2 records with 2 different currencies (1 of them is always HUF), we have to find the one with HUF
                                                           if there's only 1 record, it has to be empty
                                                         */   
                                           outer apply (select top 1 InvoiceArrears.Amount
                                                        from FIN.InvoiceArrears
                                                        where Invoice.ID = InvoiceArrears.InvoiceID
                                                          and InvoiceArrears.CurrencyCode = @localCurrencyCode
                                                          and InvoiceArrears.CurrencyCode <> InvoiceArrearsDebtCost.CurrencyCode
                                                          and exists(select *
                                                                     from FIN.AccountType 
                                                                     where InvoiceArrears.AccountTypeID = AccountType.ID
                                                                       and AccountType.MainClass = 'ACCOUNT_MAIN_CLASS_COST'
                                                                       and AccountType.Code in('ACCOUNT_TYPE_DEBT_COST_MANAGED' , 'ACCOUNT_TYPE_DEBT_COST')
                                                                       and AccountType.Pending = 'BOOLEAN_FALSE'
                                                                    )
                                                        order by Case when InvoiceArrears.CurrencyCode = @localCurrencyCode then 0 else 1 end
                                                       ) InvoiceArrearsDebtCostLocalCurrency
                                           left join FIN.Account on Calculation.ID = Account.CalculationID
                                                                    and exists(select *
                                                                               from FIN.AccountType 
                                                                               where Account.AccountTypeID = AccountType.ID
                                                                                 and AccountType.MainClass = 'ACCOUNT_MAIN_CLASS_GENERAL'
                                                                                 and AccountType.Code = 'ACCOUNT_TYPE_BOOK_VALUE'
                                                                                 and AccountType.Pending = 'BOOLEAN_FALSE'
                                                                              )
                                           outer apply (select top 1 /*top 1: just in case*/ f.FeeRate, f.PeriodMinimumValue, f.PeriodMaximumValue, f.PeriodTypeCode
                                                        from FIN.Calculation c join FIN.FeeList fl on c.FeeListId = fl.ID
                                                                               join FIN.Fee f on fl.ID = f.FeeListID
                                                        where c.ID = DebtCase.MainCalculationId
                                                          and f.Code = 'FEE_MANAGEMENT_FEE'
                                                          and f.TypeCode = 'FEE_TYPE_INTEREST_PERCENT'
                                                          and IsNull(f.ValidFrom, DebtCase.PurchaseDate) <= DebtCase.PurchaseDate
                                                          and DebtCase.PurchaseDate <= IsNull(f.ValidUntil, DebtCase.PurchaseDate)
                                                        order by f.ID desc 
                                                       ) CostFeeData   
            where DebtCase.ID = @debtCaseID
      end
      else if @syncType = 'Debtor' /*OK*/
      begin
        set @taskTypeCode = 'TASK_TYPE_DATA_SYNC_DEBTOR_INK'

        /*Megjegyzés:
           - StatusCode: ebből nincs Inkasso-s, csak az IFC.GetINK034_PartyMap fv-ben kérjük le az Inkassós megfelelőjét
        */
          
        insert into IFC.InkassoSyncSendDebtor(IndecsInkassoSyncID, DebtorID, EntityID, ExternalEntityID, DebtCaseID, RoleCode, InkRoleCode, StatusCode, ValidUntil, DataLastModUser, DataLastModDateTime, DataCreationUser, DataCreationDateTime, 
                                              ModificationType, InterfaceStatusCode, CreationDate, CreationTime, CreationUserName
                                             )
            select  @indecsInkassoSyncID IndecsInkassoSyncID, 
                    d.ID DebtorID /*INDECS rendszer partymap id*/, 
                    d.EntityID /*Indecsrendszerazonosító*/, 
                    IFC.GetInkassoExternalEntityID(e.ID, e.SourceInterfaceType, e.SourceID) ExternalEntityID,
                    d.DebtCaseID /*Külső kulcs: UGY.UGYID*/, 
                    d.RoleCode /*RoleCode (Indecs)*/, 
                    IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, d.RoleCode, 'VALUESET_DEBTOR_ROLE', null /*@date*/) InkRoleCode /*RoleCode (Inkasso). Külső kulcs: KEZESTIPUS.KEZESTIPUSID*/, 
                    d.StatusCode /*A kapcsolat aktivitás jelölése értékei: F/T*/,
                    d.ValidUntil /*A dátum jelöli a kapcsolat inaktivitás kezdetét*/,
                    Case when @syncEventType = @syncEventTypeUpdate then @dataChangedUserName else null end DataLastModUser /*the user of the last modification*/, 
                    Case when @syncEventType = @syncEventTypeUpdate then @dataChangedDateTime else null end DataLastModDateTime /*the last modification date*/, 
                    d.CreationUserName DataCreationUser,
                    Cast(d.CreationDate as DateTime) + Cast(d.CreationTime as DateTime) DataCreationDateTime,
                    @modificationType ModificationType,
                    'INTERFACE_STATUS_NEW' InterfaceStatusCode,
                    GetDate() CreationDate,
                    GetDate() CreationTime,
                    @dataChangedUserName CreationUserName
            from DCS.Debtor d with(nolock) join PRT.Entity e with(nolock) on d.EntityID = e.ID
            where d.ID = @ID
      end
      else if @syncType = 'Asset' /*OK*/
      begin
        select @taskTypeCode = 'TASK_TYPE_DATA_SYNC_RELATION_DEBT_CASE_ASSET_INK',
               @today = GetDate()

        /*Megjegyzés, kérdések:
           - ilyen szinkron egyedül az ügyszinkron kapcsán generálódik majd az (EntityAsset létrejötte után), utólagosan a fedezetadatokon nem lehet majd módosítani (és visszafele sem jön ilyen adat)
           - a MarketValue, stb.-hez elvileg tartozik Currency (AST.AssetValuationValue.ValueCurrencyCode), bár valamiért nincs mindenhol feltöltve - abban maradtunk, hogy itt bízunk benne, 
             hogy mindenhol csak HUF lesz
        */
          
        insert into IFC.InkassoSyncSendAsset(IndecsInkassoSyncID, AssetID, LandRegisterReference, TATypeCode, TASubTypeCode, ZipCode, Settlement, Street, StatusCode, InkStatusCode, LandRegisterCity, AssetTypeCode, InkAssetTypeCode, 
                                             AssetNatureCode, InkAssetNatureCode, Name, MarketValue, EscapeValue, RealMarketValue, RealEscapeValue, LastValuationDate, PropertySheetNr, DebtCaseID, ExecutionRightNr, ExecutionRightValue, 
                                             ExecutionRightDate, MortgageRightNr, MortgageRightDate, OwnerEntityID, ExternalOwnerEntityID, OwnershipValidFrom, OwnershipPretense, OwnershipValidUntil, ShareDividend, 
                                             DataLastModUser, DataLastModDateTime, DataCreationUser, DataCreationDateTime, InterfaceStatusCode, CreationDate, CreationTime, CreationUserName
                                            )
            select @indecsInkassoSyncID IndecsInkassoSyncID, 
                   a.ID AssetID,
                   a.LandRegisterReference,
                   null TATypeCode,
                   null TASubTypeCode,
                   ad.ZipCode,
                   ad.Settlement,
                   Case when ad.ID is not null then Concat(ad.PublicPlaceName, ' ', GEN.TranslateCode(ad.PublicPlaceType, 'HU')) else null end Street,
                   ad.StatusCode Status,
                   IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, ad.StatusCode, 'VALUESET_STATUS', null /*@date*/) InkStatusCode,
                   a.LandRegisterCity, 
                   a.AssetTypeCode,
                   IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, a.AssetTypeCode, 'VALUESET_ASSET_PROPERTY_TYPE', null /*@date*/) InkAssetTypeCode,
                   a.AssetNatureCode,
                   IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, a.AssetNatureCode, 'VALUESET_ASSET_NATURE', null /*@date*/) InkAssetNatureCode,
                   a.Name,
                   (select top 1 avv.NetValue
                    from AST.AssetValuationValue avv with(nolock)
                    where avv.AssetValuationID = av.AssetValuationID
                      and avv.ValueTypeCode = 'ASSET_VALUATION_VALUE_TYPE_MARKET'
                    order by avv.ID desc
                   ) MarketValue /*Kihelyezéskori ÉB – FF23*/,
                   (select top 1 avv.NetValue
                    from AST.AssetValuationValue avv with(nolock)
                    where avv.AssetValuationID = av.AssetValuationID
                      and avv.ValueTypeCode = 'ASSET_VALUATION_VALUE_TYPE_ESCAPE'
                    order by avv.ID desc
                   ) EscapeValue /*Kihelyezéskori ÉB – FF24*/,
                   (select top 1 avv.NetValue
                    from AST.AssetValuationValue avv with(nolock)
                    where avv.AssetValuationID = av.AssetValuationID
                      and avv.ValueTypeCode = 'ASSET_VALUATION_VALUE_TYPE_READY_TO_MOVE'
                    order by avv.ID desc
                   ) RealMarketValue /*Új értékbecslés – FF25*/,
                   (select top 1 avv.NetValue
                    from AST.AssetValuationValue avv with(nolock)
                    where avv.AssetValuationID = av.AssetValuationID
                      and avv.ValueTypeCode = 'ASSET_VALUATION_VALUE_TYPE_LIQUIDATION'
                    order by avv.ID desc
                   ) RealEscapeValue /*Új értékbecslés – FF26*/,
                   av.ValuationDate LastValuationDate /*Időben az utolsó*/,
                   null PropertySheetNr,
                   dca.DebtCaseID,
                   null ExecutionRightNr,
                   null ExecutionRightValue,
                   null ExecutionRightDate,
                   null MortgageRightNr,
                   null MortgageRightDate,
                   ea.EntityID OwnerEntityID, 
                   IFC.GetInkassoExternalEntityID(ea.EntityID, ea.EntitySourceInterfaceType, ea.EntitySourceID) ExternalOwnerEntityID, 
                   ea.ValidFrom OwnershipValidFrom, 
                   null OwnershipPretense,
                   ea.ValidUntil OwnershipValidUntil, 
                   ea.ShareDividend,
                   Case when @syncEventType = @syncEventTypeUpdate then @dataChangedUserName else null end DataLastModUser /*the user of the last modification*/, 
                   Case when @syncEventType = @syncEventTypeUpdate then @dataChangedDateTime else null end DataLastModDateTime /*the last modification date*/, 
                   a.CreationUserName DataCreationUser,
                   Cast(a.CreationDate as DateTime) + Cast(a.CreationTime as DateTime) DataCreationDateTime,
                   'INTERFACE_STATUS_NEW' InterfaceStatusCode,
                   GetDate() CreationDate,
                   GetDate() CreationTime,
                   @dataChangedUserName CreationUserName
            from AST.Asset a with(nolock) left join PRT.Address ad with(nolock) on ad.AssetID = a.ID and ad.AddressType = 'ADDRESS_TYPE_ASSET_LOCATION'
                                          outer apply (select top 1 v.ID AssetValuationID, v.ValuationDate
                                                       from AST.AssetValuation v with(nolock)
                                                       where v.AssetID = a.ID
                                                       order by v.ValuationDate desc
                                                      ) av
                                          join AST.DebtCaseAsset dca with(nolock) on dca.AssetID = a.ID 
                                                                                 and dca.StatusCode = 'STATUS_NORMAL'
                                                                                 and IsNull(dca.ValidFrom, @today) <= @today
                                                                                 and @today <= IsNull(dca.ValidUntil, @today)
                                          outer apply (select top 1 ea.EntityID, ea.ValidFrom, ea.ValidUntil, ea.ShareDividend, e.SourceInterfaceType EntitySourceInterfaceType, e.SourceID EntitySourceID
                                                      from AST.EntityAsset ea with(nolock) join PRT.Entity e with(nolock) on ea.EntityID = e.ID
                                                      where ea.AssetID = a.ID
                                                        and ea.EntityAssetRelationTypeCode = 'ENTITY_ASSET_RELATION_TYPE_OWNER'
                                                        and ea.StatusCode = 'STATUS_NORMAL'
                                                        and IsNull(ea.ValidFrom, @today) <= @today
                                                        and @today <= IsNull(ea.ValidUntil, @today)
                                                      ) ea
            where a.ID = @id
              and dca.DebtCaseID = @debtCaseID
      end
  

      /*creating a new task referencing the inserted indecsInkassoSyncID
        There's no ObjectID in IFC tables --> we set ORG.Task.ReferencedObjectID to null. After creating the task, the taskID will be stored in IFC.IndecsInkassoSync.TaskID
      */
      if @taskTypeCode is not null
      begin
         select @taskUserName = m.TechnicalUserName
         from ORG.Module m
         where m.ModuleCode = @moduleCode
         
         if @taskUserName is null
            set @taskUserName = 'admin'

         exec ORG.TaskInsert	@p_taskTypeCode = @taskTypeCode,
	                            @p_referencedObjectID = null,
                              @p_userName = @taskUserName,
	                            @p_detailsStatusCode = 'TASK_DETAILED_STATUS_WAITING_TO_BE_PROCESSED',
	                            @p_creationUserName = @dataChangedUserName,
                              @p_correlationID = @correlationID,
	                            @p_newTaskID = @taskID output

        update IFC.IndecsInkassoSync
        set TaskID = @taskID, LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @dataChangedUserName
        where ID = @indecsInkassoSyncID


        /*create new module instance (if needed)*/
        if @moduleInstanceID is null
        begin
          select @moduleStatusCode = Case when @isBatch = 1 then 'MODULE_INSTANCE_STATUS_PREPARATION' else 'MODULE_INSTANCE_STATUS_READY_TO_RUN' end

          exec ORG.ModuleInstanceInsert @p_moduleCode = @moduleCode, 
                                        @p_statusCode = @moduleStatusCode, 
                                        @p_CorrelationID = @correlationID, 
                                        @p_UserName = @dataChangedUserName, 
                                        @p_moduleInstanceID = @moduleInstanceID out
        end
      end

    commit


    /*Logging processing end*/
    set @logMessage = Concat('End procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @dataChangedUserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

  end try
  begin catch
    if @@trancount > 0
       rollback

    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @correlationID,
                            @p_UserName = @dataChangedUserName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage

    ;throw
  end catch
end
go


CREATE FUNCTION [PRT].[GetAddressCountryStr](@p_AddressID NUMERIC(16), @p_LanguageID NVARCHAR(5))
RETURNS NVARCHAR(200)
BEGIN
  DECLARE @m_Result NVARCHAR(100);
  DECLARE @m_CountryCode NVARCHAR(100);
  DECLARE @m_CountryID NVARCHAR(50);
  DECLARE @m_CountryName NVARCHAR(50);
  DECLARE @p_CountryID NVARCHAR(50);
  DECLARE @m_ZipCode NVARCHAR(10);
  DECLARE @m_City NVARCHAR(50);
  DECLARE @m_Street NVARCHAR(60);
  DECLARE @m_Street_Type NVARCHAR(60);
  DECLARE @m_HouseNr NVARCHAR(50);
  DECLARE @m_Floor NVARCHAR(20);
  DECLARE @m_Door NVARCHAR(20);

  SELECT
    @m_CountryID = CountryID,
    @p_CountryID = CountryID,
    @m_ZipCode = ZipCode,
    @m_City = Settlement,
    @m_Street = PublicPlaceName,
	@m_Street_Type = GEN.TranslateCode(PublicPlaceType,'HU'),
    @m_HouseNr = HouseNr,
    @m_Floor = Floor,
    @m_Door = Door,
    @m_CountryCode = CountryID,
    @m_CountryName = GEN.TranslateCode(CountryID,'HU')
  FROM
    PRT.Address
  WHERE
    Address.ID = @p_AddressID;

  -- HUNGARIAN STYLE ADDRESS (Zipcode City, Street HouseNr Floor Door)
  IF @p_CountryID = 'COUNTRY_HU'
  BEGIN
    -- Country code
    IF @m_CountryCode = 'COUNTRY_HU' 
      SET @m_Result = '';
    ELSE
      SET @m_Result = CONCAT(@m_CountryCode, '-', ISNULL(@m_ZipCode, ''), ' ', @m_City);

     IF @m_ZipCode IS NOT NULL AND @m_ZipCode <> ''
      SET @m_Result = CONCAT(@m_Result, @m_ZipCode, ' ');

    IF @m_City IS NOT NULL AND @m_City <> '' 
      SET @m_Result = CONCAT(@m_Result, @m_City, ' ');


	    IF(@m_Street IS NOT NULL AND @m_Street <> '') OR (@m_HouseNr IS NOT NULL AND @m_HouseNr <> '' AND @m_HouseNr <> '0') 
      SET @m_Result = CONCAT(@m_Result,@m_Street, ' ');

	  IF(@m_Street_Type IS NOT NULL AND @m_Street_Type <> '')

      SET @m_Result = CONCAT(@m_Result, @m_Street_Type, ',');

	

    SET @m_Result = CONCAT(@m_Result, ' ', ' ', ISNULL(@m_HouseNr, ''), '. ', ISNULL(@m_Floor, ''), ' ', ISNULL(@m_Door, ''));
  END
  ELSE
  BEGIN
    -- CZECH, SLOVAK, SLOVEN, GERMAN STYLE ADDRESS (Street HouseNr Floor Door, Zipcode City, Country)
    SET @m_Result = CONCAT(ISNULL(@m_Street, ''), ' ', ISNULL(@m_HouseNr, ''), ' ', ISNULL(@m_Floor, ''));

    IF @m_City IS NOT NULL AND @m_City <> '' 
      SET @m_Result = CONCAT(@m_Result, @m_City, ' ');

    IF @m_ZipCode IS NOT NULL AND @m_ZipCode <> ''
      SET @m_Result = CONCAT(@m_Result, @m_ZipCode, ' ');

    -- (remove the commented out section with "Város" and uncomment if necessary)

    -- IF(TRIM(@m_Result) <> '' AND ((@m_ZipCode IS NOT NULL AND @m_ZipCode <> '') OR (@m_City IS NOT NULL AND @m_City <> ''))) 
    --   SET @m_Result = CONCAT(TRIM(@m_Result), ', ');

    -- IF @m_City IS NOT NULL AND @m_City <> '' 
    --   SET @m_Result = CONCAT(@m_Result, @m_City, ' ');

    -- IF @m_CountryID <> @p_CountryID 
    --   IF TRIM(@m_Result) <> '' 
    --     SET @m_Result = CONCAT(TRIM(@m_Result), ', ', @m_CountryName);
    --   ELSE
    --     SET @m_Result = @m_CountryCode;

  END

  RETURN @m_Result;
END
go

CREATE FUNCTION [GEN].[GetAppUserName](
  @p_UserID numeric(16),
  @p_LanguageID nvarchar(2),
  @p_TitlePosition numeric(1) = 0)
returns nvarchar(250)
/***********************************
* Administrator: Bognár Dávid      *
*  Created:      2022.11.16        *
*  Last revised: 2022.11.16        *
************************************
*
*
**********************************************************************
* Returns a formatted user name string.                              *
*                                                                    *
* p_CrefoID        ID of the user                                    *
* p_LanguageID     Language identifier. If it is 9 (Hungarian), then *
*                  the name order is 1. last name 2. first name,     *
*                  otherwise 1. first name 2. last name              *
* p_TitlePosition  -1 left, 0 none, 1 right                          *
* Example:                                                           *
*          select GetUserName('KOVACSG1', 1)                         *
*          returns                                                   *
*          Géza Kovács                                               *
*                                                                    *
*********************************************************************/
begin
  --declare @err_notfound exception for sqlstate value '02000';
  declare @m_result nvarchar(250);
  declare @m_NameHU nvarchar(250);
  declare @m_Name nvarchar(250);
  declare @m_Title nvarchar(50);
  
  select @m_NameHU=Trim(concat(LastName, ' ',FirstName)) ,
	     @m_Name=Trim(concat(FirstName , ' ' , LastName)),
		 @m_Title=Title 

	from PRT.AppUser au
		left join prt.Entity ent on au.EntityID=ent.ID
		left join prt.Person per on ent.ID=per.EntityID
	where au.ID = @p_UserID;

  if @p_LanguageID = 'HU' 
    set @m_Result=@m_NameHU
  else
    set @m_Result=@m_Name
  if(@p_TitlePosition = -1) and(@m_Title <> '') set @m_Result=concat(@m_Title, ' ' , @m_Result)
  if(@p_TitlePosition = 1) and(@m_Title <> '') set @m_Result=concat(@m_Result , ', ' , @m_Title)
    return @m_result
end
go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2022-11-22
-- Last modified date: 2022-11-22
-- Description:	Return control type by valuse set.
-- =============================================
CREATE   FUNCTION [GEN].[GetControlTypeByValueSet] (
	-- Add the parameters for the function here 
	@p_valueSetID NUMERIC(16)
)
RETURNS NVARCHAR(200)
AS
BEGIN
	DECLARE @l_dataType NVARCHAR(20) = NULL;
	DECLARE @l_controlType NVARCHAR(200) = NULL;

	IF COALESCE(@p_valueSetID, 0) > 0 
	BEGIN
		SELECT @l_dataType = [ValueSet].[DataType] 
		FROM [GEN].[ValueSet] 
		WHERE [ValueSet].[ID] = @p_valueSetID;
		
		SELECT @l_controlType =
		CASE @l_dataType 
			WHEN 'C' THEN 'CHARACTER'
			WHEN 'D' THEN 'DATE'
			WHEN 'N' THEN 'NUMERIC'
			WHEN 'E' THEN 'DROP_DOWN'
		END
	END

	RETURN(@l_controlType);
END
go

-- =============================================
-- Author:		Bognár Dávid
-- Create date: 2023.04.28.
-- Last modified date: 2023.04.28.
-- Description:	Return CompanyEntityID
-- =============================================
CREATE   FUNCTION [GEN].[GetCouncilEntityID] 
(
	-- Add the parameters for the function here
	@p_personEntityID NUMERIC(16)
)
RETURNS NVARCHAR(500)
AS
BEGIN
	-- Declare the return variable here
	DECLARE @l_result NVARCHAR(500) = NULL;

	-- Add the T-SQL statements to compute the return value here
	IF COALESCE(@p_personEntityID, 0) > 0 
	BEGIN
		SELECT @l_result =  
			 PRT.Company.EntityID from PRT.Entity

LEFT JOIN PRT.Address ent_cim on ent_cim.EntityID=PRT.Entity.ID

LEFT JOIN PRT.Company on ent_cim.Settlement COLLATE Latin1_general_CI_AI =REPLACE(PRT.Company.Name,'Polgármesteri hivatal ','') COLLATE Latin1_general_CI_AI AND LegalFormCode='LEGAL_FORM_39'
LEFT JOIN PRT.Address ceg_cim on ceg_cim.EntityID=PRT.Company.EntityID
WHERE ent_cim.AddressType='ADDRESS_TYPE_PERSON_PERMANENT' AND ent_cim.StatusCode='STATUS_NORMAL'
AND ceg_cim.District=ent_cim.District

AND PRT.Entity.ID=@p_personEntityID;
	END;

	-- Return the result of the function
	RETURN coalesce(@l_result,0);

END
go

CREATE FUNCTION [PRT].[GetCrefoName](
  @p_CrefoID numeric(16),
  @p_LanguageID numeric(16),
  @p_ShowStatisticalNr nvarchar(1) = 'F',
  @p_ShortNameFirst nvarchar(1) = 'F',
  @p_JustPersonSearch nvarchar(1) = 'F')
returns nvarchar(250)
/***********************************
* Administrator: Dávid Bognár      *
*  Created:      2022.11.15        *
*  Last revised: 2022.11.15        *
************************************
*
*
*********************************************************************
* Returns a formatted crefo name string.                            *
*                                                                   *
* p_CrefoID     Crefo number of the person / company                *
* p_LanguageID  Language identifier. If it is 9 (Hungarian), then   *
*               the name order is 1. last name 2. first name,       *
*               otherwise 1. first name 2. last name                *
*                                                                   *
* Example:                                                          *
*          select GetCrefoName(9310000434, 1)                       *
*          returns                                                  *
*          Géza Kovács                                              *
*                                                                   *
********************************************************************/
begin
  --declare @err_notfound exception for sqlstate value '02000';
  declare @m_result nvarchar(250);
  declare @m_NameHU nvarchar(250);
  declare @m_Name nvarchar(250);
  /* declare @c_companystat dynamic scroll cursor for 
    select if coalesce(trim(statisticalnr),'') = '' then
        coalesce( if p_ShortNameFirst = 'T' then (SELECT first Name.Name FROM CIS.Name WHERE Name.CrefoID = p_CrefoID and NameType = 'STL' and (COALESCE(Name.Status,'N')= 'N') order by Name.id desc) else null endif, Company.Name)
      else
        coalesce( if p_ShortNameFirst = 'T' then (SELECT first Name.Name FROM CIS.Name WHERE Name.CrefoID = p_CrefoID and NameType = 'STL' and (COALESCE(Name.Status,'N')= 'N') order by Name.id desc) else null endif, Company.Name) || ' (' || (select CIS.Translate('Statistical number',2,p_LanguageID)) || ': ' || StatisticalNr || ')'
      endif 
	from
      CIS.Company 
	where ID = p_CrefoID;
  declare c_company dynamic scroll cursor for 
    select coalesce( if p_ShortNameFirst = 'T' then (SELECT first Name.Name FROM CIS.Name WHERE Name.CrefoID = p_CrefoID and NameType = 'STL' and (COALESCE(Name.Status,'N')= 'N') order by Name.id desc) else null endif, Company.Name) Name from CIS.Company where ID = p_CrefoID;
  */
  
  declare c_person scroll cursor for 
    select CAST(TRIM(concat(Title,' ',LastName, ' ', FirstName)) as nvarchar(250)) as NameHU,
	       CAST(TRIM(concat(Title,' ',FirstName,' ', LastName)) as nvarchar(250)) as Name 
	from
      PRT.Person 
	where EntityID = @p_CrefoID;
	
    if @p_JustPersonSearch = 'T' 
		open c_person;
		fetch next from c_person into @m_NameHU,@m_Name;
		if @p_LanguageID = 9 
			set @m_Result=@m_NameHU
		else
			set @m_Result=@m_Name
		--close c_person
	/* else  	
	
		if p_ShowStatisticalNr = 'T' then
			open c_companystat;
			fetch next c_companystat into m_result
		else
			open c_company;
			fetch next c_company into m_result
		end if;
		if sqlstate = err_notfound then
			open c_person;
			fetch next c_person into m_NameHU,m_Name;
			if p_LanguageID = 9 then
				set m_Result=m_NameHU
			else
				set m_Result=m_Name
			end if;
			close c_person
		end if;
		if p_ShowStatisticalNr = 'T' then
			close c_companystat
		else
			close c_company
		end if;
	end if;	*/
  return @m_result
end
go

/*Author: Gyenese Katalin
  Create date: 2023.11.15. - DV-1260
  Last modified date: 2023.11.15.
  Description: Converts the given UTC datetimeString to datetime

  Parameters:
    - @utcDateTimeString: datetime in UTC format (eg.: 2023-08-24T22:00:00.000+00:00)
    - @timeZone: the name of the timezone (Central Europe Standard Time if null)
*/

create   function [GEN].[GetDateTimeFromUTC](@utcDateTimeString NVarChar(200), @timeZone NVarChar(200) = null)
returns DateTime
as
begin
  
  if @timeZone is null
     set @timeZone = 'Central Europe Standard Time'

  return Cast(CONVERT(datetimeoffset, @utcDateTimeString, 127) AT TIME ZONE @timeZone as DateTime)
end
go

-- =============================================
-- Author:		Aranyi Balázs
-- Create date: 2023.04.12.
-- Last modified date: 2023.04.12.
-- Description:	Return name of debt case. 
-- =============================================
CREATE   FUNCTION [DCS].[GetDebtCaseName] 
(
	-- Add the parameters for the function here
	@p_debtCaseID NUMERIC(16)
)
RETURNS NVARCHAR(500)
AS
BEGIN
	-- Declare the return variable here
	DECLARE @l_result NVARCHAR(500) = NULL;

	-- Add the T-SQL statements to compute the return value here
	IF COALESCE(@p_debtCaseID, 0) > 0 
	BEGIN
		SELECT @l_result = CAST([DebtCase].[DebtNr] + ' ' + 
			(SELECT [PRT].[GetEntityName]([Debtor].[EntityID]) + ' (' + [GEN].[TranslateCode]([Debtor].[RoleCode], 'HU') + ')' 
			 FROM [DCS].[Debtor] 
			 WHERE [Debtor].[ID] = [DebtCase].[MainDebtorID]) AS NVARCHAR(500))
		FROM [DCS].[DebtCase] 
		WHERE [DebtCase].[ID] = @p_debtCaseID;
	END;

	-- Return the result of the function
	RETURN @l_result;

END
go

-- =============================================
-- Author:		Aranyi Balázs
-- Create date: 2023.04.12.
-- Last modified date: 2023.04.12.
-- Description:	Return name of debt case. 
-- =============================================
CREATE   FUNCTION [DCS].[GetDebtorName] 
(
	-- Add the parameters for the function here
	@p_debtorID NUMERIC(16)
)
RETURNS NVARCHAR(500)
AS
BEGIN
	-- Declare the return variable here
	DECLARE @l_result NVARCHAR(500) = NULL;

	-- Add the T-SQL statements to compute the return value here
	IF COALESCE(@p_debtorID, 0) > 0 
	BEGIN
		SELECT @l_result =  
			[PRT].[GetEntityName]([Debtor].[EntityID]) 
			 FROM [DCS].[Debtor] 
		WHERE [Debtor].[ID] = @p_debtorID;
	END;

	-- Return the result of the function
	RETURN @l_result;

END
go

/*Author: Gyenese Katalin
  Create date: 2023.10.06. - DV-1524
  Last modified date: 2023.10.06.
  Description: Returns the contact data of an Entity with the given contactType (which is valid for the given date)

  Parameters:
    - @entityID: PRT.Entity.ID
    - @contactType: ContactType filter (PRT.Contact.ContactType)
    - @date: the date for the PRT.Contact.ValidFrom-ValidUntil filter (today if null)
*/

CREATE   function PRT.GetEntityContactData(@entityID Numeric(16), @contactType NVarChar(200), @date Date)
returns NVarChar(200)
as
begin
  if @date is null
     select @date = GetDate()

  return (select top 1 /*just in case*/ c.Contact
          from PRT.Contact c with(nolock)
          where c.EntityID = @entityID
              and c.StatusCode = 'STATUS_NORMAL'
              and c.ContactType = @contactType
              and IsNull(c.ValidFrom, @date) <= @date
              and @date <= ISNull(c.ValidUntil, @date)
          order by c.ID
         )
end
go

/*Author: Gyenese Katalin
  Create date: 2023.11.17 - DV-1750
  Description: Gets the EntityID based on the external ID received from the Inkasso

  Parameters:
    - @ExternalEntityID: the Inkasso entityID
*/
CREATE   function [IFC].[GetEntityIDByInkassoEntityID](@ExternalEntityID NVarChar(200))
returns Numeric(16)
as
begin
  declare @res Numeric(16)

  /*if @InkassoEntityID is not a number, it's our Entity.SourceID with SourceInterFaceType ECOLLECT; otherwise it's our Entity.ID*/
  if @ExternalEntityID like '%[^0-9]%' /*not a number*/
  begin
    /*top 1: just in case*/
    select top 1 @res = e.ID
    from PRT.Entity e
    where e.SourceInterfaceType = 'ECOLLECT'
      and e.SourceID = @ExternalEntityID
  end
  else
  begin
    select @res = e.ID
    from PRT.Entity e
    where e.ID = @ExternalEntityID  
  end

  return @res
end
go


/*Author: Gyenese Katalin
  Create date: 2023.10.09. - DV-1524
  Last modified date: 2023.10.09.
  Description: Returns the name of an Entity with the given nameType (which is valid for the given date)

  Parameters:
    - @entityID: PRT.Entity.ID
    - @nameTypeCode: NameTypeCode filter (PRT.Name.NameTypeCode)
    - @date: the date for the PRT.Name.ValidFrom-ValidUntil filter (today if null)
*/

CREATE   function PRT.GetEntityNameByType(@entityID Numeric(16), @nameTypeCode NVarChar(200), @date Date)
returns NVarChar(200)
as
begin
  if @date is null
     select @date = GetDate()

  return (select top 1 /*just in case*/ n.Name
          from PRT.Name n with(nolock)
          where n.EntityID = @entityID
            and n.StatusCode = 'STATUS_NORMAL'
            and n.NameTypeCode = @nameTypeCode
            and IsNull(n.ValidFrom, @date) <= @date
            and @date <= ISNull(n.ValidUntil, @date)
          order by n.ID 
         )
end
go

CREATE FUNCTION [FIN].[GetExchangeRate](
  @p_ExchangeRateSystemCode nvarchar(200),
  @p_ExchangeDate date,
  @p_SourceCurrencyCode nvarchar(200),
  @p_TargetCurrencyCode nvarchar(200))

returns numeric
/***********************************
* Administrator: Bognár Dávid      *
*  Created:      2022.11.16        *
*  Last revised: 2022.11.16        *
************************************
*
*
**********************************************************************
* Returns a formatted user name string.                              *
*                                                                    *
* p_CrefoID        ID of the user                                    *
* p_LanguageID     Language identifier. If it is 9 (Hungarian), then *
*                  the name order is 1. last name 2. first name,     *
*                  otherwise 1. first name 2. last name              *
* p_TitlePosition  -1 left, 0 none, 1 right                          *
* Example:                                                           *
*          select GetUserName('KOVACSG1', 1)                         *
*          returns                                                   *
*          Géza Kovács                                               *
*                                                                    *
*********************************************************************/
begin
  --declare @err_notfound exception for sqlstate value '02000';
  declare @m_result numeric;
 
  
  select @m_result=a.rate

	from FIN.ExchangeRate a
		
	where ExchangeRateSystemCode=@p_ExchangeRateSystemCode and
		  ExchangeDate=@p_ExchangeDate and
          SourceCurrencyCode=@p_SourceCurrencyCode and
		  TargetCurrencyCode=@p_TargetCurrencyCode;
        



  if @m_result is null
    set @m_Result='Nincs árfolyam'
  else
    set @m_Result=@m_Result

    return @m_result
end
go

-- =============================================
-- Author:		Bognár Dávid
-- Create date: 2023.12.11.
-- Last modified date:
-- Description:	
-- =============================================
CREATE FUNCTION [FIN].[GetFeeValue] 
(
	-- Add the parameters for the function here
	@p_DebtCaseObjectID NUMERIC(16),
	@p_SettingCode NVARCHAR(200)
)
RETURNS money
AS
BEGIN
	-- Declare the return variable here

DECLARE @l_result int;

IF @p_SettingCode='SETTING_FEE_INTEREST_ENTRY_CRITERIA'

select  @l_result=FeeRate from DCS.DebtCase dc
LEFT JOIN FIN.Calculation c on dc.MainCalculationID=c.ID
LEFT JOIN FIN.FeeList fl on fl.ID=c.FeeListID
LEFT JOIN FIN.Fee f on fl.ID=f.FeeListID
where dc.objectid=@p_DebtCaseObjectID
and f.Code='FEE_INTEREST'

IF @p_SettingCode='SETTING_FEE_SUM_ENTRY_CRITERIA'

select  @l_result=SUM(FeeRate) from DCS.DebtCase dc
LEFT JOIN FIN.Calculation c on dc.MainCalculationID=c.ID
LEFT JOIN FIN.FeeList fl on fl.ID=c.FeeListID
LEFT JOIN FIN.Fee f on fl.ID=f.FeeListID
where dc.objectid=@p_DebtCaseObjectID
and f.Code in ('FEE_INTEREST','FEE_PENALTY_INTEREST')


	-- Return the result of the function
	RETURN @l_result;

END
go

-- =============================================
-- Author:		T. Gábor
-- Create date: 2022-10-14
-- Description:	Get Fields ExtendedInformation
-- =============================================
CREATE PROCEDURE [GEN].[GetFieldsExtendedInformation] @iSchemaName nVarchar(500) = NULL
AS
BEGIN
	SELECT
		Cast(SCHEMA_NAME(tbl.schema_id) as Nvarchar(500)) AS SchemaName,	
		tbl.name AS TableName, 
		clmns.name AS ColumnName,
		p.name AS ExtendedPropertyName,
		CAST(p.value AS sql_variant) AS ExtendedPropertyValue
	FROM
		sys.tables AS tbl
		INNER JOIN sys.all_columns AS clmns ON clmns.object_id=tbl.object_id
		Left JOIN sys.extended_properties AS p ON p.major_id=tbl.object_id AND p.minor_id=clmns.column_id AND p.class=1
	Where Cast(SCHEMA_NAME(tbl.schema_id) as Nvarchar(500)) = Isnull(@iSchemaName, Cast(SCHEMA_NAME(tbl.schema_id) as Nvarchar(500)))
END
go

-- =============================================
-- Author:		Bognár Dávid
-- Create date: 2023.11.28.
-- Last modified date: 2023.04.12.
-- Description:	
-- =============================================
CREATE   FUNCTION [FIN].[GetInitialArrears] 
(
	-- Add the parameters for the function here
	@p_DebtCaseID NUMERIC(16)
)
RETURNS money
AS
BEGIN
	-- Declare the return variable here

DECLARE @l_result money;


select  @l_result=ac.Balance
from DCS.DebtCase dc join FIN.Calculation c on dc.MainCalculationID = c.ID
                     join FIN.Account ac on ac.CalculationID = c.ID
                     join FIN.AccountType t on ac.AccountTypeID = t.ID
where dc.Id = @p_DebtCaseID
  and t.Code = 'ACCOUNT_TYPE_DEBT_TOTAL_LOCAL_CURRENCY'



	-- Return the result of the function
	RETURN @l_result;

END
go

/*Author: Gyenese Katalin
  Create date: 2023.10.31. - DV-1524
  Last modified date: 2023.10.31.
  Description: Gets the external ID of the Entity which has to be sent to the Inkasso

  Parameters:
    - @entityID: the entityID
    - @sourceInterfaceType: the sourceInterfaceType
    - @sourceID: the sourceID
*/
CREATE   function IFC.GetInkassoExternalEntityID(@entityID Numeric(16), @sourceInterfaceType NVarChar(200), @sourceID NVarChar(200))
returns NVarChar(200)
as
begin
  /*Amennyiben a PRT.Entity.SourceInterfaceType értéke = 'ECOLLECT', akkor a PRT.Entity.SourceID, minden más esetben PRT.Entity.ID*/
  return (Case when @SourceInterfaceType = 'ECOLLECT' then @SourceID else Cast(@entityID as NVarChar(200)) end)
end



go

/*Author: Gyenese Katalin
  Create date: 2023.10.10. - DV-1524
  Last modified date: 2023.11.13.
  Description: Gets the InkassoRecordID for a recordID (based on MIG.InkassoMigrationMapping) from the last migration

  Parameters:
    - @inkassoTableName: the inkassoTableName of the record (MIG.InkassoMigrationMapping.InkassoTableName)
    - @tableName: the tableName of the inserted record
    - @recordID: the recordID (in Indecs)
*/
CREATE   function GEN.GetInkassoRecordID(@inkassoTableName NVarChar(250), @tableName NVarChar(250), @recordID Numeric(16))
returns Numeric(16)
as
begin
  return (select top 1 imm.InkassoRecordID
          from MIG.InkassoMigrationMapping imm
          where imm.InkassoTableName = @inkassoTableName
            and imm.TableName = @tableName
            and imm.RecordID = @recordID
          order by imm.ID desc
         )
end
go

CREATE   function [GEN].[GetMappedValue](@direction int, @mappingCode NVarChar(200), @sourceCode NVarChar(200), @valueSetCode NVarChar(200), @date Date)
returns NVarChar(200)
as
begin
  declare @res  NVarChar(200)

  if @date is null
     set @date = GetDate()

  if @direction = 1 /* get ExternalCode based on Indecs code*/
  begin
    select top 1 @res = c.ExternalCode
    from IFC.Mapping m join IFC.MappingCode c on m.ID = c.MappingID
    where m.MappingCode = @mappingCode
      and c.Code = @sourceCode
      and IsNull(c.ValuesetCode, '') = IsNull(@valueSetCode, '')
      and IsNull(c.ValidFrom, @date) <= @date
      and @date <= IsNull(c.ValidUntil, @date)
  end
  else if @direction = 2 /* get Indecs code based on ExternalCode*/
  begin
    select top 1 @res = c.Code
    from IFC.Mapping m join IFC.MappingCode c on m.ID = c.MappingID
    where m.MappingCode = @mappingCode
      and c.ExternalCode = @sourceCode
      and IsNull(c.ValuesetCode, '') = IsNull(@valueSetCode, '')
      and IsNull(c.ValidFrom, @date) <= @date
      and @date <= IsNull(c.ValidUntil, @date)
  end

  return @res
end
go

/*Author: Gyenese Katalin
  Create date: 2023.10.06. - DV-1524
  Last modified date: 2023.10.06.
  Description: Gets the mapped Inkasso value based on the IFC.Mapping and IFC.MappingCode tables.

  Parameters:
    - @direction: 1 = get Inkasso code based on Indecs code
                  2 = get Indecs code based on Inkasso code 
    - @sourceCode: Indecs code / Inkasso code (based on the direction)
    - @valueSetCode: IFC.MappingCode.ValuesetCode
    - @date: the date for the IFC.MappingCode.ValidFrom-ValidUntil filter (today if null)
*/

CREATE   function [IFC].[GetMappedValueInkasso](@direction int, @sourceCode NVarChar(200), @valueSetCode NVarChar(200), @date Date)
returns NVarChar(200)
as
begin
  declare @res NVarChar(200)

  select @res = GEN.GetMappedValue(@direction, 'MAPPING_INKASSO', @sourceCode, @valueSetCode, @date)

  return @res
end
go

-- =============================================
-- Author:		Aranyi Balázs
-- Create date: 2023.02.16.
-- Last modified date: 2023.03.07.
-- Description:	Returns with the next value of the sequence specified in the parameter. 
-- =============================================
CREATE PROCEDURE [GEN].[GetNextSequenceValue] 
(	
	-- Add the parameters for the stored procedure here
	@p_sequenceCode NVARCHAR(200),
	@p_result NVARCHAR(200) OUTPUT
)
AS
BEGIN
	SET NOCOUNT ON;
	-- Declare the return variable here
	DECLARE @l_result NVARCHAR(200) = NULL;
	-- További változók
	DECLARE @l_sequenceID NUMERIC(16) = NULL;
	DECLARE @l_sequenceValueID NUMERIC(16) = NULL;
	DECLARE @l_sequenceMask NVARCHAR(200) = NULL;
	DECLARE @l_sequenceNextValue INT = 0;
	DECLARE @l_sequenceMaskValue NVARCHAR(MAX) = NULL;
	DECLARE @l_zeroPrefix NVARCHAR(50) = '00000';
	DECLARE @l_sql NVARCHAR(MAX) = NULL;
	DECLARE @l_sequenceName NVARCHAR(200) = NULL;
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_errorMsg NVARCHAR(MAX) = ''; --Hiba üzenetek tárolása, kezelése miatt

	--Feldolgozás kezdete
	BEGIN TRY
		IF COALESCE(@p_sequenceCode, '') = '' 
			RAISERROR('The p_sequenceCode parameter is not defined!', 16, 1);

		SELECT 
			@l_sequenceID = [Sequence].[ID],
			@l_sequenceMask = [Sequence].[MaskValue],
			@l_sequenceName = [Sequence].[SequenceName]
		FROM [GEN].[Sequence] 
		WHERE [Sequence].[Code] = @p_sequenceCode;

		PRINT CONCAT('ID: ', @l_sequenceID);
		PRINT CONCAT('Mask: ', @l_sequenceMask);
		PRINT CONCAT('Name: ', @l_sequenceName);

		SELECT 
			@l_sequenceValueID = [SequenceValue].[ID]
		FROM [GEN].[SequenceValue] 
		WHERE [SequenceValue].[SequenceID] = @l_sequenceID
		AND COALESCE([SequenceValue].[ValidFrom], CAST(GETDATE() AS Date)) <= CAST(GETDATE() AS Date) 
		AND COALESCE([SequenceValue].[ValidUntil], CAST(GETDATE() AS Date)) >= CAST(GETDATE() AS Date);

		PRINT CONCAT('Value ID: ', @l_sequenceValueID);

		SELECT @l_sql = 
			N'UPDATE [GEN].[SequenceValue] SET [Value] = NEXT VALUE FOR ' + @l_sequenceName + ' WHERE [SequenceValue].[ID] = ' + 
				CAST(@l_sequenceValueID AS NVARCHAR(16));
		PRINT @l_sql;

		EXEC sp_executesql @l_sql;

		SELECT @l_sequenceNextValue = [SequenceValue].[Value] 
		FROM [GEN].[SequenceValue] 
		WHERE [SequenceValue].[ID] = @l_sequenceValueID;

		PRINT CONCAT('Value: ', @l_sequenceNextValue);

		DECLARE sequenceMask_cursor CURSOR FOR
		SELECT CAST(value AS NVARCHAR(MAX)) 
		FROM string_split(@l_sequenceMask, '/');

		OPEN sequenceMask_cursor;
		FETCH NEXT FROM sequenceMask_cursor
		INTO 
			@l_sequenceMaskValue;

		WHILE @@FETCH_STATUS = 0 
		BEGIN
			IF COALESCE(@l_sequenceMaskValue, '') = '#YYYY'
				SELECT @l_result = CONCAT(@l_result, CAST(DATEPART(year, CAST(GETDATE() AS Date)) AS NVARCHAR(4)), '/')
			ELSE IF COALESCE(@l_sequenceMaskValue, '') = '#YY'
				SELECT @l_result = CONCAT(@l_result, RIGHT(CAST(DATEPART(year, CAST(GETDATE() AS Date)) AS NVARCHAR(4)), 2), '/')
			ELSE IF COALESCE(@l_sequenceMaskValue, '') = '#N'
				SELECT @l_result = CONCAT(@l_result, @l_sequenceNextValue, '/')
			ELSE IF COALESCE(@l_sequenceMaskValue, '') LIKE '#N_%'
				SELECT @l_result = CONCAT(@l_result, LEFT(@l_zeroPrefix, LEN(@l_zeroPrefix) - LEN(CAST(@l_sequenceNextValue AS NVARCHAR(16)))), CAST(@l_sequenceNextValue AS NVARCHAR(16)), '/')
			ELSE 
				SELECT @l_result = CONCAT(@l_result, @l_sequenceMaskValue, '/');

			FETCH NEXT FROM sequenceMask_cursor
			INTO 
				@l_sequenceMaskValue;
		END

		CLOSE sequenceMask_cursor;
		DEALLOCATE sequenceMask_cursor;

		IF RIGHT(@l_result, 1) = '/'
			SELECT @l_result = LEFT(@l_result, LEN(@l_result) - 1);

		SELECT @p_result = @l_result;
		PRINT @l_result;

		RETURN 1;
	END TRY
	BEGIN CATCH
		SELECT @p_result = NULL;

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'sequenceMask_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE sequenceMask_cursor;

			DEALLOCATE sequenceMask_cursor;
		END;

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());
		PRINT @l_errorMsg;

		RETURN 99;
	END CATCH
END
go

/*Author: Gyenese Katalin
  Create date: 2023.10.09. - DV-1524
  Last modified date: 2023.10.09.
  Description: Returns the identifier of an Object with the given identifierType (which is valid for the given date)

  Parameters:
    - @objectID: GEN.Object.ID
    - @identifierTypeCode: IdentifierTypeCode filter (GEN.ObjectIdentifier.IdentifierTypeCode)
    - @date: the date for the GEN.ObjectIdentifier.ValidFrom-ValidUntil filter (today if null)
*/

CREATE   function GEN.GetObjectIdentifierByType(@objectID Numeric(16), @identifierTypeCode NVarChar(200), @date Date)
returns NVarChar(200)
as
begin
  if @date is null
     select @date = GetDate()

  return (select top 1 /*just in case*/ oi.Identifier
          from GEN.ObjectIdentifier oi with(nolock)
          where oi.ReferencedObjectID = @objectID
            and oi.StatusCode = 'STATUS_NORMAL'
            and oi.IdentifierTypeCode = @identifierTypeCode
            and IsNull(oi.ValidFrom, @date) <= @date
            and @date <= ISNull(oi.ValidUntil, @date)
          order by oi.ID 
         )
end
go


-- =============================================
-- Author:		Aranyi Balázs
-- Create date: 2023.04.12.
-- Last modified date: 2023.04.12.
-- Description:	Return name of object. 
-- =============================================
CREATE FUNCTION [GEN].[GetObjectType] 
(
	-- Add the parameters for the function here
	@p_objectID NUMERIC(16)
)
RETURNS NVARCHAR(500)
AS
BEGIN
	-- Declare the return variable here
	DECLARE @l_result NVARCHAR(500) = NULL;
	DECLARE @l_objectTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_objectReferenceID NVARCHAR(200) = NULL;

	set @l_result=(
select 
case when GEN.Object.ObjectType='OBJECT_TYPE_PRT_ENTITY' AND PRT.Entity.EntityType='C' then 'OBJECT_TYPE_PRT_COMPANY'
     when GEN.Object.ObjectType='OBJECT_TYPE_PRT_ENTITY' AND PRT.Entity.EntityType='P' then 'OBJECT_TYPE_PRT_PERSON'
	 else GEN.Object.ObjectType end ObjectType
from GEN.Object
left join PRT.Entity on PRT.Entity.ObjectID=GEN.Object.ID
where GEN.Object.ID=@p_objectID);


	-- Return the result of the function
	RETURN @l_result;

END
go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2022-11-22
-- Last modified date: 2022-11-22
-- Description:	Return the value set.
-- =============================================
CREATE   FUNCTION [GEN].[GetValueSet] (
	-- Add the parameters for the function here 
	@p_valueSetID NUMERIC(16),
	@p_language NVARCHAR(5) = 'HU'
)
RETURNS @valueSet TABLE (
	CodeID NVARCHAR(200),
	Text NVARCHAR(200))
AS
BEGIN
	DECLARE @l_dataType NVARCHAR(20) = NULL;
	
	IF COALESCE(@p_valueSetID, 0) > 0 
	BEGIN
		SELECT @l_dataType = [ValueSet].[DataType] 
		FROM [GEN].[ValueSet] 
		WHERE [ValueSet].[ID] = @p_valueSetID;
		
		IF COALESCE(@l_dataType, '') = 'E'
			INSERT INTO @valueSet
			SELECT 
				[Translation].[CodeID],
				[Translation].[Text] 
			FROM [GEN].[Translation] 
			JOIN [GEN].[Code] ON ([Code].[ID] = [Translation].[CodeID])
			WHERE [Code].[ValueSetID] = @p_valueSetID 
			AND [Translation].[Language] = @p_language;
	END

	RETURN;
END
go

/*Author: Gyenese Katalin
  Create date: 2023.11.10. - DV-1636
  Last modified date: 2023.11.10.
  Description: it refreshes the missing mappings on a InkassoSyncSend... record.
               if the mapping is still missing, it generates a Notification

  Parameters:
    - @syncType: the type of the synchronization: Company/Person/Address/Phone/Event/DebtCase/Debtor/Asset/ConstructionCode (no logic for: Document)
    - @taskID: the ID of the task
    - @correlationID: the correlationID of the caller
    - @userName: the userName of the caller
*/
CREATE     procedure [IFC].[HandleSendInkassoSyncMappings](@syncType NVarChar(200), @taskID Numeric(16), @correlationID NVarChar(200), @userName NVarChar(200))
as
begin
  set NOCOUNT ON
  set XACT_ABORT ON

  
  /*variables for logging*/
	declare @procedureName nvarchar(100) = 'IFC.RefreshSendInkassoSyncMappings', @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for the proConstructionCodecedure logic*/
          
  declare @syncRecordID Numeric(16), @statusCode NVarChar(200), @InkStatusCode NVarChar(200), @currencyCode NVarChar(200), @InkCurrencyCode NVarChar(200),
          /*Company*/
          @legalFormCode NVarChar(200), @InkLegalFormCode NVarChar(200), @InkCompanyFormCode NVarChar(200),
          /*Person*/
          @nationalityCode NVarChar(200), @InkNationalityCode NVarChar(200), @deceasedCode NVarChar(200), @InkDeceasedCode NVarChar(200),
          /*Address*/
          @mailingAddressCode NVarChar(200), @InkMailingAddressCode NVarChar(200),
          @countryCode NVarChar(200), @InkCountryCode NVarChar(200) /*+ StatusCode*/,
          /*Phone*/
          @dataOrigin NVarChar(200), @InkDataOrigin NVarChar(200) /*+ StatusCode*/, @contactType NVarChar(200), @InkContactType NVarChar(200), 
          /*Event*/
          @eventTypeCode NVarChar(200), @InkEventTypeCode NVarChar(200),
          /*DebtCase*/
          @departmentTypeCode NVarChar(200), @InkDepartmentTypeCode NVarChar(200),
          @contractTypeCode NVarChar(200), @InkContractTypeCode NVarChar(200), @creditTypeCode NVarChar(200), @InkCreditTypeCode NVarChar(200),
          @contractDataOriginCode NVarChar(200), @InkContractDataOriginCode NVarChar(200) /*+CurrencyCode*/,
          @sourceSystemID NVarchar(200), @InkSourceSystemID NVarchar(200),
          /*Debtor*/
          @roleCode NVarChar(200), @InkRoleCode NVarChar(200),
          /*Asset*/
          @assetTypeCode NVarChar(200), @InkAssetTypeCode NVarChar(200), @assetNatureCode NVarChar(200), @InkAssetNatureCode NVarChar(200) /*+StatusCode*/,
          /*ConstructionCode*/
          @ConsolidatedProductCode NVarChar(200), @InkConsolidatedProductID NVarChar(200) /*+CurrencyCode*/

  begin try 
    if @syncType = 'Company'
    begin
      /*LegalFormCode --> InkCompanyFormCode, InkLegalFormCode*/
      select @syncRecordID = c.ID,
             @legalFormCode = c.LegalFormCode, @InkLegalFormCode = c.InkLegalFormCode, @InkCompanyFormCode = c.InkCompanyFormCode
      from IFC.InkassoSyncSendCompany c join IFC.IndecsInkassoSync s on c.IndecsInkassoSyncID = s.ID
	    where s.TaskID = @taskID 
  
      
      if @legalFormCode is not null and (@InkLegalFormCode is null or @InkCompanyFormCode is null)
      begin
        if @InkCompanyFormCode is null /*missing CompanyFormCode (the legal form code in Indecs = the company form code in Inkasso*/
        begin
          select @InkCompanyFormCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @legalFormCode, 'VALUESET_LEGAL_FORM', null /*@date*/)
          if @InkCompanyFormCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for Inkasso CompanyFormCode (Indecs LegalFormCode: ',  @legalFormCode, ', ValueSet: VALUESET_LEGAL_FORM.) ')
          end
        end
        if @InkLegalFormCode is null /*missing Inkasso LegalFormCode (the Inkasso Legal form is a shorter list than the Indecs Legal form)*/
        begin
          select @InkLegalFormCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @legalFormCode, 'VALUESET_INKASSO_LEGAL_FORM', null /*@date*/)

          if @InkLegalFormCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for Inkasso LegalFormCode (Indecs LegalFormCode: ',  @legalFormCode, ', ValueSet: VALUESET_INKASSO_LEGAL_FORM.) ')
          end
        end
        

        if IsNull(@errorMessage, '') = ''
        begin
          update IFC.InkassoSyncSendCompany
          set InkLegalFormCode = IsNull(InkLegalFormCode, @InkLegalFormCode),
              InkCompanyFormCode = IsNull(InkCompanyFormCode, @InkCompanyFormCode),   
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @userName
          where ID = @syncRecordID
        end
      end
    end
    else if @syncType = 'Person'
    begin
      /*NationalityCode, DeceasedCode*/
      select @syncRecordID = p.ID,
             @nationalityCode = p.NationalityCode, @InkNationalityCode = p.InkNationalityCode,
             @deceasedCode = p.DeceasedCode, @InkDeceasedCode = p.InkDeceasedCode
      from IFC.InkassoSyncSendPerson p join IFC.IndecsInkassoSync s on p.IndecsInkassoSyncID = s.ID
	    where s.TaskID = @taskID 
        
      
      if    @nationalityCode is not null and @InkNationalityCode is null
         or @deceasedCode is not null and @InkDeceasedCode is null
      begin
        if @nationalityCode is not null and @InkNationalityCode is null /*missing NationalityCode*/
        begin
          select @InkNationalityCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @nationalityCode, 'VALUESET_NATIONALITY', null /*@date*/)

          if @InkNationalityCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for NationalityCode (Indecs NationalityCode: ',  @nationalityCode, ', ValueSet: VALUESET_NATIONALITY.) ')
          end
        end
        if @deceasedCode is not null and @InkDeceasedCode is null /*missing DeceasedCode*/
        begin
          select @InkDeceasedCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @deceasedCode, 'VALUESET_BOOLEAN', null /*@date*/)

          if @InkDeceasedCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for DeceasedCode (Indecs DeceasedCode: ',  @deceasedCode, ', ValueSet: VALUESET_BOOLEAN.) ')
          end
        end

        if IsNull(@errorMessage, '') = ''
        begin
          update InkassoSyncSendPerson
          set InkNationalityCode = IsNull(InkNationalityCode, @InkNationalityCode),
              InkDeceasedCode = IsNull(InkDeceasedCode, @InkDeceasedCode),   
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @userName
          where ID = @syncRecordID
        end
      end
    end
    else if @syncType = 'Address'
    begin
      /*StatusCode, MailingAddressCode, CountryCode*/
      select @syncRecordID = a.ID,
             @statusCode = a.StatusCode, @InkStatusCode = a.InkStatusCode, @mailingAddressCode = a.MailingAddressCode, @InkMailingAddressCode = a.InkMailingAddressCode, 
             @countryCode = a.CountryCode, @InkCountryCode = a.InkCountryCode
      from IFC.InkassoSyncSendAddress a join IFC.IndecsInkassoSync s on a.IndecsInkassoSyncID = s.ID
	    where s.TaskID = @taskID 
        
      if    @statusCode is not null and @InkStatusCode is null
         or @mailingAddressCode is not null and @InkMailingAddressCode is null
         or @countryCode is not null and @InkCountryCode is null
      begin
        if @statusCode is not null and @InkStatusCode is null /*missing StatusCode*/
        begin
          select @InkStatusCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @statusCode, 'VALUESET_STATUS', null /*@date*/)

          if @InkStatusCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for StatusCode (Indecs StatusCode: ',  @statusCode, ', ValueSet: VALUESET_STATUS.) ')
          end
        end
        if @mailingAddressCode is not null and @InkMailingAddressCode is null /*missing MailingAddressCode*/
        begin
          select @InkMailingAddressCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @mailingAddressCode, 'VALUESET_BOOLEAN', null /*@date*/)

          if @InkMailingAddressCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for MailingAddressCode (Indecs MailingAddressCode: ',  @mailingAddressCode, ', ValueSet: VALUESET_BOOLEAN.) ')
          end
        end
        if @countryCode is not null and @InkCountryCode is null /*missing CountryCode*/
        begin
          select @InkCountryCode = c.Alpha2Code
          from GEN.Country c
          where c.CountryCode = @countryCode

          if @InkCountryCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing Alpha2Code in GEN.Country (CountryCode: ',  @countryCode, '.) ')
          end
        end


        if IsNull(@errorMessage, '') = ''
        begin
          update InkassoSyncSendAddress
          set InkStatusCode = IsNull(InkStatusCode, @InkStatusCode),
              InkMailingAddressCode = IsNull(InkMailingAddressCode, @InkMailingAddressCode),   
              InkCountryCode = IsNull(InkCountryCode, @InkCountryCode),   
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @userName
          where ID = @syncRecordID
        end
      end
    end
    else if @syncType = 'Phone'
    begin
      /*StatusCode, DataOriginCode, ContactType*/
      select @syncRecordID = p.ID,
             @statusCode = p.StatusCode, @InkStatusCode = p.InkStatusCode,
             @dataOrigin = p.DataOriginCode, @InkDataOrigin = p.InkDataOriginCode,
             @contactType = p.ContactTypeCode, @InkContactType = p.InkContactTypeCode
      from IFC.InkassoSyncSendPhone p join IFC.IndecsInkassoSync s on p.IndecsInkassoSyncID = s.ID
	    where s.TaskID = @taskID 
        
      
      if    @statusCode is not null and @InkStatusCode is null
         or @dataOrigin is not null and @InkDataOrigin is null
         or @contactType is not null and @InkContactType is null
      begin
        if @statusCode is not null and @InkStatusCode is null /*missing StatusCode*/
        begin
          select @InkStatusCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @statusCode, 'VALUESET_PHONE_STATUS', null /*@date*/)

          if @InkStatusCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for StatusCode (Indecs StatusCode: ',  @statusCode, ', ValueSet: VALUESET_PHONE_STATUS.) ')
          end
        end
        if @dataOrigin is not null and @InkDataOrigin is null /*missing DataOrigin*/
        begin
          select @InkDataOrigin = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @dataOrigin, 'VALUESET_DATA_ORIGIN', null /*@date*/)

          if @InkDataOrigin is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for DataOrigin (Indecs DataOrigin: ',  @dataOrigin, ', ValueSet: VALUESET_DATA_ORIGIN.) ')
          end
        end
        if @contactType is not null and @InkContactType is null /*missing ContactType*/
        begin
          select @InkContactType = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @contactType, 'VALUESET_CONTACT_TYPE', null /*@date*/)

          if @InkContactType is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for ContactType (Indecs ContactType: ',  @contactType, ', ValueSet: VALUESET_CONTACT_TYPE.) ')
          end
        end

        if IsNull(@errorMessage, '') = ''
        begin
          update InkassoSyncSendPhone
          set InkStatusCode = IsNull(InkStatusCode, @InkStatusCode),
              InkDataOriginCode = IsNull(InkDataOriginCode, @InkDataOrigin),   
              InkContactTypeCode = IsNull(InkContactTypeCode, @InkContactType),   
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @userName
          where ID = @syncRecordID
        end
      end
    end
    else if @syncType = 'Event'
    begin
      /*EventTypeCode*/
      select @syncRecordID = e.ID,
             @eventTypeCode = e.EventTypeCode, @InkEventTypeCode= e.InkEventTypeCode
      from IFC.InkassoSyncSendEvent e join IFC.IndecsInkassoSync s on e.IndecsInkassoSyncID = s.ID
	    where s.TaskID = @taskID 
        
      
      if @eventTypeCode is not null and @InkEventTypeCode is null /*missing EventTypeCoder*/
      begin
        select @InkEventTypeCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @eventTypeCode, 'VALUESET_EVENT_TYPE', null /*@date*/)

        if @InkEventTypeCode is null
        begin
          select @errorMessage = Concat(@errorMessage, 'Missing mapping for EventTypeCode (Indecs EventTypeCode: ',  @eventTypeCode, ', ValueSet: VALUESET_EVENT_TYPE.) ')
        end
        
        if IsNull(@errorMessage, '') = ''
        begin
          update IFC.InkassoSyncSendEvent
          set InkEventTypeCode = @InkEventTypeCode,
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @userName
          where ID = @syncRecordID
        end
      end
    end
    else if @syncType = 'DebtCase'
    begin
      /*CurrencyCode, DepartmentTypeCode, ContractTypeCode, CreditTypeCode, ContractDataOriginCode, SourceSystemID*/
      select @syncRecordID = d.ID,
             @currencyCode = d.CurrencyCode, @InkCurrencyCode = d.InkCurrencyCode, @departmentTypeCode = d.DepartmentTypeCode, @InkDepartmentTypeCode = d.InkDepartmentTypeCode,
             @contractTypeCode = d.ContractTypeCode, @InkContractTypeCode = d.InkContractTypeCode, @creditTypeCode = d.CreditTypeCode, @InkCreditTypeCode = d.InkCreditTypeCode,
             @contractDataOriginCode = d.ContractDataOriginCode, @InkContractDataOriginCode = d.InkContractDataOriginCode,
             @sourceSystemID = d.SourceSystemID, @InkSourceSystemID = d.InkSourceSystemID
      from IFC.InkassoSyncSendDebtCase d join IFC.IndecsInkassoSync s on d.IndecsInkassoSyncID = s.ID
	    where s.TaskID = @taskID 
        
      if    @currencyCode is not null and @InkCurrencyCode is null
         or @departmentTypeCode is not null and @InkDepartmentTypeCode is null
         or @contractTypeCode is not null and @InkContractTypeCode is null
         or @creditTypeCode is not null and @InkCreditTypeCode is null
         or @contractDataOriginCode is not null and @InkContractDataOriginCode is null
         or @sourceSystemID is not null and @InkSourceSystemID is null
      begin
        if @currencyCode is not null and @InkCurrencyCode is null /*missing CurrencyCode*/
        begin
          select @InkCurrencyCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @currencyCode, 'VALUESET_CURRENCY', null /*@date*/)

          if @InkCurrencyCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for CurrencyCode (Indecs CurrencyCode: ',  @currencyCode, ', ValueSet: VALUESET_CURRENCY.) ')
          end
        end
        if @departmentTypeCode is not null and @InkDepartmentTypeCode is null /*missing DepartmentTypeCode*/
        begin
          select @InkDepartmentTypeCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @departmentTypeCode, 'VALUESET_DEPARTMENT_TYPE', null /*@date*/)

          if @InkDepartmentTypeCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for DepartmentTypeCode (Indecs DepartmentTypeCode: ',  @departmentTypeCode, ', ValueSet: VALUESET_DEPARTMENT_TYPE.) ')
          end
        end
        if @contractTypeCode is not null and @InkContractTypeCode is null /*missing ContractTypeCode*/
        begin
          select @InkContractTypeCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @contractTypeCode, 'VALUESET_CONTRACT_TYPE', null /*@date*/)

          if @InkContractTypeCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for ContractTypeCode (Indecs ContractTypeCode: ',  @contractTypeCode, ', ValueSet: VALUESET_CONTRACT_TYPE.) ')
          end
        end
        if @creditTypeCode is not null and @InkCreditTypeCode is null /*missing CreditTypeCode*/
        begin
          select @InkCreditTypeCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @creditTypeCode, 'VALUESET_CREDIT_TYPE', null /*@date*/)

          if @InkCreditTypeCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for CreditTypeCode (Indecs CreditTypeCode: ',  @creditTypeCode, ', ValueSet: VALUESET_CREDIT_TYPE.) ')
          end
        end
        if @contractDataOriginCode is not null and @InkContractDataOriginCode is null /*missing ContractDataOriginCode*/
        begin
          select @InkContractDataOriginCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @contractDataOriginCode, 'VALUESET_DATA_ORIGIN', null /*@date*/)

          if @InkContractDataOriginCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for ContractDataOriginCode (Indecs ContractDataOriginCode: ',  @contractDataOriginCode, ', ValueSet: VALUESET_DATA_ORIGIN.) ')
          end
        end
        if @sourceSystemID is not null and @InkSourceSystemID is null /*missing SourceSystemID*/
        begin
          select @InkSourceSystemID = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @sourceSystemID, 'VALUESET_ACCOUNTING_SYSTEM', null /*@date*/)

          if @InkSourceSystemID is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for SourceSystemID (Indecs SourceSystemID: ',  @sourceSystemID, ', ValueSet: VALUESET_ACCOUNTING_SYSTEM.) ')
          end
        end
        

        if IsNull(@errorMessage, '') = ''
        begin
          update InkassoSyncSendDebtCase
          set InkCurrencyCode = IsNull(InkCurrencyCode, @InkCurrencyCode),
              InkDepartmentTypeCode = IsNull(InkDepartmentTypeCode, @InkDepartmentTypeCode),   
              InkContractTypeCode = IsNull(InkContractTypeCode, @InkContractTypeCode),
              InkCreditTypeCode = IsNull(InkCreditTypeCode, @InkCreditTypeCode),   
              InkContractDataOriginCode = IsNull(InkContractDataOriginCode, @InkContractDataOriginCode),   
              InkSourceSystemID = IsNull(InkSourceSystemID, @InkSourceSystemID),   
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @userName
          where ID = @syncRecordID
        end
      end
    end
    else if @syncType = 'Debtor'
    begin
      /*RoleCode*/
      select @syncRecordID = d.ID,
             @roleCode = d.RoleCode, @InkRoleCode= d.InkRoleCode
      from IFC.InkassoSyncSendDebtor d join IFC.IndecsInkassoSync s on d.IndecsInkassoSyncID = s.ID
	    where s.TaskID = @taskID 
        
      
      if @roleCode is not null and @InkRoleCode is null /*missing RoleCode*/
      begin
        select @InkRoleCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @roleCode, 'VALUESET_DEBTOR_ROLE', null /*@date*/)

        if @InkRoleCode is null
        begin
          select @errorMessage = Concat(@errorMessage, 'Missing mapping for RoleCode (Indecs RoleCode: ',  @roleCode, ', ValueSet: VALUESET_DEBTOR_ROLE.) ')
        end
        
        if IsNull(@errorMessage, '') = ''
        begin
          update IFC.InkassoSyncSendDebtor
          set InkRoleCode = @InkRoleCode,
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @userName
          where ID = @syncRecordID
        end
      end
    end
    else if @syncType = 'Asset'
    begin
      /*StatusCode, AssetTypeCode, AssetNatureCode*/
      select @syncRecordID = a.ID,
             @statusCode = a.StatusCode, @InkStatusCode = a.InkStatusCode, @assetTypeCode = a.AssetTypeCode, @InkAssetTypeCode = a.InkAssetTypeCode,
             @assetNatureCode = a.AssetNatureCode, @InkAssetNatureCode = a.InkAssetNatureCode
      from IFC.InkassoSyncSendAsset a join IFC.IndecsInkassoSync s on a.IndecsInkassoSyncID = s.ID
	    where s.TaskID = @taskID 
        
      if    @statusCode is not null and @InkStatusCode is null
         or @assetTypeCode is not null and @InkAssetTypeCode is null
         or @assetNatureCode is not null and @InkContractTypeCode is null
      begin
        if @statusCode is not null and @InkStatusCode is null /*missing StatusCode*/
        begin
          select @InkStatusCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @statusCode, 'VALUESET_STATUS', null /*@date*/)

          if @InkStatusCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for StatusCode (Indecs StatusCode: ',  @statusCode, ', ValueSet: VALUESET_STATUS.) ')
          end
        end
        if @assetTypeCode is not null and @InkAssetTypeCode is null /*missing AssetTypeCode*/
        begin
          select @InkAssetTypeCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @assetTypeCode, 'VALUESET_ASSET_PROPERTY_TYPE', null /*@date*/)

          if @InkAssetTypeCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for AssetTypeCode (Indecs AssetTypeCode: ',  @assetTypeCode, ', ValueSet: VALUESET_ASSET_PROPERTY_TYPE.) ')
          end
        end
        if @assetNatureCode is not null and @InkAssetNatureCode is null /*missing AssetNatureCode*/
        begin
          select @InkAssetNatureCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @assetNatureCode, 'VALUESET_ASSET_NATURE', null /*@date*/)

          if @InkAssetNatureCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for AssetNatureCode (Indecs AssetNatureCode: ',  @assetNatureCode, ', ValueSet: VALUESET_ASSET_NATURE.) ')
          end
        end
       
       
        if IsNull(@errorMessage, '') = ''
        begin
          update InkassoSyncSendAsset
          set InkStatusCode = IsNull(InkStatusCode, @InkStatusCode),
              InkAssetTypeCode = IsNull(InkAssetTypeCode, @InkAssetTypeCode),   
              InkAssetNatureCode = IsNull(InkAssetNatureCode, @InkAssetNatureCode),
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @userName
          where ID = @syncRecordID
        end
      end
    end
    else if @syncType = 'ConstructionCode'
    begin
      /*ConsolidatedProductCode, CurrencyCode*/
      select @syncRecordID = c.ID,
             @currencyCode = c.CurrencyCode, @InkCurrencyCode = c.InkCurrencyCode,
             @ConsolidatedProductCode = c.ConsolidatedProductCode, @InkConsolidatedProductID = c.InkConsolidatedProductID
      from IFC.InkassoSyncSendConstructionCode c join IFC.IndecsInkassoSync s on c.IndecsInkassoSyncID = s.ID
	    where s.TaskID = @taskID 
        

      if    @currencyCode is not null and @InkCurrencyCode is null
         or @ConsolidatedProductCode is not null and @InkConsolidatedProductID is null
      begin
        if @currencyCode is not null and @InkCurrencyCode is null /*missing CurrencyCode*/
        begin
          select @InkCurrencyCode = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @currencyCode, 'VALUESET_CURRENCY', null /*@date*/)

          if @InkCurrencyCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for CurrencyCode (Indecs CurrencyCode: ',  @currencyCode, ', ValueSet: VALUESET_CURRENCY.) ')
          end
        end
        if @ConsolidatedProductCode is not null and @InkConsolidatedProductID is null /*missing ConsolidatedProductCode*/
        begin
          select @InkConsolidatedProductID = IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, @ConsolidatedProductCode, 'VALUESET_CONSOLIDATED_PRODUCT', null /*@date*/)

          if @ConsolidatedProductCode is null
          begin
            select @errorMessage = Concat(@errorMessage, 'Missing mapping for ConsolidatedProductCode (Indecs ConsolidatedProductCode: ',  @ConsolidatedProductCode, ', ValueSet: VALUESET_CONSOLIDATED_PRODUCT.) ')
          end
        end

        if IsNull(@errorMessage, '') = ''
        begin
          update IFC.InkassoSyncSendConstructionCode
          set InkCurrencyCode = @InkCurrencyCode,
              @InkConsolidatedProductID = @InkConsolidatedProductID,   
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @userName
          where ID = @syncRecordID
        end
      end
    end
    

    if IsNull(@errorMessage, '') <> ''
    begin
      /*TODO: send notification*/

      raiserror(@errorMessage, 16, 1)
    end
  end try
  begin catch
    if @@trancount > 0
       rollback

    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @correlationID,
                            @p_UserName = @userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage

    ;throw
  end catch
end
go

/*Author: Gyenese Katalin
  Create date: 2023.11.10. - DV-1524
  Last modified date: 2023.11.10.
  Description: it returns the INK001_dealChanged webservice fields (for Inkasso synchronization).

  Parameters:
    - @p_taskID: taskID
    - @p_correlationID: the correlationID of the caller
    - @p_userName: the username of the caller
*/
CREATE   procedure [IFC].[INK001_dealChanged](@p_taskID Numeric(16), @p_correlationID NVarChar(200) = null, @p_userName NVarChar(200) = null)
as
begin 
  set NOCOUNT ON
  set XACT_ABORT ON

  /*variables for logging*/
  declare @procedureName nvarchar(100) = 'IFC.INK001_dealChanged', @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for procedure logic*/
  declare @l_tasktype NVarChar(200) = 'TASK_TYPE_DATA_SYNC_DEBT_CASE_INK', @l_costMin Money, @l_costMax Money, @l_costMinMaxPeriodTypeCode NVarChar(200)

  declare @table table( inkasszoDealID Numeric(16)                /*Ügy egyedi azonosító. InkassoSyncSendDebtCase.DebtCaseID*/,
                        hitelezoCegId Numeric(16)                 /*Engedményező cég egyedi azonosítója. InkassoSyncSendDebtCase.ExternalOriginalCreditorEntityID*/,
                        debtorId Numeric(16)                      /*Adós egyedi azonosítója. InkassoSyncSendDebtCase.MainDebtorID*/,
                        ecollectId Numeric(16)                    /*Ügy „beszédes” azonosítója, ha képződik az Ecollectben. OTP kérésre null-lal töltjük*/,
                        contractDate DateTime                     /*Megbízás dátuma. InkassoSyncSendDebtCase.PurchaseDate*/,
                        dealCurrency NVarChar(200)                /*Ügy devizája – FK14. InkassoSyncSendDebtCase.InkCurrencyCode*/,
                        dealPrice Money                           /*Vételár – F26. InkassoSyncSendDebtCase.PurchasePrice*/,
                        contractCapital Money                     /*Vásárolt tőketartozás – FK10.InkassoSyncSendDebtCase.DebtCapital*/,
                        contractInterest Money                    /*Vásárolt ügyleti kamattartozás – FK11.InkassoSyncSendDebtCase.DebtInterest*/,
                        contractDefaultInterest Money             /*Vásárolt késedelmi kamattartozás – FK12.InkassoSyncSendDebtCase.DebtPenaltyInterest*/,
                        contractCostsDue Money                    /*Vásárolt költségtartozás – FK13.InkassoSyncSendDebtCase.DebtCost*/,
                        contractCostsDueHUF Money                 /*Vásárolt HUF költségtartozás – FK60.InkassoSyncSendDebtCase.DebtCostLocalCurrency*/,
                        originalBankAccontNumber NVarChar(200)    /*Eredeti bankszámlaszám – FK02.InkassoSyncSendDebtCase.AccountNr*/,
                        subaccountNumber NVarChar(200)            /*Alszámlaszám – FK03. InkassoSyncSendDebtCase.SubAccountNr*/,
                        debtURBISAccountNumber NVarChar(200)      /*Követelés URBIS számlaszáma (Ha létezik ). InkassoSyncSendDebtCase.URBISAccountNr*/,
                        ecollectDealID Numeric(16)                /*Szerződés egyedi azonosító (Ha ez Ecollect képez egyedi azonosítót a szerződéshez). InkassoSyncSendDebtCase.ContractID*/,
                        contractTAExportID NVarChar(200)          /*Szerződésszám az Interfészből – FK05. InkassoSyncSendDebtCase.ContractNr*/,
                        contractPricingID NVarChar(200)           /*Árazás azonosító– FK24. InkassoSyncSendDebtCase.PricingID*/,
                        typeOfDebt NVarChar(200)                  /*Lakossái fedezetlen (01), Lakossági fedezetes (02), Vállalati (03). InkassoSyncSendDebtCase.DebtTypeCode*/,
                        OTPDivisionCode NVarChar(200)             /*Üzletág kód – FK07. InkassoSyncSendDebtCase.InkDepartmentTypeCode*/,
                        typeOfContract NVarChar(200)              /*(E = engedményezett, B = behajtásra átadott) – FK28. InkassoSyncSendDebtCase.ContractTypeCode*/,
                        contractSignedDate Date                   /*Szerződés aláírás dátuma – FK30. InkassoSyncSendDebtCase.ContractSignDate*/,
                        typeOfLoan NVarChar(200)                  /*Hiteltípus – FK08. InkassoSyncSendDebtCase.InkCreditTypeCode*/,
                        debtorName NVarChar(250)                  /*Adós neve. InkassoSyncSendDebtCase.DebtorName*/,
                        balanceDate Date                          /*Vásárlás fordulónapja. – FK25. InkassoSyncSendDebtCase.BalanceDate*/,
                        branchCode Numeric(16)                    /*Fiókkód  – FK01. InkassoSyncSendDebtCase.OfficeID*/,
                        originOfData NVarChar(200)                /*Forrásrendszer azonosítója – FK04. InkassoSyncSendDebtCase.InkSourceSystemID*/,
                        creditInterestRate Numeric(10,4)          /*Ügyleti kamat % – FK16. InkassoSyncSendDebtCase.NormalInterestRate*/,
                        defaultInterestRate Numeric(10,4)         /*Késedelmi kamat % – FK17. InkassoSyncSendDebtCase.PenaltyInterestRate*/,
                        costRate Numeric(10,4)                    /*Kezelési költség%  – FK18. InkassoSyncSendDebtCase.CostRate*/,
                        terminationDate DateTime                  /*Felmondás dátuma – FK19 . InkassoSyncSendDebtCase.TerminationDate*/,
                        grantDate Date                            /*Hitelkihelyezés dátuma – FK20. InkassoSyncSendDebtCase.IssueDate*/,
                        defaultDate DateTime                      /*Késedelembe esés dátuma – FK21 . InkassoSyncSendDebtCase.FulfillmentDate*/,
                        baselPool NVarChar(200)                   /*Kockázati pool azonosító – FK31. InkassoSyncSendDebtCase.RiskPool*/,
                        productSegmentIDEcollect NVarChar(200)    /*Termékszegmens azonosító, ha az Ecollect ezt meghatározza.. InkassoSyncSendDebtCase.ProductSegment*/,
                        housingSaving NVarChar(200)               /*Speciális felmondott jelző – Késedelmi kamat leállítandó – FK54. InkassoSyncSendDebtCase.HousingSaving*/,
                        housingSavingDefaultStopdate Date         /*Késedelmi kamat leállításnak dátuma. InkassoSyncSendDebtCase.HousingSavingDefaultStopDate*/,
                        HVPFlag NVarChar(200)                     /*HVP jelző – FK53 . InkassoSyncSendDebtCase.HPV*/,
                        dealCostMin Money                         /*Kezelési költség minimuma – FK43. InkassoSyncSendDebtCase.CostMin*/,
                        dealCostMax Money                         /*Kezelési költség maximuma – FK44. InkassoSyncSendDebtCase.CostMax*/,
                        creditGuaranteeFlag NVarChar(200)         /*Hitelgarancia jelző – FK61. InkassoSyncSendDebtCase.CreditGuarantee*/,
                        contractDealValue Money                   /*Szerződés összege – FK38. InkassoSyncSendDebtCase.DebtTotal*/,
                        KHRDeadline NVarChar(200)                 /*A BAR-ba felkerülés lehetőségét szerződésben elfogadta – FK39. InkassoSyncSendDebtCase.KHR*/,
                        KHRDefaultDeadline Date                   /*Az ügylet 90 napos figyelésének kezdő dátuma – FK40. InkassoSyncSendDebtCase.KHRPenaltyDate*/,
                        KHRnotifyDate DateTime                    /*Az ügyfélnek küldött figyelmeztető levél dátuma – FK41. InkassoSyncSendDebtCase.KHRDunningLetterDate*/,
                        KHRDelayDate DateTime                     /*Amikor a forrásrendzser BAR-ba feladta – FK42. InkassoSyncSendDebtCase.KHROmissionDate*/,
                        bankIncome Money                          /*Ügyfél által befizetett összeg – FK62. InkassoSyncSendDebtCase.IncomeTransactionAmount*/,
                        KHRContractID NVarChar(200)               /*KHR szerződés azonosító – FK63. InkassoSyncSendDebtCase.KHRContractID*/,
                        dataSource NVarChar(200)                  /*Milyen forrásból lett betöltve az ügy – (I = interfész, E = excel). InkassoSyncSendDebtCase.InkContractDataOriginCode*/,
                        consolidatedSource NVarChar(200)          /*Konszolidált forrás. InkassoSyncSendDebtCase.ConsolidatedSource*/,
                        consolidatedProduct NVarChar(200)         /*Konszolidált termék. InkassoSyncSendDebtCase.ConsolidatedProduct*/,
                        constructCode NVarChar(200)               /*Konstrukció – FK55. InkassoSyncSendDebtCase.ConstructionCode*/,
                        consolidatedProductID NVarChar(200)       /*Konszolidált termék azonosító. InkassoSyncSendDebtCase.ConsolidatedProductID*/,
                        EVQualifyID NVarChar(200)                 /*EV minősítés. InkassoSyncSendDebtCase.EVQualifyCode*/,
                        EVQualifyGroup NVarChar(200)              /*EV minősítés csoport. InkassoSyncSendDebtCase.EVQualifyGroup*/,
                        method NVarChar(200)                      /*InkassoSyncSendDebtCase.Method*/,
                        Level5ID NVarChar(200)                    /*InkassoSyncSendDebtCase.Level5ID*/,
                        Level7ID NVarChar(200)                    /*InkassoSyncSendDebtCase.Level7ID*/,
                        productCategory NVarChar(200)             /*InkassoSyncSendDebtCase.ProductCategory*/,
                        collectorRelatedDeal Numeric(16)          /*Gyűjtőszámla kapcsolódó ügy. InkassoSyncSendDebtCase.CollectorRelatedDebtCaseID*/,
                        collectorRelatedType NVarChar(200)        /*Kapcsolódó ügy típusa. (GYGY- gyűjtő, FOGY- főszámla). InkassoSyncSendDebtCase.CollectorRelatedDebtCaseType*/,
                        importDate DateTime                       /*Rögzítés dátuma – a követelés betöltésének dátuma. InkassoSyncSendDebtCase.DebtCaseCreationDateTime*/,
                        OTPFBranch Numeric(16)                    /*Kezelő iroda (Ha az ügyleosztás az Ecollecben már megtörténik). InkassoSyncSendDebtCase.OfficeID*/,
                        OTPFClerk NVarChar(200)                   /*Kezelő ügyintéző. InkassoSyncSendDebtCase.OperatorUserName*/,
                        ModificationType NVarChar(200)            /*Tranzakció típusa (értékkészlet: UPDATE,INSERT,DELETE). InkassoSyncSendDebtCase.ModificationType*/,
                        errorMsg NVarChar(max)                    /*Hibaüzenet a backendnek.*/
                      )


  begin try
    if not exists(select *
                  from ORG.Task t
                  where t.ID = @p_taskID
                    and t.taskTypeID = @l_taskType
                 )
    begin
      insert into @table(errorMsg) 
        select Concat('The @p_taskID parameter is empty or not a task of type "', @l_tasktype, '".') errorMsg
    end
    else /*@p_taskID is valid*/
    begin
      /*CostMinMaxPeriodTypeCode check - only PERIOD_TYPE_DAY is valid*/
      if exists(select *
                from IFC.InkassoSyncSendDebtCase d join IFC.IndecsInkassoSync s on d.IndecsInkassoSyncID = s.ID
	              where s.TaskID = @p_taskID
                  and IsNull(d.CostMinMaxPeriodTypeCode, '') <> 'PERIOD_TYPE_DAY'
                  and (d.CostMin is not null or d.CostMax is not null)
               )
      begin
        select @l_costMin = d.CostMin, @l_costMax = d.CostMax, @l_costMinMaxPeriodTypeCode = d.CostMinMaxPeriodTypeCode
        from IFC.InkassoSyncSendDebtCase d join IFC.IndecsInkassoSync s on d.IndecsInkassoSyncID = s.ID
	      where s.TaskID = @p_taskID
          and IsNull(d.CostMinMaxPeriodTypeCode, '') <> 'PERIOD_TYPE_DAY'
          and (d.CostMin is not null or d.CostMax is not null)

        select @errorMessage = Concat('If CostMin/CostMax has a value, the CostMinMaxPeriodTypeCode has to be PERIOD_TYPE_DAY. (CostMin: ', @l_costMin, ', CostMax: ', @l_costMax, ', CostMinMaxPeriodTypeCode: ', @l_costMinMaxPeriodTypeCode, ')')
        raiserror(@errorMessage, 16, 1)
      end

      /*mapping checks*/
      exec IFC.HandleSendInkassoSyncMappings @syncType = 'DebtCase', 
                                             @taskID = @p_taskID, 
                                             @correlationID = @p_correlationID, 
                                             @userName = @p_userName


      insert into @table( inkasszoDealID                 /*Ügy egyedi azonosító. InkassoSyncSendDebtCase.DebtCaseID*/,
                          hitelezoCegId                  /*Engedményező cég egyedi azonosítója. InkassoSyncSendDebtCase.ExternalOriginalCreditorEntityID*/,
                          debtorId                       /*Adós egyedi azonosítója. InkassoSyncSendDebtCase.MainDebtorID*/,
                          ecollectId                     /*Ügy „beszédes” azonosítója, ha képződik az Ecollectben. OTP kérésre null-lal töltjük*/,
                          contractDate                   /*Megbízás dátuma. InkassoSyncSendDebtCase.PurchaseDate*/,
                          dealCurrency                   /*Ügy devizája – FK14. InkassoSyncSendDebtCase.InkCurrencyCode*/,
                          dealPrice                      /*Vételár – F26. InkassoSyncSendDebtCase.PurchasePrice*/,
                          contractCapital                /*Vásárolt tőketartozás – FK10.InkassoSyncSendDebtCase.DebtCapital*/,
                          contractInterest               /*Vásárolt ügyleti kamattartozás – FK11.InkassoSyncSendDebtCase.DebtInterest*/,
                          contractDefaultInterest        /*Vásárolt késedelmi kamattartozás – FK12.InkassoSyncSendDebtCase.DebtPenaltyInterest*/,
                          contractCostsDue               /*Vásárolt költségtartozás – FK13.InkassoSyncSendDebtCase.DebtCost*/,
                          contractCostsDueHUF            /*Vásárolt HUF költségtartozás – FK60.InkassoSyncSendDebtCase.DebtCostLocalCurrency*/,
                          originalBankAccontNumber       /*Eredeti bankszámlaszám – FK02.InkassoSyncSendDebtCase.AccountNr*/,
                          subaccountNumber               /*Alszámlaszám – FK03. InkassoSyncSendDebtCase.SubAccountNr*/,
                          debtURBISAccountNumber         /*Követelés URBIS számlaszáma (Ha létezik ). InkassoSyncSendDebtCase.URBISAccountNr*/,
                          ecollectDealID                 /*Szerződés egyedi azonosító (Ha ez Ecollect képez egyedi azonosítót a szerződéshez). InkassoSyncSendDebtCase.ContractID*/,
                          contractTAExportID             /*Szerződésszám az Interfészből – FK05. InkassoSyncSendDebtCase.ContractNr*/,
                          contractPricingID              /*Árazás azonosító– FK24. InkassoSyncSendDebtCase.PricingID*/,
                          typeOfDebt                     /*Lakossái fedezetlen (01), Lakossági fedezetes (02), Vállalati (03). InkassoSyncSendDebtCase.DebtTypeCode*/,
                          OTPDivisionCode                /*Üzletág kód – FK07. InkassoSyncSendDebtCase.InkDepartmentTypeCode*/,
                          typeOfContract                 /*(E = engedményezett, B = behajtásra átadott) – FK28. InkassoSyncSendDebtCase.InkContractTypeCode*/,
                          contractSignedDate             /*Szerződés aláírás dátuma – FK30. InkassoSyncSendDebtCase.ContractSignDate*/,
                          typeOfLoan                     /*Hiteltípus – FK08. InkassoSyncSendDebtCase.InkCreditTypeCode*/,
                          debtorName                     /*Adós neve. InkassoSyncSendDebtCase.DebtorName*/,
                          balanceDate                    /*Vásárlás fordulónapja. – FK25. InkassoSyncSendDebtCase.BalanceDate*/,
                          branchCode                     /*Fiókkód  – FK01. InkassoSyncSendDebtCase.OfficeID*/,
                          originOfData                   /*Forrásrendszer azonosítója – FK04. InkassoSyncSendDebtCase.InkSourceSystemID*/,
                          creditInterestRate             /*Ügyleti kamat % – FK16. InkassoSyncSendDebtCase.NormalInterestRate*/,
                          defaultInterestRate            /*Késedelmi kamat % – FK17. InkassoSyncSendDebtCase.PenaltyInterestRate*/,
                          costRate                       /*Kezelési költség%  – FK18. InkassoSyncSendDebtCase.CostRate*/,
                          terminationDate                /*Felmondás dátuma – FK19 . InkassoSyncSendDebtCase.TerminationDate*/,
                          grantDate                      /*Hitelkihelyezés dátuma – FK20. InkassoSyncSendDebtCase.IssueDate*/,
                          defaultDate                    /*Késedelembe esés dátuma – FK21 . InkassoSyncSendDebtCase.FulfillmentDate*/,
                          baselPool                      /*Kockázati pool azonosító – FK31. InkassoSyncSendDebtCase.RiskPool*/,
                          productSegmentIDEcollect       /*Termékszegmens azonosító, ha az Ecollect ezt meghatározza.. InkassoSyncSendDebtCase.ProductSegment*/,
                          housingSaving                  /*Speciális felmondott jelző – Késedelmi kamat leállítandó – FK54. InkassoSyncSendDebtCase.HousingSaving*/,
                          housingSavingDefaultStopdate   /*Késedelmi kamat leállításnak dátuma. InkassoSyncSendDebtCase.HousingSavingDefaultStopDate*/,
                          HVPFlag                        /*HVP jelző – FK53 . InkassoSyncSendDebtCase.HPV*/,
                          dealCostMin                    /*Kezelési költség minimuma – FK43. InkassoSyncSendDebtCase.CostMin*/,
                          dealCostMax                    /*Kezelési költség maximuma – FK44. InkassoSyncSendDebtCase.CostMax*/,
                          creditGuaranteeFlag            /*Hitelgarancia jelző – FK61. InkassoSyncSendDebtCase.CreditGuarantee*/,
                          contractDealValue              /*Szerződés összege – FK38. InkassoSyncSendDebtCase.DebtTotal*/,
                          KHRDeadline                    /*A BAR-ba felkerülés lehetőségét szerződésben elfogadta – FK39. InkassoSyncSendDebtCase.KHR*/,
                          KHRDefaultDeadline             /*Az ügylet 90 napos figyelésének kezdő dátuma – FK40. InkassoSyncSendDebtCase.KHRPenaltyDate*/,
                          KHRnotifyDate                  /*Az ügyfélnek küldött figyelmeztető levél dátuma – FK41. InkassoSyncSendDebtCase.KHRDunningLetterDate*/,
                          KHRDelayDate                   /*Amikor a forrásrendzser BAR-ba feladta – FK42. InkassoSyncSendDebtCase.KHROmissionDate*/,
                          bankIncome                     /*Ügyfél által befizetett összeg – FK62. InkassoSyncSendDebtCase.IncomeTransactionAmount*/,
                          KHRContractID                  /*KHR szerződés azonosító – FK63. InkassoSyncSendDebtCase.KHRContractID*/,
                          dataSource                     /*Milyen forrásból lett betöltve az ügy – (I = interfész, E = excel). InkassoSyncSendDebtCase.InkContractDataOriginCode*/,
                          consolidatedSource             /*Konszolidált forrás. InkassoSyncSendDebtCase.ConsolidatedSource*/,
                          consolidatedProduct            /*Konszolidált termék. InkassoSyncSendDebtCase.ConsolidatedProduct*/,
                          constructCode                  /*Konstrukció – FK55. InkassoSyncSendDebtCase.ConstructionCode*/,
                          consolidatedProductID          /*Konszolidált termék azonosító. InkassoSyncSendDebtCase.ConsolidatedProductID*/,
                          EVQualifyID                    /*EV minősítés. InkassoSyncSendDebtCase.EVQualifyCode*/,
                          EVQualifyGroup                 /*EV minősítés csoport. InkassoSyncSendDebtCase.EVQualifyGroup*/,
                          method                         /*InkassoSyncSendDebtCase.Method*/,
                          Level5ID                       /*InkassoSyncSendDebtCase.Level5ID*/,
                          Level7ID                       /*InkassoSyncSendDebtCase.Level7ID*/,
                          productCategory                /*InkassoSyncSendDebtCase.ProductCategory*/,
                          collectorRelatedDeal           /*Gyűjtőszámla kapcsolódó ügy. InkassoSyncSendDebtCase.CollectorRelatedDebtCaseID*/,
                          collectorRelatedType           /*Kapcsolódó ügy típusa. (GYGY- gyűjtő, FOGY- főszámla). InkassoSyncSendDebtCase.CollectorRelatedDebtCaseType*/,
                          importDate                     /*Rögzítés dátuma – a követelés betöltésének dátuma. InkassoSyncSendDebtCase.DebtCaseCreationDateTime*/,
                          OTPFBranch                     /*Kezelő iroda (Ha az ügyleosztás az Ecollecben már megtörténik). InkassoSyncSendDebtCase.OfficeID*/,
                          OTPFClerk                      /*Kezelő ügyintéző. InkassoSyncSendDebtCase.OperatorUserName*/,
                          ModificationType               /*Tranzakció típusa (értékkészlet: UPDATE,INSERT,DELETE). InkassoSyncSendDebtCase.ModificationType*/
                        )
        select d.DebtCaseID inkasszoDealID,
               d.ExternalOriginalCreditorEntityID hitelezoCegId,
               d.MainDebtorID debtorId,
               null ecollectId,
               d.PurchaseDate contractDate,
               d.InkCurrencyCode dealCurrency,
               d.PurchasePrice dealPrice,
               d.DebtCapital contractCapital,
               d.DebtInterest contractInterest,
               d.DebtPenaltyInterest contractDefaultInterest,
               d.DebtCost contractCostsDue,
               d.DebtCostLocalCurrency contractCostsDueHUF,
               d.AccountNr originalBankAccontNumber,
               d.SubAccountNr subaccountNumber,
               d.URBISAccountNr debtURBISAccountNumber,
               d.ContractID ecollectDealID,
               d.ContractNr contractTAExportID,
               d.PricingID contractPricingID,
               d.DebtTypeCode typeOfDebt,
               d.InkDepartmentTypeCode OTPDivisionCode,
               d.InkContractTypeCode typeOfContract,
               d.ContractSignDate contractSignedDate,
               d.InkCreditTypeCode typeOfLoan,
               d.DebtorName debtorName,
               d.BalanceDate balanceDate,
               d.OfficeID branchCode,
               d.InkSourceSystemID originOfData,
               d.NormalInterestRate creditInterestRate,
               d.PenaltyInterestRate defaultInterestRate,
               d.costRate,
               d.terminationDate,
               d.IssueDate grantDate,
               d.FulfillmentDate defaultDate,
               d.RiskPool baselPool,
               d.ProductSegment productSegmentIDEcollect,
               d.housingSaving,
               d.housingSavingDefaultStopdate,
               d.HPV HVPFlag,
               d.CostMin dealCostMin,
               d.CostMax dealCostMax,
               d.CreditGuarantee creditGuaranteeFlag,
               d.DebtTotal contractDealValue,
               d.KHR KHRDeadline,
               d.KHRPenaltyDate KHRDefaultDeadline,
               d.KHRDunningLetterDate KHRnotifyDate,
               d.KHROmissionDate KHRDelayDate,
               d.IncomeTransactionAmount bankIncome,
               d.KHRContractID,
               d.InkContractDataOriginCode dataSource,
               d.consolidatedSource,
               d.consolidatedProduct,
               d.ConstructionCode constructCode,
               d.consolidatedProductID,
               d.EVQualifyCode EVQualifyID,
               d.EVQualifyGroup,
               d.method,
               d.Level5ID,
               d.Level7ID,
               d.productCategory,
               d.CollectorRelatedDebtCaseID collectorRelatedDeal,
               d.CollectorRelatedDebtCaseType collectorRelatedType,
               d.DebtCaseCreationDateTime importDate,
               d.OfficeID OTPFBranch,
               d.OperatorUserName OTPFClerk,
               d.ModificationType
        from IFC.InkassoSyncSendDebtCase d join IFC.IndecsInkassoSync s on d.IndecsInkassoSyncID = s.ID
	      where s.TaskID = @p_taskID
    end


    /*returning data for the backend*/
	  select *
    from @table
  end try
  begin catch
    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_correlationID,
                            @p_UserName = @p_userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage


    insert into @table(errorMsg) 
        select @errorMessage errorMsg      

    select *
    from @table
  end catch
end
go

/*Author: Gyenese Katalin
  Create date: 2023.11.10. - DV-1524
  Last modified date: 2023.11.10.
  Description: it returns the INK002_collateralChanged webservice fields (for Inkasso synchronization).

  Parameters:
    - @p_taskID: taskID
    - @p_correlationID: the correlationID of the caller
    - @p_userName: the username of the caller
*/
CREATE   procedure IFC.INK002_collateralChanged(@p_taskID Numeric(16), @p_correlationID NVarChar(200) = null, @p_userName NVarChar(200) = null)
as
begin 
  set NOCOUNT ON
  set XACT_ABORT ON

  /*variables for logging*/
	declare @procedureName nvarchar(100) = 'IFC.INK002_collateralChanged', @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for procedure logic*/
  declare @l_tasktype NVarChar(200) = 'TASK_TYPE_DATA_SYNC_RELATION_DEBT_CASE_ASSET_INK'

  declare @table table( collateralID Numeric(16)                /*Fedezet egyedi azonosító. InkassoSyncSendAsset.AssetID*/,
                        registryLotNr NVarChar(200)             /*Helyrajzi szám – FF13. InkassoSyncSendAsset.LandRegisterReference*/,
                        coverageTypeDWH NVarChar(200)           /*TA tipus – FF11. InkassoSyncSendAsset.TATypeCode*/, 
                        coverageSubtypeDWH NVarChar(200)        /*TA jelleg – FF12. InkassoSyncSendAsset.TASubTypeCode*/, 
                        zipCode NVarChar(200)                   /*Irányítószám – FF18. InkassoSyncSendAsset.ZipCode*/,
                        city NVarChar(200)                      /*Város – FF19. InkassoSyncSendAsset.Settlement*/,
                        address NVarChar(200)                   /*Utca – FF20 + Házszám – FF21. InkassoSyncSendAsset.Street*/,
                        stateID NVarChar(200)                   /*InkassoSyncSendAsset.InkStatusCode*/,
                        registryLocation NVarChar(100)          /*Helyrajzi szám helység. InkassoSyncSendAsset.LandRegisterCity*/,
                        type NVarChar(200)                      /*Ingatlan típusa – FF11. InkassoSyncSendAsset.InkAssetTypeCode*/,
                        coverageType NVarChar(200)              /*Ingatlan típusa – FF11. InkassoSyncSendAsset.InkAssetTypeCode*/,
                        coverageSubtype NVarChar(200)           /*Ingatlan jellege – FF12. InkassoSyncSendAsset.InkAssetNatureCode*/,
                        title NVarChar(200)                     /*Megnevezés – FF10. InkassoSyncSendAsset.Name*/,
                        marketValue Money                       /*Kihelyezéskori ÉB – FF23. InkassoSyncSendAsset.MarketValue*/,
                        salvagevalue Money                      /*Kihelyezéskori ÉB – FF24. InkassoSyncSendAsset.EscapeValue*/,
                        marketValueReview Money                 /*Új értékbecslés – FF25. InkassoSyncSendAsset.RealMarketValue*/,
                        salvagevalueReview Money                /*Új értékbecslés – FF26. InkassoSyncSendAsset.RealEscapeValue*/,
                        valuationDate Date                      /*Utolsó értékbecslés dátuma – FF27. InkassoSyncSendAsset.LastValuationDate*/,
                        landCertificateID NVarChar(100)         /*Tulajdoni lap száma. InkassoSyncSendAsset.PropertySheetNr*/,
                        ecollectDealID Numeric(16)              /*Ügy egyedi azonosító. InkassoSyncSendAsset.DebtCaseID*/,
                        collateralRelationID  Numeric(16)       /*Rekord egyedi azonosító. ???*/,
                        enforcementID NVarChar(100)             /*VH bejegyzés száma – FF16. InkassoSyncSendAsset.ExecutionRightNr*/,
                        enforcementValue Money                  /*InkassoSyncSendAsset.ExecutionRightValue*/,
                        enforcementDate DateTime                /*VH bejegyzés kelte – FF17. InkassoSyncSendAsset.ExecutionRightDate*/,
                        encumbranceGrantID NVarChar(100)        /*Jelzálog bejegyzés száma – FF14. InkassoSyncSendAsset.MortgageRightNr*/,
                        encumbranceGrantDate DateTime           /*Jelzálog bejegyzés dátuma – FF15. InkassoSyncSendAsset.MortgageRightDate*/,
                        commentsconnectedDeals NVarChar(200)    /*Megjegyzés. ???*/,
                        ownerPartyID Numeric(16)                /*Tulajdonos egyedi azonosító. InkassoSyncSendAsset.ExternalOwnerEntityID*/,
                        ownershipDate Date                      /*Szerzés dátuma. InkassoSyncSendAsset.OwnershipValidFrom*/,
                        ownershipType NVarChar(200)             /*Szerzés jogcíme. InkassoSyncSendAsset.OwnershipPretense*/,
                        cancelationDate Date                    /*Megszűnés dátuma. InkassoSyncSendAsset.OwnershipValidUntil*/,
                        collateralProportion NVarChar(200)      /*Tulajdoni hányad – FF08. ???*/,
                        collateralProportionPct Numeric(16)     /*Tulajdoni hányad százalék – FF09. InkassoSyncSendAsset.ShareDividend*/,
                        commentsConnectedParties NVarChar(200)  /*Megjegyzés. ???*/,
                        errorMsg NVarChar(max)                  /*Hibaüzenet a backendnek.*/
                      )

  begin try
    if not exists(select *
                  from ORG.Task t
                  where t.ID = @p_taskID
                    and t.taskTypeID = @l_taskType
                 )
    begin
      insert into @table(errorMsg) 
        select Concat('The @p_taskID parameter is empty or not a task of type "', @l_tasktype, '".') errorMsg
    end
    else /*@p_taskID is valid*/
    begin
      /*mapping checks*/
      exec IFC.HandleSendInkassoSyncMappings @syncType = 'Asset', 
                                             @taskID = @p_taskID, 
                                             @correlationID = @p_correlationID, 
                                             @userName = @p_userName

      insert into @table( collateralID               /*Fedezet egyedi azonosító. InkassoSyncSendAsset.AssetID*/,
                          registryLotNr              /*Helyrajzi szám – FF13. InkassoSyncSendAsset.LandRegisterReference*/,
                          coverageTypeDWH            /*TA tipus – FF11. InkassoSyncSendAsset.TATypeCode*/, 
                          coverageSubtypeDWH         /*TA jelleg – FF12. InkassoSyncSendAsset.TASubTypeCode*/, 
                          zipCode                    /*Irányítószám – FF18. InkassoSyncSendAsset.ZipCode*/,
                          city                       /*Város – FF19. InkassoSyncSendAsset.Settlement*/,
                          address                    /*Utca – FF20 + Házszám – FF21. InkassoSyncSendAsset.Street*/,
                          stateID                    /*InkassoSyncSendAsset.InkStatusCode*/,
                          registryLocation           /*Helyrajzi szám helység. InkassoSyncSendAsset.LandRegisterCity*/,
                          type                       /*Ingatlan típusa – FF11. InkassoSyncSendAsset.InkAssetTypeCode*/,
                          coverageType               /*Ingatlan típusa – FF11. InkassoSyncSendAsset.InkAssetTypeCode*/,
                          coverageSubtype            /*Ingatlan jellege – FF12. InkassoSyncSendAsset.InkAssetNatureCode*/,
                          title                      /*Megnevezés – FF10. InkassoSyncSendAsset.Name*/,
                          marketValue                /*Kihelyezéskori ÉB – FF23. InkassoSyncSendAsset.MarketValue*/,
                          salvagevalue               /*Kihelyezéskori ÉB – FF24. InkassoSyncSendAsset.EscapeValue*/,
                          marketValueReview          /*Új értékbecslés – FF25. InkassoSyncSendAsset.RealMarketValue*/,
                          salvagevalueReview         /*Új értékbecslés – FF26. InkassoSyncSendAsset.RealEscapeValue*/,
                          valuationDate              /*Utolsó értékbecslés dátuma – FF27. InkassoSyncSendAsset.LastValuationDate*/,
                          landCertificateID          /*Tulajdoni lap száma. InkassoSyncSendAsset.PropertySheetNr*/,
                          ecollectDealID             /*Ügy egyedi azonosító. InkassoSyncSendAsset.DebtCaseID*/,
                          collateralRelationID       /*Rekord egyedi azonosító. ???*/,
                          enforcementID              /*VH bejegyzés száma – FF16. InkassoSyncSendAsset.ExecutionRightNr*/,
                          enforcementValue           /*InkassoSyncSendAsset.ExecutionRightValue*/,
                          enforcementDate            /*VH bejegyzés kelte – FF17. InkassoSyncSendAsset.ExecutionRightDate*/,
                          encumbranceGrantID         /*Jelzálog bejegyzés száma – FF14. InkassoSyncSendAsset.MortgageRightNr*/,
                          encumbranceGrantDate       /*Jelzálog bejegyzés dátuma – FF15. InkassoSyncSendAsset.MortgageRightDate*/,
                          commentsconnectedDeals     /*Megjegyzés. ???*/,
                          ownerPartyID               /*Tulajdonos egyedi azonosító. InkassoSyncSendAsset.ExternalOwnerEntityID*/,
                          ownershipDate              /*Szerzés dátuma. InkassoSyncSendAsset.OwnershipValidFrom*/,
                          ownershipType              /*Szerzés jogcíme. InkassoSyncSendAsset.OwnershipPretense*/,
                          cancelationDate            /*Megszűnés dátuma. InkassoSyncSendAsset.OwnershipValidUntil*/,
                          collateralProportion       /*Tulajdoni hányad – FF08. ???*/,
                          collateralProportionPct    /*Tulajdoni hányad százalék – FF09. InkassoSyncSendAsset.ShareDividend*/,
                          commentsConnectedParties   /*Megjegyzés. ???*/
                         )
        select a.AssetID collateralID,
               a.LandRegisterReference registryLotNr,
               a.TATypeCode coverageTypeDWH, 
               a.TASubTypeCode coverageSubtypeDWH, 
               a.zipCode,
               a.Settlement city,
               a.Street address,
               a.InkStatusCode stateID,
               a.LandRegisterCity registryLocation,
               a.InkAssetTypeCode type,
               a.InkAssetTypeCode coverageType,
               a.InkAssetNatureCode coverageSubtype,
               a.Name title,
               a.marketValue,
               a.EscapeValue salvagevalue,
               a.RealMarketValue marketValueReview,
               a.RealEscapeValue salvagevalueReview,
               a.LastValuationDate valuationDate,
               a.PropertySheetNr landCertificateID,
               a.DebtCaseID ecollectDealID,
               null collateralRelationID  /*???*/,
               a.ExecutionRightNr enforcementID,
               a.ExecutionRightValue enforcementValue,
               a.ExecutionRightDate enforcementDate,
               a.MortgageRightNr encumbranceGrantID,
               a.MortgageRightDate encumbranceGrantDate,
               null commentsconnectedDeals     /*???*/,
               a.ExternalOwnerEntityID ownerPartyID,
               a.OwnershipValidFrom ownershipDate,
               a.OwnershipPretense ownershipType,
               a.OwnershipValidUntil cancelationDate,
               null collateralProportion       /*???*/,
               a.ShareDividend collateralProportionPct,
               null commentsConnectedParties   /*???*/
        from IFC.InkassoSyncSendAsset a join IFC.IndecsInkassoSync s on a.IndecsInkassoSyncID = s.ID
	      where s.TaskID = @p_taskID

    end

  
    /*returning data for the backend*/
	  select *
    from @table
  end try
  begin catch
    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_correlationID,
                            @p_UserName = @p_userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage


    insert into @table(errorMsg) 
        select @errorMessage errorMsg      

    select *
    from @table
  end catch
end
go

/*Author: Gyenese Katalin
  Create date: 2023.11.10. - DV-1524
  Last modified date: 2023.11.10.
  Description: it returns the INK004_workflowChanged webservice fields (for Inkasso synchronization).

  Parameters:
    - @p_taskID: taskID
    - @p_correlationID: the correlationID of the caller
    - @p_userName: the username of the caller
*/
CREATE   procedure IFC.INK004_workflowChanged(@p_taskID Numeric(16), @p_correlationID NVarChar(200) = null, @p_userName NVarChar(200) = null)
as
begin 
  set NOCOUNT ON
  set XACT_ABORT ON

  /*variables for logging*/
	declare @procedureName nvarchar(100) = 'IFC.INK004_workflowChanged', @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for procedure logic*/
  declare @l_tasktype NVarChar(200) = 'TASK_TYPE_DATA_SYNC_EVENT_INK'

  declare @table table(eventId Numeric(16)	          /*Rekord egyedi azonosító. InkassoSyncSendEvent.EventID*/,
                       description NVarChar(max)      /*Mi a státusza a telefonszámnak. InkassoSyncSendEvent.Description*/,
                       dealId Numeric(16)             /*Ügy egyedi azonosítója. InkassoSyncSendEvent.DebtCaseID*/,
                       actorId Numeric(16)   	        /*Kötelezett egyedi azonosítója. Itt a KÜT-ös referenciát (CEG.ECOLLECTPARTNERID-t) kapjuk és abból forgatjuk ki a CEG.CEGID-t. InkassoSyncSendEvent.ExternalEntityID*/,
                       collateralId Numeric(16)       /*Fedezet egyedi azonosítója. InkassoSyncSendEvent.AssetID*/,
                       eventType NVarChar(200)	      /*Esemény típusa (Inkasso). InkassoSyncSendEvent.InkEventTypeCode*/,
                       executionDate DateTime  	      /*Esemény elintézésének dátuma. InkassoSyncSendEvent.ArrangeDateTime*/,
                       dateOfEntry DateTime           /*Esemény létrehozás dátuma. InkassoSyncSendEvent.EventCreationDateTime*/,
                       ruserId NVarChar(200)	        /*Az eseményt rögzítő user azonosítója. InkassoSyncSendEvent.EventCreationUser*/,
                       vuserId NVarChar(200)	        /*Az eseményt végrehajtó user azonosítója. InkassoSyncSendEvent.EventArrangeUser*/,
                       errorMsg NVarChar(max)         /*Hibaüzenet a backendnek.*/
                      )

  begin try
    if not exists(select *
                  from ORG.Task t
                  where t.ID = @p_taskID
                    and t.taskTypeID = @l_taskType
                 )
    begin
      insert into @table(errorMsg) 
        select Concat('The @p_taskID parameter is empty or not a task of type "', @l_tasktype, '".') errorMsg
    end
    else /*@p_taskID is valid*/
    begin
      /*mapping checks*/
      exec IFC.HandleSendInkassoSyncMappings @syncType = 'Event', 
                                             @taskID = @p_taskID, 
                                             @correlationID = @p_correlationID, 
                                             @userName = @p_userName


      insert into @table( eventId 	        /*Rekord egyedi azonosító. InkassoSyncSendEvent.EventID*/,
                          description       /*Mi a státusza a telefonszámnak. InkassoSyncSendEvent.Description*/,
                          dealId            /*Ügy egyedi azonosítója. InkassoSyncSendEvent.DebtCaseID*/,
                          actorId    	      /*Kötelezett egyedi azonosítója. Itt a KÜT-ös referenciát (CEG.ECOLLECTPARTNERID-t) kapjuk és abból forgatjuk ki a CEG.CEGID-t. InkassoSyncSendEvent.ExternalEntityID*/,
                          collateralId      /*Fedezet egyedi azonosítója. InkassoSyncSendEvent.AssetID*/,
                          eventType 	      /*Esemény típusa (Inkasso). InkassoSyncSendEvent.InkEventTypeCode*/,
                          executionDate     /*Esemény elintézésének dátuma. InkassoSyncSendEvent.ArrangeDateTime*/,
                          dateOfEntry       /*Esemény létrehozás dátuma. InkassoSyncSendEvent.EventCreationDateTime*/,
                          ruserId 	        /*Az eseményt rögzítő user azonosítója. InkassoSyncSendEvent.EventCreationUser*/,
                          vuserId 	        /*Az eseményt végrehajtó user azonosítója. InkassoSyncSendEvent.EventArrangeUser*/
                        ) 
        select e.eventId,
               e.description,
               e.DebtCaseID dealId,
               e.ExternalEntityID actorId,
               e.AssetID collateralId,
               e.InkEventTypeCode eventType,
               e.ArrangeDateTime executionDate,
               e.EventCreationDateTime dateOfEntry,
               e.EventCreationUser ruserId,
               e.EventArrangeUser vuserId
        from IFC.InkassoSyncSendEvent e join IFC.IndecsInkassoSync s on e.IndecsInkassoSyncID = s.ID
	      where s.TaskID = @p_taskID
    end


    /*returning data for the backend*/
	  select *
    from @table
  end try
  begin catch
    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_correlationID,
                            @p_UserName = @p_userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage


    insert into @table(errorMsg) 
        select @errorMessage errorMsg      

    select *
    from @table
  end catch
end
go

/*Author: Gyenese Katalin
  Create date: 2023.11.10. - DV-1524
  Last modified date: 2023.11.10.
  Description: it returns the INK005_documentChanged webservice fields (for Inkasso synchronization).

  Parameters:
    - @p_taskID: taskID
    - @p_correlationID: the correlationID of the caller
    - @p_userName: the username of the caller
*/
CREATE   procedure [IFC].[INK005_documentChanged](@p_taskID Numeric(16), @p_correlationID NVarChar(200) = null, @p_userName NVarChar(200) = null)
as
begin 
  set NOCOUNT ON
  set XACT_ABORT ON

  /*variables for logging*/
	declare @procedureName nvarchar(100) = 'IFC.INK005_documentChanged', @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for procedure logic*/
  declare @l_tasktype NVarChar(200) = 'TASK_TYPE_DATA_SYNC_OUTGOING_DOCUMENT_INK'

  declare @table table( modificationDate DateTime               /*Amennyiben a SZTORNO (törlés) dátum üres, akkor a MODOSITAS (módosítás) dátumot küldjük. InkassoSyncSendDocument.DocumentLastModDateTime*/,
                        muserId NVarChar(200)                   /*Amennyiben a SZTORNOUSERID (törlő user) azonosítója üres, akkor a MODOSITO (módosító user) azonosítóját küldjük. InkassoSyncSendDocument.DocumentLastModUserName*/,
                        modificationType NVarChar(200)          /*A tranzakció típusa: I: rögzítés (INSERT)
                                                                                       U: módosítás (UPDATE)
                                                                                       D: törlés (DELETE)
                                                                  InkassoSyncSendDocument.InkModificationTypeCode
                                                                */, 
                        documentId NVarChar(200)                /*A dokumentum INDECS-es belső azonosítója. InkassoSyncSendDocument.DocumentID*/,
                        clerkId NVarChar(200)                   /*Rögzítő user azonosítója. InkassoSyncSendDocument.DocumentCreationUserName*/,
                        documentPath NVarChar(500)              /*A dokumentum elérési útvonala + a fájlnév + kiterjesztés. InkassoSyncSendDocument.DocumentPath*/,
                        documentTypeId NVarChar(200)             /*Az Inkasszó dokumentumtípus kódja. InkassoSyncSendDocument.InkDocumentTypeID*/,             
                        dealId Numeric(16)                      /*A kapcsolódó ügy Inkasszós azonosítója. InkassoSyncSendDocument.DebtCaseID*/,
                        actorId NVarChar(200)                   /*A dokumentumhoz kapcsolódó ügyfél KÜT-ös azonosítója. InkassoSyncSendDocument.EntityID*/,
                        debtorId NVarChar(200)                  /*A dokumentumhoz kapcsolódó ügy adósának (UGY.ADOSCEGID alapján) KÜT-ös azonosítója. InkassoSyncSendDocument.DebtorExternalEntityID*/,
                        documentStatusId Numeric(16)            /*A dokumentum státusza. InkassoSyncSendDocument.InkDocumentStatusID*/,  
                        mediaId Numeric(16)                     /*Értesítés típusa. InkassoSyncSendDocument.InkMediaID*/,
                        debtorAddressId NVarChar(200)           /*A dokumentum kötelezettjéhez (ACTORID) tartozó levélküldési címet kellene ide betölteni, de jelenleg az ügyön megadott alapértelmezett címet töltenénk bele, 
                                                                  ami sántít, mert ez nem feltétlen az ACTORID-hoz tartozó cím.
                                                                  InkassoSyncSendDocument.EntityAddressID
                                                                */,
                        mailBarcode NVarChar(100)               /*A központi levelezés során a levélre került ragszám. InkassoSyncSendDocument.Barcode*/,
                        postalRegNr NVarChar(100)               /*?. InkassoSyncSendDocument.PostalRegNr*/,
                        registrationDate DateTime               /*A rögzítés dátuma – YYYY.MM.DD HH24:MI:SS formátumban. InkassoSyncSendDocument.DocumentCreationDateTime*/,
                        linkedDocId NVarChar(200)               /*A dokumentumhoz kapcsolódó dokumentum azonosítója.
                                                                  !!!Meg kell ezt majd vizsgálni, mert jelenleg már van egy tábla ahol a dokumentum - dokumentum összerendelések zajlanak, így lehet több kapcsolódó dokumentum is.!!!
                                                                  InkassoSyncSendDocument.RelatedDocumentID  
                                                                */,
                        mailingDate Date                        /*A dokumentum elküldésének dátuma. – YYYY.MM.DD formátumban. InkassoSyncSendDocument.DocumentMailingDate*/,
                        printDate Date                          /*Monopost előállítás dátuma – YYYY.MM.DD formátumban. InkassoSyncSendDocument.DocumentPrintDate*/,
                        errorMsg NVarChar(max)                  /*Hibaüzenet a backendnek.*/
                      ) 

  begin try
    if not exists(select *
                  from ORG.Task t
                  where t.ID = @p_taskID
                    and t.taskTypeID = @l_taskType
                 )
    begin
      insert into @table(errorMsg) 
        select Concat('The @p_taskID parameter is empty or not a task of type "', @l_tasktype, '".') errorMsg
    end
    else /*@p_taskID is valid*/
    begin
      insert into @table( modificationDate               /*Amennyiben a SZTORNO (törlés) dátum üres, akkor a MODOSITAS (módosítás) dátumot küldjük. InkassoSyncSendDocument.DocumentLastModDateTime*/,
                          muserId                        /*Amennyiben a SZTORNOUSERID (törlő user) azonosítója üres, akkor a MODOSITO (módosító user) azonosítóját küldjük. InkassoSyncSendDocument.DocumentLastModUserName*/,
                          modificationType               /*A tranzakció típusa: I: rögzítés (INSERT)
                                                                                U: módosítás (UPDATE)
                                                                                D: törlés (DELETE)
                                                          InkassoSyncSendDocument.InkModificationTypeCode
                                                         */, 
                          documentId                     /*A dokumentum INDECS-es belső azonosítója. InkassoSyncSendDocument.DocumentID*/,
                          clerkId                        /*Rögzítő user azonosítója. InkassoSyncSendDocument.DocumentCreationUserName*/,
                          documentPath                   /*A dokumentum elérési útvonala + a fájlnév + kiterjesztés. InkassoSyncSendDocument.DocumentPath*/,
                          documentTypeId                 /*Az Inkasszó dokumentumtípus kódja. InkassoSyncSendDocument.InkDocumentTypeID*/,             
                          dealId                         /*A kapcsolódó ügy Inkasszós azonosítója. InkassoSyncSendDocument.DebtCaseID*/,
                          actorId                        /*A dokumentumhoz kapcsolódó ügyfél KÜT-ös azonosítója. InkassoSyncSendDocument.EntityID*/,
                          debtorId                       /*A dokumentumhoz kapcsolódó ügy adósának (UGY.ADOSCEGID alapján) KÜT-ös azonosítója. InkassoSyncSendDocument.DebtorExternalEntityID*/,
                          documentStatusId               /*A dokumentum státusza. InkassoSyncSendDocument.InkDocumentStatusID*/,  
                          mediaId                        /*Értesítés típusa. InkassoSyncSendDocument.InkMediaID*/,
                          debtorAddressId                /*A dokumentum kötelezettjéhez (ACTORID) tartozó levélküldési címet kellene ide betölteni, de jelenleg az ügyön megadott alapértelmezett címet töltenénk bele, 
                                                           ami sántít, mert ez nem feltétlen az ACTORID-hoz tartozó cím.
                                                           InkassoSyncSendDocument.EntityAddressID
                                                         */,
                          mailBarcode                    /*A központi levelezés során a levélre került ragszám. InkassoSyncSendDocument.Barcode*/,
                          postalRegNr                    /*?. InkassoSyncSendDocument.PostalRegNr*/,
                          registrationDate               /*A rögzítés dátuma – YYYY.MM.DD HH24:MI:SS formátumban. InkassoSyncSendDocument.DocumentCreationDateTime*/,
                          linkedDocId                    /*A dokumentumhoz kapcsolódó dokumentum azonosítója.
                                                           !!!Meg kell ezt majd vizsgálni, mert jelenleg már van egy tábla ahol a dokumentum - dokumentum összerendelések zajlanak, így lehet több kapcsolódó dokumentum is.!!!
                                                           InkassoSyncSendDocument.RelatedDocumentID  
                                                         */,
                          mailingDate                    /*A dokumentum elküldésének dátuma. – YYYY.MM.DD formátumban. InkassoSyncSendDocument.DocumentMailingDate*/,
                          printDate                      /*Monopost előállítás dátuma – YYYY.MM.DD formátumban. InkassoSyncSendDocument.DocumentPrintDate*/
                         )
        select  d.DocumentLastModDateTime modificationDate,
                d.DocumentLastModUserName muserId,
                d.InkModificationTypeCode modificationType,
                d.DocumentID documentId,
                d.DocumentCreationUserName clerkId,
                d.DocumentPath documentPath,
                d.InkDocumentTypeID documentTypeId,
                d.DebtCaseID dealId,
                d.EntityID actorId,
                d.DebtorExternalEntityID debtorId,
                d.InkDocumentStatusID documentStatusId,  
                d.InkMediaID mediaId,
                d.EntityAddressID debtorAddressId,
                d.Barcode mailBarcode,
                d.PostalRegNr postalRegNr,
                d.DocumentCreationDateTime registrationDate,
                d.RelatedDocumentID linkedDocId,
                d.DocumentMailingDate mailingDate,
                d.DocumentPrintDate printDate          
        from IFC.InkassoSyncSendDocument d join IFC.IndecsInkassoSync s on d.IndecsInkassoSyncID = s.ID
	      where s.TaskID = @p_taskID
    end

    /*returning data for the backend*/
	  select *
    from @table
  end try
  begin catch
    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_correlationID,
                            @p_UserName = @p_userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage


    insert into @table(errorMsg) 
        select @errorMessage errorMsg      

    select *
    from @table
  end catch
end
go

/*Author: Gyenese Katalin
  Create date: 2023.11.10. - DV-1524
  Last modified date: 2023.11.10.
  Description: it returns the INK006_constructionCode webservice fields (for Inkasso synchronization).

  Parameters:
    - @p_taskID: taskID
    - @p_correlationID: the correlationID of the caller
    - @p_userName: the username of the caller
*/
CREATE   procedure [IFC].[INK006_constructionCode](@p_taskID Numeric(16), @p_correlationID NVarChar(200) = null, @p_userName NVarChar(200) = null)
as
begin 
  set NOCOUNT ON
  set XACT_ABORT ON

  /*variables for logging*/
	declare @procedureName nvarchar(100) = 'IFC.INK006_constructionCode', @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for procedure logic*/
  declare @l_tasktype NVarChar(200) = 'TASK_TYPE_DATA_SYNC_CONSTRUCTION_CODE_INK'
  
  declare @table table(constructionId NVarChar(200)             /*InkassoSyncSendConstructionCode.ConstructionCode*/,
                       level1 NVarChar(200)                     /*InkassoSyncSendConstructionCode.Level1*/,
                       level2 NVarChar(200)                     /*InkassoSyncSendConstructionCode.Level2*/,
                       level3 NVarChar(200)                     /*InkassoSyncSendConstructionCode.Level3*/,
                       level4 NVarChar(200)                     /*InkassoSyncSendConstructionCode.Level4*/,
                       level5 NVarChar(200)                     /*InkassoSyncSendConstructionCode.Level5*/,
                       level6 NVarChar(200)                     /*InkassoSyncSendConstructionCode.Level6*/,
                       level7 NVarChar(200)                     /*InkassoSyncSendConstructionCode.Level7*/,
                       rbprod NVarChar(200)                     /*InkassoSyncSendConstructionCode.RbProd*/,
                       IFRSProductCode NVarChar(200)            /*InkassoSyncSendConstructionCode.IFRSProductCode*/,
                       currency NVarChar(200)                   /*InkassoSyncSendConstructionCode.InkCurrencyCode*/,
                       consolidatedProductId NVarChar(200)      /*InkassoSyncSendConstructionCode.InkConsolidatedProductID*/,
                       createdBy NVarChar(200)                  /*Létrehozó azonosítója. InkassoSyncSendConstructionCode.DataCreationUser*/,
                       creationDate DateTime                    /*Létrehozás dátuma. InkassoSyncSendConstructionCode.DataCreationDateTime*/,
                       lastModifiedBy NVarChar(200)             /*Módosító azonosítója. InkassoSyncSendConstructionCode.DataLastModUser*/,
                       lastModificationDate DateTime            /*Utolsó módosítás dátuma. InkassoSyncSendConstructionCode.DataLastModDateTime*/,
                       errorMsg NVarChar(max)                   /*Hibaüzenet a backendnek.*/
                      )

  begin try  
    if not exists(select *
                  from ORG.Task t
                  where t.ID = @p_taskID
                    and t.taskTypeID = @l_taskType
                 )
    begin
      insert into @table(errorMsg) 
        select Concat('The @p_taskID parameter is empty or not a task of type "', @l_tasktype, '".') errorMsg
    end

    else /*@p_taskID is valid*/
    begin
      /*mapping checks*/
      exec IFC.HandleSendInkassoSyncMappings @syncType = 'ConstructionCode', 
                                             @taskID = @p_taskID, 
                                             @correlationID = @p_correlationID, 
                                             @userName = @p_userName
                                             
      insert into @table( constructionId              /*InkassoSyncSendConstructionCode.ConstructionCode*/,
                          level1                      /*InkassoSyncSendConstructionCode.Level1*/,
                          level2                      /*InkassoSyncSendConstructionCode.Level2*/,
                          level3                      /*InkassoSyncSendConstructionCode.Level3*/,
                          level4                      /*InkassoSyncSendConstructionCode.Level4*/,
                          level5                      /*InkassoSyncSendConstructionCode.Level5*/,
                          level6                      /*InkassoSyncSendConstructionCode.Level6*/,
                          level7                      /*InkassoSyncSendConstructionCode.Level7*/,
                          rbprod                      /*InkassoSyncSendConstructionCode.RbProd*/,
                          IFRSProductCode             /*InkassoSyncSendConstructionCode.IFRSProductCode*/,
                          currency                    /*InkassoSyncSendConstructionCode.InkCurrencyCode*/,
                          consolidatedProductId       /*InkassoSyncSendConstructionCode.InkConsolidatedProductID*/,
                          createdBy                   /*Létrehozó azonosítója. InkassoSyncSendConstructionCode.DataCreationUser*/,
                          creationDate                /*Létrehozás dátuma. InkassoSyncSendConstructionCode.DataCreationDateTime*/,
                          lastModifiedBy              /*Módosító azonosítója. InkassoSyncSendConstructionCode.DataLastModUser*/,
                          lastModificationDate        /*Utolsó módosítás dátuma. InkassoSyncSendConstructionCode.DataLastModDateTime*/
                        )
         select c.ConstructionCode constructionId,
                c.level1,
                c.level2,
                c.level3,
                c.level4,
                c.level5,
                c.level6,
                c.level7,
                c.rbprod,
                c.IFRSProductCode,
                c.InkCurrencyCode,
                c.InkConsolidatedProductID,
                c.DataCreationUser createdBy,
                c.DataCreationDateTime creationDate,
                c.DataLastModUser lastModifiedBy,
                c.DataLastModDateTime lastModificationDate
         from IFC.InkassoSyncSendConstructionCode c join IFC.IndecsInkassoSync s on c.IndecsInkassoSyncID = s.ID
	       where s.TaskID = @p_taskID
    end


    /*returning data for the backend*/
	  select *
    from @table
  end try
  begin catch
    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_correlationID,
                            @p_UserName = @p_userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage


    insert into @table(errorMsg) 
        select @errorMessage errorMsg      

    select *
    from @table
  end catch
end
go

/*Author: Gyenese Katalin
  Create date: 2023.11.10. - DV-1524
  Last modified date: 2023.11.10.
  Description: it returns the INK031_PartyBase webservice fields (for Inkasso synchronization).

  Parameters:
    - @p_taskID: taskID
    - @p_correlationID: the correlationID of the caller
    - @p_userName: the username of the caller
*/
create   procedure [IFC].[INK031_PartyBase](@p_taskID Numeric(16), @p_correlationID NVarChar(200) = null, @p_userName NVarChar(200) = null)
as
begin 
  set NOCOUNT ON
  set XACT_ABORT ON

  /*variables for logging*/
	declare @procedureName nvarchar(100) = 'IFC.INK031_PartyBase', @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for procedure logic*/
  declare @l_tasktype NVarChar(200) = 'TASK_TYPE_DATA_SYNC_ENTITY_INK'

	declare @table table (id NVarChar(200)                        /*PK - ECOLLECT azonosító = CEG.ECOLLECTPARTNERID.  InkassoSyncSendPerson.ExternalPersonID / InkassoSyncSendCompany.ExternalCompanyID*/,
                        title NVarChar(200)                     /*Titulus.  InkassoSyncSendPerson.Title*/,
                        singleFieldValue NVarChar(250)          /*Név. InkassoSyncSendPerson.Title (ha van) + ' ' + InkassoSyncSendPerson.LastName + ' ' + InkassoSyncSendPerson.FirstName / InkassoSyncSendCompany.Name*/,
                        firstName NVarChar(150)                 /*Viselt vezetéknév.  InkassoSyncSendPerson.FirstName*/,
	                      lastName NVarChar(150)                  /*Viselt keresztnév.  InkassoSyncSendPerson.LastName*/,
	                      shortName NVarChar(250)                 /*Cég rövid neve.  InkassoSyncSendCompany.ShortName*/,
	                      nameOnLetters NVarChar(300)             /*Leveleken megjelenő név.  InkassoSyncSendPerson.LastName + ' ' + InkassoSyncSendPerson.FirstName / InkassoSyncSendCompany.Name*/,
	                      legalForm NVarChar(200)                 /*A cég jogi formája. Külső kulcs: JOGIFORMA.  InkassoSyncSendCompany.InkLegalFormCode */,
	                      TEAORCode NVarChar(200)                 /*nincs megfeleltetve, null-t adunk benne*/,
                        chamberMembershipDate Date              /*Kamarai tagság kezdete.  InkassoSyncSendCompany.ChamberMembershipBeginDate*/,
	                      cegkapuShortName NVarChar(250)          /*A cég rövid neve a Cégkapu rendszerben.  InkassoSyncSendCompany.ShortNameCegkapu*/,
                        companyForm NVarChar(250)               /*A cég cégformakódja. Külső kulcs: CEGFORMA.  InkassoSyncSendCompany.InkCompanyFormCode*/,
                        nationality NVarChar(200)               /*Állampolgárság (ISO3).  InkassoSyncSendPerson.InkNationalityCode*/,
	                      deceased NVarChar(200)                  /*Elhunyt jelölő (I/N).  InkassoSyncSendPerson.InkDeceasedCode*/,
                        deceasedDate Date                       /*Elhalálozás dátuma.  InkassoSyncSendPerson.DeceasedDate*/,
                        note NVarChar(4000)                     /*Szöveges megjegyzés a partnerhez.  ???*/,
                        Email NVarChar(100)                     /*Email cím.  InkassoSyncSendPerson.Email / InkassoSyncSendCompany.Email*/,
	                      maidenName NVarChar(40)                 /*Leánykori név. InkassoSyncSendPerson.MaidenName*/,
                        maidenLastName NVarChar(150)            /*Születéskori név keresztnév.  InkassoSyncSendPerson.BirthLastName*/,
                        maidenFirstName NVarChar(150)           /*Születéskori név vezetéknév.  InkassoSyncSendPerson.BirthFirstName*/,
                        birthPlace NVarChar(100)                /*Születési hely.  InkassoSyncSendPerson.BirthPlace*/,
	                      birthDate Date                          /*Születési dátum.  InkassoSyncSendPerson.BirthDate*/,
                        MotherName NVarChar(40)                 /*Anyja neve.  InkassoSyncSendPerson.MothersFullName*/,
	                      MotherLastName NVarChar(150)            /*Anyja neve keresztnév.  InkassoSyncSendPerson.MothersLastName*/,
	                      MotherFirstName NVarChar(150)           /*Anyja neve vezetéknév.  InkassoSyncSendPerson.MothersFirstName*/,
                        IDCard NVarChar(20)                     /*Személyazonosító irat száma.  InkassoSyncSendPerson.IDNumber*/,
                        passportNumber NVarChar(15)             /*Útlevélszám.  InkassoSyncSendPerson.PassportNumber*/,
	                      driversLicense NVarChar(15)             /*Jogosítvány száma.  InkassoSyncSendPerson.LicenseNumber*/,
                        pensionID NVarChar(20)                  /*Nyugdíj törzsszám.  InkassoSyncSendPerson.RetiredIDNumber*/,
                        companyRegistrationNumber NVarChar(50)  /*Cégjegyzékszám.  InkassoSyncSendCompany.RegistrationNr*/,
                        taxCode NVarChar(20)                    /*Adószám.  InkassoSyncSendCompany.TaxNr*/,
                        LEICode NVarChar(100)                   /*nincs megfeleltetve, null-t adunk benne*/,
                        ubankID NVarChar(30)                    /*ügyfél banki azonosítója.  InkassoSyncSendPerson.PartyBankID / InkassoSyncSendCompany.PartyBankID*/,
	                      originalID NVarChar(200)                /*Forrásrendszeri azonosító.  InkassoSyncSendPerson.SourceID / InkassoSyncSendCompany.SourceID*/,
	                      CREFO NVarChar(16)                      /*CEGREGISZTER szám.  InkassoSyncSendPerson.Crefo / InkassoSyncSendCompany.Crefo*/,
                        customerNumber NVarChar(50)             /*Ügyfélszám (GWB).  InkassoSyncSendPerson.GWBCustomerNr / InkassoSyncSendCompany.GWBCustomerNr*/,
                        UrbisID NVarChar(8)                     /*A partner URBIS azonosítója.  InkassoSyncSendPerson.URBISID / InkassoSyncSendCompany.URBISID*/,
                        GDPRPredeletionMarkDate DateTime        /*Azt a dátumot (YYYY.MM.DD. HH24:MI:SS) jelöli amikor a partnert GDPR előtörölni kell majd.  InkassoSyncSendPerson.GDPRPreDeleteMarkingDateTime*/,
                        GDPRPredeletionDate DateTime            /*A GDPR előtörlés dátuma (YYYY.MM.DD. HH24:MI:SS).  InkassoSyncSendPerson.GDPRPreDeleteDateTime*/,
	                      GDPRDepersonalizationDate DateTime      /*GDRP elévülés adattörlés dátuma.  InkassoSyncSendPerson.GDPRDepersonalizationDateTime*/,
                        lastModificationDate DateTime           /*Utolsó módosítás dátuma.  InkassoSyncSendPerson.DataLastModDate / InkassoSyncSendCompany.DataLastModDateTime*/,
                        lastModifiedBy NVarChar(200)            /*Melyik user módosította utoljára.  InkassoSyncSendPerson.DataLastModUser /  InkassoSyncSendCompany.DataLastModUser*/,
                        createdBy NVarChar(200)                 /*Létrehozó user.  InkassoSyncSendPerson.DataCreationUser / InkassoSyncSendCompany.DataCreationUser*/,
                        creationDate DateTime                   /*Létrehozás dátuma.  InkassoSyncSendPerson.DataCreationDate / InkassoSyncSendCompany.DataCreationDateTime*/,
                        VersionDate DateTime                    /*Mikori a partnerverzió dátuma ? (KÜT).  InkassoSyncSendPerson.DataVersionDateTime / InkassoSyncSendCompany.DataVersionDateTime*/,
                        VersionNumber NVarChar(22)              /*Melyik partnerverzió ez? (KÜT).  InkassoSyncSendPerson.DataVersionNr / InkassoSyncSendCompany.DataVersionNr*/,
                        errorMsg NVarChar(max)                  /*Hibaüzenet a backendnek.*/  
                       )



  begin try
    if not exists(select *
                  from ORG.Task t
                  where t.ID = @p_taskID
                    and t.taskTypeID = @l_taskType
                 )
    begin
      insert into @table(errorMsg) 
        select Concat('The @p_taskID parameter is empty or not a task of type "', @l_tasktype, '".') errorMsg
    end
    else /*@p_taskID is valid*/
    begin
      /*Person*/
      if exists(select *
                from IFC.InkassoSyncSendPerson p join IFC.IndecsInkassoSync s on p.IndecsInkassoSyncID = s.ID
                where s.TaskID = @p_taskID
               )
      begin
        /*mapping checks*/
        exec IFC.HandleSendInkassoSyncMappings @syncType = 'Person', 
                                               @taskID = @p_taskID, 
                                               @correlationID = @p_correlationID, 
                                               @userName = @p_userName


        /*read data*/  
        insert into @table (id                         /*PK - ECOLLECT azonosító = CEG.ECOLLECTPARTNERID.  InkassoSyncSendPerson.ExternalPersonID*/,
                            title                      /*Titulus.  InkassoSyncSendPerson.Title*/,
                            singleFieldValue           /*Név. InkassoSyncSendPerson.Title (ha van) + ' ' + InkassoSyncSendPerson.LastName + ' ' + InkassoSyncSendPerson.FirstName*/,      
                            firstName                  /*Viselt vezetéknév.  InkassoSyncSendPerson.FirstName*/,
	                          lastName                   /*Viselt keresztnév.  InkassoSyncSendPerson.LastName*/,
	                          NameOnLetters              /*Leveleken megjelenő név.  InkassoSyncSendPerson.LastName + ' ' + InkassoSyncSendPerson.FirstName*/,
	                          nationality                /*Állampolgárság (ISO3).  InkassoSyncSendPerson.InkNationalityCode*/,
	                          deceased                   /*Elhunyt jelölő (I/N).  InkassoSyncSendPerson.InkDeceasedCode*/,
                            deceasedDate               /*Elhalálozás dátuma.  InkassoSyncSendPerson.DeceasedDate*/,
                            note                       /*Szöveges megjegyzés a partnerhez.  ???*/,
                            Email                      /*Email cím.  InkassoSyncSendPerson.Email*/,
	                          maidenName                 /*Leánykori név. InkassoSyncSendPerson.MaidenName*/,
                            maidenLastName             /*Születéskori név keresztnév.  InkassoSyncSendPerson.BirthLastName*/,
                            maidenFirstName            /*Születéskori név vezetéknév.  InkassoSyncSendPerson.BirthFirstName*/,
                            birthPlace                 /*Születési hely.  InkassoSyncSendPerson.BirthPlace*/,
	                          birthDate                  /*Születési dátum.  InkassoSyncSendPerson.BirthDate*/,
                            MotherName                 /*Anyja neve.  InkassoSyncSendPerson.MothersFullName*/,
	                          MotherLastName             /*Anyja neve keresztnév.  InkassoSyncSendPerson.MothersLastName*/,
	                          MotherFirstName            /*Anyja neve vezetéknév.  InkassoSyncSendPerson.MothersFirstName*/,
                            IDCard                     /*Személyazonosító irat száma.  InkassoSyncSendPerson.IDNumber*/,
                            passportNumber             /*Útlevélszám.  InkassoSyncSendPerson.PassportNumber*/,
	                          driversLicense             /*Jogosítvány száma.  InkassoSyncSendPerson.LicenseNumber*/,
                            pensionID                  /*Nyugdíj törzsszám.  InkassoSyncSendPerson.RetiredIDNumber*/,
                            LEICode                    /*nincs megfeleltetve, null-t adunk benne*/,
                            ubankID                    /*ügyfél banki azonosítója.  InkassoSyncSendPerson.PartyBankID*/,
	                          originalID                 /*Forrásrendszeri azonosító.  InkassoSyncSendPerson.SourceID*/,
	                          CREFO                      /*CEGREGISZTER szám.  InkassoSyncSendPerson.Crefo*/,
                            customerNumber             /*Ügyfélszám (GWB).  InkassoSyncSendPerson.GWBCustomerNr */,
                            UrbisID                    /*A partner URBIS azonosítója.  InkassoSyncSendPerson.URBISID*/,
                            GDPRPredeletionMarkDate    /*Azt a dátumot (YYYY.MM.DD. HH24:MI:SS) jelöli amikor a partnert GDPR előtörölni kell majd.  InkassoSyncSendPerson.GDPRPreDeleteMarkingDateTime*/,
                            GDPRPredeletionDate        /*A GDPR előtörlés dátuma (YYYY.MM.DD. HH24:MI:SS).  InkassoSyncSendPerson.GDPRPreDeleteDateTime*/,
	                          GDPRDepersonalizationDate  /*GDRP elévülés adattörlés dátuma.  InkassoSyncSendPerson.GDPRDepersonalizationDateTime*/,
                            lastModificationDate       /*Utolsó módosítás dátuma.  InkassoSyncSendPerson.DataLastModDateTime*/,
                            lastModifiedBy             /*Melyik user módosította utoljára.  InkassoSyncSendPerson.DataLastModUser*/,
                            createdBy                  /*Létrehozó user.  InkassoSyncSendPerson.DataCreationUser */,
                            creationDate               /*Létrehozás dátuma.  InkassoSyncSendPerson.DataCreationDateTime*/,
                            VersionDate                /*Mikori a partnerverzió dátuma ? (KÜT).  InkassoSyncSendPerson.DataVersionDateTime*/,
                            VersionNumber              /*Melyik partnerverzió ez? (KÜT).  InkassoSyncSendPerson.DataVersionNr*/
                           )
         select p.ExternalPersonID id,
                p.title,
                Concat(Case when IsNull(p.title, '') <> '' then Concat(p.Title, ' ') else '' end, p.LastName, ' ', p.FirstName) singleFieldValue,
                p.firstName,
	              p.lastName,
	              Concat(p.LastName, ' ', p.FirstName) NameOnLetters,
	              p.InkNationalityCode nationality,
	              p.InkDeceasedCode deceased,
                p.deceasedDate,
                null note                         /*nincs rá mező*/,
                p.Email,
	              p.maidenName,
                p.BirthLastName maidenLastName,
                p.BirthFirstName maidenFirstName,
                p.birthPlace,
	              p.birthDate,
                p.MothersFullName MotherName,
	              p.MothersFirstName MotherFirstName,
	              p.MothersLastName MotherLastName,
                p.IDNumber IDCard,
                p.passportNumber,
	              p.LicenseNumber driversLicense,
                p.RetiredIDNumber pensionID,
                null LEICode                      /*nincs rá mező*/,
                p.PartyBankID ubankID,
	              p.SourceID originalID,
	              p.CREFO,
                p.GWBCustomerNr customerNumber,
                p.UrbisID,
                p.GDPRPreDeleteMarkingDateTime GDPRPredeletionMarkDate,
                p.GDPRPreDeleteDateTime GDPRPredeletionDate,
	              p.GDPRDepersonalizationDateTime GDPRDepersonalizationDate,
                p.DataLastModDateTime lastModificationDate,
                p.DataLastModUser lastModifiedBy,
                p.DataCreationUser createdBy,
                p.DataCreationDateTime creationDate,
                p.DataVersionDateTime VersionDate,
                p.DataVersionNr VersionNumber
         from IFC.InkassoSyncSendPerson p join IFC.IndecsInkassoSync s on p.IndecsInkassoSyncID = s.ID
	       where s.TaskID = @p_taskID 
      end
      /*Company*/
      else 
      begin
        /*mapping checks*/
        exec IFC.HandleSendInkassoSyncMappings @syncType = 'Company', 
                                               @taskID = @p_taskID, 
                                               @correlationID = @p_correlationID, 
                                               @userName = @p_userName


        /*read data*/  
        insert into @table (id                        /*PK - ECOLLECT azonosító = CEG.ECOLLECTPARTNERID.  InkassoSyncSendCompany.ExternalCompanyID*/,
                            singleFieldValue          /*Cég neve. InkassoSyncSendCompany.Name*/,
                            shortName                 /*Cég rövid neve.  InkassoSyncSendCompany.ShortName*/,
	                          NameOnLetters             /*Leveleken megjelenő név.  InkassoSyncSendCompany.Name*/,
	                          LegalForm                 /*A cég jogi formája. Külső kulcs: JOGIFORMA.  InkassoSyncSendCompany.InkLegalFormCode */,
	                          TEAORCode                 /*nincs rá mező*/,
                            chamberMembershipDate     /*Kamarai tagság kezdete.  InkassoSyncSendCompany.ChamberMembershipBeginDate*/,
	                          cegkapuShortName          /*A cég rövid neve a Cégkapu rendszerben.  InkassoSyncSendCompany.ShortNameCegkapu*/,
                            companyForm               /*A cég cégformakódja. Külső kulcs: CEGFORMA.  InkassoSyncSendCompany.InkCompanyFormCode*/,
                            Email                     /*Email cím.  InkassoSyncSendCompany.Email*/,
	                          companyRegistrationNumber /*Cégjegyzékszám.  InkassoSyncSendCompany.RegistrationNr*/,
                            taxCode                   /*Adószám.  InkassoSyncSendCompany.TaxNr*/,
                            LEICode                   /*nincs rá mező*/,
                            ubankID                   /*ügyfél banki azonosítója.  InkassoSyncSendCompany.PartyBankID*/,
	                          originalID                /*Forrásrendszeri azonosító.  InkassoSyncSendCompany.SourceID*/,
	                          CREFO                     /*CEGREGISZTER szám.  InkassoSyncSendCompany.Crefo*/,
                            customerNumber            /*Ügyfélszám (GWB).  InkassoSyncSendCompany.GWBCustomerNr*/,
                            UrbisID                   /*A partner URBIS azonosítója.  InkassoSyncSendCompany.URBISID*/,
                            lastModificationDate      /*Utolsó módosítás dátuma.  InkassoSyncSendCompany.DataLastModDateTime*/,
                            lastModifiedBy            /*Melyik user módosította utoljára.  InkassoSyncSendCompany.DataLastModUser*/,
                            createdBy                 /*Létrehozó user.  InkassoSyncSendCompany.DataCreationUser*/,
                            creationDate              /*Létrehozás dátuma.  InkassoSyncSendCompany.DataCreationDateTime*/,
                            VersionDate               /*Mikori a partnerverzió dátuma ? (KÜT).  InkassoSyncSendCompany.DataVersionDateTime*/,
                            VersionNumber             /*Melyik partnerverzió ez? (KÜT).   InkassoSyncSendCompany.DataVersionNr*/
                           )

         select c.ExternalCompanyID id,
                c.Name singleFieldValue,
                c.shortName,
	              c.Name NameOnLetters,
	              NullIf(c.InkLegalFormCode, '') LegalForm,
	              null TEAORCode                 /*nincs rá mező*/,
                c.ChamberMembershipBeginDate chamberMembershipDate,
	              c.ShortNameCegkapu cegkapuShortName,
                NullIf(c.InkCompanyFormCode, '') companyForm,
                c.Email,
	              c.RegistrationNr companyRegistrationNumber,
                c.TaxNr taxCode,
                null LEICode                   /*nincs rá mező*/,
                c.PartyBankID ubankID,
	              c.SourceID originalID,
	              c.CREFO,
                c.GWBCustomerNr customerNumber,
                c.UrbisID,
                c.DataLastModDateTime lastModificationDate,
                c.DataLastModUser lastModifiedBy,
                c.DataCreationUser createdBy,
                c.DataCreationDateTime creationDate,
                c.DataVersionDateTime VersionDate,
                c.DataVersionNr VersionNumber 
         from IFC.InkassoSyncSendCompany c join IFC.IndecsInkassoSync s on c.IndecsInkassoSyncID = s.ID
	       where s.TaskID = @p_taskID 
      end
    end


    /*returning data for the backend*/
	  select *
    from @table
  end try
  begin catch
    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_correlationID,
                            @p_UserName = @p_userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage


    insert into @table(errorMsg) 
        select @errorMessage errorMsg      

    select *
    from @table
  end catch
end
go

create   procedure [IFC].[INK032_PartyAddr](@p_taskID Numeric(16), @p_correlationID NVarChar(200) = null, @p_userName NVarChar(200) = null)
as
begin 
  set NOCOUNT ON
  set XACT_ABORT ON

  /*variables for logging*/
	declare @procedureName nvarchar(100) = 'IFC.GetINK0032_PartyAddr', @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for procedure logic*/
  declare @l_tasktype NVarChar(200) = 'TASK_TYPE_DATA_SYNC_ENTITY_ADDRESS_INK'

  declare @table table(kutAddressId Numeric(16)             /*A KÜT-beli azonosító. InkassoSyncSendAddress.AddressID*/, 
                       kutPartyID NVarChar(200)             /*A címhez tartozó Entity KÜT-ös azonosítója. InkassoSyncSendAddress.ExternalEntityID*/,
                       activeFlag NVarChar(200)             /*Aktív a cím? I: igen - N: nem. InkassoSyncSendAddress.InkStatusCode*/, 
                       defaultMailingAddress NVarChar(200)  /*Ez a default levelezési cím? I: igen - N: nem. InkassoSyncSendAddress.InkMailingAddressCode*/,
                       postalAddressFlag NVarChar(200)      /*Postacím flag. InkassoSyncSendAddress.InkPostalAddressCode*/,
                       addressValidFrom Date                /*Mikortól érvényes az adott cím. InkassoSyncSendAddress.ValidFrom*/,
                       unsuccessfulDelivery NVarChar(200)   /*történt-e már sikertelen kézbesítés erre a címre? InkassoSyncSendAddress.UnsuccessfulDeliveryCode*/,
                       addressTypeId NVarChar(200)          /*Külső kulcs: SZOTAR, TIPUS=CIMTIPUSID.  InkassoSyncSendAddress.InkAddressTypeCode*/,
                       countryName NVarChar(200)            /*A címhez tartozó ország neve. InkassoSyncSendAddress.CountryText*/, 
                       countryCode NVarChar(200)            /*A címhez tartozó ország kódja. InkassoSyncSendAddress.InkCountryCode*/,
                       postalCode NVarChar(200)             /*A címhez tartozó irányítószám. InkassoSyncSendAddress.ZipCode*/,
                       municipalityName NVarChar(200)       /*A címhez tartozó helység neve. InkassoSyncSendAddress.Settlement*/,
                       streetName NVarChar(200)             /*A címhez tartozó közterület neve (gyakran itt található az utcanév, házszám, emelet, lakásszám, stb. is). InkassoSyncSendAddress.PublicPlaceName*/,
                       streetType NVarChar(200)             /*A címhez tartozó közterület jellege. InkassoSyncSendAddress.PublicPlaceTypeText*/,
                       streetNumber NVarChar(200)           /*A címhez tartozó házszám. InkassoSyncSendAddress.HouseNr*/,
                       building NVarChar(50)                /*A címhez tartozó épület. InkassoSyncSendAddress.Building*/,
                       staircase NVarChar(10)               /*A címhez tartozó emelet. InkassoSyncSendAddress.Staircase*/,
                       floor NVarChar(10)                   /*A címhez tartozó emelet. InkassoSyncSendAddress.Floor*/,
                       door NVarChar(10)                    /*A címhez tartozó ajtó. InkassoSyncSendAddress.Door*/,
                       remark NVarChar(max)                 /*Megjegyzés. InkassoSyncSendAddress.Description*/,
                       createdBy NVarChar(200)              /*Létrehozó azonosítója. InkassoSyncSendAddress.DataCreationUser*/,
                       creationDate DateTime                /*Létrehozás dátuma. InkassoSyncSendAddress.DataCreationDateTime*/,
                       lastModifiedBy NVarChar(200)         /*Módosító azonosítója. InkassoSyncSendAddress.DataLastModUser*/,
                       lastModificationDate DateTime        /*Utolsó módosítás dátuma. InkassoSyncSendAddress.DataLastModDateTime*/,
                       errorMsg NVarChar(max)               /*Hibaüzenet a backendnek.*/
                      )
  
  begin try
    if not exists(select *
                  from ORG.Task t
                  where t.ID = @p_taskID
                    and t.taskTypeID = @l_taskType
                 )
    begin
      insert into @table(errorMsg) 
        select Concat('The @p_taskID parameter is empty or not a task of type "', @l_tasktype, '".') errorMsg
    end
    else /*@p_taskID is valid*/
    begin
      /*mapping checks*/
      exec IFC.HandleSendInkassoSyncMappings @syncType = 'Address', 
                                             @taskID = @p_taskID, 
                                             @correlationID = @p_correlationID, 
                                             @userName = @p_userName


      /*read data*/  
      insert into @table(kutAddressId            /*A KÜT-beli azonosító. InkassoSyncSendAddress.AddressID*/, 
                         kutPartyID              /*A címhez tartozó Entity KÜT-ös azonosítója. InkassoSyncSendAddress.ExternalEntityID*/,    
                         activeFlag              /*Aktív a cím? I: igen - N: nem. InkassoSyncSendAddress.InkStatusCode*/, 
                         defaultMailingAddress   /*Ez a default levelezési cím? I: igen - N: nem. InkassoSyncSendAddress.InkMailingAddressCode*/,
                         postalAddressFlag       /*Postacím flag. InkassoSyncSendAddress.InkPostalAddressCode*/,
                         addressValidFrom        /*Mikortól érvényes az adott cím. InkassoSyncSendAddress.ValidFrom*/,
                         unsuccessfulDelivery    /*történt-e már sikertelen kézbesítés erre a címre? InkassoSyncSendAddress.UnsuccessfulDeliveryCode*/,
                         addressTypeId           /*Külső kulcs: SZOTAR, TIPUS=CIMTIPUSID.  InkassoSyncSendAddress.InkAddressTypeCode*/,
                         countryName             /*A címhez tartozó ország neve. InkassoSyncSendAddress.CountryText*/, 
                         countryCode             /*A címhez tartozó ország kódja. InkassoSyncSendAddress.InkCountryCode*/,
                         postalCode              /*A címhez tartozó irányítószám. InkassoSyncSendAddress.ZipCode*/,
                         municipalityName        /*A címhez tartozó helység neve. InkassoSyncSendAddress.Settlement*/,
                         streetName              /*A címhez tartozó közterület neve (gyakran itt található az utcanév, házszám, emelet, lakásszám, stb. is). InkassoSyncSendAddress.PublicPlaceName*/,
                         streetType              /*A címhez tartozó közterület jellege. InkassoSyncSendAddress.PublicPlaceTypeText*/,
                         streetNumber            /*A címhez tartozó házszám. InkassoSyncSendAddress.HouseNr*/,
                         building                /*A címhez tartozó épület. InkassoSyncSendAddress.Building*/,
                         staircase               /*A címhez tartozó emelet. InkassoSyncSendAddress.Staircase*/,
                         floor                   /*A címhez tartozó emelet. InkassoSyncSendAddress.Floor*/,
                         door                    /*A címhez tartozó ajtó. InkassoSyncSendAddress.Door*/,
                         remark                  /*Megjegyzés. InkassoSyncSendAddress.Description*/,
                         createdBy               /*Létrehozó azonosítója. InkassoSyncSendAddress.DataCreationUser*/,
                         creationDate            /*Létrehozás dátuma. InkassoSyncSendAddress.DataCreation*/,
                         lastModifiedBy          /*Módosító azonosítója. InkassoSyncSendAddress.DataLastModUser*/,
                         lastModificationDate    /*Utolsó módosítás dátuma. InkassoSyncSendAddress.DataLastMod*/
                        )
        select a.AddressID kutAddressId,
               a.ExternalEntityID kutPartyID,
               a.InkStatusCode activeFlag,
               a.InkMailingAddressCode defaultMailingAddress,
               a.InkPostalAddressCode postalAddressFlag,
               a.ValidFrom addressValidFrom,
               a.UnsuccessfulDeliveryCode unsuccessfulDelivery,
               a.InkAddressTypeCode addressTypeId,
               a.CountryText countryName, 
               a.InkCountryCode countryCode,
               a.ZipCode postalCode,
               a.Settlement municipalityName,
               a.PublicPlaceName streetName,
               a.PublicPlaceTypeText streetType,
               a.HouseNr streetNumber,
               a.building,
               a.staircase,
               a.floor,
               a.door,
               a.Description remark,
               a.DataCreationUser createdBy,
               a.DataCreationDateTime creationDate,
               a.DataLastModUser lastModifiedBy,
               a.DataLastModDateTime lastModificationDate
        from IFC.InkassoSyncSendAddress a join IFC.IndecsInkassoSync s on a.IndecsInkassoSyncID = s.ID
	      where s.TaskID = @p_taskID
    end


    /*returning data for the backend*/
	  select *
    from @table
  end try
  begin catch
    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_correlationID,
                            @p_UserName = @p_userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage


    insert into @table(errorMsg) 
        select @errorMessage errorMsg      

    select *
    from @table
  end catch
end
go

/*Author: Gyenese Katalin
  Create date: 2023.11.10. - DV-1524
  Last modified date: 2023.11.10.
  Description: it returns the INK033_PhoneNumber webservice fields (for Inkasso synchronization).

  Parameters:
    - @p_taskID: taskID
    - @p_correlationID: the correlationID of the caller
    - @p_userName: the username of the caller
*/
CREATE     procedure [IFC].[INK033_PhoneNumber](@p_taskID Numeric(16), @p_correlationID NVarChar(200) = null, @p_userName NVarChar(200) = null)
as
begin 
  set NOCOUNT ON
  set XACT_ABORT ON

  /*variables for logging*/
	declare @procedureName nvarchar(100) = 'IFC.INK033_PhoneNumber', @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for procedure logic*/
  declare @l_tasktype NVarChar(200) = 'TASK_TYPE_DATA_SYNC_ENTITY_PHONE_INK'

  declare @table table(kutPhoneId Numeric(16)	             /*Küt telefonszám ID. InkassoSyncSendPhone.ContactID*/,
                       kutPartyID NVarChar(200)            /*A címhez tartozó Entity KÜT-ös azonosítója. InkassoSyncSendPhone.ExternalEntityID*/,
                       status NVarChar(200)                /*Mi a státusza a telefonszámnak. InkassoSyncSendPhone.InkStatusCode*/,
                       flag NVarChar(200)	                 /*A telefonszámok minősítését tartalmazó mező t1-t9. InkassoSyncSendPhone.Classification*/,
                       phoneNumberType NVarChar(200)	     /*Milyen típusú telefonszám? InkassoSyncSendPhone.InkContactTypeCode*/,
                       available NVarChar(200)	           /*Validált telefonszám-e. InkassoSyncSendPhone.ValidatedCode*/,
                       singleFieldValue NVarChar(100)	     /*Telefonszám (egyben). InkassoSyncSendPhone.Prefix + InkassoSyncSendPhone.Contact*/,
                       countryCode NVarChar(200)	         /*Melyik országhoz tartozik? InkassoSyncSendPhone.CountryCode	*/,
                       prefix NVarChar(10)	               /*Körzet/mobil előtag. InkassoSyncSendPhone.Prefix	*/,
                       lineNumber NVarChar(100)	           /*Telefonszám (prefix nélkül). InkassoSyncSendPhone.Contact*/,
                       extension NVarChar(50)	             /*Mellék. InkassoSyncSendPhone.Extension*/,
                       originalSource NVarChar(200)	       /*Honnan származik a telfonszám? InkassoSyncSendPhone.InkDataOriginCode*/,
                       originalSourceDate Date             /*Mikori dátumú a telefonszám? InkassoSyncSendPhone.ValidFrom*/,
                       info	NVarChar(max)	                 /*Van-e a telefonszámhoz valamilyen egyéb információ? InkassoSyncSendPhone.Comments*/,
                       infoDate	Date                       /*Egyéb információ dátuma? InkassoSyncSendPhone.ValidFrom*/,
                       note	NVarChar(max)	                 /*Megjegyzés. InkassoSyncSendPhone.Comments*/,
                       maskingType NVarChar(200)	         /*Arra találtuk ki, hogy jelöljük melyik maszkoló eljárás hajtotta végre a maszkolást.
                                                             (1 - GDPR előtörlés, 2 - Jogalap megszűnés). Jelenleg csak a Jogalapváltásos maszkolás tölti.". 
                                                             InkassoSyncSendPhone.MaskingModeCode	
                                                           */,
                       maskingDate DateTime                 /*A telefonszám maszkolásának dátuma (YYYY.MM.DD HH24:MI:SS).
                                                             Jelenleg csak a Jogalapváltásos maszkolás tölti.
                                                             InkassoSyncSendPhone.MaskingDateTime
                                                           */,
                       manageable	NVarChar(200)	           /*Annak jelölése, hogy a telefonszám kezeléshez hozzájárul-t a partner (I/N).	InkassoSyncSendPhone.ContributionCode	*/,
                       manageableDate	DateTime             /*A hozzájárulás/hozzájárulás visszavonásának dátuma (YYYY.MM.DD HH24:MI:SS). InkassoSyncSendPhone.ContributionDateTime*/,
                       manageableCancellationDate	DateTime /*Annak a dátuma amikor a telefonszámot mindenképp törölni kell (YYYY.MM.DD HH24:MI:SS). InkassoSyncSendPhone.ContributionCancellationDateTime*/,
                       createdBy NVarChar(200)             /*Létrehozó azonosítója. InkassoSyncSendPhone.DataCreationUser*/,
                       creationDate DateTime               /*Létrehozás dátuma. InkassoSyncSendPhone.DataCreationDateTime*/,
                       lastModifiedBy NVarChar(200)        /*Módosító azonosítója. InkassoSyncSendPhone.DataLastModUser*/,
                       lastModificationDate DateTime       /*Utolsó módosítás dátuma. InkassoSyncSendPhone.DataLastModDateTime*/,
                       errorMsg NVarChar(max)              /*Hibaüzenet a backendnek.*/
                      )

  begin try
    if not exists(select *
                  from ORG.Task t
                  where t.ID = @p_taskID
                    and t.taskTypeID = @l_taskType
                 )
    begin
      insert into @table(errorMsg) 
        select Concat('The @p_taskID parameter is empty or not a task of type "', @l_tasktype, '".') errorMsg
    end
    else /*@p_taskID is valid*/
    begin
      /*mapping checks*/
      exec IFC.HandleSendInkassoSyncMappings @syncType = 'Phone', 
                                             @taskID = @p_taskID, 
                                             @correlationID = @p_correlationID, 
                                             @userName = @p_userName
 

      insert into @table( kutPhoneId 	                  /*Küt telefonszám ID. InkassoSyncSendPhone.ContactID*/,
                          kutPartyID                    /*A címhez tartozó Entity KÜT-ös azonosítója. InkassoSyncSendPhone.ExternalEntityID*/,    
                          status                        /*Mi a státusza a telefonszámnak. InkassoSyncSendPhone.InkStatusCode*/,
                          flag 	                        /*A telefonszámok minősítését tartalmazó mező t1-t9. InkassoSyncSendPhone.Classification*/,
                          phoneNumberType 	            /*Milyen típusú telefonszám? InkassoSyncSendPhone.InkContactTypeCode*/,
                          available 	                  /*Validált telefonszám-e. InkassoSyncSendPhone.ValidatedCode*/,
                          singleFieldValue 	            /*Telefonszám (egyben). InkassoSyncSendPhone.Prefix + InkassoSyncSendPhone.Contact*/,
                          countryCode 	                /*Melyik országhoz tartozik? InkassoSyncSendPhone.CountryCode	*/,
                          prefix 	                      /*Körzet/mobil előtag. InkassoSyncSendPhone.Prefix	*/,
                          lineNumber 	                  /*Telefonszám. InkassoSyncSendPhone.Contact	*/,
                          extension 	                  /*Mellék. InkassoSyncSendPhone.Extension*/,
                          originalSource 	              /*Honnan származik a telfonszám? InkassoSyncSendPhone.InkDataOriginCode*/,
                          originalSourceDate            /*Mikori dátumú a telefonszám? InkassoSyncSendPhone.ValidFrom*/,
                          info		                      /*Van-e a telefonszámhoz valamilyen egyéb információ? InkassoSyncSendPhone.Comments*/,
                          infoDate	                    /*Egyéb információ dátuma? InkassoSyncSendPhone.ValidFrom*/,
                          note		                      /*Megjegyzés. InkassoSyncSendPhone.Comments*/,
                          maskingType 	                /*Arra találtuk ki, hogy jelöljük melyik maszkoló eljárás hajtotta végre a maszkolást.
                                                          (1 - GDPR előtörlés, 2 - Jogalap megszűnés). Jelenleg csak a Jogalapváltásos maszkolás tölti.". 
                                                          InkassoSyncSendPhone.MaskingModeCode	
                                                        */,
                          maskingDate                   /*A telefonszám maszkolásának dátuma (YYYY.MM.DD HH24:MI:SS).
                                                          Jelenleg csak a Jogalapváltásos maszkolás tölti.
                                                          InkassoSyncSendPhone.MaskingDateTime
                                                        */,
                          manageable		                /*Annak jelölése, hogy a telefonszám kezeléshez hozzájárul-t a partner (I/N).	InkassoSyncSendPhone.ContributionCode	*/,
                          manageableDate	              /*A hozzájárulás/hozzájárulás visszavonásának dátuma (YYYY.MM.DD HH24:MI:SS). InkassoSyncSendPhone.ContributionDateTime	*/,
                          manageableCancellationDate    /*Annak a dátuma amikor a telefonszámot mindenképp törölni kell (YYYY.MM.DD HH24:MI:SS). InkassoSyncSendPhone.ContributionCancellationDateTime*/,
                          createdBy                     /*Létrehozó azonosítója. InkassoSyncSendPhone.DataCreationUser*/,
                          creationDate                  /*Létrehozás dátuma. InkassoSyncSendPhone.DataCreationDateTime*/,
                          lastModifiedBy                /*Módosító azonosítója. InkassoSyncSendPhone.DataLastModUser*/,
                          lastModificationDate          /*Utolsó módosítás dátuma. InkassoSyncSendPhone.DataLastModDateTime*/
                        )
        select p.ContactID kutPhoneId,
               p.ExternalEntityID kutPartyID,
               p.InkStatusCode status,
               p.Classification flag,
               p.InkContactTypeCode phoneNumberType,
               p.ValidatedCode available,
               Concat(p.prefix, p.Contact) singleFieldValue,
               p.countryCode,
               p.prefix,
               p.Contact lineNumber,
               p.extension,
               p.InkDataOriginCode originalSource,
               p.ValidFrom originalSourceDate,
               p.Comments info,
               p.ValidFrom infoDate,
               p.Comments note,
               p.MaskingModeCode maskingType,
               p.maskingDateTime,
               p.ContributionCode manageable,
               p.ContributionDateTime manageableDate,
               p.ContributionCancellationDateTime manageableCancellationDate,
               p.DataCreationUser createdBy,
               p.DataCreationDateTime creationDate,
               p.DataLastModUser lastModifiedBy,
               p.DataLastModDateTime lastModificationDate
        from IFC.InkassoSyncSendPhone p join IFC.IndecsInkassoSync s on p.IndecsInkassoSyncID = s.ID
	      where s.TaskID = @p_taskID
    end


    /*returning data for the backend*/
	  select *
    from @table
  end try
  begin catch
    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_correlationID,
                            @p_UserName = @p_userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage


    insert into @table(errorMsg) 
        select @errorMessage errorMsg      

    select *
    from @table
  end catch
end
go

/*Author: Gyenese Katalin
  Create date: 2023.11.10. - DV-1524
  Last modified date: 2023.11.10.
  Description: it returns the INK034_PartyMap webservice fields (for Inkasso synchronization).

  Parameters:
    - @p_taskID: taskID
    - @p_correlationID: the correlationID of the caller
    - @p_userName: the username of the caller
*/
CREATE   procedure [IFC].[INK034_PartyMap](@p_taskID Numeric(16), @p_correlationID NVarChar(200) = null, @p_userName NVarChar(200) = null)
as
begin 
  set NOCOUNT ON
  set XACT_ABORT ON

  /*variables for logging*/
	declare @procedureName nvarchar(100) = 'IFC.INK034_PartyMap', @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables for procedure logic*/
  declare @l_tasktype NVarChar(200) = 'TASK_TYPE_DATA_SYNC_DEBTOR_INK'

  declare @table table( id Numeric(16)                /*INDECS rendszer partymap id. InkassoSyncSendDebtor.DebtorID*/,
                        IndecsPartyID  Numeric(16)    /*Indecsrendszerazonosító: CEG.ECOLLECTPARTNERID. InkassoSyncSendDebtor.ExternalEntityID*/,
                        InkasszoDealID  Numeric(16)   /*Külső kulcs: UGY.UGYID. InkassoSyncSendDebtor.DebtCaseID*/,
                        PartyMapType NVarChar(200)    /*Külső kulcs: KEZESTIPUS.KEZESTIPUSID. InkassoSyncSendDebtor.InkRoleCode*/,
                        Active NVarChar(200)          /*A kapcsolat aktivitás jelölése értékei: F/T. InkassoSyncSendDebtor.StatusCode alapján*/,  
                        Inactive Date                 /*A dátum jelöli a kapcsolat inaktivitás kezdetét. InkassoSyncSendDebtor.ValidUntil*/,
                        lastModifiedBy NVarChar(200)  /*A módosítást végző felhasználó. InkassoSyncSendDebtor.DataLastModUser*/,
                        lastModificationDate DateTime /*A módosítás dátuma. InkassoSyncSendDebtor.DataLastModDateTime*/,  
                        createdBy NVarChar(200)       /*A létrehozást végző felhasználó. InkassoSyncSendDebtor.DataCreationUser*/,  
                        creationDate DateTime         /*A létrehozás dátuma. InkassoSyncSendDebtor.DataCreationDateTime*/,  
                        errorMsg NVarChar(max)        /*Hibaüzenet a backendnek.*/
                      ) 
  
  begin try
    if not exists(select *
                  from ORG.Task t
                  where t.ID = @p_taskID
                    and t.taskTypeID = @l_taskType
                 )
    begin
      insert into @table(errorMsg) 
        select Concat('The @p_taskID parameter is empty or not a task of type "', @l_tasktype, '".') errorMsg
    end
    else /*@p_taskID is valid*/
    begin
      /*mapping checks*/
      exec IFC.HandleSendInkassoSyncMappings @syncType = 'Debtor', 
                                             @taskID = @p_taskID, 
                                             @correlationID = @p_correlationID, 
                                             @userName = @p_userName

      /*read data*/  
      insert into @table( id                     /*INDECS rendszer partymap id. InkassoSyncSendDebtor.DebtorID*/,
                          IndecsPartyID          /*Indecsrendszerazonosító: CEG.ECOLLECTPARTNERID. InkassoSyncSendDebtor.ExternalEntityID*/,
                          InkasszoDealID         /*Külső kulcs: UGY.UGYID. InkassoSyncSendDebtor.DebtCaseID*/,
                          PartyMapType           /*Külső kulcs: KEZESTIPUS.KEZESTIPUSID. InkassoSyncSendDebtor.InkRoleCode*/,
                          Active                 /*A kapcsolat aktivitás jelölése értékei: F/T. InkassoSyncSendDebtor.StatusCode alapján*/,  
                          Inactive               /*A módosítást végző felhasználó. InkassoSyncSendDebtor.ValidUntil*/,
                          lastModifiedBy         /*A módosítást végző felhasználó. InkassoSyncSendDebtor.DataLastModUser*/,
                          lastModificationDate   /*A módosítás dátuma. InkassoSyncSendDebtor.DataLastModDateTime*/,
                          createdBy              /*A létrehozást végző felhasználó. InkassoSyncSendDebtor.DataCreationUser*/,  
                          creationDate           /*A létrehozás dátuma. InkassoSyncSendDebtor.DataCreationDateTime*/
                         )
        select d.DebtorID id,
               d.ExternalEntityID IndecsPartyID ,
               d.DebtCaseID InkasszoDealID,
               d.InkRoleCode PartyMapType,
               IFC.GetMappedValueInkasso(1 /*Indecs --> Inkasso*/, d.StatusCode, 'VALUESET_DEBTOR_STATUS', null /*@date*/) Active,  
               d.ValidUntil Inactive,
               d.DataLastModUser lastModifiedBy,
               d.DataLastModDateTime lastModificationDateTime,  
               d.DataCreationUser createdBy,  
               d.DataCreationDateTime creationDateTime
        from IFC.InkassoSyncSendDebtor d join IFC.IndecsInkassoSync s on d.IndecsInkassoSyncID = s.ID
	      where s.TaskID = @p_taskID
    end

  
    /*returning data for the backend*/
	  select *
    from @table
  end try
  begin catch
    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_correlationID,
                            @p_UserName = @p_userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage


    insert into @table(errorMsg) 
        select @errorMessage errorMsg      

    select *
    from @table
  end catch
end
go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2022-12-20
-- Last modified date: 2023-02-27
-- Description:	Insert MIS forms from .json files
--                2023.07.25. DV-855: DefaultAction update in FormAction import
--                2023.07.26. ParentCode refresh fix in GEN.Folder
--                2023.07.27. DV-855: IconName update in GEN.Folder   
--                2023.07.28. DV-855: DisableFilterMode refresh in FormFilter import
--                2023.08.02. DV-855: Listingmode refresh + enter handling in SQLtexts
--                2023.08.09. DV-984: FormAction + FormColumn translation  
--                2023.09.05. DV-1105: Deletion
--                2023.09.15. DV-1328: if Mis.Form.SQLText is not provided and the form has listingModes, than the SQLText of the default listingMode is stored in Mis.Form.SQLText 
--                2023.09.25. DV-1376: filling GEN.RootFolder.TableName
--                2023.10.06. DV-1509: handling null translation
--                2023.10.12. DV-1570: more form import error fix 
--                2023.10.26. DV-1620: optional folderID input
-- =============================================
CREATE PROCEDURE [MIS].[InsertFromJsonMis]
	-- Add the parameters for the stored procedure here
	@p_json NVARCHAR(MAX),
  @p_userName NVARCHAR(200) = null /*the username of the caller*/,
  @p_correlationID NVARCHAR(200) = null /*the correlationID of the caller*/,
  @p_folderID Numeric(16, 0) = null /*if provided, the form will be imported to this folder*/

AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'MIS.InsertFromJsonMis'; --Naplózás miatt a tárolt eljárás neve
  DECLARE @l_errorProcedure NVarChar(200), @l_errorNumber int, @l_errorSeverity int, @l_errorState int, @l_errorLine int
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_json NVARCHAR(MAX) = NULL;
	DECLARE @l_system NVARCHAR(50) = NULL;
	DECLARE @l_version NVARCHAR(5) = NULL;
	DECLARE @l_type NVARCHAR(50) = NULL;
	DECLARE @l_itemCount NUMERIC(16) = NULL;
	DECLARE @l_misFormJSON NVARCHAR(MAX) = NULL;
	DECLARE @l_misFormFolderJSON NVARCHAR(MAX) = NULL;
	DECLARE @l_userName NVARCHAR(200) = IsNull(@p_userName, 'admin');
  DECLARE @l_disableFilterMode NVARCHAR(200)
	--A @Forms változói
	DECLARE @l_code NVARCHAR(200) = NULL;
  DECLARE @l_code_prefix NVARCHAR(200) = 'MIS_FORM_';
  DECLARE @l_code_prefix_index Numeric(16, 0) = 0;
	DECLARE @l_translations NVARCHAR(MAX) = NULL;
	DECLARE @l_folders NVARCHAR(MAX) = NULL;
	DECLARE @l_formVersion NVARCHAR(10) = NULL; 
	DECLARE @l_sqlText NVARCHAR(MAX) = NULL;
  DECLARE @l_listingModes NVARCHAR(MAX) = NULL;
  DECLARE @l_filterCatalogFolders NVARCHAR(MAX) = NULL;  /*for MIS.Filter folders*/
	DECLARE @l_filterFolders NVARCHAR(MAX) = NULL; 
	DECLARE @l_filters NVARCHAR(MAX) = NULL; 
	DECLARE @l_filterlowersqltext NVARCHAR(MAX) = NULL; 
	DECLARE @l_filteruppersqltext NVARCHAR(MAX) = NULL; 
	DECLARE @l_columns NVARCHAR(MAX) = NULL; 
	DECLARE @l_actions NVARCHAR(MAX) = NULL;
	--A @Folders változói
	DECLARE @l_folderCode NVARCHAR(200) = NULL;
	DECLARE @l_folderParentCode NVARCHAR(200) = NULL;
  DECLARE @l_folderIconName NVARCHAR(50) = NULL;
	DECLARE @l_folderType NVARCHAR(200) = NULL;
	DECLARE @l_folderRootFolder NVARCHAR(200) = NULL;
	DECLARE @l_folderTranslation NVARCHAR(MAX) = NULL;
  DECLARE @defaultLanguageISO NVarChar(2) = 'HU'
	--A @Filters változói 
	DECLARE @l_filterCode NVARCHAR(200) = NULL;
	DECLARE @l_filterValueSetCodePrefix NVARCHAR(200) = NULL;
	DECLARE @l_filterDefaultType NVARCHAR(200) = NULL;
	DECLARE @l_filterDefaultValue NVARCHAR(MAX) = NULL;
	DECLARE @l_filterOrdNr NUMERIC(16) = NULL;
	DECLARE @l_filterFilterType NVARCHAR(200) = NULL;
  DECLARE @l_filterCatalogSQLStatement NVARCHAR(MAX) = NULL;
  DECLARE @l_filterCatalogLower NVARCHAR(MAX) = NULL;
  DECLARE @l_filterCatalogUpper NVARCHAR(MAX) = NULL;
  DECLARE @l_filterCatalogFilterMode NVARCHAR(200) = NULL;
  DECLARE @l_filterCatalogFolder NVARCHAR(200) = NULL;
  DECLARE @l_filterSQLStatement NVARCHAR(MAX) = NULL;
	DECLARE @l_filterFolder NVARCHAR(200) = NULL;
	DECLARE @l_filterTranslation NVARCHAR(MAX) = NULL;
  DECLARE @l_filterListingModes NVARCHAR(MAX) = NULL;
  --A @FormFilterListingMode változói 
  DECLARE @l_filterListingModeCode NVARCHAR(200) = NULL
	DECLARE @l_filterListingModeSQLStatement NVARCHAR(MAX) = NULL;
	DECLARE @l_filterListingModeLowerSqlText NVARCHAR(MAX) = NULL;
  DECLARE @l_filterListingModeUpperSqlText NVARCHAR(MAX) = NULL;
	--A @Translations változói
	DECLARE @l_translationValueSetPrefixCode NVARCHAR(200) = NULL;
	DECLARE @l_translationCode NVARCHAR(200) = NULL;
	DECLARE @l_translationLanguage NVARCHAR(5) = NULL;
	DECLARE @l_translationText NVARCHAR(200) = NULL;
	--A @Columns változói
	DECLARE @l_columnCode NVARCHAR(200) = NULL;
	DECLARE @l_columnTitle NVARCHAR(200) = NULL;
	DECLARE @l_columnDisplayWidth INTEGER = NULL;
	DECLARE @l_columnAlignment NVARCHAR(200) = NULL;
	DECLARE @l_columnFormatMask NVARCHAR(200) = NULL;
	DECLARE @l_columnOrdNr NUMERIC(16) = NULL;
	DECLARE @l_columnArea NVARCHAR(200) = NULL;
	DECLARE @l_columnAllowedArea NVARCHAR(200) = NULL;
	DECLARE @l_columnColumnVisible NVARCHAR(200) = NULL;
	--Az @Actions változói
	DECLARE @l_actionCode NVARCHAR(200) = NULL;
	DECLARE @l_actionTitle NVARCHAR(200) = NULL;
  DECLARE @l_actionTranslations NVARCHAR(MAX) = NULL;
	DECLARE @l_actionFunctionType NVARCHAR(200) = NULL;
  DECLARE @l_actionDefaultAction NVARCHAR(50) = NULL;
	--GEN.ValueSet változói
	DECLARE @l_valueSetID NUMERIC(16) = NULL;
  DECLARE @l_valueSetIDStr NVarChar(100);
  declare @l_wrongValueSetIDStr NVarChar(100);
	--A GEN.Code változói
	DECLARE @l_codeID NVARCHAR(200) = NULL;
	--A GEN.RootFolder változói
	DECLARE @l_rootFolderID NUMERIC(16) = NULL;
  DECLARE @l_rootFolderIDFilterCatalog NUMERIC(16) = NULL;
	--A GEN.Folder változói
	DECLARE @l_folderID NUMERIC(16) = NULL;
	DECLARE @l_folderParentFolderID NUMERIC(16) = NULL;
	--A MIS.Form változói
	DECLARE @l_formID NUMERIC(16) = NULL;
	DECLARE @l_formObjectID NUMERIC(16) = NULL;
	DECLARE @l_formFolderID NUMERIC(16) = NULL;
	DECLARE @l_formRootFilterFolderID NUMERIC(16) = NULL;
  --A MIS.FormListingMode változói
  DECLARE @l_listingModeCode NVARCHAR(200);
  DECLARE @l_defaultListingModeCode NVARCHAR(200);
  DECLARE @l_listingModeSQLText NVARCHAR(max)
  --A MIS.Filter változói
	DECLARE @l_filterID NUMERIC(16) = NULL;
	--A MIS.FormFilter változói
	DECLARE @l_formFilterID NUMERIC(16) = NULL;
	DECLARE @l_formFilterFolderID NUMERIC(16) = NULL;
	--A MIS.FormColumn változói
	DECLARE @l_formColumnID NUMERIC(16) = NULL;
	--A MIS.FormAction változói
	DECLARE @l_formActionID NUMERIC(16) = NULL;
	
  --Feldolgozás kezdete (kötelező)
  BEGIN TRY
--===========================================================
--BLOCK      : START
--DESCRIPTION: Start procedure
--===========================================================

		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @l_procedureName, 
                           @p_LogMessage = @l_logMsg
			
		PRINT @l_logMsg;

--===========================================================
--BLOCK      : CHECK PARAMS
--DESCRIPTION: Checking parameters
--===========================================================
	  --Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
	  --Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
	  SELECT @l_logMsg = 'Checking parameters... ';
	  exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @l_procedureName, 
                            @p_LogMessage = @l_logMsg
			
	  PRINT @l_logMsg;
			
	  IF COALESCE(@p_json, '') = '' 
			  RAISERROR('The @p_json parameter is compulsory.', 16, 1);
    
    IF ISJSON(@p_json) = 0
        RAISERROR('The @p_json parameter contains an invalid JSON.', 16, 1);

    if @p_folderID is not null
    begin
      if not exists(select *
                    from GEN.Folder o
                    where o.ID = @p_folderID
                   )
      begin
        RAISERROR('The ID in the @p_folderID parameter does not exist.', 16, 1);
      end
    end


--===========================================================
--BLOCK      : PROCESS START
--DESCRIPTION: 
--===========================================================
	  --Feldolgozás kezdetéről naplóbejegyzés (kötelező)
	  --Innen következnek a feldolgozó utasítások, azok naplózása
	  SELECT @l_logMsg = 'Processing...';
	  exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @l_procedureName, 
                            @p_LogMessage = @l_logMsg
			
	  PRINT @l_logMsg;
			
	  SELECT @l_json = @p_json;
		
--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing header data
--===========================================================
    --Fejadatok feldolgozása
    SELECT @l_system = JSON_VALUE(@l_json, '$.header.system'),
		       @l_version = JSON_VALUE(@l_json, '$.header.version'),
		       @l_type = JSON_VALUE(@l_json, '$.header.type'),
           @l_itemCount = CAST(COALESCE(JSON_VALUE(@l_json, '$.header.itemCount'), '0') AS NUMERIC(16));
		
    SELECT @l_logMsg = CONCAT('The value of JSON type: ', @l_type);
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @l_procedureName, 
                            @p_LogMessage = @l_logMsg
			
    PRINT @l_logMsg;
		
    IF @l_system <> 'INDECS'
        RAISERROR( 'System is not INDECS.', 16, 1);
    IF @l_version <> '3'
        RAISERROR( 'Wrong INDECS version.', 16, 1);
    IF @l_type <> 'MIS_FORM'
        RAISERROR( 'Wrong type of JSON file.', 16, 1);
			
    SELECT @l_logMsg = CONCAT('The number of items in MIS JSON: ', @l_itemCount);
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                        @p_UserName = @p_UserName,
                        @p_ServiceName = @l_procedureName, 
                        @p_LogMessage = @l_logMsg
			
    PRINT @l_logMsg;

		
--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Create temporary tables
--===========================================================
			
	  --Ideiglenes táblák létrehozása 
	  declare @Forms table (code NVARCHAR(200),
			                    translations NVARCHAR(MAX),
			                    folders NVARCHAR(MAX),
			                    [version] NVARCHAR(10),
			                    sqlText NVARCHAR(MAX),
                          listingModes NVARCHAR(MAX),
                          filterCatalogFolders NVARCHAR(MAX),
			                    filterFolders NVARCHAR(MAX),
			                    filters NVARCHAR(MAX),
			                    [columns] NVARCHAR(MAX),
			                    actions NVARCHAR(MAX)
		                    )

	  declare @Translations table(valueSetPrefixCode NVARCHAR(200),
			                          code NVARCHAR(200),
			                          language NVARCHAR(5),
			                          text NVARCHAR(200)
	                             )
	  declare @Folders table(code NVARCHAR(200),
                           iconName NVARCHAR(50),
			                     parentCode NVARCHAR(200),
			                     folderType NVARCHAR(200),
			                     rootFolder NVARCHAR(200),
			                     translations NVARCHAR(MAX)
		                      )

    /*ha a JSON-ben nincs megadva valamelyik szűrőn a filterCatalogFolder, akkor az alábbi foldert vesszük defaultnak (ha változtatni akarjuk a fordítását, itt is módosítani kell!):*/
    declare @DefaultFilterCatalogFolderCode NVarChar(200) =  'FOLDER_MIS_FORM_FILTER_FOLDER'
    declare @DefaultFilterCatalogFolder table(code NVARCHAR(200),
                                              iconName NVARCHAR(50),
			                                        parentCode NVARCHAR(200),
			                                        folderType NVARCHAR(200),
			                                        rootFolder NVARCHAR(200),
			                                        translations NVARCHAR(MAX)
		                                         )
    insert into @DefaultFilterCatalogFolder(code, iconName, parentCode, folderType, rootFolder, translations)
      select @DefaultFilterCatalogFolderCode code, null iconName, null parentCode, 'FILTERCATALOG' folderType, 'FALSE' rootFolder, 
             'translations":[
                  {
                     "language":"HU",
                     "text":"Szűrők"
                  },
                  {
                     "language":"EN",
                     "text":"Filters"
                  }
               ]' translations  


	  declare @Filters table(code NVARCHAR(200),
			                     translations NVARCHAR(MAX),
			                     valueSetCodeID NVARCHAR(200),
			                     defaultType NVARCHAR(200),
			                     defaultValue NVARCHAR(MAX),
			                     ordNr NUMERIC(16),
			                     filterType NVARCHAR(200),
                           filterCatalogSQLStatement NVARCHAR(MAX),
                           filterCatalogLower NVARCHAR(MAX),
                           filterCatalogUpper NVARCHAR(MAX),
                           filterCatalogFilterMode NVARCHAR(200),
                           filterCatalogFolder NVARCHAR(200),
                           sqlStatement NVARCHAR(MAX),
			                     folder NVARCHAR(200),
			                     lowersqltext NVARCHAR(MAX),
			                     uppersqltext NVARCHAR(MAX),
                           listingModes NVARCHAR(MAX)
		                      )

	  declare @FormFilterListingMode table(listingModeCode NVARCHAR(200),
                                          sqlStatement NVARCHAR(MAX),
                                          lowersqltext NVARCHAR(MAX),
                                          uppersqltext NVARCHAR(MAX)
		                                    )

	  declare @FormListingMode table(listingModeCode NVARCHAR(200),
                                    defaultListingModeCode NVARCHAR(200),
                                    sqlText NVARCHAR(MAX),
                                    translations NVARCHAR(MAX)
	                                )

	  declare @Columns table(code NVARCHAR(200),
			                     title NVARCHAR(200),
                           translations NVARCHAR(MAX),
			                     displayWidth INTEGER,
			                     alignment NVARCHAR(200),
			                     formatMask NVARCHAR(200),
			                     ordNr NUMERIC(16),
			                     area NVARCHAR(200),
			                     allowedArea NVARCHAR(200),
			                     columnVisible NVARCHAR(200)
		                      )

	  declare @Actions table(code NVARCHAR(200),
			                      title NVARCHAR(200),
                            translations NVARCHAR(MAX),
			                      functionType NVARCHAR(200),
                            defaultAction NVarChar(50)
		                      )

    
    declare @ToDelete table(id Numeric(16, 0),
                            tablename NVarChar(200)
		                       )

		
	  SELECT @l_logMsg = 'Temporary tables created.';
	  exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @l_procedureName, 
                            @p_LogMessage = @l_logMsg
			
	  PRINT @l_logMsg;

--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing forms and fill additional temporary tables
--===========================================================
			
	  SELECT @l_misFormJSON = JSON_QUERY(@l_json, '$.misForms');

    /*DV-1620: ha meg van adva egy konkrét folderID, akkor abba importáljuk a formokat, nem oda, mint amit a json meghatároz*/
    if @p_folderID is not null
    begin
      /*construct folder hierarchy*/
      ;with folders_CTE(folderID, parentFolderID, level)
      as (
          select o.ID folderID, o.parentFolderID, 1 level
          from GEN.Folder o
          where o.ID = @p_folderID
          union all
          select o.ID folderID, o.parentFolderID, child.level + 1 level
          from GEN.Folder o join folders_CTE child on o.ID = child.ParentFolderID
          where o.ID <> child.folderID
         )
    select @l_folders =  (select o.Code code, parent.Code parentCode, 
                                (select tr.Language language, tr.Text text
                                 from GEN.Translation tr
                                 where tr.CodeID = o.Code
                                 order by Case when tr.Language = @defaultLanguageISO then 0 else 1 end
                                 for JSON PATH, INCLUDE_NULL_VALUES
                                ) translations
                         from folders_CTE folders join GEN.Folder o on folders.folderID = o.ID
                                                  left join GEN.Folder parent on folders.parentFolderID = parent.ID
                         order by folders.level desc
                         FOR JSON PATH, INCLUDE_NULL_VALUES
                        )
    end
		
	  INSERT INTO @Forms (code, translations, folders, [version], sqlText, listingModes, filterCatalogFolders, filterFolders, filters, [columns], actions)
		  SELECT  F1.code, F1.translations, Case when @p_folderID is not null then @l_folders else F1.folders end, F1.[version], F1.sqlText, F1.listingModes, F1.filterCatalogFolders, F1.filterFolders, F1.filters, F1.[columns], F1.actions
		  FROM OPENJSON(@l_misFormJSON)
		  WITH  ( code NVARCHAR(200) '$.code',
			        translations NVARCHAR(MAX) '$.translations' AS JSON,
			        folders NVARCHAR(MAX) '$.folders' AS JSON,
			        [version] NVARCHAR(10) '$.version', 
			        sqlText NVARCHAR(MAX) '$.SQLText',
              listingModes NVARCHAR(MAX) '$.listingModes' AS JSON,
              filterCatalogFolders NVARCHAR(MAX) '$.filterCatalogFolders' AS JSON,
			        filterFolders NVARCHAR(MAX) '$.filterFolders' AS JSON, 
			        filters NVARCHAR(MAX) '$.filters' AS JSON, 
			        [columns] NVARCHAR(MAX) '$.columns' AS JSON, 
			        actions NVARCHAR(MAX) '$.actions' AS JSON
            ) AS F1;
			 
	  SELECT @l_logMsg = '@Forms temporary table filled.';
	  PRINT @l_logMsg;

    BEGIN TRAN
			 
	    DECLARE misForm_cursor CURSOR LOCAL FAST_FORWARD FOR 
		    SELECT f.code, f.translations, f.folders,  f.[version], f.sqlText, f.listingModes, f.filterCatalogFolders, f.filterFolders, f.filters, f.[columns], f.actions 
		    FROM @Forms f
		
	    OPEN misForm_cursor;
		
	    WHILE 1 = 1
	    BEGIN 
        FETCH NEXT FROM misForm_cursor INTO @l_code, @l_translations, @l_folders, @l_formVersion, @l_sqlText, @l_listingModes, @l_filterCatalogFolders, @l_filterFolders, @l_filters, @l_columns, @l_actions

        if @@FETCH_STATUS <> 0
            break

		    SELECT @l_logMsg = 'Next MIS.Form';
		    PRINT @l_logMsg;
		    PRINT 'CLEAR Temporary tables content';

		    DELETE FROM @Translations;
		    DELETE FROM @Folders;
		    DELETE FROM @Filters;
        DELETE FROM @FormListingMode
		    DELETE FROM @Columns;
		    DELETE FROM @Actions;
        DELETE FROM @ToDelete;
			
		    PRINT 'Fill @Translations table with MIS.Form translation data';
		    --MIS.Form nyelvi feliratai
		    INSERT INTO @Translations (valueSetPrefixCode, code, language, text)
			    SELECT 'MIS_FORM' valueSetPrefixCode, @l_code AS code, T1.[language], T1.[text]
			    FROM OPENJSON(@l_translations) 
          WITH ([language] NVARCHAR(5) '$.language',
				        [text] NVARCHAR(50) '$.text'
                ) AS T1;

				
		    PRINT 'Fill @Folders table with MIS.Form folder data';
			
        --MIS.Form könyvtár struktúra
        INSERT INTO @Folders (code, parentCode, folderType, rootFolder, translations)
			    SELECT misFolders.code, misFolders.parentCode, 'FORM' folderType, 'FALSE' rootFolder, misFolders.translations
			    FROM OPENJSON(@l_folders) 
			    WITH (code NVARCHAR(200) '$.code',                 
                parentCode NVARCHAR(200) '$.parentCode',
					      translations NVARCHAR(MAX) '$.translations' AS JSON
                )  AS misFolders

        
		    PRINT 'Fill @Folders table with MIS.Filter folder data';
			
        --MIS.Filter könyvtár struktúra
        INSERT INTO @Folders (code, parentCode, folderType, rootFolder, translations)
			    SELECT misFolders.code, misFolders.parentCode, 'FILTERCATALOG' folderType, 'FALSE' rootFolder, misFolders.translations
			    FROM OPENJSON(@l_filterCatalogFolders) 
			    WITH (code NVARCHAR(200) '$.code',                 
                parentCode NVARCHAR(200) '$.parentCode',
					      translations NVARCHAR(MAX) '$.translations' AS JSON
               )  AS misFolders

        PRINT 'Fill @Folders table with MIS.FormFilter root folder data';
		    --MIS.FormFilter könyvtár struktúra
        --NormalFolder
        INSERT INTO @Folders (code, iconName, parentCode, folderType, rootFolder, translations)
          SELECT f.code, f.iconName, f.parentCode, 'FILTER' folderType, 'FALSE' rootFolder, f.translations
          FROM OPENJSON(@l_filterFolders) 
          WITH (code NVARCHAR(200) '$.code',
                parentCode NVARCHAR(200) '$.parentCode',
                iconName NVARCHAR(50) '$.iconName',
			          translations NVARCHAR(MAX) '$.translations' AS JSON
                )  f

		    PRINT 'Fill @Translations table with @Folders translation data';
      
		    --Feltöltöttük a könyvtárakat (FORM, FILTER), következhet a feliratok (translations) feldolgozása  (DV-1509: ha nincs translation, akkor csak a GEN.Code-ot hozzuk majd létre)
        INSERT INTO @Translations (valueSetPrefixCode, code, language, text)
			    SELECT 'FOLDER' valueSetPrefixCode, f.code AS code, T1.[language], T1.[text]
			    FROM @Folders f outer apply OPENJSON(f.translations) 
                                      WITH ([language] NVARCHAR(5) '$.language',
					                                  [text] NVARCHAR(50) '$.text'
                                           ) AS T1
          WHERE f.code is not null

		    PRINT 'Fill @Filters table with MIS.Form filters data';
		    --Szűrők
		    INSERT INTO @Filters (code, translations, valueSetCodeID, defaultType, defaultValue, ordNr, filterType, filterCatalogSQLStatement, filterCatalogLower, filterCatalogUpper, filterCatalogFilterMode, filterCatalogFolder,
                              sqlStatement, folder, lowersqltext, uppersqltext, listingModes
                             )
          SELECT F1.code, F1.translations, F1.valueSetCodeID, F1.defaultType, F1.defaultValue, F1.ordNr, F1.filterType, F1.filterCatalogSQLStatement, F1.filterCatalogLower, F1.filterCatalogUpper, F1.filterCatalogFilterMode, F1.filterCatalogFolder,
                 F1.sqlStatement, F1.folder, F1.lowersqltext, F1.uppersqltext, F1.listingModes
			    FROM OPENJSON(@l_filters) WITH (code NVARCHAR(200) '$.code', 
				                                  translations NVARCHAR(MAX) '$.translations' AS JSON,
				                                  valueSetCodeID NVARCHAR(200) '$.valueSetCodePrefix',
				                                  defaultType NVARCHAR(200) '$.defaultType',
				                                  defaultValue NVARCHAR(MAX) '$.defaultValue',
				                                  ordNr NUMERIC(16) '$.ordNr',
				                                  filterType NVARCHAR(200) '$.filterType', 
                                          filterCatalogSQLStatement NVARCHAR(MAX) '$.filterCatalogSQLStatement',
                                          filterCatalogLower NVARCHAR(MAX) '$.filterCatalogLower', 
                                          filterCatalogUpper NVARCHAR(MAX) '$.filterCatalogUpper', 
                                          filterCatalogFilterMode NVARCHAR(200) '$.filterCatalogFilterMode', 
                                          filterCatalogFolder NVARCHAR(200) '$.filterCatalogFolder', 
				                                  sqlStatement NVARCHAR(MAX) '$.SQLStatement',
				                                  folder NVARCHAR(200) '$.folder',
				                                  lowersqltext NVARCHAR(MAX) '$.lower',
				                                  uppersqltext NVARCHAR(MAX) '$.upper',
                                          listingModes NVARCHAR(MAX) '$.listingModes' AS JSON
                                         )  AS F1
                                          
			  
        if exists(select * 
                  from @Filters f
                  where not exists(select *
                                   from @Folders o
                                   where o.folderType = 'FILTER'
                                     and o.rootFolder = 'FALSE'
                                     and o.code = f.folder
                                  )
                 )
        begin
          select @l_logMsg = Concat('Unknown filter folder(', STRING_AGG(f.folder, ', '), ')')
          from (select distinct IsNull(f.folder, '') folder
                from @Filters f
                where not exists(select *
                                  from @Folders o
                                  where o.folderType = 'FILTER'
                                    and o.rootFolder = 'FALSE'
                                    and o.code = f.folder
                                )
              ) f

          raiserror (@l_logMsg, 16, 1)
        end
      

        /*ha van olyan MIS.Filter, amihez nincs megadva a filterCatalogFolder, akkor a default foldert is frissíteni kell*/
        if exists(select *
                  from @Filters f
                  where IsNull(f.filterCatalogFolder, '') = ''
                 )
        begin 
          insert into @Folders (code, parentCode, folderType, rootFolder, translations)
            select code, parentCode, folderType, rootFolder, translations
            from @DefaultFilterCatalogFolder 

          update f
          set filterCatalogFolder = @DefaultFilterCatalogFolderCode
          from @Filters f
          where IsNull(f.filterCatalogFolder, '') = '' 
        end   

        --Szűrők nyelvi feliratai (DV-1509: ha nincs translation, akkor csak a GEN.Code-ot hozzuk majd létre)
		    INSERT INTO @Translations (valueSetPrefixCode, code, language, text)
			    SELECT 'MIS_FORM_FILTER' valueSetPrefixCode, f.code, T1.[language], T1.[text]
			    FROM @Filters f outer apply OPENJSON(f.translations) WITH ([language] NVARCHAR(5) '$.language',
					                                                           [text] NVARCHAR(50) '$.text'
                                                                    ) AS T1
          WHERE f.code is not null
			
		    PRINT 'Fill @Columns table with MIS.Form columns data';

		    --Mezők
		    INSERT INTO @Columns (code, title, translations, displayWidth, alignment, formatMask, ordNr, area, allowedArea, columnVisible)
			    SELECT C1.code, C1.title, C1.translations, C1.displayWidth, C1.alignment, C1.formatMask, C1.ordNr, C1.area, C1.allowedArea, C1.columnVisible 
          FROM OPENJSON(@l_columns) WITH (code NVARCHAR(200) '$.code',
				                                  title NVARCHAR(200) '$.title',
                                          translations NVARCHAR(MAX) '$.translations' AS JSON,
				                                  displayWidth INTEGER '$.displayWidth',
				                                  alignment NVARCHAR(200) '$.alignment',
				                                  formatMask NVARCHAR(200) '$.formatMask',
				                                  ordNr NUMERIC(16) '$.ordNr',
				                                  area NVARCHAR(200) '$.area',
				                                  allowedArea NVARCHAR(200) '$.allowedArea',
				                                  columnVisible NVARCHAR(200) '$.columnVisible'
                                          ) AS C1;

      
        PRINT 'Fill @Columns table with MIS.FormColumn translation data';
		    --MIS.FormColumn nyelvi feliratai (DV-1509: ha nincs translation, akkor csak a GEN.Code-ot hozzuk majd létre)
		    INSERT INTO @Translations (valueSetPrefixCode, code, language, text)
			    SELECT 'MIS_FORM_COLUMN' valueSetPrefixCode, c.title code, trans.language, trans.text
          from @Columns c outer apply OPENJSON(c.translations) WITH ([language] NVARCHAR(5) '$.language',
				                                                             [text] NVARCHAR(50) '$.text'
                                                                    ) as trans
          where c.title is not null

				
		    PRINT 'Fill @Actions table with MIS.Form actions data';
        --Akciók
		    INSERT INTO @Actions (code, title, translations, functionType, defaultAction)
		    SELECT A1.code, A1.title, A1.translations, A1.functionType, A1.defaultAction
		    FROM OPENJSON(@l_actions) WITH (code NVARCHAR(200) '$.code',
				                                title NVARCHAR(200) '$.title',
                                        translations NVARCHAR(MAX) '$.translations' as JSON,
				                                functionType NVARCHAR(200) '$.functionType',
                                        defaultAction NVARCHAR(50) '$.defaultAction'
                                        ) AS A1;


        PRINT 'Fill @Translations table with MIS.FormAction translation data';
		    --MIS.FormAction nyelvi feliratai  (DV-1509: ha nincs translation, akkor csak a GEN.Code-ot hozzuk majd létre)
		    INSERT INTO @Translations (valueSetPrefixCode, code, language, text)
			    SELECT 'MIS_FORM_ACTION' valueSetPrefixCode, a.title code, trans.language, trans.text
          from @Actions a outer apply OPENJSON(a.translations) WITH ([language] NVARCHAR(5) '$.language',
				                                                             [text] NVARCHAR(50) '$.text'
                                                                    ) as trans
          where a.title is not null

      
        /*Listázási módok*/
        if IsNull(@l_listingModes, '') <> ''
        begin
          PRINT 'Fill @FormListingMode table with MIS.FormListingMode data';

          INSERT INTO @FormListingMode(listingModeCode, defaultListingModeCode, sqlText, translations)
            SELECT r.listingModeCode, 
                    r.defaultListingModeCode,
                    r.sqlText,
                    r.translations
            FROM OPENJSON(@l_listingModes)
            WITH (listingModeCode NVARCHAR(200) '$.listingModeCode',
			            defaultListingModeCode NVARCHAR(200) '$.defaultListingModeCode',
			            sqlText NVARCHAR(MAX) '$.SQLText',
                  translations NVARCHAR(MAX) '$.translations' AS JSON
                 ) AS r

          PRINT 'Fill @Translations table with MIS.FormListingMode translation data';
			    --MIS.FormListingMode nyelvi feliratai
			    INSERT INTO @Translations (valueSetPrefixCode, code, language, text)
			      SELECT 'FORM_LISTING_MODE' valueSetPrefixCode,lm.listingModeCode code, trans.language, trans.text
            from @FormListingMode lm outer apply OPENJSON(lm.translations) WITH ([language] NVARCHAR(5) '$.language',
				                                                                         [text] NVARCHAR(50) '$.text'
                                                                                ) as trans
            where lm.listingModeCode is not null  
        end

  --===========================================================
  --BLOCK      : PROCESS
  --DESCRIPTION: Processing content of temporary tables
  --===========================================================

			  IF COALESCE(@l_code, '') = '' 
			  BEGIN
				  SELECT @l_logMsg = 'The code of the Form cannot be an empty value.';
				  exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                          @p_UserName = @p_UserName,
                          @p_ServiceName = @l_procedureName, 
                          @p_LogMessage = @l_logMsg

				  PRINT @l_logMsg;
			  END
			  ELSE 
			  BEGIN
				  PRINT 'Processing @Translations table';

				  --Feliratok feldolgozása
				  DECLARE translation_cursor CURSOR LOCAL FAST_FORWARD FOR 
				    SELECT t.valueSetPrefixCode,
					         t.code,
					         t.[language],
					         t.[text]
				    FROM @Translations t;

				  OPEN translation_cursor;
				
				  WHILE 1 = 1
				  BEGIN
            FETCH NEXT FROM translation_cursor INTO  @l_translationValueSetPrefixCode, @l_translationCode, @l_translationLanguage, @l_translationText

            if @@FETCH_STATUS <> 0
               break
          

					  PRINT CONCAT('Processing @Translations row. PrefixCode(', 
						              @l_translationValueSetPrefixCode, '), Code(', 
						              @l_translationCode, '), Language(', 
						              @l_translationLanguage, '), Text(', 
						              @l_translationText, ').'
                        )

					  SELECT @l_valueSetID = [ValueSet].[ID]
					  FROM [GEN].[ValueSet]
					  WHERE [ValueSet].[CodePrefix] = @l_translationValueSetPrefixCode;

					  IF COALESCE(@l_valueSetID, 0) > 0 
					  BEGIN 
						  PRINT CONCAT('Try insert new data in GEN.Code with ValueSetID(', @l_valueSetID, '), ID(', @l_translationCode, ')')

              if exists(select *
                        from GEN.Code c
                        where c.ID = @l_translationCode
                          and IsNull(c.ValueSetID, 0) <> @l_valueSetID
                       )
              begin
                select @l_wrongValueSetIDStr = null, @l_valueSetIDStr = Format(@l_valueSetID, '0')

                select top 1 @l_wrongValueSetIDStr = Format(c.ValueSetID, '0')
                from GEN.Code c
                where c.ID = @l_translationCode
                  and IsNull(c.ValueSetID, 0) <> @l_valueSetID

                raiserror ('The code %s already exists in GEN.Code, but the valueSetID is wrong. (Wrong valueSetID: %s, correct valueSetID: %s)', 16, 1, @l_translationCode, @l_wrongValueSetIDStr, @l_valueSetIDStr);
              end

						  INSERT INTO [GEN].[Code] ([ID], [ValueSetID], [ValidFrom], [CreationDate], [CreationTime], [CreationUserName]) 
						    SELECT @l_translationCode, @l_valueSetID, CAST( GETDATE() AS Date), CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName
						    WHERE NOT EXISTS (SELECT * 
							                    FROM [GEN].[Code]
							                    WHERE [Code].[ValueSetID] = @l_valueSetID 
							                      AND [Code].[ID] = @l_translationCode
                                 )

						  SELECT @l_codeID = [Code].[ID]
						  FROM [GEN].[Code]
						  WHERE [Code].[ValueSetID] = @l_valueSetID
						    AND [Code].[ID] = @l_translationCode;


						  IF COALESCE(@l_codeID, '') <> '' and IsNull(@l_translationLanguage, '') <> '' /*DV-1509: ha nincs translation, akkor csak a GEN.Code-ot hozzuk létre, a Translationt nem*/
						  BEGIN
							  INSERT INTO [GEN].[Translation] ([CodeID], [Language], [Text], [CreationDate], [CreationTime], [CreationUserName])
							    SELECT @l_codeID, @l_translationLanguage, @l_translationText, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName
							    WHERE NOT EXISTS (SELECT *
								                    FROM [GEN].[Translation]
								                    WHERE [Translation].[CodeID] = @l_codeID 
								                      AND [Translation].[Language] = @l_translationLanguage
                                   )

							  UPDATE [GEN].[Translation] 
                SET [Text] = @l_translationText, 
                    [LastModifiedDate] = CAST( GETDATE() AS Date),
							      [LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
							      [LastModifiedUserName] = @l_userName
							  WHERE [Translation].[CodeID] = @l_codeID
							    AND [Translation].[Language] = @l_translationLanguage
                  AND Text <> @l_translationText
						  END
					  END
				  END;

				  CLOSE translation_cursor;
				  DEALLOCATE translation_cursor;

				  PRINT 'Processing @Folders (FORM) table';

				  --Könyvtárak (FORM) feldolgozása rekurzívan (biztos ami biztos)
				  SELECT @l_rootFolderID = [RootFolder].[ID]
				  FROM [GEN].[RootFolder] 
				  WHERE [RootFolder].[TableName] = 'MIS.Form';

          if @l_rootFolderID is null
             raiserror ('No RootFolder with TableName MIS.Form', 16, 1)


				  DECLARE formFolder_cursor CURSOR LOCAL FAST_FORWARD FOR 
				  WITH folders (parentCode, code, level) 
				  AS (SELECT f.parentCode, f.code, 0 AS level 
              FROM @Folders AS f
					    WHERE f.folderType = 'FORM'
                AND f.rootFolder = 'FALSE'
					      AND IsNull(f.parentCode, '') = ''
					    UNION ALL 
					    SELECT f.parentCode, f.code, level + 1
					    FROM @Folders AS f JOIN folders ON (f.parentCode = folders.code)
					    WHERE f.folderType = 'FORM'
                AND f.rootFolder = 'FALSE'
					  )
				    SELECT folders.parentCode, folders.code
				    FROM folders
				    ORDER BY folders.level;

				  OPEN formFolder_cursor;

				  WHILE 1 = 1
				  BEGIN
            FETCH NEXT FROM formFolder_cursor INTO @l_folderParentCode, @l_folderCode;

            if @@FETCH_STATUS <> 0
               break

            set @l_folderParentFolderID = 0

					  IF COALESCE(@l_folderParentCode, '') <> '' 
					  BEGIN
						  SELECT @l_folderParentFolderID = [Folder].[ID] 
						  FROM [GEN].[Folder] 
						  WHERE [Folder].[RootFolderID] = @l_rootFolderID 
						    AND [Folder].[Code] = @l_folderParentCode;
					  END;

            set @l_folderID = 0

					  SELECT @l_folderID = [Folder].[ID] 
					  FROM [GEN].[Folder] 
					  WHERE [Folder].[RootFolderID] = @l_rootFolderID 
					    AND [Folder].[Code] = @l_folderCode;

					  SELECT @l_objectID = 0;

					  IF COALESCE(@l_folderID, 0) = 0 
					  BEGIN 
						  INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
						  VALUES ('OBJECT_TYPE_GEN_FOLDER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_folderCode, ' Folder object'), '1.0');

						  SELECT @l_objectID = SCOPE_IDENTITY()

						  IF COALESCE(@l_folderParentCode, '') <> '' 
						  BEGIN
							  SELECT @l_folderParentFolderID = [Folder].[ID] 
							  FROM [GEN].[Folder] 
							  WHERE [Folder].[RootFolderID] = @l_rootFolderID 
						  	  AND [Folder].[Code] = @l_folderParentCode;
						  END;

						  INSERT INTO [GEN].[Folder] ([ObjectID], [ParentFolderID], [Code], [RootFolderID], [CreationDate], [CreationTime], [CreationUserName])
						    SELECT @l_objectID, NULL ParentFolderID, @l_folderCode, @l_rootFolderID, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

						  SELECT @l_folderID = SCOPE_IDENTITY()
					  END;

					  IF COALESCE(@l_folderParentFolderID, 0) > 0
					  BEGIN
						  UPDATE [GEN].[Folder] 
              SET [ParentFolderID] = @l_folderParentFolderID,
							    [LastModifiedDate] = CAST( GETDATE() AS Date),
  							  [LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
	  						  [LastModifiedUserName] = @l_userName
						  WHERE [Folder].[ID] = @l_folderID 
						  AND COALESCE([Folder].[ParentFolderID], 0) <> @l_folderParentFolderID;
					  END;

					  SELECT @l_formFolderID = @l_folderID;
				  END

				  CLOSE formFolder_cursor;
				  DEALLOCATE formFolder_cursor;

          ----------------------------------------------------------------------------------------------------------------------------------------------------------

          PRINT 'Processing @Folders (FILTERCATALOG - MIS.Filter) table'; 
          
          --Könyvtárak (FILTERCATALOG - MIS.Filter) feldolgozása rekurzívan
          set @l_rootFolderIDFilterCatalog = null

				  SELECT @l_rootFolderIDFilterCatalog = [RootFolder].[ID]
				  FROM GEN.RootFolder 
				  WHERE RootFolder.TableName = 'MIS.Filter'

          if     @l_rootFolderIDFilterCatalog is null
             and exists(select *
                        from @Folders f
                        where f.folderType = 'FILTERCATALOG'
                       )
             raiserror ('No RootFolder with TableName MIS.Filter', 16, 1)

          
          DECLARE formCatalogFolder_cursor CURSOR LOCAL FAST_FORWARD FOR 
				  WITH folders (parentCode, code, level) 
				  AS (SELECT f.parentCode, f.code, 0 AS level 
              FROM @Folders AS f
					    WHERE f.folderType = 'FILTERCATALOG'
					      AND IsNull(f.parentCode, '') = ''
					    UNION ALL 
					    SELECT f.parentCode, f.code, level + 1
					    FROM @Folders AS f JOIN folders ON (f.parentCode = folders.code)
					    WHERE f.folderType = 'FILTERCATALOG'
					  )
				    SELECT folders.parentCode, folders.code
				    FROM folders
				    ORDER BY folders.level;

				  OPEN formCatalogFolder_cursor

          WHILE 1 = 1
				  BEGIN
            FETCH NEXT FROM formCatalogFolder_cursor INTO @l_folderParentCode, @l_folderCode

            if @@FETCH_STATUS <> 0
               break

            set @l_folderParentFolderID = 0    

					  IF COALESCE(@l_folderParentCode, '') <> '' 
					  BEGIN
						  SELECT @l_folderParentFolderID = [Folder].[ID] 
						  FROM [GEN].[Folder] 
						  WHERE [Folder].[RootFolderID] = @l_rootFolderIDFilterCatalog 
						    AND [Folder].[Code] = @l_folderParentCode;
					  END;

            set @l_folderID = 0

					  SELECT @l_folderID = [Folder].[ID] 
					  FROM [GEN].[Folder] 
					  WHERE [Folder].[RootFolderID] = @l_rootFolderIDFilterCatalog 
					    AND [Folder].[Code] = @l_folderCode;

					  SELECT @l_objectID = 0;
            
					  IF COALESCE(@l_folderID, 0) = 0 
					  BEGIN 
						  INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
						  VALUES ('OBJECT_TYPE_GEN_FOLDER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_folderCode, ' Folder object'), '1.0');

						  SELECT @l_objectID = SCOPE_IDENTITY()

						  IF COALESCE(@l_folderParentCode, '') <> '' 
						  BEGIN
							  SELECT @l_folderParentFolderID = [Folder].[ID] 
							  FROM [GEN].[Folder] 
							  WHERE [Folder].[RootFolderID] = @l_rootFolderIDFilterCatalog 
						  	  AND [Folder].[Code] = @l_folderParentCode;
						  END;

						  INSERT INTO [GEN].[Folder] ([ObjectID], [ParentFolderID], [Code], [RootFolderID], [CreationDate], [CreationTime], [CreationUserName])
						    SELECT @l_objectID, NULL ParentFolderID, @l_folderCode, @l_rootFolderIDFilterCatalog, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

						  SELECT @l_folderID = SCOPE_IDENTITY()
					  END;

					  IF COALESCE(@l_folderParentFolderID, 0) > 0
					  BEGIN
						  UPDATE [GEN].[Folder] 
              SET [ParentFolderID] = @l_folderParentFolderID,
							    [LastModifiedDate] = CAST( GETDATE() AS Date),
  							  [LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
	  						  [LastModifiedUserName] = @l_userName
						  WHERE [Folder].[ID] = @l_folderID 
						  AND COALESCE([Folder].[ParentFolderID], 0) <> @l_folderParentFolderID;
					  END;
				  END

				  CLOSE formCatalogFolder_cursor;
				  DEALLOCATE formCatalogFolder_cursor;

          ----------------------------------------------------------------------------------------------------------------------------------------------------------

				  PRINT 'Processing MIS.Form general data';

				  --VIR alap adatok feldolgozása
          select @l_formID = null, @l_formObjectID = null

				  SELECT @l_formID = [Form].[ID], @l_formObjectID = [Form].[ObjectID]
				  FROM [MIS].[Form]
				  WHERE [Form].[CodeID] = @l_code;

				  SELECT @l_objectID = 0;

          /*DV-1328: ha nincs megadva SQL text, de van listázási mód (az Exceles betöltőnél ez van), akkor a default listázási mód SQL textjét töltjük a MIS.Form.SQLText-be is*/
          if IsNull(@l_sqlText, '') = ''
          begin
            if exists(select *
                      from @FormListingMode
                     )
            begin
              select top 1 @l_sqlText = sqlText
              from @FormListingMode
              order by Case when defaultListingModeCode = 'BOOLEAN_TRUE' then 0 else 1 end
            end
          end

				  IF COALESCE(@l_formID, 0) = 0
				  BEGIN 
					  INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					  VALUES ('OBJECT_TYPE_MIS_FORM', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_code, ' object'), '1.0');

					  SELECT @l_objectID = SCOPE_IDENTITY()
					  SELECT @l_formObjectID = @l_objectID;

					  IF COALESCE(@l_objectID, 0) > 0
					  BEGIN
						  INSERT INTO [MIS].[Form] ([ObjectID], [CodeID], [FolderID], [SQLText], [CreationDate], [CreationTime], [CreationUserName])
						    SELECT @l_objectID, @l_code, @l_formFolderID, @l_sqlText, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

						  SELECT @l_formID = SCOPE_IDENTITY()
					  END
				  END
          ELSE
				  BEGIN 
					  UPDATE [MIS].[Form] 
            SET [SQLText] = @l_sqlText,
                [FolderID] = @l_formFolderID,
						    [LastModifiedDate] = CAST( GETDATE() AS Date),
						    [LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
						    [LastModifiedUserName] = @l_userName
					  WHERE [Form].[ID] = @l_formID
              and (   IsNull(FolderID, 0) <> IsNull(@l_formFolderID, 0)
                   or IsNull(SQLText, '') <> IsNull(@l_sqlText, '')
                  )
				  END


          /*listingModes feldolgozása, ha van*/
          PRINT 'Processing listingModes'

          if IsNull(@l_listingModes, '') <> ''
          begin
            DECLARE listingModes_cur cursor local fast_forward for
              SELECT m.listingModeCode, m.defaultListingModeCode, m.sqlText
              FROM @FormListingMode m

            OPEN listingModes_cur

            WHILE 1 = 1
            BEGIN
              FETCH NEXT FROM listingModes_cur INTO @l_listingModeCode, @l_defaultListingModeCode, @l_listingModeSQLText
              IF @@FETCH_STATUS <> 0
                 break

              /*ha nem létezik még, akkor létrehozzunk*/
              IF NOT EXISTS(SELECT *
                            FROM MIS.FormListingMode l
                            where l.FormID = @l_formID
                              and l.ListingModeCode = @l_listingModeCode
                           )
              BEGIN
                INSERT INTO GEN.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
                                SELECT 'OBJECT_TYPE_MIS_FORMLISTINGMODE' ObjectType, CAST( GETDATE() AS Date) CreationDate, CONVERT(VARCHAR(8), GETDATE(),108) CreationTime, @l_userName CreationUserName, 
                                       Concat(@l_listingModeCode, ' FormListingMode object') Comments, '1.0' VersionNr

						    SELECT @l_objectID = SCOPE_IDENTITY()

                INSERT INTO MIS.FormListingMode(ObjectID, FormID, SQLText, ListingModeCode, DefaultListingModeCode, StatusCode, CreationDate, CreationTime, CreationUserName)
                  SELECT @l_objectID ObjectID, @l_formID FormID, @l_listingModeSQLText SQLText, @l_listingModeCode ListingModeCode, @l_defaultListingModeCode DefaultListingModeCode, 'STATUS_NORMAL' StatusCode,
                         CAST(GETDATE() AS Date) CreationDate, CONVERT(VARCHAR(8), GETDATE(),108) CreationTime, @l_userName CreationUserName
              END
              /*ha van valami változás, akkor update*/
              ELSE
              BEGIN
                UPDATE MIS.FormListingMode
                SET SQLText = @l_listingModeSQLText,
                    DefaultListingModeCode = @l_defaultListingModeCode,
                    LastModifiedDate = CAST(GETDATE() AS Date),
                    LastModifiedTime = CONVERT(VARCHAR(8), GETDATE(),108),
                    LastModifiedUserName = @l_userName
                FROM MIS.FormListingMode l
                where l.FormID = @l_formID
                  and l.ListingModeCode = @l_listingModeCode
                  and (   l.SQLText <> @l_listingModeSQLText 
                       or l.DefaultListingModeCode <> @l_defaultListingModeCode 
                      )
              END
            END

            CLOSE listingModes_cur
            DEALLOCATE listingModes_cur
          end
          
          /*törlendő MIS.FormListingMode rekordok kigyűjtése*/
          if exists(select *
                    from MIS.FormListingMode flm
                    where flm.FormID = @l_formID
                      and not exists(select *
                                     from @FormListingMode m
                                     where m.ListingModeCode = flm.ListingModeCode
                                    )
                   )
          begin
            insert into @ToDelete(id, tablename)
                          select flm.ID, 'MIS.FormListingMode' tablename
                          from MIS.FormListingMode flm
                          where flm.FormID = @l_formID
                            and not exists(select *
                                            from @FormListingMode m
                                            where m.ListingModeCode = flm.ListingModeCode
                                          )
          end
          /*listingModes feldolgozás vége*/


				  PRINT 'Processing @Folders (FILTER - ROOT) table';
				
          --Szűrők gyökér könyvtárának feldolgozása
          set @l_formRootFilterFolderID = null

				  SELECT @l_formRootFilterFolderID = [RootFolder].[ID]
				  FROM [GEN].[RootFolder] 
				  WHERE [RootFolder].[ReferenceObjectID] = @l_formObjectID;

				  SELECT @l_objectID = 0;

				  IF COALESCE(@l_formRootFilterFolderID, 0) = 0 
				  BEGIN
					  INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					  VALUES ('OBJECT_TYPE_GEN_ROOTFOLDER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, Concat('FOLDER_', @l_code /*the code of the form*/, '_FILTER RootFolder object'), '1.0');

					  SELECT @l_objectID = SCOPE_IDENTITY()

					  IF COALESCE(@l_objectID, 0) > 0 
					  BEGIN
              select @l_code_prefix_index = CharIndex(@l_code_prefix, @l_code)

						  INSERT INTO [GEN].[RootFolder] (ObjectID, [ReferenceObjectID], [TableName], [CreationDate], [CreationTime], [CreationUserName])
						    SELECT @l_objectID, @l_formObjectID, 
                       Case when @l_code_prefix_index = 1 then SubString(@l_code, Len(@l_code_prefix)+1, Len(@l_code)) else @l_code end TableName /*DV-1376: a TableName-be a Form.CodeID MIS_FORM_ utáni része kerül*/, 
                       CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

						  SELECT @l_formRootFilterFolderID = SCOPE_IDENTITY()
					  END
				  END

          update MIS.Form
          set RootFilterFolderID = @l_formRootFilterFolderID,
              LastModifiedDate = CAST( GETDATE() AS Date),
						  LastModifiedTime = CONVERT(VARCHAR(8), GETDATE(),108),
						  LastModifiedUserName = @l_userName  
          where ID = @l_formID
            and IsNull(RootFilterFolderID, -1) <> @l_formRootFilterFolderID


				  PRINT 'Processing @Folders (FILTER - NORMAL) table';
				  --Könyvtárak (FILTER) feldolgozása rekurzívan (biztos ami biztos)
				  SELECT @l_rootFolderID = @l_formRootFilterFolderID;


				  DECLARE filterFolder_cursor CURSOR LOCAL FAST_FORWARD FOR 
				  WITH folders (parentCode, code, iconName, level) 
				  AS (
					    SELECT f.parentCode, f.code, f.iconName, 0 AS level
					    FROM @Folders AS f
					    WHERE f.folderType = 'FILTER'
					      AND f.rootFolder = 'FALSE'
					      AND IsNull(f.parentCode, '') = ''
					    UNION ALL 
					    SELECT f.parentCode, f.code, f.iconName, level + 1
					    FROM @Folders AS f JOIN folders ON (f.parentCode = folders.code)
					    WHERE f.folderType = 'FILTER'
					      AND f.rootFolder = 'FALSE'
					  )
				  SELECT folders.parentCode, folders.code, folders.iconName
				  FROM folders
				  ORDER BY folders.level;

				  OPEN filterFolder_cursor;

				  WHILE 1 = 1
				  BEGIN 
            FETCH NEXT FROM filterFolder_cursor INTO  @l_folderParentCode, @l_folderCode, @l_folderIconName;

            if @@FETCH_STATUS <> 0
               break

					  SELECT @l_folderParentFolderID = 0;

					  IF COALESCE(@l_folderParentCode, '') <> '' 
					  BEGIN
						  SELECT @l_folderParentFolderID = [Folder].[ID] 
						  FROM [GEN].[Folder] 
						  WHERE [Folder].[RootFolderID] = @l_rootFolderID 
						    AND [Folder].[Code] = @l_folderParentCode;
					  END;

					  SELECT @l_folderID = 0;

					  SELECT @l_folderID = [Folder].[ID] 
					  FROM [GEN].[Folder] 
					  WHERE [Folder].[RootFolderID] = @l_rootFolderID 
					  AND [Folder].[Code] = @l_folderCode;

					  SELECT @l_objectID = 0;

					  IF COALESCE(@l_folderID, 0) = 0 
					  BEGIN 
						  INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
						  VALUES ('OBJECT_TYPE_GEN_FOLDER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_folderCode, ' Folder object'), '1.0');

						  SELECT @l_objectID = SCOPE_IDENTITY()

						  INSERT INTO [GEN].[Folder] ([ObjectID], [ParentFolderID], [Code], [RootFolderID], [IconName], [CreationDate], [CreationTime], [CreationUserName])
						    SELECT @l_objectID, NULL ParentFolderID, @l_folderCode, @l_rootFolderID, @l_folderIconName, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

						  SELECT @l_folderID = SCOPE_IDENTITY()
					  END;

					  SELECT @l_formFilterFolderID = @l_folderID;

            update GEN.Folder
            set ParentFolderID = f.ParentFolderID,
                IconName = f.IconName,
                LastModifiedDate = CAST( GETDATE() AS Date),
						    LastModifiedTime = CONVERT(VARCHAR(8), GETDATE(),108),
						    LastModifiedUserName = @l_userName
            from (select Folder.ID,
                         Case when @l_folderParentFolderID = 0 then null else @l_folderParentFolderID end ParentFolderID,
                         Case when @l_folderIconName is null /*nem volt a json-ben iconName tag --> hagyjuk azon, amin volt*/ then IconName
                              when @l_folderIconName = ''    /*volt a json-ben iconName tag, de üres --> kinullozzuk*/ then null
                              else @l_folderIconName
                         end IconName
                  from GEN.Folder
                  where Folder.ID = @l_folderID
                 ) f
            where Folder.ID = f.ID
              and (   IsNull(Folder.ParentFolderID, 0) <> ISNull(f.ParentFolderID, 0)
                   or IsNull(Folder.IconName, '') <> ISNull(f.IconName, 0)
                  )

					  PRINT CONCAT('Processing @Filter (', @l_folderCode, ') table');

					  --Szűrő könyvtárhoz tartozó szűrők feldolgozása
					  DECLARE filter_cursor CURSOR LOCAL FAST_FORWARD FOR
					  SELECT f.code, f.valueSetCodeID, f.defaultType, f.defaultValue, f.ordNr, f.filterType, f.filterCatalogSQLStatement, f.filterCatalogLower, f.filterCatalogUpper, f.filterCatalogFilterMode, f.filterCatalogFolder,
                   f.sqlStatement, f.folder, f.lowersqltext, f.uppersqltext, f.listingModes
            FROM @Filters f
					  WHERE f.folder = @l_folderCode
					  ORDER BY f.ordNr;


					  OPEN filter_cursor;

					  WHILE 1 = 1
					  BEGIN 
              FETCH NEXT FROM filter_cursor INTO  @l_filterCode, @l_filterValueSetCodePrefix, @l_filterDefaultType, @l_filterDefaultValue, @l_filterOrdNr, @l_filterFilterType, @l_filterCatalogSQLStatement, @l_filterCatalogLower, @l_filterCatalogUpper, 
                                                  @l_filterCatalogFilterMode, @l_filterCatalogFolder, @l_filterSQLStatement, @l_filterFolder, @l_filterlowersqltext, @l_filteruppersqltext, @l_filterListingModes

              if @@FETCH_STATUS <> 0
                 break

    				  select @l_filterID=0;

						  SELECT @l_filterID = [Filter].[ID] 
						  FROM [MIS].[Filter] 
						  WHERE [Filter].[Code] = @l_filterCode;

						  SELECT @l_objectID = 0;

						  IF COALESCE(@l_filterID, 0) = 0 
						  BEGIN
							  INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr]) 
							  VALUES ('OBJECT_TYPE_MIS_FILTER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_filterCode, ' Filter object'), '1.0');

							  SELECT @l_objectID = SCOPE_IDENTITY()

							  INSERT INTO MIS.Filter (ObjectID, Code, FilterType, ValueSetID, SQLText, IntervalLowerSQLText,IntervalUpperSQLText, FilterMode, FolderID, CreationDate, CreationTime, CreationUserName) 
						     SELECT @l_objectID, @l_filterCode, @l_filterFilterType, 
						   		     (SELECT [ValueSet].[ID] FROM [GEN].[ValueSet] WHERE [ValueSet].[CodePrefix] = @l_filterValueSetCodePrefix) ValueSetID, 
								        @l_filterCatalogSQLStatement, @l_filterCatalogLower, @l_filterCatalogUpper,
                        Case when IsNull(@l_filterCatalogFilterMode, '') = '' 
                             then Case when IsNull(Replace(@l_filterCatalogLower, ' ', ''), '') not in('', 'AND1=1') and IsNull(Replace(@l_filterCatalogUpper, ' ', ''), '') not in('', 'AND1=1') then 'FILTER_MODE_INTERVAL' /*megjelenhet a csúszka*/
                                       else 'FILTER_MODE_SIMPLE'
                                  end
                             else @l_filterCatalogFilterMode                                  
                        end FilterMode,
                        (SELECT top 1 Folder.ID FROM GEN.Folder WHERE Folder.RootFolderID = @l_rootFolderIDFilterCatalog AND Folder.Code = @l_filterCatalogFolder) FolderID,
								        CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;
								
							  SELECT @l_filterID = SCOPE_IDENTITY()
						  END
              ELSE
              BEGIN
						    UPDATE MIS.Filter
                SET ValueSetID = new_data.ValueSetID,
								    SQLText = new_data.SQLText,
								    IntervalLowerSQLText = new_data.IntervalLowerSQLText,
								    IntervalUpperSQLText = new_data.IntervalUpperSQLText,
                    FilterMode = new_data.FilterMode,
                    FolderID = new_data.FolderID,
								    FilterType = new_data.FilterType,
                    LastModifiedDate = CAST( GETDATE() AS Date),
								    LastModifiedTime = CONVERT(VARCHAR(8), GETDATE(),108),
								    LastModifiedUserName = @l_userName
                FROM (SELECT (SELECT [ValueSet].[ID] FROM [GEN].[ValueSet] WHERE [ValueSet].[CodePrefix] = @l_filterValueSetCodePrefix) ValueSetID,
                             @l_filterCatalogSQLStatement SQLText,
                             @l_filterCatalogLower IntervalLowerSQLText,
                             @l_filterCatalogUpper IntervalUpperSQLText,
                             Case when IsNull(@l_filterCatalogFilterMode, '') = '' 
                                  then Case when IsNull(Replace(@l_filterCatalogLower, ' ', ''), '') not in('', 'AND1=1') and IsNull(Replace(@l_filterCatalogUpper, ' ', ''), '') not in('', 'AND1=1') then 'FILTER_MODE_INTERVAL' /*megjelenhet a csúszka*/
                                            else 'FILTER_MODE_SIMPLE'
                                       end
                                  else @l_filterCatalogFilterMode                                  
                             end FilterMode,
                             (SELECT top 1 Folder.ID FROM GEN.Folder WHERE Folder.RootFolderID = @l_rootFolderIDFilterCatalog AND Folder.Code = @l_filterCatalogFolder) FolderID,
                             @l_filterFilterType FilterType
                     ) new_data
							  WHERE Filter.ID = @l_filterID
                  and (   IsNull(Filter.ValueSetID, -1) <> IsNull(new_data.ValueSetID, -1)
                       or IsNull(Filter.SQLText, '') <> IsNull(new_data.SQLText, '')
                       or IsNull(Filter.IntervalLowerSQLText, '') <> IsNull(new_data.IntervalLowerSQLText, '')
                       or IsNull(Filter.IntervalUpperSQLText, '') <> IsNull(new_data.IntervalUpperSQLText, '')
                       or IsNull(Filter.FilterMode, '') <> IsNull(new_data.FilterMode, '')
                       or IsNull(Filter.FolderID, -1) <> IsNull(new_data.FolderID, -1)
                       or IsNull(Filter.FilterType, '') <> IsNull(new_data.FilterType, '')
                      )
						  END

						  select @l_formFilterID=0;

						  SELECT @l_formFilterID = [FormFilter].[ID]
						  FROM [MIS].[FormFilter] 
						  WHERE [FormFilter].[FormID] = @l_formID 
						    AND [FormFilter].[FilterID] = @l_filterID;

						  SELECT @l_objectID = 0;

						  IF COALESCE(@l_formFilterID, 0) = 0 
						  BEGIN 
							  INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr]) 
							  VALUES ('OBJECT_TYPE_MIS_FORMFILTER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_filterCode, ' FormFilter object'), '1.0');

							  SELECT @l_objectID = SCOPE_IDENTITY()

							  IF COALESCE(@l_objectID, 0) > 0 
							  BEGIN
								  INSERT INTO MIS.FormFilter (ObjectID, FormID, FilterID, Code, FolderID, OrdNr, SQLText, IntervalLowerSQLText, IntervalUpperSQLText, DisableFilterMode, DefaultType, DefaultValue, CreationDate, CreationTime, CreationUserName) 
								    SELECT @l_objectID, @l_formID, @l_filterID, @l_filterCode, @l_formFilterFolderID FolderID, @l_filterOrdNr OrdNr, @l_filterSQLStatement SQLText, @l_filterlowersqltext IntervalLowerSQLText, @l_filteruppersqltext IntervalUpperSQLText,
                              Case when not exists(select *                  /*ha NEM tartoznak nézetek a formhoz, beállítjuk a DisableFilterMode-ot a lower+upper kitöltöttsége alapján; különben lentebb frissítjük majd*/
                                                   from @FormListingMode    
                                                  )
                                   then Case when IsNull(Replace(@l_filterlowersqltext, ' ', ''), '') not in('', 'AND1=1') and IsNull(Replace(@l_filteruppersqltext, ' ', ''), '') not in('', 'AND1=1') then 'BOOLEAN_TRUE' /*megjelenhet a csúszka*/
                                             else 'BOOLEAN_FALSE'
                                        end
                                   else 'BOOLEAN_FALSE'
                              end DisableFilterMode,
								              @l_filterDefaultType DefaultType, @l_filterDefaultValue DefaultValue,                                 
                           CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName

								  SELECT @l_formFilterID = SCOPE_IDENTITY()
							  END
						  END
              ELSE
              BEGIN
                UPDATE [MIS].[FormFilter] 
                SET [FolderID] = new_data.FolderID,
								    [OrdNr] = new_data.OrdNr, 
								    [SQLText] = new_data.SQLText,
								    [IntervalLowerSQLText]= new_data.IntervalLowerSQLText,
								    [IntervalUpperSQLText]= new_data.IntervalUpperSQLText,
                    [DisableFilterMode] = new_data.DisableFilterMode,
								    [DefaultType] = new_data.DefaultType,
								    [DefaultValue] = new_data.DefaultValue,
								    [LastModifiedDate] = CAST( GETDATE() AS Date),
								    [LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
								    [LastModifiedUserName] = @l_userName
                FROM (select @l_formFilterFolderID FolderID, @l_filterOrdNr OrdNr, @l_filterSQLStatement SQLText, @l_filterlowersqltext IntervalLowerSQLText, @l_filteruppersqltext IntervalUpperSQLText,
                              Case when not exists(select *                  /*ha NEM tartoznak nézetek a formhoz, beállítjuk a DisableFilterMode-ot a lower+upper kitöltöttsége alapján; különben lentebb frissítjük majd*/
                                                   from @FormListingMode    
                                                  )
                                   then Case when IsNull(Replace(@l_filterlowersqltext, ' ', ''), '') not in('', 'AND1=1') and IsNull(Replace(@l_filteruppersqltext, ' ', ''), '') not in('', 'AND1=1') then 'BOOLEAN_TRUE' /*megjelenhet a csúszka*/
                                             else 'BOOLEAN_FALSE'
                                        end
                                   else FormFilter.DisableFilterMode
                              end DisableFilterMode,
								              @l_filterDefaultType DefaultType, @l_filterDefaultValue DefaultValue
                      from MIS.FormFilter
                      where [FormFilter].[ID] = @l_formFilterID
                     ) new_data
							  WHERE [FormFilter].[ID] = @l_formFilterID;
              END

						  IF COALESCE(@l_formFilterID, 0) > 0 
						  BEGIN 
                delete from @FormFilterListingMode

                /*FormFilterListingMode kezelése, ha tartoznak nézetek a formhoz*/
                IF EXISTS(SELECT *                  /*azaz tartoznak nézetek a formhoz*/
                          FROM @FormListingMode    
                         ) 
                BEGIN
                  set @l_disableFilterMode = 'BOOLEAN_FALSE' /*abból indulunk ki, hogy nem jelenhet meg a csúszka*/
                
                  insert into @FormFilterListingMode (listingModeCode, sqlStatement, lowersqltext, uppersqltext)
                    select filterModes.listingModeCode, filterModes.sqlStatement, filterModes.lowersqltext, filterModes.uppersqltext
                    from OPENJSON(@l_filterListingModes)
                    WITH 	(listingModeCode NVARCHAR(200) '$.listingModeCode', 
                           sqlStatement NVARCHAR(MAX) '$.SQLStatement',
                           lowersqltext  NVARCHAR(MAX) '$.lower',
                           uppersqltext  NVARCHAR(MAX) '$.upper'
                          ) filterModes
                  
                  /*ahol nincs megadva a listingModeCode, ott azt tesszük be az összes olyanhoz, amihez nincs megadva konkrétan rá vonatkozó sor, majd az általános sorokat pedig töröljük*/
                  insert into @FormFilterListingMode (listingModeCode, sqlStatement, lowersqltext, uppersqltext)
                    SELECT flm.listingModeCode, fi.sqlStatement, fi.lowersqltext, fi.uppersqltext
                    FROM @FormFilterListingMode fi, @FormListingMode flm  
					          WHERE IsNull(fi.listingModeCode, '') = ''
                      AND NOT EXISTS(SELECT *
                                     FROM @FormFilterListingMode fi2
                                     WHERE fi2.listingModeCode = flm.listingModeCode
                                    )
                  
                  delete from @FormFilterListingMode
                  where IsNull(listingModeCode, '') = ''
                    

                  DECLARE listingMode_cur cursor local fast_forward for
                    SELECT fi.listingModeCode, fi.sqlStatement, fi.lowersqltext, fi.uppersqltext
                    FROM @FormFilterListingMode fi  
            
                  OPEN listingMode_cur

                
                  WHILE 1 = 1
                  BEGIN
                    FETCH NEXT FROM listingMode_cur INTO @l_filterListingModeCode, @l_filterListingModeSQLStatement, @l_filterListingModeLowerSqlText, @l_filterListingModeUpperSqlText

                    IF @@FETCH_STATUS <> 0
                       break

                    /*ha van legalább 1 nézet, aminél a lower+upper alapján meg kell jeleníteni a csúszkát, akkor megjelenítjük majd*/
                    if @l_disableFilterMode = 'BOOLEAN_FALSE'
                    begin
                      set @l_disableFilterMode = Case when IsNull(Replace(@l_filterListingModeLowerSqlText, ' ', ''), '') not in('', 'AND1=1') and IsNull(Replace(@l_filterListingModeUpperSqlText, ' ', ''), '') not in('', 'AND1=1') then 'BOOLEAN_TRUE' /*megjelenhet a csúszka*/
                                                      else 'BOOLEAN_FALSE'
                                                 end
                    end

                    /*nem létezik még --> létrehozzuk*/
                    IF NOT EXISTS(SELECT * 
                                  FROM MIS.FormFilterListingMode m
                                  where m.FormFilterID = @l_formFilterID
                                    and m.ListingModeCode = @l_filterListingModeCode
                                 )
                    BEGIN
                      INSERT INTO GEN.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
                                SELECT 'OBJECT_TYPE_MIS_FORMFILTERLISTINGMODE' ObjectType, CAST( GETDATE() AS Date) CreationDate, CONVERT(VARCHAR(8), GETDATE(),108) CreationTime, @l_userName CreationUserName, 'FormFilterListingMode object' Comments, '1.0' VersionNr

						          SELECT @l_objectID = SCOPE_IDENTITY()

                      INSERT INTO MIS.FormFilterListingMode(ObjectID, FormFilterID, ListingModeCode, SQLText, IntervalLowerSQLText, IntervalUpperSQLText, CreationDate, CreationTime, CreationUserName)
                        SELECT @l_objectID ObjectID, @l_formFilterID FormFilterID, @l_filterListingModeCode ListingModeCode, @l_filterListingModeSQLStatement SQLText, @l_filterListingModeLowerSqlText IntervalLowerSQLText, @l_filterListingModeUpperSqlText IntervalUpperSQLText,
                               CAST(GETDATE() AS Date) CreationDate, CONVERT(VARCHAR(8), GETDATE(),108) CreationTime, @l_userName CreationUserName
                    END
                    ELSE /*már létezik --> frissítjük*/
                    BEGIN
                      UPDATE MIS.FormFilterListingMode
                      SET SQLText = @l_filterListingModeSQLStatement,
                          IntervalLowerSQLText = @l_filterListingModeLowerSqlText,
                          IntervalUpperSQLText = @l_filterListingModeUpperSqlText,
                          LastModifiedDate = CAST(GETDATE() AS Date), 
                          LastModifiedTime = CONVERT(VARCHAR(8), GETDATE(),108), 
                          LastModifiedUserName = @l_userName
                      WHERE FormFilterListingMode.FormFilterID = @l_formFilterID
                        AND FormFilterListingMode.ListingModeCode = @l_filterListingModeCode
                        AND (    IsNull(FormFilterListingMode.SQLText, '') <> IsNull(@l_filterListingModeSQLStatement, '')
                              OR IsNull(FormFilterListingMode.IntervalLowerSQLText, '') <> IsNull(@l_filterListingModeLowerSqlText, '')
                              OR IsNull(FormFilterListingMode.IntervalUpperSQLText, '') <> IsNull(@l_filterListingModeUpperSqlText, '')
                            )
                    END
                  END

                  CLOSE listingMode_cur
                  DEALLOCATE listingMode_cur
                END

                /*DisableFilterMode update, ha kell*/
                update MIS.FormFilter
                set DisableFilterMode = @l_disableFilterMode,
                    LastModifiedDate = CAST( GETDATE() AS Date),
								    LastModifiedTime = CONVERT(VARCHAR(8), GETDATE(),108),
								    LastModifiedUserName = @l_userName
                where FormFilter.ID = @l_formFilterID
                  and IsNull(FormFilter.DisableFilterMode, '') <> @l_disableFilterMode


                /*törlendő MIS.FormFilterListingMode rekordok kigyűjtése*/
                if exists(select *
                          from MIS.FormFilterListingMode flm
                          where flm.FormFilterID = @l_formFilterID
                            and not exists(select *
                                            from @FormFilterListingMode m
                                            where m.ListingModeCode = flm.ListingModeCode
                                          )
                          )
                begin
                  insert into @ToDelete(id, tablename)
                                select flm.ID, 'MIS.FormFilterListingMode' tablename
                                from MIS.FormFilterListingMode flm
                                where flm.FormFilterID = @l_formFilterID
                                  and not exists(select *
                                                  from @FormFilterListingMode m
                                                  where m.ListingModeCode = flm.ListingModeCode
                                                )
                end

						  END
					  END

					  CLOSE filter_cursor;
					  DEALLOCATE filter_cursor;

            /*törlendő MIS.FormFilter rekordok kigyűjtése*/
            if exists(select *
                      from MIS.FormFilter ff
                      where ff.FormID = @l_formID
                        and not exists(select *
                                       from @Filters f
                                       where f.code = ff.Code
                                      )
                      )
            begin
              insert into @ToDelete(id, tablename)
                            select ff.ID, 'MIS.FormFilter' tablename
                            from MIS.FormFilter ff
                            where ff.FormID = @l_formID
                              and not exists(select *
                                             from @Filters f
                                             where f.code = ff.Code
                                            )
            end
				  END

				  CLOSE filterFolder_cursor;
				  DEALLOCATE filterFolder_cursor;

				  PRINT 'Processing @Columns table';

				  --Mezők feldolgozása
				  DECLARE formColumn_cursor CURSOR LOCAL FAST_FORWARD FOR 
				    SELECT c.code, c.title, c.displayWidth, c.alignment, c.formatMask, c.ordNr, c.area, c.allowedArea, c.columnVisible
				    FROM @Columns c
				    ORDER BY c.ordNr

				  OPEN formColumn_cursor

				  WHILE 1 = 1
				  BEGIN
            FETCH NEXT FROM formColumn_cursor INTO @l_columnCode, @l_columnTitle, @l_columnDisplayWidth, @l_columnAlignment, @l_columnFormatMask, @l_columnOrdNr, @l_columnArea, @l_columnAllowedArea, @l_columnColumnVisible

            if @@FETCH_STATUS <> 0
               break

            
            PRINT Concat('Processing Column: ', @l_columnCode)   

				    select @l_formColumnID=0;

					  SELECT @l_formColumnID = [FormColumn].[ID] 
					  FROM [MIS].[FormColumn] 
					  WHERE [FormColumn].[FormID] = @l_formID
					    AND [FormColumn].[ColumnName] = @l_columnCode;


					  SELECT @l_objectID = 0;

					  IF COALESCE(@l_formColumnID, 0) = 0
					  BEGIN
						  INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr]) 
						  VALUES ('OBJECT_TYPE_MIS_FORMCOLUMN', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_columnCode, ' FormColumn object'), '1.0');

						  SELECT @l_objectID = SCOPE_IDENTITY();

						  IF COALESCE(@l_objectID, 0) > 0 
						  BEGIN
							  INSERT INTO MIS.FormColumn(ObjectID, FormID, ColumnName, ColumnTitleCode, DisplayWidth, Alignment, FormatMask, OrdNr, Area, AllowedArea, ColumnVisible, CreationDate, CreationTime, CreationUserName) 
							    SELECT @l_objectID, @l_formID, @l_columnCode ColumnName, @l_columnTitle ColumnTitleCode, @l_columnDisplayWidth, @l_columnAlignment, @l_columnFormatMask, @l_columnOrdNr, @l_columnArea, @l_columnAllowedArea, @l_columnColumnVisible,
                         CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName
						  END
					  END
            ELSE
            BEGIN
              UPDATE MIS.FormColumn
              SET ColumnTitleCode = @l_columnTitle,
							    DisplayWidth = @l_columnDisplayWidth,
                  Alignment = @l_columnAlignment,
                  FormatMask = @l_columnFormatMask,
							    OrdNr = @l_columnOrdNr,
							    Area = @l_columnArea,
                  AllowedArea = @l_columnAllowedArea,
							    ColumnVisible = @l_columnColumnVisible,
							    LastModifiedDate = CAST( GETDATE() AS Date),
							    LastModifiedTime = CONVERT(VARCHAR(8), GETDATE(),108),
							    LastModifiedUserName = @l_userName
						  WHERE [FormColumn].[ID] = @l_formColumnID
                AND (   IsNull(ColumnTitleCode, '') <> IsNull(@l_columnTitle, '')
                      OR IsNull(DisplayWidth, '') <> IsNull(@l_columnDisplayWidth, '')
                      OR IsNull(Alignment, '') <> IsNull(@l_columnAlignment, '')
                      OR IsNull(FormatMask, '') <> IsNull(@l_columnFormatMask, '')
                      OR IsNull(OrdNr, -100000) <> IsNull(@l_columnOrdNr, -100000)
                      OR IsNull(Area, '') <> IsNull(@l_columnArea, '')
                      OR IsNull(AllowedArea, '') <> IsNull(@l_columnAllowedArea, '')
                      OR IsNull(ColumnVisible, '') <> IsNull(@l_columnColumnVisible, '')
                    )
            END 
				  END

				  CLOSE formColumn_cursor;
				  DEALLOCATE formColumn_cursor;

          /*törlendő MIS.FormColumn rekordok kigyűjtése*/
          if exists(select *
                    from MIS.FormColumn fc
                    where fc.FormID = @l_formID
                      and not exists(select *
                                     from @Columns c
                                     where c.code = fc.ColumnName
                                    )
                    )
          begin
            insert into @ToDelete(id, tablename)
                          select fc.ID, 'MIS.FormColumn' tablename
                          from MIS.FormColumn fc
                          where fc.FormID = @l_formID
                            and not exists(select *
                                           from @Columns c
                                           where c.code = fc.ColumnName
                                          )
          end


				  PRINT 'Processing @Actions table';

				  --Akciók feldolgzása
				  DECLARE formAction_cursor CURSOR LOCAL FAST_FORWARD FOR 
				    SELECT a.code, a.title, a.translations, a.functionType, a.defaultAction
				    FROM @Actions a

				  OPEN formAction_cursor;

				  WHILE 1 = 1
				  BEGIN 
            FETCH NEXT FROM formAction_cursor INTO  @l_actionCode, @l_actionTitle, @l_actionTranslations, @l_actionFunctionType, @l_actionDefaultAction

            if @@FETCH_STATUS <> 0
               break

				    select @l_formActionID=0;

					  SELECT @l_formActionID = [FormAction].[ID] 
					  FROM [MIS].[FormAction] 
					  WHERE [FormAction].[FormID] = @l_formID 
					    AND [FormAction].[FunctionName] = @l_actionCode;

					  SELECT @l_objectID = 0;

					  IF COALESCE(@l_formActionID, 0) = 0 
					  BEGIN
						  INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr]) 
						  VALUES ('OBJECT_TYPE_MIS_FORMACTION', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_actionCode, ' FormAction object'), '1.0');

						  SELECT @l_objectID = SCOPE_IDENTITY()

						  IF COALESCE(@l_objectID, 0) > 0
						  BEGIN
							  INSERT INTO MIS.FormAction (ObjectID, FormID, FunctionName, FunctionType, FunctionTitleCode, DefaultAction, CreationDate, CreationTime, CreationUserName) 
							    SELECT @l_objectID, @l_formID, @l_actionCode FunctionName, @l_actionFunctionType, @l_actionTitle FunctionTitleCode, @l_actionDefaultAction, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName
						  END;
					  END
            ELSE
					  BEGIN 
              UPDATE MIS.FormAction
              SET FunctionName = @l_actionCode,
                  FunctionType = @l_actionFunctionType,
							    FunctionTitleCode = @l_actionTitle,
                  DefaultAction = a.DefaultAction,
                  LastModifiedDate = CAST( GETDATE() AS Date),
							    LastModifiedTime = CONVERT(VARCHAR(8), GETDATE(),108),
							    LastModifiedUserName = @l_userName
              FROM (SELECT FormAction.ID,
                           Case when @l_actionDefaultAction is null /*ha benne sem volt a json-ben a DefaultActionhöz tartozó tag, akkor nem módosítjuk*/ then FormAction.DefaultAction
                                when @l_actionDefaultAction = ''    /*ha benne volt a tag a json-ben, de nem volt megadva benne semmi, akkor nullozzuk */ then null
                                else @l_actionDefaultAction
                           end DefaultAction 
                    FROM MIS.FormAction
                    WHERE FormAction.ID = @l_formActionID
                   ) a
              where FormAction.ID = a.ID
                AND (   IsNull(FormAction.FunctionName, '') <> IsNull(@l_actionCode, '')
                     OR IsNull(FormAction.FunctionType, '') <> IsNull(@l_actionFunctionType, '')
                     OR IsNull(FormAction.FunctionTitleCode, '') <> IsNull(@l_actionTitle, '')
                     OR IsNull(FormAction.DefaultAction, '') <> IsNull(a.DefaultAction, '')
                    )
					  END
				  END

				  CLOSE formAction_cursor;
				  DEALLOCATE formAction_cursor;


          /*törlendő MIS.FormAction rekordok kigyűjtése*/
          if exists(select *
                    from MIS.FormAction fa
                    where fa.FormID = @l_formID
                      and not exists(select *
                                      from @Actions a
                                      where a.code = fa.FunctionName
                                    )
                    )
          begin
            insert into @ToDelete(id, tablename)
                          select fa.ID, 'MIS.FormAction' tablename
                          from MIS.FormAction fa
                          where fa.FormID = @l_formID
                            and not exists(select *
                                            from @Actions a
                                            where a.code = fa.FunctionName
                                          )
          end
			  END
		  END
		
		  CLOSE misForm_cursor;
		  DEALLOCATE misForm_cursor; 


      /*Fizikai törlések a @ToDelete tábla alapján*/
      /*1. Törlés - MIS.FormFilterListingMode*/
      if exists(select *
                from @ToDelete d
                where d.tablename = 'MIS.FormFilterListingMode'
               )
      begin
        print 'Deleting MIS.FormFilterListingMode';

        delete del
        from MIS.FormFilterListingMode del
        where exists(select *
                     from @ToDelete d
                     where d.tablename = 'MIS.FormFilterListingMode'  
                       and d.id = del.ID
                    )
      end

      /*2. Törlés - MIS.FormListingMode*/
      if exists(select *
                from @ToDelete d
                where d.tablename = 'MIS.FormListingMode'
               )
      begin
        print 'Deleting MIS.FormListingMode';

        delete del
        from MIS.FormListingMode del
        where exists(select *
                     from @ToDelete d
                     where d.tablename = 'MIS.FormListingMode'  
                       and d.id = del.ID
                    )
      end

      /*3. Törlés - MIS.FormFilter*/
      if exists(select *
                from @ToDelete d
                where d.tablename = 'MIS.FormFilter'
               )
      begin
        print 'Deleting MIS.FormFilter';

        delete del
        from MIS.FormFilter del
        where exists(select *
                     from @ToDelete d
                     where d.tablename = 'MIS.FormFilter'  
                       and d.id = del.ID
                    )
      end

      /*4. Törlés - MIS.FormColumn*/
      if exists(select *
                from @ToDelete d
                where d.tablename = 'MIS.FormColumn'
               )
      begin
        print 'Deleting MIS.FormColumn';

        delete del
        from MIS.FormColumn del
        where exists(select *
                     from @ToDelete d
                     where d.tablename = 'MIS.FormColumn'  
                       and d.id = del.ID
                    )
      end

      /*5. Törlés - MIS.FormAction*/
      if exists(select *
                from @ToDelete d
                where d.tablename = 'MIS.FormAction'
               )
      begin
        print 'Deleting MIS.FormAction';

        delete del
        from MIS.FormAction del
        where exists(select *
                     from @ToDelete d
                     where d.tablename = 'MIS.FormAction'  
                       and d.id = del.ID
                    )
      end
      /*Fizikai törlések vége*/

    COMMIT

    SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @l_procedureName, 
                            @p_LogMessage = @l_logMsg
			
    PRINT @l_logMsg;
		
    RETURN 1;
	END TRY

	BEGIN CATCH
		IF @@TRANCOUNT > 0
       ROLLBACK

		--Hiba kezelés
    select @l_errorProcedure = ERROR_PROCEDURE(), @l_errorNumber = ERROR_NUMBER(), @l_errorSeverity = ERROR_SEVERITY(), @l_errorState = ERROR_STATE(), @l_errorLine = ERROR_LINE(), @l_logMsg = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @l_procedureName, 
                            @p_ErrorProcedure = @l_errorProcedure,
                            @p_ErrorNumber = @l_errorNumber,
                            @p_ErrorSeverity = @l_errorSeverity,
                            @p_ErrorState = @l_errorState,
                            @p_ErrorLine = @l_errorLine,
                            @p_ErrorMessage = @l_logMsg
			
		PRINT @l_logMsg;

		RETURN 99;
	END CATCH
END
go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2023-03-30
-- Last modified date: 2023-04-11
-- Description:	Insert Module definitions from .json files
-- =============================================
CREATE PROCEDURE [ORG].[InsertFromJsonModule] 
	-- Add the parameters for the stored procedure here
	@p_json NVARCHAR(MAX)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'ORG.InsertFromJsonModule'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_json NVARCHAR(MAX) = NULL;
	DECLARE @l_system NVARCHAR(50) = NULL;
	DECLARE @l_version NVARCHAR(5) = NULL;
	DECLARE @l_type NVARCHAR(50) = NULL;
    DECLARE @l_userID NVARCHAR(200) = NULL;
	DECLARE @l_itemCount NUMERIC(16) = NULL;
	DECLARE @l_modulesJSON NVARCHAR(MAX) = NULL;
	DECLARE @l_userName NVARCHAR(200) = 'admin';
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--A #Modules változói
	DECLARE @l_code NVARCHAR(200) = NULL;
	DECLARE @l_translations NVARCHAR(MAX) = NULL; 
	DECLARE @l_messageQueueTopic NVARCHAR(200) = NULL;
	DECLARE @l_executionPath NVARCHAR(200) = NULL;
	DECLARE @l_maxInstances NVARCHAR(200) = NULL; 
	DECLARE @l_stopAllowed NVARCHAR(200) = NULL; 
	DECLARE @l_sqlStatement NVARCHAR(MAX) = NULL;
	DECLARE @l_parameters NVARCHAR(MAX) = NULL; 
	--A #Parameters változói
	DECLARE @l_parameterCode NVARCHAR(200) = NULL;
	DECLARE @l_parameterTranslation NVARCHAR(MAX) = NULL;
	DECLARE @l_parameterValueSetCode NVARCHAR(200) = NULL;
	DECLARE @l_parameterDefaultTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_parameterDefaultValue NVARCHAR(MAX) = NULL;
	DECLARE @l_parameterRequired NVARCHAR(200) = NULL;
	DECLARE @l_parameterVisible NVARCHAR(200) = NULL;
	DECLARE @l_parameterReadOnly NVARCHAR(200) = NULL;
	--A #Translations változói
	DECLARE @l_translationValueSetPrefixCode NVARCHAR(200) = NULL;
	DECLARE @l_translationCode NVARCHAR(200) = NULL;
	DECLARE @l_translationLanguage NVARCHAR(5) = NULL;
	DECLARE @l_translationText NVARCHAR(200) = NULL;
	--GEN.ValueSet változói
	DECLARE @l_valueSetID NUMERIC(16) = NULL;
	--A GEN.Code változói
	DECLARE @l_codeID NVARCHAR(200) = NULL;
	--Az ORG.Module változói
	DECLARE @l_moduleID NUMERIC(16) = NULL;
	DECLARE @l_moduleObjectID NUMERIC(16) = NULL;
	--Az ORG.ModuleParameter változói
	DECLARE @l_moduleParameterID NUMERIC(16) = NULL;
	DECLARE @l_moduleParameterObjectID NUMERIC(16) = NULL;
	--Az ORG.ModuleProcedure változói
	DECLARE @l_moduleProcedureID NUMERIC(16) = NULL;

    BEGIN TRY 
--===========================================================
--BLOCK      : START
--DESCRIPTION: Start procedure
--===========================================================
		BEGIN TRANSACTION MAIN_TRANSACTION;

		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

--===========================================================
--BLOCK      : CHECK PARAMS
--DESCRIPTION: Checking parameters
--===========================================================
		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
			
		IF COALESCE(@p_json, '') = '' 
			RAISERROR('The p_json parameter isn''t empty.', 16, 1);

--===========================================================
--BLOCK      : PROCESS START
--DESCRIPTION: 
--===========================================================
		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
			
		SELECT @l_json = @p_json;
		
--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing header datas
--===========================================================
		--Fejadatok feldolgozása
		SELECT @l_system = JSON_VALUE(@l_json, '$.header.system'),
		       @l_version = JSON_VALUE(@l_json, '$.header.version'),
		       @l_type = JSON_VALUE(@l_json, '$.header.type'),
               @l_userID = 'Admin',
               @l_itemCount = CAST(COALESCE(JSON_VALUE(@l_json, '$.header.itemCount'), '0') AS NUMERIC(16));
		
		SELECT @l_logMsg = CONCAT('The value of JSON type: ', @l_type);
		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
		
		IF @l_system <> 'INDECS'
            RAISERROR( 'System is not INDECS.', 16, 1);
        IF @l_version <> '3'
            RAISERROR( 'Wrong INDECS version.', 16, 1);
        IF @l_type <> 'MODULE'
            RAISERROR( 'Wrong type of JSON file.', 16, 1);
			
		SELECT @l_logMsg = CONCAT('The number of items in Module JSON: ', @l_itemCount);
		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		
--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Create temporary tables
--===========================================================

		--Ideiglenes táblák létrehozása 
		IF OBJECT_ID('tempdb..#Modules', 'U') IS NOT NULL
			DROP TABLE #Modules;

		CREATE TABLE #Modules (
			code NVARCHAR(200),
			translations NVARCHAR(MAX),
			messageQueueTopic NVARCHAR(200),
			executionPath NVARCHAR(200),
			maxInstances NVARCHAR(200),
			stopAllowed NVARCHAR(200),
			sqlStatement NVARCHAR(MAX),
			[parameters] NVARCHAR(MAX)
		);

		IF OBJECT_ID('tempdb..#Parameters', 'U') IS NOT NULL
			DROP TABLE #Parameters;
		
		CREATE TABLE #Parameters (
			parameterCode NVARCHAR(200),
			parameterTranslation NVARCHAR(MAX),
			parameterValueSetCode NVARCHAR(200),
			parameterDefaultTypeCode NVARCHAR(200),
			parameterDefaultValue NVARCHAR(MAX),
			parameterRequired NVARCHAR(200),
			parameterVisible NVARCHAR(200),
			parameterReadOnly NVARCHAR(200)			
		);

		IF OBJECT_ID('tempdb..#Translations', 'U') IS NOT NULL
			DROP TABLE #Translations;
		
		CREATE TABLE #Translations (
			valueSetPrefixCode NVARCHAR(200),
			code NVARCHAR(200),
			language NVARCHAR(5),
			text NVARCHAR(200)
		);
		
		SELECT @l_logMsg = 'Temporary tables created.';
		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing modules and fill additional temporary tables
--===========================================================
			
		SELECT @l_modulesJSON = JSON_QUERY(@l_json, '$.modules');
		
		INSERT INTO #Modules (code, translations, messageQueueTopic, executionPath, maxInstances, stopAllowed, sqlStatement, [parameters])
		SELECT 
			Modules.code, 
			Modules.translations,
			Modules.messageQueueTopic, 
			Modules.executionPath,
			Modules.maxInstances, 
			Modules.stopAllowed,
			Modules.sqlStatement,
			Modules.[parameters]
		FROM OPENJSON(@l_modulesJSON)
		WITH 
			(code NVARCHAR(200) '$.code',
			 translations NVARCHAR(MAX) '$.translations' AS JSON,
			 messageQueueTopic NVARCHAR(200) '$.messageQueueTopic',
			 executionPath NVARCHAR(200) '$.executionPath', 
			 maxInstances NVARCHAR(200) '$.maxInstances',
			 stopAllowed NVARCHAR(200) '$.stopAllowed',
			 sqlStatement NVARCHAR(MAX) '$.sqlStatement', 
			 [parameters] NVARCHAR(MAX) '$.parameters' AS JSON) AS Modules;
			 
		SELECT @l_logMsg = '#Modules temporary table filled.';
		PRINT @l_logMsg;
			 
		DECLARE module_cursor CURSOR FOR 
		SELECT 
			#Modules.code, 
			#Modules.translations,
			#Modules.messageQueueTopic, 
			#Modules.executionPath, 
			#Modules.maxInstances,
			#Modules.stopAllowed,
			#Modules.sqlStatement,
			#Modules.[parameters] 
		FROM #Modules;
		
		OPEN module_cursor;
		FETCH NEXT FROM module_cursor 
		INTO 
			@l_code,
			@l_translations,
			@l_messageQueueTopic,
			@l_executionPath,
			@l_maxInstances,
			@l_stopAllowed, 
			@l_sqlStatement,
			@l_parameters;

		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT @l_logMsg = 'Next ORG.Module';
			PRINT @l_logMsg;

			SELECT @l_moduleID = NULL;
			SELECT @l_moduleObjectID = NULL;
			SELECT @l_moduleProcedureID = NULL;
			
			PRINT 'CLEAR Temporary tables contetnt';

			DELETE FROM #Translations;
			DELETE FROM #Parameters;

			PRINT 'Fill #Translations table with ORG.Module translation data';
			--ORG.Module nyelvi feliratai
			INSERT INTO #Translations (valueSetPrefixCode, code, language, text)
			SELECT 
				'MODULE',
				@l_code AS code,
				ModuleTrans.[language],
				ModuleTrans.[text]
			FROM OPENJSON(@l_translations) WITH (
				[language] NVARCHAR(5) '$.language',
				[text] NVARCHAR(50) '$.text') AS ModuleTrans;

			PRINT 'Fill #Parameters table with ORG.Module parameters data';
			--Szűrők
			INSERT INTO #Parameters (parameterCode, parameterTranslation, parameterValueSetCode, 
				parameterDefaultTypeCode, parameterDefaultValue, parameterRequired, parameterVisible, parameterReadOnly)
			SELECT 
				ModuleParams.code, 
				ModuleParams.translations, 
				ModuleParams.valueSetCode, 
				ModuleParams.defaultTypeCode, 
				ModuleParams.defaultValue, 
				ModuleParams.[required], 
				ModuleParams.visible, 
				ModuleParams.[readOnly]
			FROM OPENJSON(@l_parameters) WITH (
				code NVARCHAR(200) '$.code', 
				translations NVARCHAR(MAX) '$.translation' AS JSON,
				valueSetCode NVARCHAR(200) '$.valueSetCode',
				defaultTypeCode NVARCHAR(200) '$.defaultTypeCode',
				defaultValue NVARCHAR(MAX) '$.defaultValue',
				[required] NVARCHAR(200) '$.required',
				visible NVARCHAR(200) '$.visible', 
				[readOnly] NVARCHAR(MAX) '$.readOnly') AS ModuleParams;

			DECLARE parameterTranslation_cursor CURSOR FOR 
			SELECT
				#Parameters.parameterCode,
				#Parameters.parameterTranslation
			FROM #Parameters;
			
			OPEN parameterTranslation_cursor;
			FETCH NEXT FROM parameterTranslation_cursor 
			INTO 
				@l_parameterCode,
				@l_parameterTranslation;
			
			PRINT 'Fill #Translation table with #Parameters translation data';
			WHILE @@FETCH_STATUS = 0 
			BEGIN
				--Szűrők nyelvi feliratai
				INSERT INTO #Translations (valueSetPrefixCode, code, language, text)
				SELECT 
					'MODULE_PARAMETER',
					@l_parameterCode AS code,
					ParameterTrans.[language],
					ParameterTrans.[text]
				FROM OPENJSON(@l_parameterTranslation) WITH (
					[language] NVARCHAR(5) '$.language',
					[text] NVARCHAR(50) '$.text') AS ParameterTrans;
				
				FETCH NEXT FROM parameterTranslation_cursor 
				INTO 
					@l_parameterCode,
					@l_parameterTranslation;
			END;
			
			CLOSE parameterTranslation_cursor;
			DEALLOCATE parameterTranslation_cursor;

--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing content of temporary tables
--===========================================================

			IF COALESCE(@l_code, '') = '' 
			BEGIN
				SELECT @l_logMsg = 'The code of the Module cannot be an empty value.';

				BEGIN TRANSACTION LOG_TRANSACTION;
				INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
				SELECT 
					CAST( GETDATE() AS Date ),	-- LogDate,	
					CAST( GETDATE() AS Time ),	-- LogTime,
					SUSER_SNAME(),				-- UserName
					NULL,			-- CorrelationID
					'INDECS 3.0',			    -- ApplicationName
					DB_NAME(),					-- Environment
					'BACKEND',					-- Layer
					@l_procedureName,   		-- ServiceName
					'1.0',						-- ServiceVersion
					'INFO',					        -- SeverityLevel
					NULL,						-- MessageCategory
					@l_logMsg;				    -- LogMessage
				COMMIT TRANSACTION LOG_TRANSACTION;

				PRINT @l_logMsg;
			END
			ELSE
			BEGIN
				PRINT 'Processing #Translations table';

				--Feliratok feldolgozása
				DECLARE translation_cursor CURSOR FOR 
				SELECT
					#Translations.valueSetPrefixCode,
					#Translations.code,
					#Translations.[language],
					#Translations.[text]
				FROM #Translations;

				OPEN translation_cursor;
				FETCH NEXT FROM translation_cursor
				INTO
					@l_translationValueSetPrefixCode,
					@l_translationCode,
					@l_translationLanguage,
					@l_translationText;

				WHILE @@FETCH_STATUS = 0
				BEGIN
					PRINT CONCAT('Processing #Translations row. PrefixCode(', 
						@l_translationValueSetPrefixCode, '), Code(', 
						@l_translationCode, '), Language(', 
						@l_translationLanguage, '), Text(', 
						@l_translationText, ').');

					SELECT @l_valueSetID = [ValueSet].[ID]
					FROM [GEN].[ValueSet]
					WHERE [ValueSet].[CodePrefix] = @l_translationValueSetPrefixCode;

					IF COALESCE(@l_valueSetID, 0) > 0 
					BEGIN 
						PRINT CONCAT('Try insert new data in GEN.Code with ValueSetID(', 
							@l_valueSetID, '), ID(', @l_translationCode, ')');

						INSERT INTO [GEN].[Code] ([ID], [ValueSetID], [ValidFrom],  
							[CreationDate], [CreationTime], [CreationUserName]) 
						SELECT @l_translationCode, @l_valueSetID, CAST( GETDATE() AS Date), 
							CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName
						WHERE NOT EXISTS 
							(SELECT 1 
							 FROM [GEN].[Code]
							 WHERE [Code].[ValueSetID] = @l_valueSetID 
							 AND [Code].[ID] = @l_translationCode);

						SELECT @l_codeID = [Code].[ID]
						FROM [GEN].[Code]
						WHERE [Code].[ValueSetID] = @l_valueSetID
						AND [Code].[ID] = @l_translationCode;

						IF COALESCE(@l_codeID, '') <> '' 
						BEGIN
							INSERT INTO [GEN].[Translation] ([CodeID], [Language], [Text], [CreationDate], [CreationTime], [CreationUserName])
							  SELECT @l_codeID, @l_translationLanguage, @l_translationText,
								  CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName
							  WHERE NOT EXISTS 
								  (SELECT 1 
								   FROM [GEN].[Translation]
								   WHERE [Translation].[CodeID] = @l_codeID 
								   AND [Translation].[Language] = @l_translationLanguage);

							UPDATE [GEN].[Translation] 
              SET [Text] = @l_translationText 
							WHERE [Translation].[CodeID] = @l_codeID
							AND [Translation].[Language] = @l_translationLanguage;
						END
					END

					FETCH NEXT FROM translation_cursor
					INTO
						@l_translationValueSetPrefixCode,
						@l_translationCode,
						@l_translationLanguage,
						@l_translationText;
				END;

				CLOSE translation_cursor;
				DEALLOCATE translation_cursor;

				PRINT CONCAT('Processing ORG.Module general data. Module code: ', @l_code);

				--Modul adatok feldolgozása
				SELECT 
					@l_moduleID = [Module].[ID], 
					@l_moduleObjectID = [Module].[ObjectID]
				FROM [ORG].[Module]
				WHERE [Module].[ModuleCode] = @l_code;

				SELECT @l_objectID = 0;

				IF COALESCE(@l_moduleID, 0) = 0
				BEGIN 
					PRINT CONCAT('Module not found with ', @l_code, ' code.');

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_code, 'module object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;
					SELECT @l_moduleObjectID = @l_objectID;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN
						INSERT INTO [ORG].[Module] ([ObjectID], [ModuleCode],  
							[CreationDate], [CreationTime], [CreationUserName])
						SELECT @l_objectID, @l_code,
							CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

						SELECT @l_moduleID = @@IDENTITY;

						PRINT CONCAT('Inserted module indentifier: ', @l_moduleID);
					END
				END;

				IF COALESCE(@l_moduleID, 0) > 0
				BEGIN
					PRINT CONCAT('Update the ', @l_moduleID, ' module data.');

					UPDATE [ORG].[Module] SET 
						[ExecutionPath] = @l_executionPath,
						[MaxInstances] = @l_maxInstances,
						[StopAllowedCode] = @l_stopAllowed,
						[StatusCode] = 'MODULE_STATUS_CAN_RUN',
						[MessageQueueTopic] = @l_messageQueueTopic,
						[LastModifiedDate] = CAST( GETDATE() AS Date),
						[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
						[LastModifiedUserName] = @l_userName
					WHERE [Module].[ID] = @l_moduleID;

					--Modul eljárás feldolgozása
					IF COALESCE(@l_sqlStatement, '') <> ''
					BEGIN
						SELECT @l_moduleProcedureID = [ModuleProcedure].[ID] 
						FROM [ORG].[ModuleProcedure] 
						WHERE [ModuleProcedure].[ModuleID] = @l_moduleID;

						IF COALESCE(@l_moduleProcedureID, 0) = 0 
						BEGIN
							INSERT INTO [ORG].[ModuleProcedure] ([ModuleID], [CreationDate], [CreationTime], [CreationUserName])
							SELECT @l_moduleID, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

							SELECT @l_moduleProcedureID = @@IDENTITY;
						END;

						IF COALESCE(@l_moduleProcedureID, 0) > 0 
						BEGIN
							UPDATE [ORG].[ModuleProcedure] SET 
								[SQLStatement] = @l_sqlStatement, 
								[LastModifiedDate] = CAST( GETDATE() AS Date),
								[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
								[LastModifiedUserName] = @l_userName
							WHERE [ModuleProcedure].[ID] = @l_moduleProcedureID;
						END;
					END; --IF COALESCE(@l_sqlStatement, '') <> '' vége

					--Paraméterek feldolgozása
					PRINT 'Processing #Parameters temporary table.';

					DECLARE parameter_cursor CURSOR FOR 
					SELECT
						#Parameters.parameterCode,
						#Parameters.parameterValueSetCode,
						#Parameters.parameterDefaultTypeCode,
						#Parameters.parameterDefaultValue,
						#Parameters.parameterRequired,
						#Parameters.parameterVisible, 
						#Parameters.parameterReadOnly
					FROM #Parameters;

					OPEN parameter_cursor;
					FETCH NEXT FROM parameter_cursor 
					INTO 
						@l_parameterCode,
						@l_parameterValueSetCode,
						@l_parameterDefaultTypeCode,
						@l_parameterDefaultValue, 
						@l_parameterRequired, 
						@l_parameterVisible, 
						@l_parameterReadOnly;

					WHILE @@FETCH_STATUS = 0
					BEGIN
						PRINT CONCAT('The ', @l_moduleID, ' module Parameter code: ', @l_parameterCode);

						SELECT @l_moduleParameterID = 0;
						SELECT @l_moduleParameterObjectID = 0;

						SELECT @l_moduleParameterID = [ModuleParameter].[ID]
						FROM [ORG].[ModuleParameter] 
						WHERE [ModuleParameter].[ModuleID] = @l_moduleID
						AND [ModuleParameter].[ParameterCode] = @l_parameterCode;

						IF COALESCE(@l_moduleParameterID, 0) = 0
						BEGIN
							PRINT 'Parameter not found.';

							INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
							VALUES ('OBJECT_TYPE_ORG_MODULEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_parameterCode, 'module parameter object'), '1.0');

							SELECT @l_objectID = @@IDENTITY;

							IF COALESCE(@l_objectID, 0) > 0
							BEGIN
								INSERT INTO [ORG].[ModuleParameter] ([ObjectID], [ModuleID], [ParameterCode],  
									[CreationDate], [CreationTime], [CreationUserName])
								SELECT @l_objectID, @l_moduleID, @l_parameterCode,
									CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

								SELECT @l_moduleParameterID = @@IDENTITY;

								PRINT CONCAT('Inserted parameter identifier: ', @l_moduleParameterID);
							END
						END;

						IF COALESCE(@l_moduleParameterID, 0) > 0 
						BEGIN
							PRINT CONCAT('Update the ', @l_moduleParameterID, ' parameter data.');

							UPDATE [ORG].[ModuleParameter] SET 
								[ValueSetID] = (SELECT [ValueSet].[ID] FROM [GEN].[valueSet] WHERE [ValueSet].[Code] = @l_parameterValueSetCode),
								[DefaultType] = @l_parameterDefaultTypeCode,
								[DefaultValue] = @l_parameterDefaultValue,
								[Required] = @l_parameterRequired,
								[Visible] = @l_parameterVisible,
								[ReadOnly] = @l_parameterReadOnly,
								[LastModifiedDate] = CAST( GETDATE() AS Date),
								[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
								[LastModifiedUserName] = @l_userName
							WHERE [ModuleParameter].[ID] = @l_moduleParameterID;
						END

						FETCH NEXT FROM parameter_cursor 
						INTO 
							@l_parameterCode,
							@l_parameterValueSetCode,
							@l_parameterDefaultTypeCode,
							@l_parameterDefaultValue, 
							@l_parameterRequired, 
							@l_parameterVisible, 
							@l_parameterReadOnly;
					END;

					CLOSE parameter_cursor;
					DEALLOCATE parameter_cursor;

				END --IF COALESCE(@l_moduleID, 0) > 0 vége
			END

			FETCH NEXT FROM module_cursor 
			INTO 
				@l_code,
				@l_translations,
				@l_messageQueueTopic,
				@l_executionPath,
				@l_maxInstances,
				@l_stopAllowed, 
				@l_sqlStatement,
				@l_parameters;
		END;
		
		CLOSE module_cursor;
		DEALLOCATE module_cursor; 

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		COMMIT TRANSACTION MAIN_TRANSACTION;
		RETURN 1;
	END TRY

	BEGIN CATCH
		ROLLBACK TRANSACTION MAIN_TRANSACTION;

		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'translation_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE translation_cursor;

			DEALLOCATE translation_cursor;
		END

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'parameterTranslation_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE parameterTranslation_cursor;

			DEALLOCATE parameterTranslation_cursor;
		END

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'module_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE module_cursor;

			DEALLOCATE module_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_errorMsg;

		RETURN 99;
	END CATCH
END
go

-- =============================================
-- Author:		Aranyi Balázs
-- Create date: 2023.04.17.
-- Last modified date: 2023.04.17.
-- Description:	Insert Task group operation definition from .json files 
-- =============================================
CREATE PROCEDURE [ORG].[InsertFromJsonTaskGroupOperation] 
	-- Add the parameters for the stored procedure here
	@p_json NVARCHAR(MAX)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'ORG.InsertFromJsonTaskGroupOperation'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_json NVARCHAR(MAX) = NULL;
	DECLARE @l_system NVARCHAR(50) = NULL;
	DECLARE @l_version NVARCHAR(5) = NULL;
	DECLARE @l_type NVARCHAR(50) = NULL;
    DECLARE @l_userID NVARCHAR(200) = NULL;
	DECLARE @l_itemCount NUMERIC(16) = NULL;
	DECLARE @l_operationsJSON NVARCHAR(MAX) = NULL;
	DECLARE @l_userName NVARCHAR(200) = 'admin';
	--A #MTaskGroupOperations változói
	DECLARE @l_code NVARCHAR(200) = NULL; 
	DECLARE @l_parameters NVARCHAR(MAX) = NULL;
	--A #Parameters változói
	DECLARE @l_parameterCode NVARCHAR(200) = NULL;
	--Az ORG.TaskGroupOperationDefinition változói
	DECLARE @l_taskGroupOperationDefinitionID NUMERIC(16) = NULL;
	--Az ORG.TaskGroupOperationDefinitionParameter változói
	DECLARE @l_taskGroupOperationDefinitionParameterID NUMERIC(16) = NULL;
	--Az ORG.TaskType változói
	DECLARE @l_taskTypeID NVARCHAR(200) = NULL;
	--Az ORG.ModuleParameter változói
	DECLARE @l_moduleParameterID NUMERIC(16) = NULL;

	BEGIN TRY 
--===========================================================
--BLOCK      : START
--DESCRIPTION: Start procedure
--===========================================================
		BEGIN TRANSACTION MAIN_TRANSACTION;

		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

--===========================================================
--BLOCK      : CHECK PARAMS
--DESCRIPTION: Checking parameters
--===========================================================
		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
			
		IF COALESCE(@p_json, '') = '' 
			RAISERROR('The p_json parameter isn''t empty.', 16, 1);

--===========================================================
--BLOCK      : PROCESS START
--DESCRIPTION: 
--===========================================================
		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
			
		SELECT @l_json = @p_json;
		
--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing header datas
--===========================================================
		--Fejadatok feldolgozása
		SELECT @l_system = JSON_VALUE(@l_json, '$.header.system'),
		       @l_version = JSON_VALUE(@l_json, '$.header.version'),
		       @l_type = JSON_VALUE(@l_json, '$.header.type'),
               @l_userID = 'Admin',
               @l_itemCount = CAST(COALESCE(JSON_VALUE(@l_json, '$.header.itemCount'), '0') AS NUMERIC(16));
		
		SELECT @l_logMsg = CONCAT('The value of JSON type: ', @l_type);
		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
		
		IF @l_system <> 'INDECS'
            RAISERROR( 'System is not INDECS.', 16, 1);
        IF @l_version <> '3'
            RAISERROR( 'Wrong INDECS version.', 16, 1);
        IF @l_type <> 'OPERATION'
            RAISERROR( 'Wrong type of JSON file.', 16, 1);
			
		SELECT @l_logMsg = CONCAT('The number of items in Operation JSON: ', @l_itemCount);
		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		
--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Create temporary tables
--===========================================================

		--Ideiglenes táblák létrehozása 
		IF OBJECT_ID('tempdb..#Operations', 'U') IS NOT NULL
			DROP TABLE #Operations;

		CREATE TABLE #Operations (
			code NVARCHAR(200),
			[parameters] NVARCHAR(MAX)
		);

		IF OBJECT_ID('tempdb..#Parameters', 'U') IS NOT NULL
			DROP TABLE #Parameters;
		
		CREATE TABLE #Parameters (
			parameterCode NVARCHAR(200)			
		);
		
		SELECT @l_logMsg = 'Temporary tables created.';
		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing modules and fill additional temporary tables
--===========================================================
			
		SELECT @l_operationsJSON = JSON_QUERY(@l_json, '$.operations');
		
		INSERT INTO #Operations (code, [parameters])
		SELECT 
			Operations.code, 
			Operations.[parameters]
		FROM OPENJSON(@l_operationsJSON)
		WITH 
			(code NVARCHAR(200) '$.code', 
			 [parameters] NVARCHAR(MAX) '$.parameters' AS JSON) AS Operations;
			 
		SELECT @l_logMsg = '#Operations temporary table filled.';
		PRINT @l_logMsg;
			 
		DECLARE operations_cursor CURSOR FOR 
		SELECT 
			#Operations.code, 
			#Operations.[parameters] 
		FROM #Operations;
		
		OPEN operations_cursor;
		FETCH NEXT FROM operations_cursor 
		INTO 
			@l_code,
			@l_parameters;

		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT @l_logMsg = 'Next ORG.TaskGroupOperationDefinition';
			PRINT @l_logMsg;

			SELECT @l_taskTypeID = NULL;
			SELECT @l_taskGroupOperationDefinitionID = NULL;
			SELECT @l_moduleParameterID = NULL;
			SELECT @l_taskGroupOperationDefinitionParameterID = NULL;
			SELECT @l_objectID = 0;
			
			PRINT 'CLEAR Temporary tables contetnt';

			DELETE FROM #Parameters;

			PRINT 'Fill #Parameters table with ORG.TaskGroupOperationDefinition parameters data';
			--Paraméterek
			INSERT INTO #Parameters (parameterCode)
			SELECT 
				TaskGroupOperationDefinitionParams.code
			FROM OPENJSON(@l_parameters) WITH (
				code NVARCHAR(200) '$.code') AS TaskGroupOperationDefinitionParams;

--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing content of temporary tables
--===========================================================

			IF COALESCE(@l_code, '') = '' 
			BEGIN
				SELECT @l_logMsg = 'The code of the Task group operation definition cannot be an empty value.';

				BEGIN TRANSACTION LOG_TRANSACTION;
				INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
				SELECT 
					CAST( GETDATE() AS Date ),	-- LogDate,	
					CAST( GETDATE() AS Time ),	-- LogTime,
					SUSER_SNAME(),				-- UserName
					NULL,			-- CorrelationID
					'INDECS 3.0',			    -- ApplicationName
					DB_NAME(),					-- Environment
					'BACKEND',					-- Layer
					@l_procedureName,   		-- ServiceName
					'1.0',						-- ServiceVersion
					'INFO',					        -- SeverityLevel
					NULL,						-- MessageCategory
					@l_logMsg;				    -- LogMessage
				COMMIT TRANSACTION LOG_TRANSACTION;

				PRINT @l_logMsg;
			END
			ELSE
			BEGIN
				PRINT CONCAT('Processing ORG.TaskGroupOperationDefinition general data. Operation code: ', @l_code);

				--Modul adatok feldolgozása
				SELECT 
					@l_taskTypeID = [TaskType].[ID]
				FROM [ORG].[TaskType]
				WHERE [TaskType].[ID] = @l_code;

				IF COALESCE(@l_taskTypeID, '') = ''
				BEGIN
					SELECT @l_logMsg = CONCAT('The ', @l_code, ' task type is not defined.', 
						'A task group operation can only be created from a defined task type.');

					BEGIN TRANSACTION LOG_TRANSACTION;
					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),				-- UserName
						NULL,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						'INFO',					        -- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;				    -- LogMessage
					COMMIT TRANSACTION LOG_TRANSACTION;
	
					PRINT @l_logMsg;
				END 
				ELSE
				BEGIN
					SELECT @l_taskGroupOperationDefinitionID = [TaskGroupOperationDefinition].[ID] 
					FROM [ORG].[TaskGroupOperationDefinition] 
					WHERE [TaskGroupOperationDefinition].[TaskTypeID] = @l_taskTypeID;

					IF COALESCE(@l_taskGroupOperationDefinitionID, 0) = 0
					BEGIN
						INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
						VALUES ('OBJECT_TYPE_ORG_TASKGROUPOPERATIONDEFINITION', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_code, ' task group operation definition  object'), '1.0');

						SELECT @l_objectID = @@IDENTITY;

						IF COALESCE(@l_objectID, 0) > 0
						BEGIN
							INSERT INTO [ORG].[TaskGroupOperationDefinition] ([ObjectID], [TaskTypeID], [StatusCode], 
								[CreationDate], [CreationTime], [CreationUserName])
							SELECT @l_objectID, @l_code, 'STATUS_NORMAL',
								CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

							SELECT @l_taskGroupOperationDefinitionID = @@IDENTITY;

							PRINT CONCAT('Inserted task group operation definition indentifier: ', @l_taskGroupOperationDefinitionID);
						END
					END;

					IF COALESCE(@l_taskGroupOperationDefinitionID, 0) > 0 
					BEGIN 
						PRINT CONCAT('Update the ', @l_taskGroupOperationDefinitionID, ' task group operation definition data.');

						UPDATE [ORG].[TaskGroupOperationDefinition] SET 
							[StatusCode] = 'STATUS_NORMAL', 
							[LastModifiedDate] = CAST( GETDATE() AS Date),
							[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
							[LastModifiedUserName] = @l_userName
						WHERE [TaskGroupOperationDefinition].[ID] = @l_taskGroupOperationDefinitionID;

						--Paraméterek feldolgozása
						PRINT 'Processing #Parameters temporary table.';

						DECLARE parameter_cursor CURSOR FOR 
						SELECT
							#Parameters.parameterCode
						FROM #Parameters;

						OPEN parameter_cursor;
						FETCH NEXT FROM parameter_cursor 
						INTO 
							@l_parameterCode;

						WHILE @@FETCH_STATUS = 0
						BEGIN
							PRINT CONCAT('The ', @l_taskGroupOperationDefinitionID, ' task group operation definition Parameter code: ', @l_parameterCode);

							SELECT @l_moduleParameterID = NULL;
							SELECT @l_taskGroupOperationDefinitionParameterID = NULL;
							SELECT @l_objectID = NULL;

							IF COALESCE(@l_parameterCode, '') <> '' 
							BEGIN 
								SELECT @l_moduleParameterID = [ModuleParameter].[ID] 
								FROM [ORG].[ModuleParameter]
								JOIN [ORG].[TaskTypeModule] ON ([TaskTypeModule].[ModuleID] = [ModuleParameter].[ModuleID])
								WHERE [TaskTypeModule].[TaskTypeID] = @l_code
								AND [ModuleParameter].[ParameterCode] = @l_parameterCode;

								IF COALESCE(@l_moduleParameterID, 0) = 0
								BEGIN 
									SELECT @l_logMsg = CONCAT('The ', @l_parameterCode, ' module parameter is not defined.', 
										'A task group operation parameter can only be created from a defined module parameter.');

									BEGIN TRANSACTION LOG_TRANSACTION;
									INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
									SELECT 
										CAST( GETDATE() AS Date ),	-- LogDate,	
										CAST( GETDATE() AS Time ),	-- LogTime,
										SUSER_SNAME(),				-- UserName
										NULL,			-- CorrelationID
										'INDECS 3.0',			    -- ApplicationName
										DB_NAME(),					-- Environment
										'BACKEND',					-- Layer
										@l_procedureName,   		-- ServiceName
										'1.0',						-- ServiceVersion
										'INFO',					        -- SeverityLevel
										NULL,						-- MessageCategory
										@l_logMsg;				    -- LogMessage
									COMMIT TRANSACTION LOG_TRANSACTION;
	
									PRINT @l_logMsg;
								END
								ELSE 
								BEGIN 
									SELECT @l_taskGroupOperationDefinitionParameterID = [TaskGroupOperationDefinitionParameter].[ID]
									FROM [ORG].[TaskGroupOperationDefinitionParameter]
									WHERE [TaskGroupOperationDefinitionParameter].[TaskGroupOperationDefinitionID] = @l_taskGroupOperationDefinitionID
									AND [TaskGroupOperationDefinitionParameter].[ParameterCode] = @l_parameterCode;

									IF COALESCE(@l_taskGroupOperationDefinitionParameterID, 0) = 0
									BEGIN 
										INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr]) 
										SELECT 'OBJECT_TYPE_ORG_TASKGROUPOPERATIONDEFINITIONPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT(@l_parameterCode, ' task group operation definition parameter object'), '1.0';

										SELECT @l_objectID = @@IDENTITY;

										IF COALESCE(@l_objectID, 0) > 0
										BEGIN
											INSERT INTO [ORG].[TaskGroupOperationDefinitionParameter] ([ObjectID], [TaskGroupOperationDefinitionID], [ParameterCode], [CreationDate], [CreationTime], [CreationUserName])
											SELECT @l_objectID, @l_taskGroupOperationDefinitionID, @l_parameterCode, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin';

											SELECT @l_taskGroupOperationDefinitionParameterID = @@IDENTITY;

											PRINT CONCAT('Inserted task group operation definition parameter indentifier: ', @l_taskGroupOperationDefinitionParameterID);
										END;
									END;

									IF COALESCE(@l_taskGroupOperationDefinitionParameterID, 0) > 0
									BEGIN 
										PRINT CONCAT('Update the ', @l_taskGroupOperationDefinitionParameterID, ' task group operation definition parameter data.');

										UPDATE [ORG].[TaskGroupOperationDefinitionParameter] SET  
											[LastModifiedDate] = CAST( GETDATE() AS Date),
											[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
											[LastModifiedUserName] = @l_userName
										WHERE [TaskGroupOperationDefinitionParameter].[ID] = @l_taskGroupOperationDefinitionID;
									END
								END
							END

							FETCH NEXT FROM parameter_cursor 
							INTO 
								@l_parameterCode;
						END

						CLOSE parameter_cursor;
						DEALLOCATE parameter_cursor;
					END
				END;
			END;

			FETCH NEXT FROM operations_cursor 
			INTO 
				@l_code,
				@l_parameters;
		END;

		CLOSE operations_cursor;
		DEALLOCATE operations_cursor; 

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		COMMIT TRANSACTION MAIN_TRANSACTION;
		RETURN 1;
	END TRY 

	BEGIN CATCH 
		ROLLBACK TRANSACTION MAIN_TRANSACTION;

		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'parameter_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE parameter_cursor;

			DEALLOCATE parameter_cursor;
		END

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'operations_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE operations_cursor;

			DEALLOCATE operations_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_errorMsg;

		RETURN 99;
	END CATCH
END
go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2023-03-31
-- Last modified date: 2023-10-12
-- Description:	Insert Module definitions from .json files
--
-- =============================================
CREATE    PROCEDURE [ORG].[InsertFromJsonTaskListType] 
	-- Add the parameters for the stored procedure here
	@p_json NVARCHAR(MAX)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'ORG.InsertFromJsonTaskListType'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_json NVARCHAR(MAX) = NULL;
	DECLARE @l_system NVARCHAR(50) = NULL;
	DECLARE @l_version NVARCHAR(5) = NULL;
	DECLARE @l_type NVARCHAR(50) = NULL;
    DECLARE @l_userID NVARCHAR(200) = NULL;
	DECLARE @l_itemCount NUMERIC(16) = NULL;
	DECLARE @l_taskListTypesJSON NVARCHAR(MAX) = NULL;
	DECLARE @l_userName NVARCHAR(200) = 'admin';
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--A #TaskListTypes változói
	DECLARE @l_code NVARCHAR(200) = NULL;
	DECLARE @l_translations NVARCHAR(MAX) = NULL; 
	DECLARE @l_misForm NVARCHAR(200) = NULL; 
	DECLARE @l_selectionRuleDataSourceCode NVARCHAR(200) = NULL;
	DECLARE @l_subjectDataSourceCode NVARCHAR(200) = NULL;
	--A #Translations változói
	DECLARE @l_translationValueSetPrefixCode NVARCHAR(200) = NULL;
	DECLARE @l_translationCode NVARCHAR(200) = NULL;
	DECLARE @l_translationLanguage NVARCHAR(5) = NULL;
	DECLARE @l_translationText NVARCHAR(200) = NULL;
	--GEN.ValueSet változói
	DECLARE @l_valueSetID NUMERIC(16) = NULL;
	--A GEN.Code változói
	DECLARE @l_codeID NVARCHAR(200) = NULL;
	--Az ORG.TaskListType változói
	DECLARE @l_taskListTypeID NVARCHAR(200) = NULL;
	DECLARE @l_taskListTypeObjectID NUMERIC(16) = NULL;
	DECLARE @l_layoutFormID NUMERIC(16) = NULL;
	DECLARE @l_selectionRuleDataSourceID NUMERIC(16) = NULL;
	DECLARE @l_subjectDataSourceID NUMERIC(16) = NULL;

    BEGIN TRY 
--===========================================================
--BLOCK      : START
--DESCRIPTION: Start procedure
--===========================================================
		BEGIN TRANSACTION MAIN_TRANSACTION;

		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

--===========================================================
--BLOCK      : CHECK PARAMS
--DESCRIPTION: Checking parameters
--===========================================================
		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
			
		IF COALESCE(@p_json, '') = '' 
			RAISERROR('The p_json parameter isn''t empty.', 16, 1);

--===========================================================
--BLOCK      : PROCESS START
--DESCRIPTION: 
--===========================================================
		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
			
		SELECT @l_json = @p_json;
		
--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing header datas
--===========================================================
		--Fejadatok feldolgozása
		SELECT @l_system = JSON_VALUE(@l_json, '$.header.system'),
		       @l_version = JSON_VALUE(@l_json, '$.header.version'),
		       @l_type = JSON_VALUE(@l_json, '$.header.type'),
               @l_userID = 'Admin',
               @l_itemCount = CAST(COALESCE(JSON_VALUE(@l_json, '$.header.itemCount'), '0') AS NUMERIC(16));
		
		SELECT @l_logMsg = CONCAT('The value of JSON type: ', @l_type);
		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
		
		IF @l_system <> 'INDECS'
            RAISERROR( 'System is not INDECS.', 16, 1);
        IF @l_version <> '3'
            RAISERROR( 'Wrong INDECS version.', 16, 1);
        IF @l_type <> 'TASK_LIST_TYPE'
            RAISERROR( 'Wrong type of JSON file.', 16, 1);
			
		SELECT @l_logMsg = CONCAT('The number of items in Task list type JSON: ', @l_itemCount);
		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		
--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Create temporary tables
--===========================================================

		--Ideiglenes táblák létrehozása 
		IF OBJECT_ID('tempdb..#TaskListTypes', 'U') IS NOT NULL
			DROP TABLE #TaskListTypes;

		CREATE TABLE #TaskListTypes (
			code NVARCHAR(200),
			translations NVARCHAR(MAX),
			misForm NVARCHAR(200),
			selectionRuleDataSourceCode NVARCHAR(200),
			subjectDataSourceCode NVARCHAR(200)
		);

		IF OBJECT_ID('tempdb..#Translations', 'U') IS NOT NULL
			DROP TABLE #Translations;
		
		CREATE TABLE #Translations (
			valueSetPrefixCode NVARCHAR(200),
			code NVARCHAR(200),
			language NVARCHAR(5),
			text NVARCHAR(200)
		);
		
		SELECT @l_logMsg = 'Temporary tables created.';
		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing task list types and fill additional temporary tables
--===========================================================
			
		SELECT @l_taskListTypesJSON = JSON_QUERY(@l_json, '$.taskListTypes');
		
		INSERT INTO #TaskListTypes (code, translations, misForm, selectionRuleDataSourceCode, subjectDataSourceCode)
		SELECT 
			TaskListTypes.code, 
			TaskListTypes.translations,
			TaskListTypes.misForm,
			TaskListTypes.selectionRuleDataSourceCode,
			TaskListTypes.subjectDataSourceCode
		FROM OPENJSON(@l_taskListTypesJSON)
		WITH 
			(code NVARCHAR(200) '$.code',
			 translations NVARCHAR(MAX) '$.translations' AS JSON,
			 misForm NVARCHAR(200) '$.misForm',
			 selectionRuleDataSourceCode NVARCHAR(200) '$.selectionRuleDataSourceCode',
			 subjectDataSourceCode NVARCHAR(200) '$.subjectDataSourceCode') AS TaskListTypes;
			 
		SELECT @l_logMsg = '#TaskListTypes temporary table filled.';
		PRINT @l_logMsg;
			 
		DECLARE taskListType_cursor CURSOR FOR 
		SELECT 
			#TaskListTypes.code, 
			#TaskListTypes.translations,
			#TaskListTypes.misForm, 
			#TaskListTypes.selectionRuleDataSourceCode,
			#TaskListTypes.subjectDataSourceCode
		FROM #TaskListTypes;
		
		OPEN taskListType_cursor;
		FETCH NEXT FROM taskListType_cursor 
		INTO 
			@l_code,
			@l_translations,
			@l_misForm,
			@l_selectionRuleDataSourceCode,
			@l_subjectDataSourceCode;

		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT @l_logMsg = 'Next ORG.TaskListType';
			PRINT @l_logMsg;

			SELECT @l_taskListTypeID = NULL;
			SELECT @l_taskListTypeObjectID = NULL;
			SELECT @l_layoutFormID = NULL;
			SELECT @l_selectionRuleDataSourceID = NULL;
			SELECT @l_subjectDataSourceID = NULL;
			
			PRINT 'CLEAR Temporary tables contetnt';

			DELETE FROM #Translations;

			PRINT 'Fill #Translations table with ORG.TaskListType translation data';
			--ORG.TaskListType nyelvi feliratai
			INSERT INTO #Translations (valueSetPrefixCode, code, language, text)
			SELECT 
				'TASK_LIST_TYPE',
				@l_code AS code,
				TaskListTypeTrans.[language],
				TaskListTypeTrans.[text]
			FROM OPENJSON(@l_translations) WITH (
				[language] NVARCHAR(5) '$.language',
				[text] NVARCHAR(50) '$.text') AS TaskListTypeTrans;

--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing content of temporary tables
--===========================================================

			IF COALESCE(@l_code, '') = '' 
			BEGIN
				SELECT @l_logMsg = 'The code of the Task list type cannot be an empty value.';

				BEGIN TRANSACTION LOG_TRANSACTION;
				INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
				SELECT 
					CAST( GETDATE() AS Date ),	-- LogDate,	
					CAST( GETDATE() AS Time ),	-- LogTime,
					SUSER_SNAME(),				-- UserName
					NULL,			-- CorrelationID
					'INDECS 3.0',			    -- ApplicationName
					DB_NAME(),					-- Environment
					'BACKEND',					-- Layer
					@l_procedureName,   		-- ServiceName
					'1.0',						-- ServiceVersion
					'INFO',					        -- SeverityLevel
					NULL,						-- MessageCategory
					@l_logMsg;				    -- LogMessage
				COMMIT TRANSACTION LOG_TRANSACTION;

				PRINT @l_logMsg;
			END
			ELSE
			BEGIN
				PRINT 'Processing #Translations table';

				--Feliratok feldolgozása
				DECLARE translation_cursor CURSOR FOR 
				SELECT
					#Translations.valueSetPrefixCode,
					#Translations.code,
					#Translations.[language],
					#Translations.[text]
				FROM #Translations;

				OPEN translation_cursor;
				FETCH NEXT FROM translation_cursor
				INTO
					@l_translationValueSetPrefixCode,
					@l_translationCode,
					@l_translationLanguage,
					@l_translationText;

				WHILE @@FETCH_STATUS = 0
				BEGIN
					PRINT CONCAT('Processing #Translations row. PrefixCode(', 
						@l_translationValueSetPrefixCode, '), Code(', 
						@l_translationCode, '), Language(', 
						@l_translationLanguage, '), Text(', 
						@l_translationText, ').');

					SELECT @l_valueSetID = [ValueSet].[ID]
					FROM [GEN].[ValueSet]
					WHERE [ValueSet].[CodePrefix] = @l_translationValueSetPrefixCode;

					IF COALESCE(@l_valueSetID, 0) > 0 
					BEGIN 
						PRINT CONCAT('Try insert new data in GEN.Code with ValueSetID(', 
							@l_valueSetID, '), ID(', @l_translationCode, ')');

						INSERT INTO [GEN].[Code] ([ID], [ValueSetID], [ValidFrom],  
							[CreationDate], [CreationTime], [CreationUserName]) 
						SELECT @l_translationCode, @l_valueSetID, CAST( GETDATE() AS Date), 
							CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName
						WHERE NOT EXISTS 
							(SELECT 1 
							 FROM [GEN].[Code]
							 WHERE [Code].[ValueSetID] = @l_valueSetID 
							 AND [Code].[ID] = @l_translationCode);

						SELECT @l_codeID = [Code].[ID]
						FROM [GEN].[Code]
						WHERE [Code].[ValueSetID] = @l_valueSetID
						AND [Code].[ID] = @l_translationCode;

						IF COALESCE(@l_codeID, '') <> '' 
						BEGIN
							INSERT INTO [GEN].[Translation] ([CodeID], [Language], [Text], [CreationDate], [CreationTime], [CreationUserName])
							SELECT @l_codeID, @l_translationLanguage, @l_translationText,
								CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName
							WHERE NOT EXISTS 
								(SELECT 1 
								 FROM [GEN].[Translation]
								 WHERE [Translation].[CodeID] = @l_codeID 
								 AND [Translation].[Language] = @l_translationLanguage);

							UPDATE [GEN].[Translation] SET 
								[Text] = @l_translationText 
							WHERE [Translation].[CodeID] = @l_codeID
							AND [Translation].[Language] = @l_translationLanguage;
						END
					END

					FETCH NEXT FROM translation_cursor
					INTO
						@l_translationValueSetPrefixCode,
						@l_translationCode,
						@l_translationLanguage,
						@l_translationText;
				END;

				CLOSE translation_cursor;
				DEALLOCATE translation_cursor;

				PRINT CONCAT('Processing ORG.TaskListType general data. Task list type code: ', @l_code);

				--Feladat lista típus adatok feldolgozása
				SELECT 
					@l_taskListTypeID = [TaskListType].[ID], 
					@l_taskListTypeObjectID = [TaskListType].[ObjectID]
				FROM [ORG].[TaskListType]
				WHERE [TaskListType].[ID] = @l_code;

				SELECT @l_objectID = 0;
				
				--VIR felület megállapítása
				IF COALESCE(@l_misForm, '') <> '' 
				BEGIN
					SELECT @l_layoutFormID = [Form].[ID] 
					FROM [MIS].[Form]
					WHERE [Form].[CodeID] = @l_misForm;
				END;
				
				--Lista kiválasztó szabály adatforrás megállapítása
				IF COALESCE(@l_selectionRuleDataSourceCode, '') <> '' 
				BEGIN 
					SELECT @l_selectionRuleDataSourceID = [DataSource].[ID] 
					FROM [GEN].[DataSource] 
					WHERE [DataSource].[DataCode] = @l_selectionRuleDataSourceCode;
				END
				
				--Tárgy generáló adatforrás megállapítása
				IF COALESCE(@l_subjectDataSourceCode, '') <> '' 
				BEGIN 
					SELECT @l_subjectDataSourceID = [DataSource].[ID] 
					FROM [GEN].[DataSource]
					WHERE [DataSource].[DataCode] = @l_subjectDataSourceCode;
				END

				IF COALESCE(@l_taskListTypeID, '') = ''
				BEGIN 
					PRINT CONCAT('Task list type not found with ', @l_code, ' code.');

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_TASKLISTTYPE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_code, 'task list type object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;
					SELECT @l_taskListTypeObjectID = @l_objectID;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN
						INSERT INTO [ORG].[TaskListType] ([ID], [ObjectID], [ValidFrom],  
							[CreationDate], [CreationTime], [CreationUserName])
						SELECT @l_code, @l_objectID, CAST(GETDATE() AS Date),
							CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

						SELECT @l_taskListTypeID = @l_code;

						PRINT CONCAT('Inserted task list type indentifier: ', @l_taskListTypeID);
					END
				END;

				IF COALESCE(@l_taskListTypeID, '') <> ''
				BEGIN
					PRINT CONCAT('Update the ', @l_taskListTypeID, ' task list type data.');

					UPDATE [ORG].[TaskListType] SET 
						[StatusCode] = 'STATUS_NORMAL',
						[LayoutFormID] = @l_layoutFormID,
						[SelectionRuleDataSourceID] = @l_selectionRuleDataSourceID,
						[SubjectDataSourceID] = @l_subjectDataSourceID,
						[LastModifiedDate] = CAST(GETDATE() AS Date),
						[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
						[LastModifiedUserName] = @l_userName
					WHERE [TaskListType].[ID] = @l_taskListTypeID;

				END --IF COALESCE(@l_taskListTypeID, '') = '' vége
			END

			FETCH NEXT FROM taskListType_cursor 
			INTO 
				@l_code,
				@l_translations,
				@l_misForm,
				@l_selectionRuleDataSourceCode,
				@l_subjectDataSourceCode;
		END;
		
		CLOSE taskListType_cursor;
		DEALLOCATE taskListType_cursor; 

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		COMMIT TRANSACTION MAIN_TRANSACTION;
		RETURN 1;
	END TRY

	BEGIN CATCH
		ROLLBACK TRANSACTION MAIN_TRANSACTION;

		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'translation_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE translation_cursor;

			DEALLOCATE translation_cursor;
		END

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'taskListType_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE taskListType_cursor;

			DEALLOCATE taskListType_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_errorMsg;

		RETURN 99;
	END CATCH
END
go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2023-04-05
-- Last modified date: 2023-04-19
-- Description:	Insert Task type definitions from .json files
-- =============================================
CREATE   PROCEDURE [ORG].[InsertFromJsonTaskType] 
	-- Add the parameters for the stored procedure here
	@p_json NVARCHAR(MAX)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'ORG.InsertFromJsonTaskType'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_json NVARCHAR(MAX) = NULL;
	DECLARE @l_system NVARCHAR(50) = NULL;
	DECLARE @l_version NVARCHAR(5) = NULL;
	DECLARE @l_type NVARCHAR(50) = NULL;
    DECLARE @l_userID NVARCHAR(200) = NULL;
	DECLARE @l_itemCount NUMERIC(16) = NULL;
	DECLARE @l_taskTypesJSON NVARCHAR(MAX) = NULL;
	DECLARE @l_userName NVARCHAR(200) = 'admin';
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--A #TaskTypes változói
	DECLARE @l_code NVARCHAR(200) = NULL;
	DECLARE @l_translations NVARCHAR(MAX) = NULL; 
	DECLARE @l_moduleCode NVARCHAR(200) = NULL;
	DECLARE @l_deadlineDayTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_deadlineDay NVARCHAR(200) = NULL; 
	DECLARE @l_referencedObjectTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_resultObjectTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_taskListTypeCode NVARCHAR(200) = NULL; 
	DECLARE @l_detailedStatuses NVARCHAR(MAX) = NULL;
	DECLARE @l_actions NVARCHAR(MAX) = NULL;
	--A #DetailStatuses változói
	DECLARE @l_detailStatusCode NVARCHAR(200) = NULL;
	DECLARE @l_detailStatusTranslation NVARCHAR(MAX) = NULL;
	--#Actions változói
	DECLARE @l_actionCode NVARCHAR(200) = NULL;
	DECLARE @l_actionTranslations NVARCHAR(MAX) = NULL;
	DECLARE @l_actionDefaultActionCode NVARCHAR(200) = NULL;
	DECLARE @l_actionConditionSetCode NVARCHAR(200) = NULL;
	DECLARE @l_actionEventTypeCode NVARCHAR(200) = NULL;
	--A #Translations változói
	DECLARE @l_translationValueSetPrefixCode NVARCHAR(200) = NULL;
	DECLARE @l_translationCode NVARCHAR(200) = NULL;
	DECLARE @l_translationLanguage NVARCHAR(5) = NULL;
	DECLARE @l_translationText NVARCHAR(200) = NULL;
	--GEN.ValueSet változói
	DECLARE @l_valueSetID NUMERIC(16) = NULL;
	--A GEN.Code változói
	DECLARE @l_codeID NVARCHAR(200) = NULL;
	--Az ORG.TaskType változói
	DECLARE @l_taskTypeID NVARCHAR(200) = NULL;
	DECLARE @l_taskTypeObjectID NUMERIC(16) = NULL;
	--Az ORG.TaskListType változói
	DECLARE @l_taskListTypeID NVARCHAR(200) = NULL;
	--Az ORG.TaskTypeAction változói
	DECLARE @l_taskTypeActionID NUMERIC(16) = NULL;
	DECLARE @l_taskTypeActionObjectID NUMERIC(16) = NULL;
	DECLARE @l_taskTypeActionConditionSetID NUMERIC(16) = NULL;
	--Az ORG.TaskTypeModule változói
	DECLARE @l_taskTypeModuleID NUMERIC(16) = NULL;
	--Az ORG.Module változói
	DECLARE @l_moduleID NUMERIC(16) = NULL;

    BEGIN TRY 
--===========================================================
--BLOCK      : START
--DESCRIPTION: Start procedure
--===========================================================
		BEGIN TRANSACTION MAIN_TRANSACTION;

		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

--===========================================================
--BLOCK      : CHECK PARAMS
--DESCRIPTION: Checking parameters
--===========================================================
		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
			
		IF COALESCE(@p_json, '') = '' 
			RAISERROR('The p_json parameter isn''t empty.', 16, 1);

--===========================================================
--BLOCK      : PROCESS START
--DESCRIPTION: 
--===========================================================
		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
			
		SELECT @l_json = @p_json;
		
--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing header datas
--===========================================================
		--Fejadatok feldolgozása
		SELECT @l_system = JSON_VALUE(@l_json, '$.header.system'),
		       @l_version = JSON_VALUE(@l_json, '$.header.version'),
		       @l_type = JSON_VALUE(@l_json, '$.header.type'),
               @l_userID = 'Admin',
               @l_itemCount = CAST(COALESCE(JSON_VALUE(@l_json, '$.header.itemCount'), '0') AS NUMERIC(16));
		
		SELECT @l_logMsg = CONCAT('The value of JSON type: ', @l_type);
		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
		
		IF @l_system <> 'INDECS'
            RAISERROR( 'System is not INDECS.', 16, 1);
        IF @l_version <> '3'
            RAISERROR( 'Wrong INDECS version.', 16, 1);
        IF @l_type <> 'TASK_TYPE'
            RAISERROR( 'Wrong type of JSON file.', 16, 1);
			
		SELECT @l_logMsg = CONCAT('The number of items in Task type JSON: ', @l_itemCount);
		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		
--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Create temporary tables
--===========================================================

		--Ideiglenes táblák létrehozása 
		IF OBJECT_ID('tempdb..#TaskTypes', 'U') IS NOT NULL
			DROP TABLE #TaskTypes;

		CREATE TABLE #TaskTypes (
			code NVARCHAR(200),
			translations NVARCHAR(MAX),
			moduleCode NVARCHAR(200),
			deadlineDayTypeCode NVARCHAR(200),
			deadlineDay NVARCHAR(200),
			taskListTypeCode NVARCHAR(200),
			referencedObjectTypeCode NVARCHAR(200),
			resultObjectTypeCode NVARCHAR(200),
			detailedStatuses NVARCHAR(MAX),
			actions NVARCHAR(MAX)
		);

		IF OBJECT_ID('tempdb..#DetailStatuses', 'U') IS NOT NULL
			DROP TABLE #DetailStatuses;
		
		CREATE TABLE #DetailStatuses (
			detailStatusCode NVARCHAR(200),
			detailStatusTranslation NVARCHAR(MAX)			
		);

		IF OBJECT_ID('tempdb..#TaskTypeActions', 'U') IS NOT NULL
			DROP TABLE #TaskTypeActions;

		CREATE TABLE #TaskTypeActions (
			actionCode NVARCHAR(200),
			actionTranslations NVARCHAR(MAX),
			actionDefaultActionCode NVARCHAR(200),
			actionConditionSetCode NVARCHAR(200),
			actionEventTypeCode NVARCHAR(200)
		);

		IF OBJECT_ID('tempdb..#Translations', 'U') IS NOT NULL
			DROP TABLE #Translations;
		
		CREATE TABLE #Translations (
			valueSetPrefixCode NVARCHAR(200),
			code NVARCHAR(200),
			language NVARCHAR(5),
			text NVARCHAR(200)
		);
		
		SELECT @l_logMsg = 'Temporary tables created.';
		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing modules and fill additional temporary tables
--===========================================================
			
		SELECT @l_taskTypesJSON = JSON_QUERY(@l_json, '$.taskTypes');
		
		INSERT INTO #TaskTypes (
			code, 
			translations, 
			moduleCode, 
			deadlineDayTypeCode, 
			deadlineDay, 
			taskListTypeCode, 
			referencedObjectTypeCode, 
			resultObjectTypeCode, 
			detailedStatuses, 
			actions)
		SELECT 
			TaskTypes.code, 
			TaskTypes.translations,
			TaskTypes.moduleCode, 
			TaskTypes.deadlineDayTypeCode,
			TaskTypes.deadlineDay, 
			TaskTypes.taskListTypeCode,
			TaskTypes.referencedObjectTypeCode,
			TaskTypes.resultObjectTypeCode,
			TaskTypes.detailedStatuses,
			TaskTypes.actions
		FROM OPENJSON(@l_taskTypesJSON)
		WITH 
			(code NVARCHAR(200) '$.code',
			 translations NVARCHAR(MAX) '$.translations' AS JSON,
			 moduleCode NVARCHAR(200) '$.moduleCode',
			 deadlineDayTypeCode NVARCHAR(200) '$.deadlineDayTypeCode', 
			 deadlineDay NVARCHAR(200) '$.deadlineDay',
			 taskListTypeCode NVARCHAR(200) '$.taskListTypeCode',
			 referencedObjectTypeCode NVARCHAR(200) '$.referencedObjectTypeCode',
			 resultObjectTypeCode NVARCHAR(200) '$.resultObjectTypeCode',
			 detailedStatuses NVARCHAR(MAX) '$.detailedStatuses' AS JSON,
			 actions NVARCHAR(MAX) '$.actions' AS JSON) AS TaskTypes;
			 
		SELECT @l_logMsg = '#TaskTypes temporary table filled.';
		PRINT @l_logMsg;
			 
		DECLARE taskType_cursor CURSOR FOR 
		SELECT 
			#TaskTypes.code, 
			#TaskTypes.translations,
			#TaskTypes.moduleCode, 
			#TaskTypes.deadlineDayTypeCode, 
			#TaskTypes.deadlineDay,
			#TaskTypes.taskListTypeCode,
			#TaskTypes.referencedObjectTypeCode,
			#taskTypes.resultObjectTypeCode,
			#TaskTypes.detailedStatuses,
			#TaskTypes.actions
		FROM #TaskTypes;
		
		OPEN taskType_cursor;
		FETCH NEXT FROM taskType_cursor 
		INTO 
			@l_code,
			@l_translations,
			@l_moduleCode,
			@l_deadlineDayTypeCode,
			@l_deadlineDay,
			@l_taskListTypeCode,
			@l_referencedObjectTypeCode,
			@l_resultObjectTypeCode,
			@l_detailedStatuses,
			@l_actions;

		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT @l_logMsg = 'Next ORG.TaskType';
			PRINT @l_logMsg;

			SELECT @l_taskTypeID = NULL;
			SELECT @l_taskTypeObjectID = NULL;
			SELECT @l_taskTypeActionID = NULL;
			SELECT @l_taskTypeActionObjectID = NULL;
			SELECT @l_taskTypeModuleID = NULL;
			SELECT @l_moduleID = NULL;
			
			PRINT 'CLEAR Temporary tables contetnt';

			DELETE FROM #Translations;
			DELETE FROM #DetailStatuses;
			DELETE FROM #TaskTypeActions;

			IF @l_moduleCode = ''
				SELECT @l_moduleCode = NULL;

			IF @l_deadlineDayTypeCode = ''
				SELECT @l_deadlineDayTypeCode = NULL;

			IF @l_deadlineDay = '' 
				SELECT @l_deadlineDay = NULL;

			PRINT 'Fill #Translations table with ORG.TaskType translation data';
			--ORG.Module nyelvi feliratai
			INSERT INTO #Translations (valueSetPrefixCode, code, language, text)
			SELECT 
				'TASK_TYPE',
				@l_code AS code,
				ModuleTrans.[language],
				ModuleTrans.[text]
			FROM OPENJSON(@l_translations) WITH (
				[language] NVARCHAR(5) '$.language',
				[text] NVARCHAR(50) '$.text') AS ModuleTrans;

			PRINT 'Fill #DetailStatuses table with ORG.TaskType detail statuses data';
			--Részletes állapotok
			INSERT INTO #DetailStatuses (detailStatusCode, detailStatusTranslation)
			SELECT 
				DetailStatuses.code, 
				DetailStatuses.translations
			FROM OPENJSON(@l_detailedStatuses) WITH (
				code NVARCHAR(200) '$.code', 
				translations NVARCHAR(MAX) '$.translation' AS JSON) AS DetailStatuses;

			DECLARE detailStatusTranslation_cursor CURSOR FOR 
			SELECT
				#DetailStatuses.detailStatusCode,
				#DetailStatuses.detailStatusTranslation
			FROM #DetailStatuses;
			
			OPEN detailStatusTranslation_cursor;
			FETCH NEXT FROM detailStatusTranslation_cursor 
			INTO 
				@l_detailStatusCode,
				@l_detailStatusTranslation;
			
			PRINT 'Fill #Translation table with #DetailStatuses translation data';
			WHILE @@FETCH_STATUS = 0 
			BEGIN
				INSERT INTO #Translations (valueSetPrefixCode, code, language, text)
				SELECT 
					'TASK_DETAILED_STATUS',
					@l_detailStatusCode AS code,
					DetailStatusTrans.[language],
					DetailStatusTrans.[text]
				FROM OPENJSON(@l_detailStatusTranslation) WITH (
					[language] NVARCHAR(5) '$.language',
					[text] NVARCHAR(50) '$.text') AS DetailStatusTrans;
				
				FETCH NEXT FROM detailStatusTranslation_cursor 
				INTO 
					@l_detailStatusCode,
					@l_detailStatusTranslation;
			END;
			
			CLOSE detailStatusTranslation_cursor;
			DEALLOCATE detailStatusTranslation_cursor;

			PRINT 'Fill #TaskTypeActions table with ORG.TaskType actions data';
			--Akciók
			INSERT INTO #TaskTypeActions (actionCode, actionTranslations, actionDefaultActionCode, actionConditionSetCode, actionEventTypeCode)
			SELECT 
				Actions.code, 
				Actions.translations,
				Actions.defaultActionCode,
				Actions.conditionSetCode,
				Actions.eventTypeCode
			FROM OPENJSON(@l_actions) WITH (
				code NVARCHAR(200) '$.code', 
				translations NVARCHAR(MAX) '$.translation' AS JSON,
				defaultActionCode NVARCHAR(200) '$.defaultActionCode', 
				conditionSetCode NVARCHAR(200) '$.conditionSetCode',
				eventTypeCode NVARCHAR(200) '$.eventTypeCode') AS Actions;

			DECLARE actionsTranslation_cursor CURSOR FOR 
			SELECT
				#TaskTypeActions.actionCode,
				#TaskTypeActions.actionTranslations
			FROM #TaskTypeActions;
			
			OPEN actionsTranslation_cursor;
			FETCH NEXT FROM actionsTranslation_cursor 
			INTO 
				@l_actionCode,
				@l_actionTranslations;
			
			PRINT 'Fill #Translation table with #TaskTypeActions translation data';
			WHILE @@FETCH_STATUS = 0 
			BEGIN
				INSERT INTO #Translations (valueSetPrefixCode, code, language, text)
				SELECT 
					'TASK_TYPE_ACTION',
					@l_actionCode AS code,
					TaskTypeActionTrans.[language],
					TaskTypeActionTrans.[text]
				FROM OPENJSON(@l_actionTranslations) WITH (
					[language] NVARCHAR(5) '$.language',
					[text] NVARCHAR(50) '$.text') AS TaskTypeActionTrans;
				
				FETCH NEXT FROM actionsTranslation_cursor 
				INTO 
					@l_actionCode,
					@l_actionTranslations;
			END;
			
			CLOSE actionsTranslation_cursor;
			DEALLOCATE actionsTranslation_cursor;

--===========================================================
--BLOCK      : PROCESS
--DESCRIPTION: Processing content of temporary tables
--===========================================================

			IF COALESCE(@l_code, '') = '' 
			BEGIN
				SELECT @l_logMsg = 'The code of the Task type cannot be an empty value.';

				BEGIN TRANSACTION LOG_TRANSACTION;
				INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
				SELECT 
					CAST( GETDATE() AS Date ),	-- LogDate,	
					CAST( GETDATE() AS Time ),	-- LogTime,
					SUSER_SNAME(),				-- UserName
					NULL,			-- CorrelationID
					'INDECS 3.0',			    -- ApplicationName
					DB_NAME(),					-- Environment
					'BACKEND',					-- Layer
					@l_procedureName,   		-- ServiceName
					'1.0',						-- ServiceVersion
					'INFO',					        -- SeverityLevel
					NULL,						-- MessageCategory
					@l_logMsg;				    -- LogMessage
				COMMIT TRANSACTION LOG_TRANSACTION;

				PRINT @l_logMsg;
			END
			ELSE
			BEGIN
				PRINT 'Processing #Translations table';

				--Feliratok feldolgozása
				DECLARE translation_cursor CURSOR FOR 
				SELECT
					#Translations.valueSetPrefixCode,
					#Translations.code,
					#Translations.[language],
					#Translations.[text]
				FROM #Translations;

				OPEN translation_cursor;
				FETCH NEXT FROM translation_cursor
				INTO
					@l_translationValueSetPrefixCode,
					@l_translationCode,
					@l_translationLanguage,
					@l_translationText;

				WHILE @@FETCH_STATUS = 0
				BEGIN
					PRINT CONCAT('Processing #Translations row. PrefixCode(', 
						@l_translationValueSetPrefixCode, '), Code(', 
						@l_translationCode, '), Language(', 
						@l_translationLanguage, '), Text(', 
						@l_translationText, ').');

					SELECT @l_valueSetID = [ValueSet].[ID]
					FROM [GEN].[ValueSet]
					WHERE [ValueSet].[CodePrefix] = @l_translationValueSetPrefixCode;

					IF COALESCE(@l_valueSetID, 0) > 0 
					BEGIN 
						PRINT CONCAT('Try insert new data in GEN.Code with ValueSetID(', 
							@l_valueSetID, '), ID(', @l_translationCode, ')');

						INSERT INTO [GEN].[Code] ([ID], [ValueSetID], [ValidFrom],  
							[CreationDate], [CreationTime], [CreationUserName]) 
						SELECT @l_translationCode, @l_valueSetID, CAST( GETDATE() AS Date), 
							CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName
						WHERE NOT EXISTS 
							(SELECT 1 
							 FROM [GEN].[Code]
							 WHERE [Code].[ValueSetID] = @l_valueSetID 
							 AND [Code].[ID] = @l_translationCode);

						SELECT @l_codeID = [Code].[ID]
						FROM [GEN].[Code]
						WHERE [Code].[ValueSetID] = @l_valueSetID
						AND [Code].[ID] = @l_translationCode;

						IF COALESCE(@l_codeID, '') <> '' 
						BEGIN
							INSERT INTO [GEN].[Translation] ([CodeID], [Language], 
								[CreationDate], [CreationTime], [CreationUserName],[Text])
							SELECT @l_codeID, @l_translationLanguage, 
								CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName,@l_translationText 
							WHERE NOT EXISTS 
								(SELECT 1 
								 FROM [GEN].[Translation]
								 WHERE [Translation].[CodeID] = @l_codeID 
								 AND [Translation].[Language] = @l_translationLanguage);

							UPDATE [GEN].[Translation] SET 
								[Text] = @l_translationText 
							WHERE [Translation].[CodeID] = @l_codeID
							AND [Translation].[Language] = @l_translationLanguage;
						END
					END

					FETCH NEXT FROM translation_cursor
					INTO
						@l_translationValueSetPrefixCode,
						@l_translationCode,
						@l_translationLanguage,
						@l_translationText;
				END;

				CLOSE translation_cursor;
				DEALLOCATE translation_cursor;

				PRINT CONCAT('Processing ORG.TaskType general data. Task type code: ', @l_code);

				--Feladat típus adatok feldolgozása
				SELECT 
					@l_taskTypeID = [TaskType].[ID], 
					@l_taskTypeObjectID = [TaskType].[ObjectID]
				FROM [ORG].[TaskType]
				WHERE [TaskType].[ID] = @l_code;

				SELECT @l_objectID = 0;

				IF COALESCE(@l_taskTypeID, '') = ''
				BEGIN 
					PRINT CONCAT('Task type not found with ', @l_code, ' code.');

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_TASKTYPE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_code, 'task type object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;
					SELECT @l_taskTypeObjectID = @l_objectID;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN
						INSERT INTO [ORG].[TaskType] ([ID], [ObjectID], [StatusCode], [ValidFrom],  
							[CreationDate], [CreationTime], [CreationUserName])
						SELECT @l_code, @l_objectID, 'STATUS_NORMAL', CAST( GETDATE() AS Date),
							CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

						SELECT @l_taskTypeID = @l_code;

						PRINT CONCAT('Inserted task type indentifier: ', @l_taskTypeID);
					END
				END;

				IF COALESCE(@l_taskTypeID, '') <> ''
				BEGIN
					PRINT CONCAT('Update the ', @l_taskTypeID, ' task type data.');

					SELECT @l_taskListTypeID = NULL;
					
					IF COALESCE(@l_taskListTypeCode, '') <> '' 
						SELECT @l_taskListTypeID = [TaskListType].[ID] 
						FROM [ORG].[TaskListType] 
						WHERE [TaskListType].[ID] = @l_taskListTypeCode;

					IF COALESCE(@l_referencedObjectTypeCode, '') = ''
						SELECT @l_referencedObjectTypeCode = NULL
					ELSE
					BEGIN
						SELECT @l_referencedObjectTypeCode = [ObjectType].[Code] 
						FROM [GEN].[ObjectType] 
						WHERE [ObjectType].[Code] = @l_referencedObjectTypeCode;
					END;

					IF COALESCE(@l_resultObjectTypeCode, '') = ''
						SELECT @l_resultObjectTypeCode = NULL
					ELSE
					BEGIN
						SELECT @l_resultObjectTypeCode = [ObjectType].[Code] 
						FROM [GEN].[ObjectType] 
						WHERE [ObjectType].[Code] = @l_resultObjectTypeCode;
					END;

					UPDATE [ORG].[TaskType] SET 
						[DeadlineDayTypeCode] = @l_deadlineDayTypeCode,
						[DeadlineDay] = CAST(@l_deadlineDay AS NUMERIC(5)),
						[TaskListTypeID] = @l_taskListTypeID,
						[ReferencedObjectTypeCode] = @l_referencedObjectTypeCode,
						[ResultObjectTypeCode] = @l_resultObjectTypeCode,
						[LastModifiedDate] = CAST( GETDATE() AS Date),
						[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
						[LastModifiedUserName] = @l_userName
					WHERE [TaskType].[ID] = @l_taskTypeID;

					--Modul feldolgozása
					IF COALESCE(@l_moduleCode, '') <> ''
					BEGIN
						SELECT @l_moduleID = [Module].[ID] 
						FROM [ORG].[Module] 
						WHERE [Module].[ModuleCode] = @l_moduleCode;

						IF COALESCE(@l_moduleID, 0) = 0 
							SELECT @l_moduleID = NULL;

						IF COALESCE(@l_moduleID, 0) > 0 
						BEGIN
							SELECT @l_taskTypeModuleID = [TaskTypeModule].[ID] 
							FROM [ORG].[TaskTypeModule] 
							JOIN [ORG].[Module] ON ([Module].[ID] = [TaskTypeModule].[ModuleID])
							WHERE [TaskTypeModule].[TaskTypeID] = @l_code 
							AND [Module].[ModuleCode] = @l_moduleCode;

							IF COALESCE(@l_taskTypeModuleID, 0) = 0 
							BEGIN
								INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
								VALUES ('OBJECT_TYPE_ORG_TASKTYPEMODULE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_code, 'task type module object'), '1.0');

								SELECT @l_objectID = @@IDENTITY;

								INSERT INTO [ORG].[TaskTypeModule] ([ObjectID], [TaskTypeID], [ModuleID], [StatusCode], [CreationDate], [CreationTime], [CreationUserName])
								SELECT @l_objectID, @l_code, @l_moduleID, 'STATUS_NORMAL', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

								SELECT @l_taskTypeModuleID = @@IDENTITY;
							END
							ELSE 
							BEGIN
								UPDATE [ORG].[TaskTypeModule] SET 
									[ModuleID] = @l_moduleID,
									[LastModifiedDate] = CAST( GETDATE() AS Date),
									[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
									[LastModifiedUserName] = @l_userName
								WHERE [TaskTypeModule].[ID] = @l_taskTypeModuleID;
							END
						END;
					END; --IF COALESCE(@l_moduleCode, '') <> '' vége

					--Paraméterek feldolgozása
					PRINT 'Processing #TaskTypeActions temporary table.';

					DECLARE taskTypeAction_cursor CURSOR FOR 
					SELECT
						#TaskTypeActions.actionCode,
						#TaskTypeActions.actionDefaultActionCode,
						#TaskTypeActions.actionConditionSetCode,
						#TaskTypeActions.actionEventTypeCode
					FROM #TaskTypeActions;

					OPEN taskTypeAction_cursor;
					FETCH NEXT FROM taskTypeAction_cursor 
					INTO 
						@l_actionCode,
						@l_actionDefaultActionCode,
						@l_actionConditionSetCode,
						@l_actionEventTypeCode;

					WHILE @@FETCH_STATUS = 0
					BEGIN
						PRINT CONCAT('The ', @l_taskTypeID, ' task type Action code: ', @l_actionCode);

						SELECT @l_taskTypeActionID = 0;
						SELECT @l_taskTypeActionObjectID = 0;
						SELECT @l_taskTypeActionConditionSetID = NULL;

						IF COALESCE(@l_actionConditionSetCode, '') <> '' 
						BEGIN
							SELECT @l_taskTypeActionConditionSetID = [ConditionSet].[ID]
							FROM [ORG].[ConditionSet]
							WHERE [ConditionSet].[ConditionSetCode] = @l_actionConditionSetCode;

							IF COALESCE(@l_taskTypeActionConditionSetID, 0) = 0 
								SELECT @l_taskTypeActionConditionSetID = NULL;
						END;

						SELECT @l_taskTypeActionID = [TaskTypeAction].[ID]
						FROM [ORG].[TaskTypeAction] 
						WHERE [TaskTypeAction].[TaskTypeID] = @l_code
						AND [TaskTypeAction].[ActionCode] = @l_actionCode;

						IF COALESCE(@l_taskTypeActionID, 0) = 0
						BEGIN
							PRINT 'Action not found.';

							INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
							VALUES ('OBJECT_TYPE_ORG_TASKTYPEACTION', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName, CONCAT(@l_actionCode, 'task type action object'), '1.0');

							SELECT @l_objectID = @@IDENTITY;

							IF COALESCE(@l_objectID, 0) > 0
							BEGIN
								INSERT INTO [ORG].[TaskTypeAction] ([ObjectID], [TaskTypeID], [ActionCode],  
									[CreationDate], [CreationTime], [CreationUserName])
								SELECT @l_objectID, @l_code, @l_actionCode,
									CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_userName;

								SELECT @l_taskTypeActionID = @@IDENTITY;

								PRINT CONCAT('Inserted task type action identifier: ', @l_taskTypeActionID);
							END
						END;

						IF COALESCE(@l_taskTypeActionID, 0) > 0 
						BEGIN
							PRINT CONCAT('Update the ', @l_taskTypeActionID, ' task type action data.');

							UPDATE [ORG].[TaskTypeAction] SET 
								[DefaultActionCode] = @l_actionDefaultActionCode,
								[ConditionSetID] = @l_taskTypeActionConditionSetID,
								[LastModifiedDate] = CAST( GETDATE() AS Date),
								[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
								[LastModifiedUserName] = @l_userName
							WHERE [TaskTypeAction].[ID] = @l_taskTypeActionID;
						END

						FETCH NEXT FROM taskTypeAction_cursor 
						INTO 
							@l_actionCode,
							@l_actionDefaultActionCode,
							@l_actionConditionSetCode,
							@l_actionEventTypeCode;
					END;

					CLOSE taskTypeAction_cursor;
					DEALLOCATE taskTypeAction_cursor;

				END --IF COALESCE(@l_taskTypeID, '') <> '' vége
			END

			FETCH NEXT FROM taskType_cursor 
			INTO 
				@l_code,
				@l_translations,
				@l_moduleCode,
				@l_deadlineDayTypeCode,
				@l_deadlineDay,
				@l_taskListTypeCode,
				@l_referencedObjectTypeCode,
				@l_resultObjectTypeCode,
				@l_detailedStatuses,
				@l_actions;
		END;
		
		CLOSE taskType_cursor;
		DEALLOCATE taskType_cursor; 

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		COMMIT TRANSACTION MAIN_TRANSACTION;
		RETURN 1;
	END TRY

	BEGIN CATCH
		ROLLBACK TRANSACTION MAIN_TRANSACTION;

		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'detailStatusTranslation_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE detailStatusTranslation_cursor;

			DEALLOCATE detailStatusTranslation_cursor;
		END

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'actionsTranslation_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE actionsTranslation_cursor;

			DEALLOCATE actionsTranslation_cursor;
		END

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'translation_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE translation_cursor;

			DEALLOCATE translation_cursor;
		END

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'taskTypeAction_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE taskTypeAction_cursor;

			DEALLOCATE taskTypeAction_cursor;
		END

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'taskType_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE taskType_cursor;

			DEALLOCATE taskType_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_errorMsg;

		RETURN 99;
	END CATCH
END
go

-- =============================================
-- Author:		Ozvaldik Krisztina
-- Creation date: 2022.08.04.
-- Last modified date: 2023.04.03.
-- Description:	Inserts valuesets FROM .json files
-- =============================================
CREATE PROCEDURE [GEN].[InsertFromJsonValueSet]
	@p_json NVARCHAR(MAX),
    @p_lang NVARCHAR(5)
AS
BEGIN
	SET NOCOUNT ON;
    /*** VÁLTOZÓK ***/
    DECLARE @l_json NVARCHAR(MAX)
	DECLARE @l_system NVARCHAR(200)
	DECLARE @l_version NVARCHAR(5)
	DECLARE @l_type NVARCHAR(200)
    DECLARE @l_userID NVARCHAR(200)
    DECLARE @l_valueSetVersion NVARCHAR(5)
    DECLARE @l_code NVARCHAR(200)
	DECLARE @l_dataType NVARCHAR(200)
	DECLARE @l_codePrefix NVARCHAR(200)
    DECLARE @l_objectID NUMERIC(16,0)
	DECLARE @l_valueSetID NUMERIC(16,0)
	DECLARE @l_valuesJSON NVARCHAR(MAX)
	DECLARE @l_sqlStatement NVARCHAR(MAX)
    DECLARE @l_valueSetCodeID NVARCHAR(200)
    DECLARE @l_logMessage NVARCHAR(MAX)

    BEGIN TRANSACTION

    BEGIN TRY
        --JSON fájl megtalálása
        SET @l_logMessage = 'Finding JSON file'
        PRINT (@l_logMessage)

        IF @p_json IS NOT NULL
            IF @p_json LIKE '%"header"%'
                SELECT @l_json = @p_json
            /*ELSE IF RIGHT(@p_json, 5) = '.json'
                SELECT @l_json = BulkColumn FROM OPENROWSET(BULK ''' + @p_json + ''', SINGLE_BLOB) JSON;*/
            ELSE
                RAISERROR( 'Invalid string parameter.', 16, 1);
        ELSE
            RAISERROR( 'Empty string parameter.', 16, 1);
        --Adatok kinyerése
        SET @l_logMessage = 'Setting variables from JSON'
        PRINT (@l_logMessage)

        SELECT  @l_system = JSON_VALUE( @l_json, '$.header.system'),
		        @l_version = JSON_VALUE( @l_json, '$.header.version'),
		        @l_type = JSON_VALUE( @l_json, '$.header.type'),
                @l_dataType = JSON_VALUE( @l_json, '$.valueSetData.dataType' ),
                @l_userID = 'Admin',
                @l_valueSetVersion = JSON_VALUE( @l_json, '$.valueSetData.version' ),
                @l_code = JSON_VALUE( @l_json, '$.valueSetData.code')

		--Ellenőrzi, hogy jó e a fájl formátuma
        SET @l_logMessage = 'Checking file validity'
        PRINT (@l_logMessage)

        IF @l_system <> 'INDECS'
            RAISERROR( 'System is not INDECS.', 16, 1);
        IF @l_version <> '3'
            RAISERROR( 'Wrong INDECS version.', 16, 1);
        IF @l_type <> 'VALUESET'
            RAISERROR( 'Wrong type of JSON file.', 16, 1);

        SET @l_logMessage = 'Starting procedure'
        PRINT (@l_logMessage)

        SELECT @l_valueSetCodeID = CONCAT('VALUESET_', @l_code)

        --Valueset translationök táblába töltése
        SELECT T1.* INTO #CodeTranslation FROM
            (SELECT @l_valueSetCodeID AS CodeID,
                    Language,
                    Text
                FROM OPENJSON ( @l_json ) WITH (
                    translations    NVARCHAR(MAX)   '$.valueSetData.translations' AS JSON) 
                OUTER APPLY OPENJSON ( translations ) WITH(
                    Language    NVARCHAR(5)     '$.language',
                    Text        NVARCHAR(200)    '$.text')) AS T1

        IF @l_dataType = 'ENUMERATION'
            BEGIN
                /*** ENUM ***/
                SET @l_logMessage = 'Beginning to process enumeration valueset'
                PRINT (@l_logMessage)

                SELECT  @l_valuesJSON = JSON_QUERY(@l_json, '$.valueSetData.values'),
                        @l_codePrefix = JSON_VALUE( @l_json, '$.valueSetData.codePrefix' )
                --Temporary táblák létrehozása
                SELECT C1.* INTO #CodeEnum FROM
                (SELECT CONCAT(@l_codePrefix, '_', JSON_VALUE(v_enum.value, '$.code')) AS ID,
                        (CASE WHEN JSON_VALUE(v_enum.value, '$.validFrom') = '' THEN NULL
                        ELSE JSON_VALUE(v_enum.value, '$.validFrom') END) AS ValidFrom,
                        (CASE WHEN JSON_VALUE(v_enum.value, '$.validUntil') = '' THEN NULL
                        ELSE JSON_VALUE(v_enum.value, '$.validUntil') END) AS ValidUntil
                    FROM OPENJSON(@l_valuesJSON) as v_enum) AS C1

                SELECT T1.* INTO #TranslationEnum FROM
                    (SELECT CONCAT(@l_codePrefix, '_', id) AS CodeID,
                            Language,
                            Text
                        FROM OPENJSON ( @l_valuesJSON ) WITH (
                            id NVARCHAR(200) '$.code',
                            translations    NVARCHAR(MAX)   '$.translations' AS JSON) 
                        OUTER APPLY OPENJSON ( translations ) WITH(
                            Language    NVARCHAR(5)     '$.language',
                            Text        NVARCHAR(200)    '$.text')) AS T1

                SELECT  @l_valueSetID = [GEN].[ValueSet].ID,
                        @l_objectID = [GEN].[ValueSet].ObjectID
                    FROM [GEN].[ValueSet]
                WHERE CodePrefix = @l_codePrefix

                --Ha már létezik a ValueSet
                IF @l_valueSetID IS NOT NULL
                    BEGIN
                        SET @l_logMessage = 'Valueset found. Updating valueset.'
                        PRINT (@l_logMessage)

                        --Verziószám update
                        SET @l_logMessage = 'GEN.Object update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].[Object] SET 
                            LastModifiedDate = CONVERT(DATE, GETDATE()),
                            LastModifiedTime = CONVERT(TIME, GETDATE()),
                            LastModifiedUserName =  @l_userID,
                            VersionNr = @l_valueSetVersion
                        WHERE ID = @l_objectID
                                    
                        --GEN.ValueSet Update
                        SET @l_logMessage = 'GEN.ValueSet update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].[ValueSet] SET 
                            LastModifiedDate = CONVERT(DATE, GETDATE()),
                            LastModifiedTime = CONVERT(TIME, GETDATE()),
                            LastModifiedUserName =  @l_userID
                        WHERE [GEN].[ValueSet].ID = @l_valueSetID

                        SELECT @l_valueSetID = ID FROM [GEN].[ValueSet]
                        WHERE CodePrefix = @l_codePrefix

                        IF NOT EXISTS (SELECT 1 FROM GEN.Code WHERE ID = @l_valueSetCodeID)
                        BEGIN
                            INSERT INTO [GEN].[Code] ( ID, ValueSetID, ValidFrom, CreationDate, CreationTime, CreationUserName )
                            SELECT  @l_valueSetCodeID,
                                    @l_valueSetID,
                                    '1000-01-01',
                                    CONVERT(DATE, GETDATE()),
                                    CONVERT(TIME, GETDATE()),
                                    @l_userID
                        END

                        --ValueSet translations insert
                        SET @l_logMessage = 'GEN.ValueSet translations insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeTranslation.CodeID,
                                #CodeTranslation.Language,
                                #CodeTranslation.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeTranslation
                        WHERE #CodeTranslation.CodeID NOT IN (
                            SELECT [GEN].[Translation].CodeID 
                                FROM [GEN].[Translation])
                        OR #CodeTranslation.Language NOT IN (
                            SELECT [GEN].[Translation].Language 
                                FROM [GEN].[Translation]
                            WHERE #CodeTranslation.CodeID = [GEN].[Translation].CodeID)

                        --ValueSet translations update
                        SET @l_logMessage = 'GEN.ValueSet translations update'
                        PRINT (@l_logMessage)

                        UPDATE  [GEN].[Translation] SET
                                [GEN].[Translation].Text = #CodeTranslation.Text,
                                [GEN].[Translation].LastModifiedDate = CONVERT(DATE, GETDATE()),
                                [GEN].[Translation].LastModifiedTime = CONVERT(TIME, GETDATE()),
                                [GEN].[Translation].LastModifiedUserName = @l_userID
                            FROM [GEN].[Translation]
                        JOIN #CodeTranslation ON [GEN].Translation.CodeID = #CodeTranslation.CodeID
                        AND [GEN].[Translation].Language = #CodeTranslation.Language
                        WHERE CreationDate <> CONVERT(DATE, GETDATE())
                        OR ABS(DATEDIFF(second, CreationTime, CONVERT(TIME, GETDATE()))) <= 1

                        --GEN.Code insert
                        SET @l_logMessage = 'GEN.Code insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Code] (ID, ValueSetID, ValidFrom, ValidUntil, CreationDate, CreationTime, CreationUserName)
                        SELECT  #CodeEnum.ID,
                                @l_valueSetID,
                                #CodeEnum.ValidFrom,
                                #CodeEnum.ValidUntil,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeEnum
                        WHERE #CodeEnum.ID NOT IN (
                            SELECT [GEN].[Code].ID FROM [GEN].[Code])

                        --GEN.Code update
                        SET @l_logMessage = 'GEN.Code update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].Code SET
                                [GEN].[Code].ValidFrom = #CodeEnum.ValidFrom,
                                [GEN].[Code].ValidUntil = #CodeEnum.ValidUntil,
                                [GEN].[Code].LastModifiedDate = CONVERT(DATE, GETDATE()),
                                [GEN].[Code].LastModifiedTime = CONVERT(TIME, GETDATE()),
                                [GEN].[Code].LastModifiedUserName = @l_userID
                            FROM [GEN].[Code]
                        JOIN #CodeEnum ON [GEN].[Code].ID = #CodeEnum.ID
                        WHERE CreationDate <> CONVERT(DATE, GETDATE())
                        OR ABS(DATEDIFF(second, CreationTime, CONVERT(TIME, GETDATE()))) <= 1

                        --GEN.Translation insert
                        SET @l_logMessage = 'GEN.Translation insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Translation] (CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #TranslationEnum.CodeID,
                                #TranslationEnum.Language,
                                #TranslationEnum.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #TranslationEnum
                        WHERE #TranslationEnum.CodeID NOT IN (
                            SELECT [GEN].[Translation].CodeID 
                                FROM [GEN].[Translation])
                        OR #TranslationEnum.Language NOT IN (
                            SELECT [GEN].[Translation].Language 
                                FROM [GEN].[Translation]
                            WHERE #TranslationEnum.CodeID = [GEN].[Translation].CodeID)

                        --GEN.Translation update
                        SET @l_logMessage = 'GEN.Translation update'
                        PRINT (@l_logMessage)

                        UPDATE  [GEN].[Translation] SET
                                [GEN].[Translation].Text = #TranslationEnum.Text,
                                [GEN].[Translation].LastModifiedDate = CONVERT(DATE, GETDATE()),
                                [GEN].[Translation].LastModifiedTime = CONVERT(TIME, GETDATE()),
                                [GEN].[Translation].LastModifiedUserName = @l_userID
                            FROM [GEN].[Translation]
                        JOIN #TranslationEnum ON [GEN].Translation.CodeID = #TranslationEnum.CodeID AND
                        [GEN].[Translation].Language = #TranslationEnum.Language
                        WHERE CreationDate <> CONVERT(DATE, GETDATE())
                        OR ABS(DATEDIFF(second, CreationTime, CONVERT(TIME, GETDATE()))) <= 1
                    END
                --Ha még nem létezik a ValueSet
                ELSE
                    BEGIN
                        SET @l_logMessage = 'Valueset not found. Creating new valueset'
                        PRINT (@l_logMessage)
                        
                        --Gen.Object insert
                        SET @l_logMessage = 'GEN.Object insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Object] ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
                        SELECT  'OBJECT_TYPE_GEN_VALUESET', 
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()), 
                                @l_userID, 
                                CONCAT( @l_codePrefix, ' value set object' ),
                                @l_valueSetVersion
                                        
                        SELECT @l_objectID = @@IDENTITY
                                    
                        --GEN.ValueSet insert
                        SET @l_logMessage = 'GEN.ValueSet insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[ValueSet] ( ObjectID, CodePrefix, Code, DataType, DataLength, CreationDate, CreationTime, CreationUserName )
                        SELECT  @l_objectID,
                                @l_codePrefix,
                                @l_valueSetCodeID,
                                SUBSTRING(@l_dataType, 1, 1),
                                JSON_VALUE( @l_json, '$.valueSetData.dataLength' ),
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()), 
                                @l_userID

                        --ValueSet translations insert
                        SET @l_logMessage = 'GEN.ValueSet translations insert'
                        PRINT (@l_logMessage)

                        SELECT @l_valueSetID = ID FROM [GEN].[ValueSet]
                        WHERE CodePrefix = 'VALUESET'

                        IF NOT EXISTS (SELECT 1 FROM GEN.Code WHERE ID = @l_valueSetCodeID)
                        BEGIN
                            INSERT INTO [GEN].[Code] ( ID, ValueSetID, ValidFrom, CreationDate, CreationTime, CreationUserName )
                            SELECT  @l_valueSetCodeID,
                                    @l_valueSetID,
                                    '1000-01-01',
                                    CONVERT(DATE, GETDATE()),
                                    CONVERT(TIME, GETDATE()),
                                    @l_userID
                        END

                        INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeTranslation.CodeID,
                                #CodeTranslation.Language,
                                #CodeTranslation.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeTranslation

                        SELECT @l_valueSetID = ID FROM [GEN].[ValueSet]
                        WHERE CodePrefix = @l_codePrefix

                        --GEN.Code insert
                        SET @l_logMessage = 'GEN.Code insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Code] ( ID, ValueSetID, ValidFrom, ValidUntil, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeEnum.ID,
                                @l_valueSetID,
                                #CodeEnum.ValidFrom,
                                #CodeEnum.ValidUntil,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeEnum

                        --GEN.Translation insert
                        SET @l_logMessage = 'GEN.Translation insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #TranslationEnum.CodeID,
                                #TranslationEnum.Language,
                                #TranslationEnum.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #TranslationEnum
                    END
                /*** ENUM ***/
            END
        ELSE IF @l_dataType = 'QUERY'
            BEGIN
            /*** QUERY ***/
                SET @l_logMessage = 'Beginning to process query valueset'
                PRINT (@l_logMessage)

                SELECT @l_sqlStatement = JSON_VALUE( @l_json, '$.valueSetData.SQLStatement')
                
                SELECT @l_valueSetID = [GEN].[ValueSet].ID,
                        @l_objectID = [GEN].[ValueSet].ObjectID
                    FROM [GEN].[ValueSet]
                WHERE [GEN].[ValueSet].ObjectID = (
                    SELECT [GEN].[Object].ID FROM [GEN].[Object]
                    WHERE ObjectType = 'GEN.ValueSet' AND Comments LIKE @l_code + '%')
                --Ha már létezik a ValueSet
                IF @l_valueSetID IS NOT NULL
                    BEGIN
                        SET @l_logMessage = 'Valueset found. Updating valueset'
                        PRINT (@l_logMessage)

                        --Verziószám update
                        SET @l_logMessage = 'GEN.Object update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].[Object] SET 
                            LastModifiedDate = CONVERT(DATE, GETDATE()),
                            LastModifiedTime = CONVERT(TIME, GETDATE()),
                            LastModifiedUserName =  @l_userID,
                            VersionNr = @l_valueSetVersion
                        WHERE ID = @l_objectID

                        --Valueset update
                        SET @l_logMessage = 'GEN.ValueSet update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].[ValueSet] SET 
                            LastModifiedDate = CONVERT(DATE, GETDATE()),
                            LastModifiedTime = CONVERT(TIME, GETDATE()),
                            LastModifiedUserName =  @l_userID,
                            SQLStatement = @l_sqlStatement
                        WHERE ID = @l_valueSetID

                        --ValueSet translations insert
                        SET @l_logMessage = 'GEN.ValueSet translations insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeTranslation.CodeID,
                                #CodeTranslation.Language,
                                #CodeTranslation.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeTranslation
                        WHERE #CodeTranslation.CodeID NOT IN (
                            SELECT [GEN].[Translation].CodeID 
                                FROM [GEN].[Translation])
                        OR #CodeTranslation.Language NOT IN (
                            SELECT [GEN].[Translation].Language 
                                FROM [GEN].[Translation]
                            WHERE #CodeTranslation.CodeID = [GEN].[Translation].CodeID)

                        --ValueSet translations update
                        SET @l_logMessage = 'GEN.ValueSet translations update'
                        PRINT (@l_logMessage)

                        UPDATE  [GEN].[Translation] SET
                                [GEN].[Translation].Text = #CodeTranslation.Text,
                                [GEN].[Translation].LastModifiedDate = CONVERT(DATE, GETDATE()),
                                [GEN].[Translation].LastModifiedTime = CONVERT(TIME, GETDATE()),
                                [GEN].[Translation].LastModifiedUserName = @l_userID
                            FROM [GEN].[Translation]
                        JOIN #CodeTranslation ON [GEN].Translation.CodeID = #CodeTranslation.CodeID
                        WHERE [GEN].[Translation].Language = #CodeTranslation.Language

                        SET @l_logMessage = 'Updated valueset. Procedure successfully done.'
                        PRINT (@l_logMessage)
                    END
                --Ha még nem létezik a ValueSet
                ELSE 
                    BEGIN
                        SET @l_logMessage = 'Valueset not found. Creating new valueset'
                        PRINT (@l_logMessage)

                        --Gen.Object insert
                        SET @l_logMessage = 'GEN.Object insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Object] ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
                        SELECT  'GEN.ValueSet', 
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()), 
                                @l_userID, 
                                CONCAT( @l_code, ' value set object' ),
                                @l_valueSetVersion
                                        
                        SELECT @l_objectID = @@IDENTITY
                                
                        --GEN.ValueSet insert
                        SET @l_logMessage = 'GEN.ValueSet insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[ValueSet] ( ObjectID, DataType, DataLength, SQLStatement, CreationDate, CreationTime, CreationUserName )
                        SELECT  @l_objectID,
                                SUBSTRING(@l_dataType, 1, 1),
                                JSON_VALUE( @l_json, '$.valueSetData.dataLength' ),
                                @l_sqlStatement,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID

                        --ValueSet translations insert
                        SET @l_logMessage = 'GEN.ValueSet translations insert'
                        PRINT (@l_logMessage)

                        SELECT @l_valueSetID = ID FROM [GEN].[ValueSet]
                        WHERE CodePrefix = 'VALUESET'
                        
                        IF NOT EXISTS (SELECT 1 FROM GEN.Code WHERE ID = @l_valueSetCodeID)
                        BEGIN
                            INSERT INTO [GEN].[Code] ( ID, ValueSetID, ValidFrom, CreationDate, CreationTime, CreationUserName )
                            SELECT  @l_valueSetCodeID,
                                    @l_valueSetID,
                                    '1000-01-01',
                                    CONVERT(DATE, GETDATE()),
                                    CONVERT(TIME, GETDATE()),
                                    @l_userID
                        END

                        INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeTranslation.CodeID,
                                #CodeTranslation.Language,
                                #CodeTranslation.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeTranslation
                        
                        SET @l_logMessage = 'Created new valueset. Procedure successfully done.'
                        PRINT (@l_logMessage)
                    /*** QUERY ***/
                    END
            END
        ELSE
            RAISERROR( 'Datatype not recognized in JSON file.', 16, 1);

    COMMIT TRANSACTION

    END TRY
    --Hibakezelés
    BEGIN CATCH
        DECLARE @l_errorMessage NVARCHAR(MAX) 
        DECLARE @l_errorSeverity INT 
        DECLARE @l_errorState INT
        DECLARE @l_errorLine INT

        SELECT   
        @l_errorMessage = ERROR_MESSAGE(),  
        @l_errorSeverity = ERROR_SEVERITY(),  
        @l_errorState = ERROR_STATE(),
        @l_errorLine = ERROR_LINE()

        SET @l_errorMessage = CONCAT('Error occured in line: ', @l_errorLine, ', in query: ', @l_logMessage, Char(10), 'ERROR MESSAGE: ', @l_errorMessage)

        RAISERROR ( @l_errorMessage, @l_errorSeverity, @l_errorState, @l_errorLine )

        ROLLBACK TRANSACTION

    END CATCH
END
go

-- =============================================
-- Author:		Ozvaldik Krisztina
-- Creation date: 2022.08.04.
-- Last modified date: 2023.04.03.
-- Description:	Inserts valuesets FROM .json files
-- =============================================
CREATE PROCEDURE [GEN].[InsertFromJsonValueSet_NEW]
	@p_json NVARCHAR(MAX)
AS
BEGIN
	SET NOCOUNT ON;
    /*** VÁLTOZÓK ***/
    DECLARE @l_json NVARCHAR(MAX)
	DECLARE @l_system NVARCHAR(200)
	DECLARE @l_version NVARCHAR(5)
	DECLARE @l_type NVARCHAR(200)
    DECLARE @l_userID NVARCHAR(200)
    DECLARE @l_valueSetVersion NVARCHAR(5)
    DECLARE @l_code NVARCHAR(200)
	DECLARE @l_dataType NVARCHAR(200)
	DECLARE @l_codePrefix NVARCHAR(200)
    DECLARE @l_objectID NUMERIC(16,0)
	DECLARE @l_valueSetID NUMERIC(16,0)
	DECLARE @l_valuesJSON NVARCHAR(MAX)
	DECLARE @l_sqlStatement NVARCHAR(MAX)
    DECLARE @l_valueSetCodeID NVARCHAR(200)
    DECLARE @l_logMessage NVARCHAR(MAX)

    BEGIN TRANSACTION

    BEGIN TRY
        --JSON fájl megtalálása
        SET @l_logMessage = 'Finding JSON file'
        --PRINT (@l_logMessage)

        IF @p_json IS NOT NULL
          --  IF @p_json LIKE '%"header"%'
                SELECT @l_json = @p_json
            /*ELSE IF RIGHT(@p_json, 5) = '.json'
                SELECT @l_json = BulkColumn FROM OPENROWSET(BULK ''' + @p_json + ''', SINGLE_BLOB) JSON;*/
            ELSE
                RAISERROR( 'Invalid string parameter.', 16, 1);
       -- ELSE
         --   RAISERROR( 'Empty string parameter.', 16, 1);
        --Adatok kinyerése
        SET @l_logMessage = 'Setting variables from JSON'
        --PRINT (@l_logMessage)

           SELECT  @l_system = JSON_VALUE( @l_json, '$.header.system'),
		        @l_version = JSON_VALUE( @l_json, '$.header.version'),
		        @l_type = JSON_VALUE( @l_json, '$.header.type'),
                @l_dataType = JSON_VALUE( @l_json, '$[0].valueSetType' ),
                @l_userID = 'Admin',
                @l_valueSetVersion = JSON_VALUE( @l_json, '$.valueSetData.version' ),
                @l_code = JSON_VALUE( @l_json, '$[0].code')


		
    
      SELECT @l_valueSetCodeID =@l_code
 
        --Valueset translationök táblába töltése
        SELECT T1.* INTO #CodeTranslation FROM
            (SELECT @l_valueSetCodeID AS CodeID,
                    Language,
                    Text
                FROM OPENJSON ( @l_json ) WITH (
                    translations    NVARCHAR(MAX)   '$.valueSetData.translations' AS JSON) 
                OUTER APPLY OPENJSON ( translations ) WITH(
                    Language    NVARCHAR(5)     '$.language',
                    Text        NVARCHAR(200)    '$.text')) AS T1;





        IF @l_dataType = 'ENUM'
            BEGIN
                /*** ENUM ***/
             --   SET @l_logMessage = 'Beginning to process enumeration valueset'
             --  PRINT (@l_logMessage)

                SELECT  @l_valuesJSON = JSON_QUERY(@l_json, '$[0].codes'),
                        @l_codePrefix = JSON_VALUE( @l_json, '$[0].prefixCode' )
                --Temporary táblák létrehozása
                SELECT C1.* INTO #CodeEnum FROM
                (SELECT JSON_VALUE(v_enum.value, '$.code') AS ID,
                        (CASE WHEN JSON_VALUE(v_enum.value, '$.validFrom') = '' THEN NULL
                        ELSE JSON_VALUE(v_enum.value, '$.validFrom') END) AS ValidFrom,
                        (CASE WHEN JSON_VALUE(v_enum.value, '$.validUntil') = '' THEN NULL
                        ELSE JSON_VALUE(v_enum.value, '$.validUntil') END) AS ValidUntil
                    FROM OPENJSON(@l_valuesJSON) as v_enum) AS C1;



					SELECT T1.* INTO #TranslationEnum FROM
                    (SELECT  id AS CodeID,
                            Language,
                            Text
                        FROM OPENJSON ( @l_valuesJSON ) WITH (
                            id NVARCHAR(200) '$.code',
                            translations    NVARCHAR(MAX)   '$.translations' AS JSON) 
                        OUTER APPLY OPENJSON ( translations ) WITH(
                            Language    NVARCHAR(5)     '$.languageISOCode',
                            Text        NVARCHAR(200)    '$.text')) AS T1;


			select *from #TranslationEnum;
			select *from #CodeEnum;
			select *from #CodeTranslation;
	
		
 


					SELECT  @l_valueSetID = [GEN].[ValueSet].ID,
                        @l_objectID = [GEN].[ValueSet].ObjectID
                    FROM [GEN].[ValueSet]
                WHERE CodePrefix = @l_codePrefix 
				
				

                --Ha már létezik a ValueSet
                IF @l_valueSetID IS NOT NULL
                    BEGIN
                        SET @l_logMessage = 'Valueset found. Updating valueset.'
                        PRINT (@l_logMessage)

                        --Verziószám update
                        SET @l_logMessage = 'GEN.Object update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].[Object] SET 
                            LastModifiedDate = CONVERT(DATE, GETDATE()),
                            LastModifiedTime = CONVERT(TIME, GETDATE()),
                            LastModifiedUserName =  @l_userID,
                            VersionNr = @l_valueSetVersion
                        WHERE ID = @l_objectID
                                    
                        --GEN.ValueSet Update
                        SET @l_logMessage = 'GEN.ValueSet update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].[ValueSet] SET 
                            LastModifiedDate = CONVERT(DATE, GETDATE()),
                            LastModifiedTime = CONVERT(TIME, GETDATE()),
                            LastModifiedUserName =  @l_userID
                        WHERE [GEN].[ValueSet].ID = @l_valueSetID

                        SELECT @l_valueSetID = ID FROM [GEN].[ValueSet]
                        WHERE CodePrefix = @l_codePrefix

                        IF NOT EXISTS (SELECT 1 FROM GEN.Code WHERE ID = @l_valueSetCodeID)
                        BEGIN
                            INSERT INTO [GEN].[Code] ( ID, ValueSetID, ValidFrom, CreationDate, CreationTime, CreationUserName )
                            SELECT  @l_valueSetCodeID,
                                    @l_valueSetID,
                                    '1000-01-01',
                                    CONVERT(DATE, GETDATE()),
                                    CONVERT(TIME, GETDATE()),
                                    @l_userID
                        END

                        --ValueSet translations insert
                        SET @l_logMessage = 'GEN.ValueSet translations insert'
                      --  PRINT (@l_logMessage)

					 /*   INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeTranslation.CodeID,
                                #CodeTranslation.Language,
                                #CodeTranslation.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeTranslation
                        WHERE #CodeTranslation.CodeID NOT IN (
                            SELECT [GEN].[Translation].CodeID 
                                FROM [GEN].[Translation])
                        OR #CodeTranslation.Language NOT IN (
                            SELECT [GEN].[Translation].Language 
                                FROM [GEN].[Translation]
                            WHERE #CodeTranslation.CodeID = [GEN].[Translation].CodeID)

							*/

                        --ValueSet translations update
                     /*   SET @l_logMessage = 'GEN.ValueSet translations update'
                        PRINT (@l_logMessage)

                        UPDATE  [GEN].[Translation] SET
                                [GEN].[Translation].Text = #CodeTranslation.Text,
                                [GEN].[Translation].LastModifiedDate = CONVERT(DATE, GETDATE()),
                                [GEN].[Translation].LastModifiedTime = CONVERT(TIME, GETDATE()),
                                [GEN].[Translation].LastModifiedUserName = @l_userID
                            FROM [GEN].[Translation]
                        JOIN #CodeTranslation ON [GEN].Translation.CodeID = #CodeTranslation.CodeID
                        AND [GEN].[Translation].Language = #CodeTranslation.Language
                        WHERE CreationDate <> CONVERT(DATE, GETDATE())
                        OR ABS(DATEDIFF(second, CreationTime, CONVERT(TIME, GETDATE()))) <= 1 */

					
                        --GEN.Code insert
                        SET @l_logMessage = 'GEN.Code insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Code] (ID, ValueSetID, ValidFrom, ValidUntil, CreationDate, CreationTime, CreationUserName)
                        SELECT  #CodeEnum.ID,
                                @l_valueSetID,
                                #CodeEnum.ValidFrom,
                                #CodeEnum.ValidUntil,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeEnum
                        WHERE #CodeEnum.ID NOT IN (
                            SELECT [GEN].[Code].ID FROM [GEN].[Code])


					



                        --GEN.Code update
                        SET @l_logMessage = 'GEN.Code update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].Code SET
                                [GEN].[Code].ValidFrom = #CodeEnum.ValidFrom,
                                [GEN].[Code].ValidUntil = #CodeEnum.ValidUntil,
                                [GEN].[Code].LastModifiedDate = CONVERT(DATE, GETDATE()),
                                [GEN].[Code].LastModifiedTime = CONVERT(TIME, GETDATE()),
                                [GEN].[Code].LastModifiedUserName = @l_userID
                            FROM [GEN].[Code]
                        JOIN #CodeEnum ON [GEN].[Code].ID = #CodeEnum.ID
                        WHERE CreationDate <> CONVERT(DATE, GETDATE())
                        OR ABS(DATEDIFF(second, CreationTime, CONVERT(TIME, GETDATE()))) <= 1

                        --GEN.Translation insert
                        SET @l_logMessage = 'GEN.Translation insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Translation] (CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #TranslationEnum.CodeID,
                                #TranslationEnum.Language,
                                #TranslationEnum.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #TranslationEnum
                        WHERE (#TranslationEnum.CodeID NOT IN (
                            SELECT [GEN].[Translation].CodeID 
                                FROM [GEN].[Translation])
                        OR #TranslationEnum.Language NOT IN (
                            SELECT [GEN].[Translation].Language 
                                FROM [GEN].[Translation]
                            WHERE #TranslationEnum.CodeID = [GEN].[Translation].CodeID)) AND #TranslationEnum.Text is not null

							 --GEN.Translation update
                        SET @l_logMessage = 'GEN.Translation update'
                        PRINT (@l_logMessage)


	  
                        UPDATE  [GEN].[Translation] SET
                                [GEN].[Translation].Text = #TranslationEnum.Text,
                                [GEN].[Translation].LastModifiedDate = CONVERT(DATE, GETDATE()),
                                [GEN].[Translation].LastModifiedTime = CONVERT(TIME, GETDATE()),
                                [GEN].[Translation].LastModifiedUserName = @l_userID
                            FROM [GEN].[Translation]
                        JOIN #TranslationEnum ON [GEN].Translation.CodeID = #TranslationEnum.CodeID AND
                        [GEN].[Translation].Language = #TranslationEnum.Language
                        WHERE CreationDate <> CONVERT(DATE, GETDATE())
                        OR ABS(DATEDIFF(second, CreationTime, CONVERT(TIME, GETDATE()))) <= 1
                    END
                --Ha még nem létezik a ValueSet
                ELSE
                    BEGIN
                        SET @l_logMessage = 'Valueset not found. Creating new valueset'
                       -- PRINT (@l_logMessage)
                        
                        --Gen.Object insert
                        SET @l_logMessage = 'GEN.Object insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Object] ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
                        SELECT  'OBJECT_TYPE_GEN_VALUESET', 
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()), 
                                @l_userID, 
                                CONCAT( @l_codePrefix, ' value set object' ),
                                @l_valueSetVersion
                                        
                        SELECT @l_objectID = @@IDENTITY
                                    
                        --GEN.ValueSet insert
                        SET @l_logMessage = 'GEN.ValueSet insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[ValueSet] ( ObjectID, CodePrefix, Code, DataType, DataLength, CreationDate, CreationTime, CreationUserName )
                        SELECT  @l_objectID,
                                @l_codePrefix,
                                @l_valueSetCodeID,
                                SUBSTRING(@l_dataType, 1, 1),
                                JSON_VALUE( @l_json, '$.valueSetData.dataLength' ),
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()), 
                                @l_userID

                        --ValueSet translations insert
                        SET @l_logMessage = 'GEN.ValueSet translations insert'
                        PRINT (@l_logMessage)

                        SELECT @l_valueSetID = ID FROM [GEN].[ValueSet]
                        WHERE CodePrefix = 'VALUESET'

                        IF NOT EXISTS (SELECT 1 FROM GEN.Code WHERE ID = @l_valueSetCodeID)
                        BEGIN
                            INSERT INTO [GEN].[Code] ( ID, ValueSetID, ValidFrom, CreationDate, CreationTime, CreationUserName )
                            SELECT  @l_valueSetCodeID,
                                    @l_valueSetID,
                                    '1000-01-01',
                                    CONVERT(DATE, GETDATE()),
                                    CONVERT(TIME, GETDATE()),
                                    @l_userID
                        END


                     /*   INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeTranslation.CodeID,
                                #CodeTranslation.Language,
                                #CodeTranslation.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeTranslation */

                        SELECT @l_valueSetID = ID FROM [GEN].[ValueSet]
                        WHERE CodePrefix = @l_codePrefix

                        --GEN.Code insert
                        SET @l_logMessage = 'GEN.Code insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Code] ( ID, ValueSetID, ValidFrom, ValidUntil, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeEnum.ID,
                                @l_valueSetID,
                                #CodeEnum.ValidFrom,
                                #CodeEnum.ValidUntil,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeEnum

                        --GEN.Translation insert
                        SET @l_logMessage = 'GEN.Translation insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #TranslationEnum.CodeID,
                                #TranslationEnum.Language,
                                #TranslationEnum.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #TranslationEnum
                    END
                /*** ENUM ***/
            END




        ELSE IF @l_dataType = 'QUERY'
            BEGIN
            /*** QUERY ***/
                SET @l_logMessage = 'Beginning to process query valueset'
                PRINT (@l_logMessage)

                SELECT @l_sqlStatement = JSON_VALUE( @l_json, '$.valueSetData.SQLStatement')
                
                SELECT @l_valueSetID = [GEN].[ValueSet].ID,
                        @l_objectID = [GEN].[ValueSet].ObjectID
                    FROM [GEN].[ValueSet]
                WHERE [GEN].[ValueSet].ObjectID = (
                    SELECT [GEN].[Object].ID FROM [GEN].[Object]
                    WHERE ObjectType = 'GEN.ValueSet' AND Comments LIKE @l_code + '%')
                --Ha már létezik a ValueSet
                IF @l_valueSetID IS NOT NULL
                    BEGIN
                        SET @l_logMessage = 'Valueset found. Updating valueset'
                        PRINT (@l_logMessage)

                        --Verziószám update
                        SET @l_logMessage = 'GEN.Object update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].[Object] SET 
                            LastModifiedDate = CONVERT(DATE, GETDATE()),
                            LastModifiedTime = CONVERT(TIME, GETDATE()),
                            LastModifiedUserName =  @l_userID,
                            VersionNr = @l_valueSetVersion
                        WHERE ID = @l_objectID

                        --Valueset update
                        SET @l_logMessage = 'GEN.ValueSet update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].[ValueSet] SET 
                            LastModifiedDate = CONVERT(DATE, GETDATE()),
                            LastModifiedTime = CONVERT(TIME, GETDATE()),
                            LastModifiedUserName =  @l_userID,
                            SQLStatement = @l_sqlStatement
                        WHERE ID = @l_valueSetID

                        --ValueSet translations insert
                        SET @l_logMessage = 'GEN.ValueSet translations insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeTranslation.CodeID,
                                #CodeTranslation.Language,
                                #CodeTranslation.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeTranslation
                        WHERE #CodeTranslation.CodeID NOT IN (
                            SELECT [GEN].[Translation].CodeID 
                                FROM [GEN].[Translation])
                        OR #CodeTranslation.Language NOT IN (
                            SELECT [GEN].[Translation].Language 
                                FROM [GEN].[Translation]
                            WHERE #CodeTranslation.CodeID = [GEN].[Translation].CodeID)

                        --ValueSet translations update
                        SET @l_logMessage = 'GEN.ValueSet translations update'
                        PRINT (@l_logMessage)

                        UPDATE  [GEN].[Translation] SET
                                [GEN].[Translation].Text = #CodeTranslation.Text,
                                [GEN].[Translation].LastModifiedDate = CONVERT(DATE, GETDATE()),
                                [GEN].[Translation].LastModifiedTime = CONVERT(TIME, GETDATE()),
                                [GEN].[Translation].LastModifiedUserName = @l_userID
                            FROM [GEN].[Translation]
                        JOIN #CodeTranslation ON [GEN].Translation.CodeID = #CodeTranslation.CodeID
                        WHERE [GEN].[Translation].Language = #CodeTranslation.Language

                        SET @l_logMessage = 'Updated valueset. Procedure successfully done.'
                        PRINT (@l_logMessage)
                    END
                --Ha még nem létezik a ValueSet
                ELSE 
                    BEGIN
                        SET @l_logMessage = 'Valueset not found. Creating new valueset'
                        PRINT (@l_logMessage)

                        --Gen.Object insert
                        SET @l_logMessage = 'GEN.Object insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Object] ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
                        SELECT  'GEN.ValueSet', 
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()), 
                                @l_userID, 
                                CONCAT( @l_code, ' value set object' ),
                                @l_valueSetVersion
                                        
                        SELECT @l_objectID = @@IDENTITY
                                
                        --GEN.ValueSet insert
                        SET @l_logMessage = 'GEN.ValueSet insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[ValueSet] ( ObjectID, DataType, DataLength, SQLStatement, CreationDate, CreationTime, CreationUserName )
                        SELECT  @l_objectID,
                                SUBSTRING(@l_dataType, 1, 1),
                                JSON_VALUE( @l_json, '$.valueSetData.dataLength' ),
                                @l_sqlStatement,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID

                        --ValueSet translations insert
                        SET @l_logMessage = 'GEN.ValueSet translations insert'
                        PRINT (@l_logMessage)

                        SELECT @l_valueSetID = ID FROM [GEN].[ValueSet]
                        WHERE CodePrefix = 'VALUESET'
                        
                        IF NOT EXISTS (SELECT 1 FROM GEN.Code WHERE ID = @l_valueSetCodeID)
                        BEGIN
                            INSERT INTO [GEN].[Code] ( ID, ValueSetID, ValidFrom, CreationDate, CreationTime, CreationUserName )
                            SELECT  @l_valueSetCodeID,
                                    @l_valueSetID,
                                    '1000-01-01',
                                    CONVERT(DATE, GETDATE()),
                                    CONVERT(TIME, GETDATE()),
                                    @l_userID
                        END

                        INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeTranslation.CodeID,
                                #CodeTranslation.Language,
                                #CodeTranslation.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeTranslation
                        
                        SET @l_logMessage = 'Created new valueset. Procedure successfully done.'
                        PRINT (@l_logMessage)
                    /*** QUERY ***/



                    END
	
            END 
 
		
	  
        ELSE
            RAISERROR( 'Datatype not recognized in JSON file.', 16, 1);

    COMMIT TRANSACTION

    END TRY
    --Hibakezelés
    BEGIN CATCH
        DECLARE @l_errorMessage NVARCHAR(MAX) 
        DECLARE @l_errorSeverity INT 
        DECLARE @l_errorState INT
        DECLARE @l_errorLine INT

        SELECT   
        @l_errorMessage = ERROR_MESSAGE(),  
        @l_errorSeverity = ERROR_SEVERITY(),  
        @l_errorState = ERROR_STATE(),
        @l_errorLine = ERROR_LINE()

        SET @l_errorMessage = CONCAT('Error occured in line: ', @l_errorLine, ', in query: ', @l_logMessage, Char(10), 'ERROR MESSAGE: ', @l_errorMessage)

        RAISERROR ( @l_errorMessage, @l_errorSeverity, @l_errorState, @l_errorLine )

        ROLLBACK TRANSACTION

    END CATCH
END

go

-- =============================================
-- Author:		Ozvaldik Krisztina
-- Creation date: 2022.08.04.
-- Last modified date: 2023.04.03.
-- Description:	Inserts valuesets FROM .json files
-- =============================================
CREATE PROCEDURE [GEN].[InsertFromJsonValueSet_NEW_NEW]
	@p_json NVARCHAR(MAX)
AS
BEGIN
	SET NOCOUNT ON;
    /*** VÁLTOZÓK ***/
    DECLARE @l_json NVARCHAR(MAX)
	DECLARE @l_system NVARCHAR(200)
	DECLARE @l_version NVARCHAR(5)
	DECLARE @l_type NVARCHAR(200)
    DECLARE @l_userID NVARCHAR(200)
    DECLARE @l_valueSetVersion NVARCHAR(5)
    DECLARE @l_code NVARCHAR(200)
	DECLARE @l_dataType NVARCHAR(200)
	DECLARE @l_codePrefix NVARCHAR(200)
    DECLARE @l_objectID NUMERIC(16,0)
	DECLARE @l_valueSetID NUMERIC(16,0)
	DECLARE @l_valuesJSON NVARCHAR(MAX)
	DECLARE @l_sqlStatement NVARCHAR(MAX)
    DECLARE @l_valueSetCodeID NVARCHAR(200)
    DECLARE @l_logMessage NVARCHAR(MAX)

    BEGIN TRANSACTION

    BEGIN TRY
        --JSON fájl megtalálása
        SET @l_logMessage = 'Finding JSON file'
        --PRINT (@l_logMessage)

        IF @p_json IS NOT NULL
          --  IF @p_json LIKE '%"header"%'
                SELECT @l_json = @p_json
            /*ELSE IF RIGHT(@p_json, 5) = '.json'
                SELECT @l_json = BulkColumn FROM OPENROWSET(BULK ''' + @p_json + ''', SINGLE_BLOB) JSON;*/
            ELSE
                RAISERROR( 'Invalid string parameter.', 16, 1);
       -- ELSE
         --   RAISERROR( 'Empty string parameter.', 16, 1);
        --Adatok kinyerése
        SET @l_logMessage = 'Setting variables from JSON'
        --PRINT (@l_logMessage)

           SELECT  @l_system = JSON_VALUE( @l_json, '$.header.system'),
		        @l_version = JSON_VALUE( @l_json, '$.header.version'),
		        @l_type = JSON_VALUE( @l_json, '$.header.type'),
                @l_dataType = JSON_VALUE( @l_json, '$[0].valueSetType' ),
                @l_userID = 'Admin',
                @l_valueSetVersion = JSON_VALUE( @l_json, '$.valueSetData.version' ),
                @l_code = JSON_VALUE( @l_json, '$[0].code')


		
    
      SELECT @l_valueSetCodeID =@l_code
 
        --Valueset translationök táblába töltése
        SELECT T1.* INTO #CodeTranslation FROM
            (SELECT @l_valueSetCodeID AS CodeID,
                    Language,
                    Text
                FROM OPENJSON ( @l_json ) WITH (
                    translations    NVARCHAR(MAX)   '$.valueSetData.translations' AS JSON) 
                OUTER APPLY OPENJSON ( translations ) WITH(
                    Language    NVARCHAR(5)     '$.language',
                    Text        NVARCHAR(200)    '$.text')) AS T1;





        IF @l_dataType = 'ENUM'
            BEGIN
                /*** ENUM ***/
             --   SET @l_logMessage = 'Beginning to process enumeration valueset'
             --  PRINT (@l_logMessage)

                SELECT  @l_valuesJSON = JSON_QUERY(@l_json, '$[0].codes'),
                        @l_codePrefix = JSON_VALUE( @l_json, '$[0].prefixCode' )
                --Temporary táblák létrehozása
                SELECT C1.* INTO #CodeEnum FROM
                (SELECT JSON_VALUE(v_enum.value, '$.code') AS ID,
                        (CASE WHEN JSON_VALUE(v_enum.value, '$.validFrom') = '' THEN NULL
                        ELSE JSON_VALUE(v_enum.value, '$.validFrom') END) AS ValidFrom,
                        (CASE WHEN JSON_VALUE(v_enum.value, '$.validUntil') = '' THEN NULL
                        ELSE JSON_VALUE(v_enum.value, '$.validUntil') END) AS ValidUntil
                    FROM OPENJSON(@l_valuesJSON) as v_enum) AS C1;



					SELECT T1.* INTO #TranslationEnum FROM
                    (SELECT  id AS CodeID,
                            Language,
                            Text
                        FROM OPENJSON ( @l_valuesJSON ) WITH (
                            id NVARCHAR(200) '$.code',
                            translations    NVARCHAR(MAX)   '$.translations' AS JSON) 
                        OUTER APPLY OPENJSON ( translations ) WITH(
                            Language    NVARCHAR(5)     '$.languageISOCode',
                            Text        NVARCHAR(200)    '$.text')) AS T1;


			select *from #TranslationEnum;
			select *from #CodeEnum;
			select *from #CodeTranslation;
	
		
 


					SELECT  @l_valueSetID = [GEN].[ValueSet].ID,
                        @l_objectID = [GEN].[ValueSet].ObjectID
                    FROM [GEN].[ValueSet]
                WHERE CodePrefix = @l_codePrefix 
				
				

                --Ha már létezik a ValueSet
                IF @l_valueSetID IS NOT NULL
                    BEGIN
                        SET @l_logMessage = 'Valueset found. Updating valueset.'
                        PRINT (@l_logMessage)

                        --Verziószám update
                        SET @l_logMessage = 'GEN.Object update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].[Object] SET 
                            LastModifiedDate = CONVERT(DATE, GETDATE()),
                            LastModifiedTime = CONVERT(TIME, GETDATE()),
                            LastModifiedUserName =  @l_userID,
                            VersionNr = @l_valueSetVersion
                        WHERE ID = @l_objectID
                                    
                        --GEN.ValueSet Update
                        SET @l_logMessage = 'GEN.ValueSet update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].[ValueSet] SET 
                            LastModifiedDate = CONVERT(DATE, GETDATE()),
                            LastModifiedTime = CONVERT(TIME, GETDATE()),
                            LastModifiedUserName =  @l_userID
                        WHERE [GEN].[ValueSet].ID = @l_valueSetID

                        SELECT @l_valueSetID = ID FROM [GEN].[ValueSet]
                        WHERE CodePrefix = @l_codePrefix

                        IF NOT EXISTS (SELECT 1 FROM GEN.Code WHERE ID = @l_valueSetCodeID)
                        BEGIN
                            INSERT INTO [GEN].[Code] ( ID, ValueSetID, ValidFrom, CreationDate, CreationTime, CreationUserName )
                            SELECT  @l_valueSetCodeID,
                                    @l_valueSetID,
                                    '1000-01-01',
                                    CONVERT(DATE, GETDATE()),
                                    CONVERT(TIME, GETDATE()),
                                    @l_userID
                        END

                        --ValueSet translations insert
                        SET @l_logMessage = 'GEN.ValueSet translations insert'
                      --  PRINT (@l_logMessage)

					 /*   INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeTranslation.CodeID,
                                #CodeTranslation.Language,
                                #CodeTranslation.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeTranslation
                        WHERE #CodeTranslation.CodeID NOT IN (
                            SELECT [GEN].[Translation].CodeID 
                                FROM [GEN].[Translation])
                        OR #CodeTranslation.Language NOT IN (
                            SELECT [GEN].[Translation].Language 
                                FROM [GEN].[Translation]
                            WHERE #CodeTranslation.CodeID = [GEN].[Translation].CodeID)

							*/

                        --ValueSet translations update
                     /*   SET @l_logMessage = 'GEN.ValueSet translations update'
                        PRINT (@l_logMessage)

                        UPDATE  [GEN].[Translation] SET
                                [GEN].[Translation].Text = #CodeTranslation.Text,
                                [GEN].[Translation].LastModifiedDate = CONVERT(DATE, GETDATE()),
                                [GEN].[Translation].LastModifiedTime = CONVERT(TIME, GETDATE()),
                                [GEN].[Translation].LastModifiedUserName = @l_userID
                            FROM [GEN].[Translation]
                        JOIN #CodeTranslation ON [GEN].Translation.CodeID = #CodeTranslation.CodeID
                        AND [GEN].[Translation].Language = #CodeTranslation.Language
                        WHERE CreationDate <> CONVERT(DATE, GETDATE())
                        OR ABS(DATEDIFF(second, CreationTime, CONVERT(TIME, GETDATE()))) <= 1 */

					
                        --GEN.Code insert
                        SET @l_logMessage = 'GEN.Code insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Code] (ID, ValueSetID, ValidFrom, ValidUntil, CreationDate, CreationTime, CreationUserName)
                        SELECT  #CodeEnum.ID,
                                @l_valueSetID,
                                #CodeEnum.ValidFrom,
                                #CodeEnum.ValidUntil,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeEnum
                        WHERE #CodeEnum.ID NOT IN (
                            SELECT [GEN].[Code].ID FROM [GEN].[Code])


					



                        --GEN.Code update
                        SET @l_logMessage = 'GEN.Code update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].Code SET
                                [GEN].[Code].ValidFrom = #CodeEnum.ValidFrom,
                                [GEN].[Code].ValidUntil = #CodeEnum.ValidUntil,
                                [GEN].[Code].LastModifiedDate = CONVERT(DATE, GETDATE()),
                                [GEN].[Code].LastModifiedTime = CONVERT(TIME, GETDATE()),
                                [GEN].[Code].LastModifiedUserName = @l_userID
                            FROM [GEN].[Code]
                        JOIN #CodeEnum ON [GEN].[Code].ID = #CodeEnum.ID
                        WHERE CreationDate <> CONVERT(DATE, GETDATE())
                        OR ABS(DATEDIFF(second, CreationTime, CONVERT(TIME, GETDATE()))) <= 1

                        --GEN.Translation insert
                        SET @l_logMessage = 'GEN.Translation insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Translation] (CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #TranslationEnum.CodeID,
                                #TranslationEnum.Language,
                                #TranslationEnum.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #TranslationEnum
                        WHERE (#TranslationEnum.CodeID NOT IN (
                            SELECT [GEN].[Translation].CodeID 
                                FROM [GEN].[Translation])
                        OR #TranslationEnum.Language NOT IN (
                            SELECT [GEN].[Translation].Language 
                                FROM [GEN].[Translation]
                            WHERE #TranslationEnum.CodeID = [GEN].[Translation].CodeID)) AND #TranslationEnum.Text is not null

							 --GEN.Translation update
                        SET @l_logMessage = 'GEN.Translation update'
                        PRINT (@l_logMessage)


	  
                        UPDATE  [GEN].[Translation] SET
                                [GEN].[Translation].Text = #TranslationEnum.Text,
                                [GEN].[Translation].LastModifiedDate = CONVERT(DATE, GETDATE()),
                                [GEN].[Translation].LastModifiedTime = CONVERT(TIME, GETDATE()),
                                [GEN].[Translation].LastModifiedUserName = @l_userID
                            FROM [GEN].[Translation]
                        JOIN #TranslationEnum ON [GEN].Translation.CodeID = #TranslationEnum.CodeID AND
                        [GEN].[Translation].Language = #TranslationEnum.Language
                        WHERE CreationDate <> CONVERT(DATE, GETDATE())
                        OR ABS(DATEDIFF(second, CreationTime, CONVERT(TIME, GETDATE()))) <= 1
                    END
                --Ha még nem létezik a ValueSet
                ELSE
                    BEGIN
                        SET @l_logMessage = 'Valueset not found. Creating new valueset'
                       -- PRINT (@l_logMessage)
                        
                        --Gen.Object insert
                        SET @l_logMessage = 'GEN.Object insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Object] ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
                        SELECT  'OBJECT_TYPE_GEN_VALUESET', 
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()), 
                                @l_userID, 
                                CONCAT( @l_codePrefix, ' value set object' ),
                                @l_valueSetVersion
                                        
                        SELECT @l_objectID = @@IDENTITY
                                    
                        --GEN.ValueSet insert
                        SET @l_logMessage = 'GEN.ValueSet insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[ValueSet] ( ObjectID, CodePrefix, Code, DataType, DataLength, CreationDate, CreationTime, CreationUserName )
                        SELECT  @l_objectID,
                                @l_codePrefix,
                                @l_valueSetCodeID,
                                SUBSTRING(@l_dataType, 1, 1),
                                JSON_VALUE( @l_json, '$.valueSetData.dataLength' ),
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()), 
                                @l_userID

                        --ValueSet translations insert
                        SET @l_logMessage = 'GEN.ValueSet translations insert'
                        PRINT (@l_logMessage)

                        SELECT @l_valueSetID = ID FROM [GEN].[ValueSet]
                        WHERE CodePrefix = 'VALUESET'

                        IF NOT EXISTS (SELECT 1 FROM GEN.Code WHERE ID = @l_valueSetCodeID)
                        BEGIN
                            INSERT INTO [GEN].[Code] ( ID, ValueSetID, ValidFrom, CreationDate, CreationTime, CreationUserName )
                            SELECT  @l_valueSetCodeID,
                                    @l_valueSetID,
                                    '1000-01-01',
                                    CONVERT(DATE, GETDATE()),
                                    CONVERT(TIME, GETDATE()),
                                    @l_userID
                        END


                     /*   INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeTranslation.CodeID,
                                #CodeTranslation.Language,
                                #CodeTranslation.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeTranslation */

                        SELECT @l_valueSetID = ID FROM [GEN].[ValueSet]
                        WHERE CodePrefix = @l_codePrefix

                        --GEN.Code insert
                        SET @l_logMessage = 'GEN.Code insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Code] ( ID, ValueSetID, ValidFrom, ValidUntil, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeEnum.ID,
                                @l_valueSetID,
                                #CodeEnum.ValidFrom,
                                #CodeEnum.ValidUntil,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeEnum

                        --GEN.Translation insert
                        SET @l_logMessage = 'GEN.Translation insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #TranslationEnum.CodeID,
                                #TranslationEnum.Language,
                                #TranslationEnum.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #TranslationEnum
                    END
                /*** ENUM ***/
            END




        ELSE IF @l_dataType = 'QUERY'
            BEGIN
            /*** QUERY ***/
                SET @l_logMessage = 'Beginning to process query valueset'
                PRINT (@l_logMessage)

                SELECT @l_sqlStatement = JSON_VALUE( @l_json, '$.valueSetData.SQLStatement')
                
                SELECT @l_valueSetID = [GEN].[ValueSet].ID,
                        @l_objectID = [GEN].[ValueSet].ObjectID
                    FROM [GEN].[ValueSet]
                WHERE [GEN].[ValueSet].ObjectID = (
                    SELECT [GEN].[Object].ID FROM [GEN].[Object]
                    WHERE ObjectType = 'GEN.ValueSet' AND Comments LIKE @l_code + '%')
                --Ha már létezik a ValueSet
                IF @l_valueSetID IS NOT NULL
                    BEGIN
                        SET @l_logMessage = 'Valueset found. Updating valueset'
                        PRINT (@l_logMessage)

                        --Verziószám update
                        SET @l_logMessage = 'GEN.Object update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].[Object] SET 
                            LastModifiedDate = CONVERT(DATE, GETDATE()),
                            LastModifiedTime = CONVERT(TIME, GETDATE()),
                            LastModifiedUserName =  @l_userID,
                            VersionNr = @l_valueSetVersion
                        WHERE ID = @l_objectID

                        --Valueset update
                        SET @l_logMessage = 'GEN.ValueSet update'
                        PRINT (@l_logMessage)

                        UPDATE [GEN].[ValueSet] SET 
                            LastModifiedDate = CONVERT(DATE, GETDATE()),
                            LastModifiedTime = CONVERT(TIME, GETDATE()),
                            LastModifiedUserName =  @l_userID,
                            SQLStatement = @l_sqlStatement
                        WHERE ID = @l_valueSetID

                        --ValueSet translations insert
                        SET @l_logMessage = 'GEN.ValueSet translations insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeTranslation.CodeID,
                                #CodeTranslation.Language,
                                #CodeTranslation.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeTranslation
                        WHERE #CodeTranslation.CodeID NOT IN (
                            SELECT [GEN].[Translation].CodeID 
                                FROM [GEN].[Translation])
                        OR #CodeTranslation.Language NOT IN (
                            SELECT [GEN].[Translation].Language 
                                FROM [GEN].[Translation]
                            WHERE #CodeTranslation.CodeID = [GEN].[Translation].CodeID)

                        --ValueSet translations update
                        SET @l_logMessage = 'GEN.ValueSet translations update'
                        PRINT (@l_logMessage)

                        UPDATE  [GEN].[Translation] SET
                                [GEN].[Translation].Text = #CodeTranslation.Text,
                                [GEN].[Translation].LastModifiedDate = CONVERT(DATE, GETDATE()),
                                [GEN].[Translation].LastModifiedTime = CONVERT(TIME, GETDATE()),
                                [GEN].[Translation].LastModifiedUserName = @l_userID
                            FROM [GEN].[Translation]
                        JOIN #CodeTranslation ON [GEN].Translation.CodeID = #CodeTranslation.CodeID
                        WHERE [GEN].[Translation].Language = #CodeTranslation.Language

                        SET @l_logMessage = 'Updated valueset. Procedure successfully done.'
                        PRINT (@l_logMessage)
                    END
                --Ha még nem létezik a ValueSet
                ELSE 
                    BEGIN
                        SET @l_logMessage = 'Valueset not found. Creating new valueset'
                        PRINT (@l_logMessage)

                        --Gen.Object insert
                        SET @l_logMessage = 'GEN.Object insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[Object] ( ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr )
                        SELECT  'GEN.ValueSet', 
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()), 
                                @l_userID, 
                                CONCAT( @l_code, ' value set object' ),
                                @l_valueSetVersion
                                        
                        SELECT @l_objectID = @@IDENTITY
                                
                        --GEN.ValueSet insert
                        SET @l_logMessage = 'GEN.ValueSet insert'
                        PRINT (@l_logMessage)

                        INSERT INTO [GEN].[ValueSet] ( ObjectID, DataType, DataLength, SQLStatement, CreationDate, CreationTime, CreationUserName )
                        SELECT  @l_objectID,
                                SUBSTRING(@l_dataType, 1, 1),
                                JSON_VALUE( @l_json, '$.valueSetData.dataLength' ),
                                @l_sqlStatement,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID

                        --ValueSet translations insert
                        SET @l_logMessage = 'GEN.ValueSet translations insert'
                        PRINT (@l_logMessage)

                        SELECT @l_valueSetID = ID FROM [GEN].[ValueSet]
                        WHERE CodePrefix = 'VALUESET'
                        
                        IF NOT EXISTS (SELECT 1 FROM GEN.Code WHERE ID = @l_valueSetCodeID)
                        BEGIN
                            INSERT INTO [GEN].[Code] ( ID, ValueSetID, ValidFrom, CreationDate, CreationTime, CreationUserName )
                            SELECT  @l_valueSetCodeID,
                                    @l_valueSetID,
                                    '1000-01-01',
                                    CONVERT(DATE, GETDATE()),
                                    CONVERT(TIME, GETDATE()),
                                    @l_userID
                        END

                        INSERT INTO [GEN].[Translation] ( CodeID, Language, Text, CreationDate, CreationTime, CreationUserName )
                        SELECT  #CodeTranslation.CodeID,
                                #CodeTranslation.Language,
                                #CodeTranslation.Text,
                                CONVERT(DATE, GETDATE()),
                                CONVERT(TIME, GETDATE()),
                                @l_userID
                            FROM #CodeTranslation
                        
                        SET @l_logMessage = 'Created new valueset. Procedure successfully done.'
                        PRINT (@l_logMessage)
                    /*** QUERY ***/



                    END
	
            END 
 
		
	  
        ELSE
            RAISERROR( 'Datatype not recognized in JSON file.', 16, 1);

    COMMIT TRANSACTION

    END TRY
    --Hibakezelés
    BEGIN CATCH
        DECLARE @l_errorMessage NVARCHAR(MAX) 
        DECLARE @l_errorSeverity INT 
        DECLARE @l_errorState INT
        DECLARE @l_errorLine INT

        SELECT   
        @l_errorMessage = ERROR_MESSAGE(),  
        @l_errorSeverity = ERROR_SEVERITY(),  
        @l_errorState = ERROR_STATE(),
        @l_errorLine = ERROR_LINE()

        SET @l_errorMessage = CONCAT('Error occured in line: ', @l_errorLine, ', in query: ', @l_logMessage, Char(10), 'ERROR MESSAGE: ', @l_errorMessage)

        RAISERROR ( @l_errorMessage, @l_errorSeverity, @l_errorState, @l_errorLine )

        ROLLBACK TRANSACTION

    END CATCH
END

go

CREATE   PROCEDURE [IFC].[InvoiceLoader](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16), @p_moduleInstanceIDInkasso Numeric(16) = null output)

/*
==========================================================================================
 Author:		Tóth Gábor
 Creation date:			2022.11.07.
 Last modified date:	2022.11.08.
						2022-11-09: @p_moduleInstanceID, Átnevezés, 999 -> 99
						2022-11-13: "Demo" mód törlése, "SourceInterfaceType" <-> "MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE" csere, Set @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
						2022-11-15: @l_TransactionDate = Coalesce(@ContractDate, @TerminationDate, @IssueDate), InvoiceLineID
						2022-11-16: CreditType kivéve, mert a DebtCase-hez lesz kötve
						2022-11-19: invoiceTotal
						2022-11-22: "Begin TRANSACTION" ki-kommentelése
						2022-11-22: "DEALLOCATE db_cursor"
						2022-11-22: 'ACCOUNT_MAIN_CLASS_INTEREST' <-- 'ACCOUNT_MAIN_CLASS_NORMAL_INTEREST'
						2022-11-29: @l_AcountTypeID javítás
						2022-12-07: "Insert Into FIN.InvoiceArrears" Insert GEN.Object kivétele, mert sehová sem mutatott.
						2022-12-16: CreationUserName
						2023-01-10: InvoiceTypeCode, CurrencyCode
						2023-01-11: Vételár
						2023-01-17: Loaded-Related DebtCase is not found.
						2023-01-17: PRETENSE_CODE_INITIAL_BOOK_VALUE
						2023-01-18: Vételár, DebtCase.MainCalculationID
						2023-01-19: Új Debt struktúra + PurchaseDate
						2023-01-20: Diszkont számla
						2023-01-23: PRETENSE_CODE_INITIAL_DISCOUNT_VALUE elírás
						2023-01-23: @l_PurchasePrice negátlás
						2023-01-24: @TotalGrossAmount, @TotalNetAmount, @TotalVATAmount, @TotalCredit, @TotalInstalment is not NULL
						2023-01-25: @l_LocalCurrencyCode <> 'CURRENCY_HUF'
						2023-01-25: @InvoiceTypeCode
						2023.01.27, Set @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
						2023.01.30: If @l_LocalCurrencyCode <> @CurrencyCode
						2023.01.30: @l_own
						2023.01.31: @lArfolyam, IF Isnull(@ArrearsCostLocalCurrency,0) <> 0
						2023.02.09: Vételár-, Diszkont számla - @l_Own <> 'BOOLEAN_FALSE'   Nem Kezelt ügy 
						2023.02.14: @l_PurchasePriceCurrencyCode
						2023.02.20: @l_PortfolioID, @l_DataOriginCode = '';
						2023.02.22: Hibakezelés
						2023-02-27: Set @PaymentMethodCode = 'PAYMENT_METHOD_CASH', 
						2023-02-27: Set @InvoiceTypeCode = 'INVOICE_TYPE_CREDIT'
						2023.03.01: Errormessage vesszővel lettek elválasztva
						2023.03.16: ErrorCode-ok
						2023.03.27: ErrorCode-ok, ObjectType
						2023.08.31: FIN.Invoice.PaymentMethod helyett FIN.Invoice.PaymentMethodCode
            2023.11.03: Inkasso szinkron DV-1592
						2023.11.21: If not exists @..Code..
						2023.11.23: Ne jöjjön létre az "ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT" számla DV-1794
						2023.11.23: @TerminationDate insert a FIN.Invoice-ba DV-1792
            2023.11.27: Inkasso szinkron - GenerateSendInkassoSyncData rendesen hibát dob DV-1592
                                         - a szinkronhívást lejjebb kell tenni, hogy már az InvoiceArrearsból is meglegyen minden adat + AssetSync is fusson, ha már van Asset betöltve DV-1773
						2023.12.02: Kritikus és Blokkoló hibák kezelése DV-1736
						2023.12.04: "<>" javítva "="-re DV-1736
						2023.12.05: kamatráták kiértékelése DV-1736
						2023.12.06. PRETENSE_CODE_... --> PRETENSE_ átnevezés DV-1867
						2023.12.09: Kritikus és Blokkoló hibák kezelése DV-1956 - Betöltő eljárás módosítása a IFC.InterfaceError.Errormessage mező töltésére
						2023.12.10: "InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'",  DV-1956
						2023.12.10: exec FIN.RefreshFee DV-1830
						2023.12.11: @l_LocalCurrencyCode,  DV-1956
            2023.12.12: FIN.RefreshFee hívás javítás DV-1830
            2023.12.12: Inkasso szinkron ellenőrzés módosítás DV-1775
            2023.12.18: a konstrukciós kódhoz kapcsolódó event kiírása az ügyszinkront követően, hogy jó legyen a sorrend DV-1920
            2023.12.19: a feeListet mindenképp hozzuk létre a mainCalculationhöz DV-1830
            2023.12.19: a konstrukciós kódhoz kapcsolódó event kiírása - jav. DV-2022
						2023.12.22: 'SETTING_FEE_SUM_ENTRY_CRITERIA', 'SETTING_FEE_INTEREST_ENTRY_CRITERIA', DV-1736
            2023.12.22: a FeeRate-ek százalékos formában érkeznek, eltárolni a 100-zal osztott értéket kell DV-1830 UPDATE2
==========================================================================================
*/

AS

Begin
	Set NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(MAX);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	DECLARE @l_BlockerError nvarchar(1);  
	-- ha van blokkoló hiba, akkor @l_BlockerError = 'T', 
	-- InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_BLOCKING', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	-- ha csak kritikus hiba van, akkor @l_BlockerError = 'T', 
	-- InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	--DECLARE @l_Prev_ModuleInstanceID Numeric(16);
	DECLARE @l_ErrorMessage nvarchar(MAX);

	SET @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
	--SET @l_Prev_ModuleInstanceID = (Select Top 1 ModuleInstanceID from IFC.InterfaceError where TableName = 'IFC.Company' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' order by id desc);

	Insert Into LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	Select 
		Cast( GetDate() AS Date ),	-- LogDate,	
		Cast( GetDate() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.InvoiceLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	Set @CRLF = CHAR(10)+CHAR(13);


    Begin TRY
        Set @LogMessage = 'InvoiceLoader Started at ' + Cast(Cast( GetDate() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
		
		Declare @l_DebtCase nvarchar(1); -- DebtCase = 'T'
-----------------------------------------------
		Declare @ID NUMERIC(16);
		Declare @ObjectID NUMERIC(16);
		Declare @InvoiceTypeText NVARCHAR(200);
		Declare @InvoiceTypeCode NVARCHAR(200);
		Declare @SellerPartyID NUMERIC(16);
		Declare @BuyerPartyID NUMERIC(16);
		Declare @InvoiceNr NVARCHAR(200);
		Declare @RegistrationNr NVARCHAR(200);
		--Declare @CreditTypeCode NVARCHAR(200); /* Nem itt lesz */
		--Declare @CreditTypeText NVARCHAR(200);
		Declare @ProductCode NVARCHAR(200);
		Declare @ProductText NVARCHAR(200);
		Declare @ContractDate DATE;
		Declare @FulfillmentDate DATE;
		Declare @IssueDate DATE;
		Declare @DueDate DATE;
		Declare @TerminationDate DATE;
		Declare @PaymentMethodCode NVARCHAR(200);
		Declare @PaymentMethodText NVARCHAR(200);
		Declare @CurrencyCode NVARCHAR(200);
		Declare @CurrencyText NVARCHAR(200);
		Declare @TotalNetAmount MONEY;
		Declare @TotalVATAmount MONEY;
		Declare @TotalGrossAmount MONEY;
		Declare @TotalCredit MONEY;
		Declare @TotalInstalment MONEY;
		Declare @ArrearsCapital MONEY;
		Declare @ArrearsInterest MONEY;
		Declare @ArrearsPenaltyInterest MONEY;
		Declare @ArrearsCost MONEY;
		Declare @ArrearsCostLocalCurrency MONEY;
		Declare @InterestRate NUMERIC(10,5);
		Declare @PenaltyInterestRate NUMERIC(10,5);
		Declare @InvoiceID NUMERIC(16);
		Declare @SourceID NVARCHAR(200);
		Declare @SourceDebtCaseID NVARCHAR(200);
		Declare @SourceContractID NVARCHAR(200);
		Declare @SourceInterfaceType NVARCHAR(200);
		Declare @InterfaceStatusCode NVARCHAR(200);
		Declare @OperationCode NVARCHAR(200);
		Declare @ImportTableID NUMERIC(16);
		Declare @SellerPartyName NVARCHAR(200);
		Declare @BuyerPartyName NVARCHAR(200);
		Declare @CostRate NUMERIC(10,5);
		Declare @CostRatePeriodTypeCode NVarChar(200)

	
		Declare @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		Declare @l_EntityID numeric(18);
		Declare @l_ObjectID numeric(18);
		Declare @l_CalculationID numeric(18);

		Declare @l_FINInvoiceID numeric(18);
		Declare @l_ContractId numeric(18);
		Declare @l_FINInvoiceArrearsID numeric(18);
		Declare @l_InvoiceArrearsID numeric(18);
		Declare @l_FINAccountID numeric(18);
		Declare @l_InvoiceArrearsInterestID numeric(18);
		Declare @l_InvoiceType nvarchar(200);
		Declare @l_PaymentMethod nvarchar(200);
		Declare @l_AcountTypeID numeric(16);
		Declare @l_TransactionDate date;

		
		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ExisingRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);
		Declare @l_DebtCaseID numeric(18);
		Declare @l_PurchasePrice Money;
		Declare @l_PurchaseDate date;
		Declare @l_Discount Money;
		Declare @l_PurchasePriceCurrencyCode nvarchar(200);

		Declare @l_PortfolioID nvarchar(200);
		Declare @l_DataOriginCode nvarchar(200);


		Declare @l_LocalCurrencyCode nvarchar(50);
		Set @l_LocalCurrencyCode = Isnull((Select SettingValue from Gen.Setting where SettingCode = 'SETTING_LOCAL_CURRENCY'), 'CURRENCY_HUF');

		Declare @l_Own nvarchar(20);
		--Declare @l_PurchasePriceCurrency nvarchar(200);
		Declare @l_Arfolam Numeric(20,4);
		DECLARE @TAAllomany nvarchar(1); /* értéke 'F', ha nem TA-s a betöltendő állomány, 'T'-s ha TA-s állomány */

		DECLARE @FINAccount nVarchar(500);
		DECLARE @FINCalculation nVarchar(500);
		DECLARE @FINCalculationInvoice nVarchar(500);
		DECLARE @FINInvoice nVarchar(500);
		DECLARE @FINTransaction nVarchar(500);

		DECLARE @l_InkassoSyncOnDebtCase int = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'DebtCase', 'insert')
		DECLARE @l_InkassoSyncOnDebtor int = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'Debtor', 'insert')
		DECLARE @l_InkassoSyncOnAsset int = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'Asset', 'insert')
		DECLARE @l_inkassoSyncType NVarChar(200), @l_inkassoSyncID Numeric(16), @l_inkassoSyncDebtCaseID Numeric(16), @l_eventTypeForConstructionCode NVarChar(200), @now DateTime, @l_objectidDebtCase Numeric(16)

		DECLARE @ERR_SIFTYPE_CANNOT_BE_EMPTY nvarchar(200);
		SET @ERR_SIFTYPE_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_SID_CANNOT_BE_EMPTY nvarchar(200);
		SET @ERR_SID_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_SourceDebtCaseID_CANNOT_BE_EMPTY nvarchar(200);
		SET @ERR_SourceDebtCaseID_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_Related_DebtCase_is_not_found nvarchar(200);
		SET @ERR_Related_DebtCase_is_not_found = 'ERR_GENERAL';
		DECLARE @ERR_ACCOUNTNUMBER_CANNOT_BE_EMPTY nvarchar(200);
		SET @ERR_ACCOUNTNUMBER_CANNOT_BE_EMPTY = 'ERR_ACCOUNTNUMBER_CANNOT_BE_EMPTY';
		DECLARE @ERR_INVOICETYPE_CANNOT_BE_EMPTY nvarchar(200);
		SET @ERR_INVOICETYPE_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_INVOICETYPECODE_CANNOT_BE_EMPTY nvarchar(200);
		SET @ERR_INVOICETYPECODE_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_INVOICETYPETEXT_IS_NOT_VALID nvarchar(200);
		SET @ERR_INVOICETYPETEXT_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_INVOICETYPECODE_IS_NOT_VALID nvarchar(200);
		SET @ERR_INVOICETYPECODE_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_PAYMENTMETHODTEXT_IS_NOT_VALID nvarchar(200);
		SET @ERR_PAYMENTMETHODTEXT_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_PAYMENTMETHODCODE_IS_NOT_VALID nvarchar(200);
		SET @ERR_PAYMENTMETHODCODE_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_CURRENCYTEXT_IS_EMPTY nvarchar(200);
		SET @ERR_CURRENCYTEXT_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_CURRENCYCODE_IS_EMPTY nvarchar(200);
		SET @ERR_CURRENCYCODE_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_CURRENCYTEXT_IS_NOT_VALID nvarchar(200);
		SET @ERR_CURRENCYTEXT_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_CURRENCYCODE_IS_NOT_VALID nvarchar(200);
		SET @ERR_CURRENCYCODE_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_INTERFACE_NO_AMOUNT_CLAIMED nvarchar(200);
		SET @ERR_INTERFACE_NO_AMOUNT_CLAIMED = 'ERR_INTERFACE_NO_AMOUNT_CLAIMED';
		DECLARE @ERR_SELLERPARTYNAME_IS_NOT_VALID nvarchar(200);
		SET @ERR_SELLERPARTYNAME_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_SELLERPARTYID_IS_NOT_VALID nvarchar(200);
		SET @ERR_SELLERPARTYID_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_BUYERPARTYNAME_IS_NOT_VALID nvarchar(200);
		SET @ERR_BUYERPARTYNAME_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_BUYERPARTYID_IS_NOT_VALID nvarchar(200);
		SET @ERR_BUYERPARTYID_IS_NOT_VALID = 'ERR_GENERAL';
		DECLARE @ERR_INTERESTRATE_IS_TOO_HIGH nvarchar(200);
		SET @ERR_INTERESTRATE_IS_TOO_HIGH = 'ERR_GENERAL';
		DECLARE @ERR_MERGEDRATE_IS_TOO_HIGH nvarchar(200);
		SET @ERR_MERGEDRATE_IS_TOO_HIGH = 'ERR_GENERAL';

		DECLARE @ERR_INTERESTRATE_IS_EMPTY nvarchar(200);
		SET @ERR_INTERESTRATE_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_INTERESTRATE_IS_OUT_OF_RANGE nvarchar(200);
		SET @ERR_INTERESTRATE_IS_OUT_OF_RANGE = 'ERR_GENERAL';
		DECLARE @ERR_PENALTYINTERESTRATE_IS_EMPTY nvarchar(200);
		SET @ERR_PENALTYINTERESTRATE_IS_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_PENALTYINTERESTRATE_IS_LESS_THAN_ZERO nvarchar(200);
		SET @ERR_PENALTYINTERESTRATE_IS_LESS_THAN_ZERO = 'ERR_GENERAL';
		DECLARE @ERR_COSTRATE_IS_LESS_THAN_ZERO nvarchar(200);
		SET @ERR_COSTRATE_IS_LESS_THAN_ZERO = 'ERR_GENERAL';


		SET @FINAccount = (Select Top 1 Code from GEN.ObjectType where TableName = 'FIN.ACCOUNT' order by TableName desc);
		SET @FINCalculation = (Select Top 1 Code from GEN.ObjectType where TableName = 'FIN.CALCULATION' order by TableName desc);
		SET @FINCalculationInvoice = (Select Top 1 Code from GEN.ObjectType where TableName = 'FIN.CALCULATIONINVOICE' order by TableName desc);
		SET @FINInvoice = (Select Top 1 Code from GEN.ObjectType where TableName = 'FIN.INVOICE' order by TableName desc);
		SET @FINTransaction = (Select Top 1 Code from GEN.ObjectType where TableName = 'FIN.TRANSACTION' order by TableName desc);

		Declare @dailyCostMin money;
		Declare @dailyCostMax money;
		Declare @feeListID Numeric(16);
		Declare @feeValidDate Date

		Declare @SETTING_FEE_SUM_ENTRY_CRITERIA numeric(10,5);
		Set @SETTING_FEE_SUM_ENTRY_CRITERIA = (Select SettingValue from GEN.Setting where [Schema] = 'GEN' and SettingCode = 'SETTING_FEE_SUM_ENTRY_CRITERIA'); --> 60

		Declare @SETTING_FEE_INTEREST_ENTRY_CRITERIA numeric(10,5);	
		Set @SETTING_FEE_INTEREST_ENTRY_CRITERIA = (Select SettingValue from GEN.Setting where [Schema] = 'GEN' and SettingCode = 'SETTING_FEE_INTEREST_ENTRY_CRITERIA'); --> 55


		Set @l_AllRowCounts = 0;
		Set @l_ImportedRowCounts = 0;
		Set @l_ExisingRowCounts = 0;
		Set @l_ErrorRowCounts = 0;

		IF @SourceInterfaceType like 'OTPTA_%'
			SET @TAAllomany = 'T';
		ELSE
			SET @TAAllomany = 'F';

		IF COALESCE(@p_moduleInstanceID, 0) > 0
		Begin
			Select 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END

		IF COALESCE(@l_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field in ParameterValue is not defined!', 16, 1);

		SET @l_AllRowCounts = (Select Count(*) FROM IFC.Invoice where SourceInterfaceType = @l_sourceInterfaceType 
					and
					(
					(Invoice.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or 
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Invoice.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Invoice' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));

		DECLARE db_cursor CURSOR FOR 
		Select ID, 
			ObjectID, InvoiceTypeText, InvoiceTypeCode, SellerPartyID, BuyerPartyID, InvoiceNr, RegistrationNr, /*CreditTypeCode, CreditTypeText,*/ ProductCode, ProductText, 
			ContractDate, FulfillmentDate, IssueDate, DueDate, TerminationDate, PaymentMethodCode, PaymentMethodText, CurrencyCode, CurrencyText, TotalNetAmount, TotalVATAmount, 
			TotalGrossAmount, TotalCredit, TotalInstalment, ArrearsCapital, ArrearsInterest, ArrearsPenaltyInterest, ArrearsCost, ArrearsCostLocalCurrency, InterestRate, PenaltyInterestRate, 
			InvoiceID, SourceID, SourceDebtCaseID, SourceContractID, SourceInterfaceType, InterfaceStatusCode, ErrorMessage, OperationCode, ImportTableID, PaymentMethodText, PaymentMethodCode,
			SellerPartyName, BuyerPartyName, CostRate
		FROM IFC.Invoice
		where SourceInterfaceType = @l_sourceInterfaceType 
					and
					(
					(Invoice.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or 
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Invoice.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Invoice' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
		order by id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID, 
			@ObjectID, @InvoiceTypeText, @InvoiceTypeCode, @SellerPartyID, @BuyerPartyID, @InvoiceNr, @RegistrationNr, /*@CreditTypeCode, @CreditTypeText,*/ @ProductCode, @ProductText, 
			@ContractDate, @FulfillmentDate, @IssueDate, @DueDate, @TerminationDate, @PaymentMethodCode, @PaymentMethodText, @CurrencyCode, @CurrencyText, @TotalNetAmount, @TotalVATAmount, 
			@TotalGrossAmount, @TotalCredit, @TotalInstalment, @ArrearsCapital, @ArrearsInterest, @ArrearsPenaltyInterest, @ArrearsCost, @ArrearsCostLocalCurrency, @InterestRate, @PenaltyInterestRate, 
			@InvoiceID, @SourceID, @SourceDebtCaseID, @SourceContractID, @SourceInterfaceType, @InterfaceStatusCode, @ErrorMessage, @OperationCode, @ImportTableID, @PaymentMethodText, @PaymentMethodCode,
			@SellerPartyName, @BuyerPartyName, @CostRate

		WHILE @@FETCH_STATUS = 0  
		Begin  
    
		Set @SourceID = Trim(@SourceID);
		Set @l_TransactionDate = NULL;
		Set @l_TransactionDate = Coalesce(@ContractDate, @TerminationDate, @IssueDate);

---------------------------------------------------------------------------------------------------------------------------------------------
	BEGIN TRY /* Belső-1 */
-- Error Section:
			SET @ErrorMessage = NULL;
			SET @l_BlockerError = '';
---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceInterfaceType:
			IF Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceInterfaceType is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'sourceInterfaceType', @ERR_SIFTYPE_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceID:
			IF Trim(Isnull(@SourceID,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'sourceID', @ERR_SID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
---------------------------------------------------------------------------------------------------------------------------------------------
-- @SourceDebtCaseID:
		If Trim(Isnull(@SourceDebtCaseID,'')) = ''
		Begin
						Set @l_ErrorMessage = 'SourceDebtCaseID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'sourceDebtCaseID', @ERR_SourceDebtCaseID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;
-- Loaded Related DebtCase:
		IF not exists (Select 1 From DCS.DebtCase where SourceInterfaceType = @SourceInterfaceType and SourceID = @SourceDebtCaseID)
		Begin /* ERR_RELATED_DEBTCASE_NOT_FOUND*/
						Set @l_ErrorMessage = 'Related DebtCase is not found';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'sourceDebtCaseID', @ERR_Related_DebtCase_is_not_found, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;
-- @InvoiceNr:
		If Trim(Isnull(@InvoiceNr,'')) = ''
		Begin
						Set @l_ErrorMessage = 'InvoiceNr is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'invoiceNr', @ERR_ACCOUNTNUMBER_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;
-- @InvoiceTypeText,@InvoiceTypeCode:
			-- 0 - NULL:
			If Trim(Isnull(@InvoiceTypeText,'')) = ''
				Set @InvoiceTypeText = NULL;
			If Trim(Isnull(@InvoiceTypeCode,'')) = ''
				Set @InvoiceTypeCode = NULL;
			Set @InvoiceTypeText = Trim(@InvoiceTypeText);
			Set @InvoiceTypeCode = Trim(@InvoiceTypeCode);
			
			-- 1 - Üres:
			If @InvoiceTypeText is NULL and @InvoiceTypeCode is NULL
			BEGIN
						Set @l_ErrorMessage = 'InvoiceTypeText/Code is Empty (Default:Credit)';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'invoiceTypeText', @ERR_INVOICETYPE_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'invoiceTypeCode', @ERR_INVOICETYPECODE_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;

						Set @InvoiceTypeCode = 'INVOICE_TYPE_CREDIT';
			END;
			-- 2 - Text-NotValid:
			If @InvoiceTypeText is NOT NULL and @InvoiceTypeCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'INVOICE_TYPE_%' and Text = @InvoiceTypeText)
				Begin
						Set @l_ErrorMessage = 'InvoiceTypeText is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'invoiceTypeText', @ERR_INVOICETYPETEXT_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @InvoiceTypeText =  NULL;
				End;
				Else
					Set @InvoiceTypeCode = (select Top 1 CodeId from Gen.Translation where codeid like 'INVOICE_TYPE_%' and Text = @InvoiceTypeText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @InvoiceTypeText is NULL and @InvoiceTypeCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'INVOICE_TYPE_%' and Id = @InvoiceTypeCode)
			BEGIN
						Set @l_ErrorMessage = 'InvoiceTypeCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'invoiceTypeCode', @ERR_INVOICETYPECODE_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @InvoiceTypeCode = NULL;
			END;
-- @PaymentMethodText,@PaymentMethodCode:
		IF @TAAllomany = 'T'
		BEGIN
			-- 0 - NULL:
			If Trim(Isnull(@PaymentMethodText,'')) = ''
				Set @PaymentMethodText = NULL;
			If Trim(Isnull(@PaymentMethodCode,'')) = ''
				Set @PaymentMethodCode = NULL;
			Set @PaymentMethodText = Trim(@PaymentMethodText);
			Set @PaymentMethodCode = Trim(@PaymentMethodCode);

			-- 1 - Üres:
			If @PaymentMethodText is NULL and @PaymentMethodCode is NULL
			BEGIN
				--Set @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' PaymentMethodText/Code is Empty,');
				Set @PaymentMethodCode = 'PAYMENT_METHOD_CASH';
			END;
			-- 2 - Text-NotValid:
			If @PaymentMethodText is NOT NULL and @PaymentMethodCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'PAYMENT_METHOD_%' and Text = @PaymentMethodText)
				Begin
						Set @l_ErrorMessage = 'PaymentMethodText is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'paymentMethodText', @ERR_PAYMENTMETHODTEXT_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @PaymentMethodText = NULL;
				End;
				Else
					Set @PaymentMethodCode = (select Top 1 CodeId from Gen.Translation where codeid like 'PAYMENT_METHOD_%' and Text = @PaymentMethodText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @PaymentMethodText is NULL and @PaymentMethodCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'PAYMENT_METHOD_%' and Id = @PaymentMethodCode)
			BEGIN
						Set @l_ErrorMessage = 'PaymentMethodCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'paymentMethodCode', @ERR_PAYMENTMETHODCODE_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @PaymentMethodCode = NULL;
			END;
		END; -- IF @TAAllomany = 'T'
			
-- @CurrencyText,@CurrencyCode:
			-- 0 - NULL:
			If Trim(Isnull(@CurrencyText,'')) = ''
				Set @CurrencyText = NULL;
			If Trim(Isnull(@CurrencyCode,'')) = ''
				Set @CurrencyCode = NULL;
			Set @CurrencyText = Trim(@CurrencyText);
			Set @CurrencyCode = Trim(@CurrencyCode);
			
			-- 1 - Üres:
			If @CurrencyText is NULL and @CurrencyCode is NULL
			BEGIN
						Set @l_ErrorMessage = 'Currency/Code is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'currencyText', @ERR_CURRENCYTEXT_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'currencyCode', @ERR_CURRENCYCODE_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
			-- 2 - Text-NotValid:
			If @CurrencyText is NOT NULL and @CurrencyCode is NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'CURRENCY_%' and Text = @CurrencyText)
				Begin
						Set @l_ErrorMessage = 'Currency is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'currencyText', @ERR_CURRENCYTEXT_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @CurrencyText = NULL;
				End;
				Else
					Set @CurrencyCode = (select Top 1 CodeId from Gen.Translation where codeid like 'CURRENCY_%' and Text = @CurrencyText order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @CurrencyText is NULL and @CurrencyCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'CURRENCY_%' and Id = @CurrencyCode)
			BEGIN
						Set @l_ErrorMessage = 'CurrencyCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'currencyCode', @ERR_CURRENCYCODE_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
						Set @CurrencyCode = NULL;
			END;

-- Legyen legalább 1 követelése:
			If Isnull(@ArrearsCapital, 0) = 0 
				and Isnull(@ArrearsInterest, 0) = 0
				and Isnull(@ArrearsPenaltyInterest, 0) = 0
				and Isnull(@ArrearsCost, 0) = 0
			BEGIN
						Set @l_ErrorMessage = 'There are no debt amount';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'arrearsCapital', @ERR_INTERFACE_NO_AMOUNT_CLAIMED, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'arrearsInterest', @ERR_INTERFACE_NO_AMOUNT_CLAIMED, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'arrearsPenaltyInterest', @ERR_INTERFACE_NO_AMOUNT_CLAIMED, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'arrearsCost', @ERR_INTERFACE_NO_AMOUNT_CLAIMED, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;

/* még nincs kész, 2023-02-22
	[ProductCode] [nvarchar](200) NULL,
	[ProductText] [nvarchar](200) NULL,
*/ 

---------------------------------------------------------------------------------------------------------------------------------------------
-- Hibakiírás:
		IF @l_BlockerError = 'T'
		BEGIN
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			UPDATE IFC.Invoice SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = Trim(Isnull(@ErrorMessage,'')), LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName  WHERE ID = @ID;
		END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Betöltés:
		IF @l_BlockerError = ''
		BEGIN

-- @SellerPartyName,@SellerPartyID:
			-- 0 - NULL:
			If Trim(Isnull(@SellerPartyName,'')) = ''
				Set @SellerPartyName = NULL;
			If Isnull(@SellerPartyID,0) = 0
				Set @SellerPartyID = NULL;
			Set @SellerPartyName = Trim(@SellerPartyName);
			
			-- 1 - Üres:
			If @SellerPartyName is NULL and @SellerPartyID is NULL
			BEGIN
				--Set @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' SellerPartyName/ID is Empty,');
				Set @ErrorMessage = @ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			If @SellerPartyName is NOT NULL and @SellerPartyID is NULL
			BEGIN
				If Not exists (Select 1 from Prt.Party join Prt.Company on Company.EntityID = Party.EntityID where Company.Name = @SellerPartyName)
				Begin
						Set @l_ErrorMessage = 'SellerPartyName is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'sellerPartyName', @ERR_SELLERPARTYNAME_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @SellerPartyName = NULL;
				End;
				Else
					Set @SellerPartyID = (select Top 1 Party.Id from Prt.Party join Prt.Company on Company.EntityID = Party.EntityID where Company.Name = @SellerPartyName order by Party.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @SellerPartyName is NULL and @SellerPartyID is not NULL
			and Not exists (Select 1 from Prt.Party join Prt.Company on Company.EntityID = Party.EntityID where Party.Id = @SellerPartyID)
			BEGIN
						Set @l_ErrorMessage = 'SellerPartyID is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'sellerPartyID', @ERR_SELLERPARTYID_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @SellerPartyName = NULL;
						Set @SellerPartyID = NULL;
			END;
-- @BuyerPartyName,@BuyerPartyID:
			-- 0 - NULL:
			If Trim(Isnull(@BuyerPartyName,'')) = ''
				Set @BuyerPartyName = NULL;
			If Isnull(@BuyerPartyID,0) = 0
				Set @BuyerPartyID = NULL;
			Set @BuyerPartyName = Trim(@BuyerPartyName);
			
			-- 1 - Üres:
			If @BuyerPartyName is NULL and @BuyerPartyID is NULL
			BEGIN
				--Set @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' BuyerPartyName/ID is Empty,');
				Set @ErrorMessage = @ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			If @BuyerPartyName is NOT NULL and @BuyerPartyID is NULL
			BEGIN
				If Not exists (Select 1 from Prt.Party join Prt.Company on Company.EntityID = Party.EntityID where Company.Name = @BuyerPartyName)
				Begin
						Set @l_ErrorMessage = 'BuyerPartyName is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'buyerPartyName', @ERR_BUYERPARTYNAME_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @BuyerPartyName = NULL;
				End;
				Else
					Set @BuyerPartyID = (select Top 1 Party.Id from Prt.Party join Prt.Company on Company.EntityID = Party.EntityID where Company.Name = @BuyerPartyName order by Party.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @BuyerPartyName is NULL and @BuyerPartyID is not NULL
			and Not exists (Select 1 from Prt.Party join Prt.Company on Company.EntityID = Party.EntityID where Party.Id = @BuyerPartyID)
			BEGIN
						Set @l_ErrorMessage = 'BuyerPartyID is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'buyerPartyID', @ERR_BUYERPARTYID_IS_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @BuyerPartyID = NULL;
			END;

-- InterestRate üres:
			If @InterestRate is NULL
			Begin
						Set @l_ErrorMessage = 'InterestRate is empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'interestRate', @ERR_INTERESTRATE_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			End;
--  > 55 % InterestRate < 0 %:
			If @InterestRate < 0 or @InterestRate > @SETTING_FEE_INTEREST_ENTRY_CRITERIA /* 55 */
			Begin
						Set @l_ErrorMessage = Concat('InterestRate out of range (x<0 or x>', @SETTING_FEE_INTEREST_ENTRY_CRITERIA, ')');
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'interestRate', @ERR_INTERESTRATE_IS_OUT_OF_RANGE, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			End;

-- PenaltyInterestRate üres:
			If @PenaltyInterestRate is NULL
			Begin
						Set @l_ErrorMessage = 'PenaltyInterestRate is empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'penaltyInterestRate', @ERR_PENALTYINTERESTRATE_IS_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			End;

-- PenaltyInterestRate < 0:
			If @PenaltyInterestRate < 0
			Begin
						Set @l_ErrorMessage = 'PenaltyInterestRate is less then Zero';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'penaltyInterestRate', @ERR_PENALTYINTERESTRATE_IS_LESS_THAN_ZERO, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			End;

-- CostRate < 0:
			If @CostRate < 0
			Begin
						Set @l_ErrorMessage = 'CostRate is less then Zero';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'costRate', @ERR_COSTRATE_IS_LESS_THAN_ZERO, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			End;

-- (InterestRate + PenaltyInterestRate) > 60 %:
			If @InterestRate + @PenaltyInterestRate > @SETTING_FEE_SUM_ENTRY_CRITERIA
			Begin
						Set @l_ErrorMessage = Concat('(InterestRate + PenaltyInterestRate) > ', @SETTING_FEE_SUM_ENTRY_CRITERIA, '%');
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'interestRate', @ERR_MERGEDRATE_IS_TOO_HIGH, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.INVOICE', @ID, 'penaltyInterestRate', @ERR_MERGEDRATE_IS_TOO_HIGH, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			End;

---------------------------------------------------------------------------------------------------------------------------------------------
			Set @l_ContractId = 0;
			--------------------------------------------------------
			Set @l_DebtCaseID = 0;
			--------------------------------------------------------
			Set @l_own = '';
			/*Set @l_DebtCaseID = (Select top 1 Id From DCS.DebtCase where SourceInterfaceType = @SourceInterfaceType and SourceID = @SourceDebtCaseID order by id desc);*/
			Select top 1 @l_DebtCaseID = Id, @l_own = OwnProperty From DCS.DebtCase where SourceInterfaceType = @SourceInterfaceType and SourceID = @SourceDebtCaseID order by id desc;

			Set @l_PortfolioID = '';
			Set @l_DataOriginCode = '';
--
			Set @l_PortfolioID = (Select Top 1 Object.PortfolioID from Dcs.DebtCase
							Join Gen.Object on Object.ID = DebtCase.ObjectID
							where DebtCase.Id = @l_DebtCaseID order by Object.ID desc);
			SELECT @l_DataOriginCode = 
				CASE (Select TreatmentTypeCode from Gen.Portfolio where Id = @l_PortfolioID)
					WHEN 'TREATMENT_TYPE_MANDATE' THEN 'DATA_ORIGIN_PRINCIPAL' /* Megbízásos */
					WHEN 'TREATMENT_TYPE_ASSIGNMENT' THEN 'DATA_ORIGIN_LEGAL_PREDECESSOR'  /* Engedményzett */
					ELSE 'DATA_ORIGIN_LEGAL_PREDECESSOR' /* Engedményzett */
				END;

			If @l_DataOriginCode = 'DATA_ORIGIN_PRINCIPAL'
				Set @l_own = 'BOOLEAN_FALSE'
			Else
				Set @l_own = 'BOOLEAN_TRUE';

			--Set @l_PurchasePriceCurrency = NULL;

			/*
			Set @l_PurchasePriceCurrency = (Select Top 1 CollectionContractSummary.PurchasePriceCurrencyCode from CRM.CollectionContractItem 
			join CRM.ContractItem on ContractItem.Id = CollectionContractItem.ContractItemID
			join CRM.CollectionContractSummary on CollectionContractSummary.ContractID = ContractItem.ContractID
			where CollectionContractItem.DebtCaseID = @l_DebtCaseID order by CollectionContractSummary.Id desc);
			*/

			--------------------------------------------------------
			Set @l_ContractId = (Select top 1 Contract.ID from CRM.Contract 
								join CRM.ContractItem on ContractItem.ContractID = Contract.ID
								join CRM.CollectionContractItem on CollectionContractItem.ContractItemID = ContractItem.ID
								where CollectionContractItem.DebtCaseId = @l_DebtCaseId order by Contract.ID);
			--------------------------------------------------------
			/*
			Set @l_PaymentMethod = 
			@PaymentMethodCode, @PaymentMethodText
			*/
			Set @l_PaymentMethod = NULL;
			--------------------------------------------------------
			/* ? VALUESET_PRODUCT
			@l_InvoiceType = 
			@InvoiceTypeText, @InvoiceTypeCode as 
			*/
			--Set @l_InvoiceType = NULL; /* 2023-01-25 */
			Set @l_InvoiceType = @InvoiceTypeCode;
			--------------------------------------------------------
			IF Isnull(@CurrencyCode,'') = '' and Isnull(Trim(@CurrencyText),'') <> ''
			Begin 
				Set @CurrencyCode = (Select Top 1 CodeID from Gen.Translation where CodeID like 'CURRENCY_%' AND Text = Trim(@CurrencyText) order by id);
			END;

-- @PaymentMethodCode + @PaymentMethodText:
			IF Isnull(@PaymentMethodCode,'') = '' and Isnull(Trim(@PaymentMethodText),'') <> ''
			Begin
				Set @PaymentMethodCode = (Select Top 1 CodeID from Gen.Translation where CodeID like 'PAYMENT_METHOD_CASH_%' AND Text = Trim(@PaymentMethodText) order by ID desc);
			END;


			Set @ArrearsCapital = Isnull(@ArrearsCapital, 0);
			Set @ArrearsInterest = Isnull(@ArrearsInterest, 0);
			Set @ArrearsPenaltyInterest = Isnull(@ArrearsPenaltyInterest, 0);
			Set @ArrearsCost = Isnull(@ArrearsCost, 0);
			Set @ArrearsCostLocalCurrency = Isnull(@ArrearsCostLocalCurrency, 0);

---------------------------------------------------------------------------------------------------------------------------------------------
-- FIN INVOICE:

-- Új FIN.Invoice ha szükséges:
			Set @l_FINInvoiceID = 0;

			If Exists (Select 1 FROM FIN.Invoice WHERE Isnull(ContractId,0) = Isnull(@l_ContractId,0) and InvoiceNr = @InvoiceNr and DebtCaseID = @l_DebtCaseID)
				--or 
				--Isnull(@OperationCode,'') = 'U'
			Begin
			-- Létezik:
				Set @l_FINInvoiceID = (Select Top 1 ID FROM FIN.Invoice WHERE ContractId = @l_ContractId and InvoiceNr = @InvoiceNr and DebtCaseID = @l_DebtCaseID order by Invoice.ID);
				Set @ErrorMessage = ISNULL(@ErrorMessage,'') + 'Invoice is exists,';
				Set @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
			End;

			Else
			-- Nem létezik FIN.Invoice:
			Begin
        BEGIN TRAN  /*Nem létező FIN.Invoice*/
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
				  -- New ObjectID:
				  Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
					  Select @FINInvoice as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
				  Set @l_ObjectID = SCOPE_IDENTITY();
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 

				  -- New FIN.Invoice:
				  Insert Into FIN.Invoice(
					  ObjectID,											InvoiceTypeCode, 
					  SellerPartyID,									BuyerPartyID, 
					  ContractID,										ReferencedInvoiceID, 
					  InvoiceNr,										RegistrationNr, 
					  FulfillmentDate,									IssueDate, 
					  DueDate,											PaymentMethodCode, 
					  CurrencyCode,										DebtCaseID, 
					  CreationDate,										CreationTime, 
					  CreationUserName,									TerminationDate) 
				  Select
					  @l_ObjectID as ObjectID,							@l_InvoiceType as InvoiceType, 
					  @SellerPartyID as SellerPartyID,					@BuyerPartyID as BuyerPartyID, 
					  @l_ContractID as ContractID,						NULL as ReferencedInvoiceID, 
					  @InvoiceNr as InvoiceNr,							@RegistrationNr as RegistrationNr, 
					  @FulfillmentDate as FulfillmentDate,				@IssueDate as IssueDate, 
					  @DueDate as DueDate,								@PaymentMethodCode as PaymentMethod, 
					  @CurrencyCode as CurrencyID,						@l_DebtCaseID, 
					  Cast( GetDate() AS Date ),						Cast( GetDate() AS Time) ,
					  @CurrentUserName,									@TerminationDate;
					
				  Set @l_FINInvoiceID = SCOPE_IDENTITY()

				  Set @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
				  Update IFC.Invoice Set InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', Errormessage = NULL, InvoiceID = @l_FINInvoiceID,
					LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;

  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
  -- Calculation (MAIN):
			  -- Létre kell hozni a FIN.Calculation-t:
				  Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				  Select @FINCalculation as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
				  Set @l_ObjectID = SCOPE_IDENTITY();

				  Insert Into FIN.Calculation(
					  ObjectID,
					  RelationObjectID,
					  CreationDate,
					  CreationTime,
					  CreationUserName) 
				  Select
					  @l_ObjectID as ObjectID,
					  NULL as RelationObjectID, 
					  Cast( GetDate() AS Date ),
					  Cast( GetDate() AS Time ),
					  @CurrentUserName;
				  Set @l_CalculationID = SCOPE_IDENTITY();

				  Update DCS.DebtCase Set MainCalculationID = @l_CalculationID where DebtCase.ID = @l_DebtCaseID;

  -- CalculationInvoice:
				  Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				  Select @FINCalculationInvoice as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
				  Set @l_ObjectID = SCOPE_IDENTITY();

				  Insert Into FIN.CalculationInvoice(
					  ObjectID,
					  CalculationID,
					  InvoiceID,
					  InterestBeginDate,
					  InterestEndDate,
					  CreationDate,
					  CreationTime,
					  CreationUserName) 
				  Select
					  @l_ObjectID as ObjectID,
					  @l_CalculationID as CalculationID, 
					  @l_FINInvoiceID as FINInvoiceID,
					  @l_PurchaseDate as InterestBeginDate, 
					  NULL as InterestEndDate,
					  Cast( GetDate() AS Date ),
					  Cast( GetDate() AS Time ),
					  @CurrentUserName;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- VÉTELÁR:

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
If @l_Own <> 'BOOLEAN_FALSE'  /* Nem Kezelt ügy */
Begin

Set @l_AcountTypeID = (Select Top 1 AccountType.ID from fin.AccountType where MainClass = 'ACCOUNT_MAIN_CLASS_GENERAL' and Code = 'ACCOUNT_TYPE_BOOK_VALUE' and Pending = 'BOOLEAN_FALSE' order by AccountType.ID);

-- Vételár - FIN Account:
-- Új FIN.Account ha szükséges:
			Set @l_FINAccountID = 0;
				Begin
				-- Nem létezik FIN.Account, létre kell hozni:

				-- New ObjectID:
						Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
							Select @FINAccount as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
						Set @l_ObjectID = SCOPE_IDENTITY();

						Set @l_PurchasePrice = 0;
						--Set @l_PurchasePrice = (Select top 1 DebtCase.PurchasePrice from IFC.DebtCase where DebtCase.SourceInterfaceType = @SourceInterfaceType and DebtCase.SourceID = @SourceDebtCaseID and DebtCase.InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED' order by id desc);
						--Set @l_PurchaseDate = (Select top 1 DebtCase.PurchaseDate from IFC.DebtCase where DebtCase.SourceInterfaceType = @SourceInterfaceType and DebtCase.SourceID = @SourceDebtCaseID and DebtCase.InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED' order by id desc);

						Select top 1 @l_PurchasePrice = DebtCase.PurchasePrice, @l_PurchaseDate = DebtCase.PurchaseDate, @l_PurchasePriceCurrencyCode = DebtCase.PurchasePriceCurrencyCode from IFC.DebtCase where DebtCase.SourceInterfaceType = @SourceInterfaceType and DebtCase.SourceID = @SourceDebtCaseID and DebtCase.InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED' order by id desc;

						Insert Into FIN.Account(
							ObjectID,												
							CalculationID, 
							AccountTypeID, 											
							CurrencyCode, 
							Balance, 												
							InvoiceLineID, 
							InvoiceArrearsID, 										
							CreationDate, 
							CreationTime, 											
							CreationUserName) 
						Select
							@l_ObjectID as ObjectID,								
							@l_CalculationID as CalculationID, 
							@l_AcountTypeID as AccountTypeID, 						
							@l_PurchasePriceCurrencyCode /*@CurrencyCode*/ as CurrencyCode, 
							@l_PurchasePrice as Balance, 							
							NULL as InvoiceLineID, /* nem kell tölteni */
							NULL as InvoiceArrearsID,
							Cast( GetDate() AS Date ), 
							Cast( GetDate() AS Time ), 								
							@CurrentUserName;
						Set @l_FINAccountID	= SCOPE_IDENTITY();
				END;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Vételár - FIN Transaction:
-- Új FIN.Transaction ha szükséges:

				-- Nem létezik FIN.Transaction, létre kell hozni:
				-- New ObjectID:
						Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
							Select @FINTransaction as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
						Set @l_ObjectID = SCOPE_IDENTITY();

						Insert Into FIN.[Transaction](ObjectID, AccountID, PeriodID, PretenseCode, BankJournalDate, BankValueDate, ValueDate, AccountingDate, ExchangeDate, Amount, CreationDate, CreationTime, CreationUserName) 
						Select
							@l_ObjectID as ObjectID,								@l_FINAccountID as AccountID, 												
							NULL as PeriodID,  /*Üresen marad*/						'PRETENSE_INITIAL_BOOK_VALUE' as PretenseCode, 
							@l_TransactionDate as BankJournalDate, 					@l_TransactionDate as BankValueDate, 							
							@l_TransactionDate as ValueDate, 						@l_TransactionDate as AccountingDate, 
							@l_TransactionDate as ExchangeDate, 					@l_PurchasePrice as Amount, 											
							Cast( GetDate() AS Date ), 								Cast( GetDate() AS Time ), 								
							@CurrentUserName;
						
END; /* Nem Kezelt ügy */
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- FIN.InvoiceTotal:
				If @TotalGrossAmount is not NULL
					Insert Into FIN.InvoiceTotal(InvoiceID, AmountTypeCode, Amount, CurrencyCode, CreationDate, CreationTime, CreationUserName)
					Select @l_FINInvoiceID, 'INVOICE_AMOUNT_TYPE_GROSS', @TotalGrossAmount, @CurrencyCode, Cast( GetDate() AS Date ), Cast( GetDate() AS Time), @CurrentUserName;
				If @TotalNetAmount is not NULL
					Insert Into FIN.InvoiceTotal(InvoiceID, AmountTypeCode, Amount, CurrencyCode, CreationDate, CreationTime, CreationUserName)
					Select @l_FINInvoiceID, 'INVOICE_AMOUNT_TYPE_NET', @TotalNetAmount, @CurrencyCode, Cast( GetDate() AS Date ), Cast( GetDate() AS Time), @CurrentUserName;
				If @TotalVATAmount is not NULL
					Insert Into FIN.InvoiceTotal(InvoiceID, AmountTypeCode, Amount, CurrencyCode, CreationDate, CreationTime, CreationUserName)
					Select @l_FINInvoiceID, 'INVOICE_AMOUNT_TYPE_VAT', @TotalVATAmount, @CurrencyCode, Cast( GetDate() AS Date ), Cast( GetDate() AS Time), @CurrentUserName;
				if @TotalCredit is not NULL
					Insert Into FIN.InvoiceTotal(InvoiceID, AmountTypeCode, Amount, CurrencyCode, CreationDate, CreationTime, CreationUserName)
					Select @l_FINInvoiceID, 'INVOICE_AMOUNT_TYPE_CREDIT', @TotalCredit, @CurrencyCode, Cast( GetDate() AS Date ), Cast( GetDate() AS Time), @CurrentUserName;
				if @TotalInstalment is not NULL
					Insert Into FIN.InvoiceTotal(InvoiceID, AmountTypeCode, Amount, CurrencyCode, CreationDate, CreationTime, CreationUserName)
					Select @l_FINInvoiceID, 'INVOICE_AMOUNT_TYPE_INSTALMENT', @TotalInstalment, @CurrencyCode, Cast( GetDate() AS Date ), Cast( GetDate() AS Time), @CurrentUserName;


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- Tõke - FIN INVOICEARREARS:

			If @l_Own = 'BOOLEAN_FALSE' /* Kezelt ügy */
				Set @l_AcountTypeID = (Select Top 1 AccountType.ID from fin.AccountType where MainClass = 'ACCOUNT_MAIN_CLASS_CAPITAL' and Code = 'ACCOUNT_TYPE_DEBT_CAPITAL_MANAGED' and Pending = 'boolean_false' order by AccountType.ID);
			Else
				Set @l_AcountTypeID = (Select Top 1 AccountType.ID from fin.AccountType where MainClass = 'Account_main_class_capital' and Code = 'Account_Type_Debt_capital' and Pending = 'boolean_false' order by AccountType.ID);

			Set @l_FINInvoiceArrearsID = 0;

			Insert Into FIN.InvoiceArrears(
				InvoiceID,  AccountTypeID, Amount, CurrencyCode, CreationDate, CreationUserName, CreationTime) 
			Select
				@l_FINInvoiceID, @l_AcountTypeID, @ArrearsCapital, @CurrencyCode, Cast( GetDate() AS Date ), @CurrentUserName, Cast( GetDate() AS Time);
			Set @l_InvoiceArrearsID	= SCOPE_IDENTITY();

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Tõke - FIN Account:
			Set @l_FINAccountID = 0;

			-- New ObjectID:
			Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				Select @FINAccount as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
			Set @l_ObjectID = SCOPE_IDENTITY();
			
			Insert Into FIN.Account(
				ObjectID,												CalculationID, 
				AccountTypeID, 											CurrencyCode, 
				Balance, 												InvoiceLineID, 
				InvoiceArrearsID, 										CreationDate, 
				CreationTime, 											CreationUserName) 
			Select
				@l_ObjectID as ObjectID,								@l_CalculationID as CalculationID, 
				@l_AcountTypeID as AccountTypeID, 						@CurrencyCode as CurrencyCode, 
				@ArrearsCapital as Balance, 							NULL as InvoiceLineID, /* nem kell tölteni */
				@l_InvoiceArrearsID, 									Cast( GetDate() AS Date ), 
				Cast( GetDate() AS Time ), 								@CurrentUserName;
			Set @l_FINAccountID	= SCOPE_IDENTITY();

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Tõke - FIN Transaction:

			-- New ObjectID:
			Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				Select @FINTransaction as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
			Set @l_ObjectID = SCOPE_IDENTITY();

			Insert Into FIN.[Transaction](ObjectID, AccountID, PeriodID, PretenseCode, BankJournalDate, BankValueDate, ValueDate, AccountingDate, ExchangeDate, Amount, CreationDate, CreationTime, CreationUserName) 
			Select
				@l_ObjectID as ObjectID,								@l_FINAccountID as AccountID, 												
				NULL as PeriodID,  /*Üresen marad*/						'PRETENSE_INITIAL_ARREARS' as PretenseCode, 
				@l_TransactionDate as BankJournalDate, 					@l_TransactionDate as BankValueDate, 							
				@l_TransactionDate as ValueDate, 						@l_TransactionDate as AccountingDate, 
				@l_TransactionDate as ExchangeDate, 					@ArrearsCapital as Amount, 											
				Cast( GetDate() AS Date ), 								Cast( GetDate() AS Time ),
				@CurrentUserName;


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


-- Ügyleti kamat - FIN INVOICEARREARS:
			If @l_Own = 'BOOLEAN_FALSE'
				Set @l_AcountTypeID = (Select AccountType.ID from fin.AccountType where MainClass = 'ACCOUNT_MAIN_CLASS_INTEREST' and Code = 'ACCOUNT_TYPE_DEBT_INTEREST_MANAGED' and Pending = 'boolean_false');
			Else
				Set @l_AcountTypeID = (Select AccountType.ID from fin.AccountType where MainClass = 'ACCOUNT_MAIN_CLASS_INTEREST' and Code = 'ACCOUNT_TYPE_DEBT_INTEREST' and Pending = 'boolean_false');
			
			Set @l_FINInvoiceArrearsID = 0;

			Insert Into FIN.InvoiceArrears(
				InvoiceID,  AccountTypeID, Amount, CurrencyCode, CreationDate, CreationUserName, CreationTime) 
			Select 
				@l_FINInvoiceID, @l_AcountTypeID, @ArrearsInterest, @CurrencyCode, Cast( GetDate() AS Date ), @CurrentUserName, Cast( GetDate() AS Time );
			Set @l_InvoiceArrearsID	= SCOPE_IDENTITY();

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Ügyleti kamat - FIN Account:
			Set @l_FINAccountID = 0;

			-- New ObjectID:
			Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
					Select @FINAccount as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
			Set @l_ObjectID = SCOPE_IDENTITY();

			Insert Into FIN.Account(
				ObjectID,												CalculationID, 
				AccountTypeID, 											CurrencyCode, 
				Balance, 												InvoiceLineID, 
				InvoiceArrearsID, 										CreationDate, 
				CreationTime, 											CreationUserName) 
			Select
				@l_ObjectID as ObjectID,								@l_CalculationID as CalculationID, 
				@l_AcountTypeID as AccountTypeID, 						@CurrencyCode as CurrencyCode, 
				@ArrearsInterest as Balance, 							NULL as InvoiceLineID, 
				@l_InvoiceArrearsID, 									Cast( GetDate() AS Date ), 
				Cast( GetDate() AS Time ), 								@CurrentUserName;
			Set @l_FINAccountID	= SCOPE_IDENTITY();


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Ügyleti kamat - FIN Transaction:

			-- New ObjectID:
			Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				Select @FINTransaction as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
				Set @l_ObjectID = SCOPE_IDENTITY();

			Insert Into FIN.[Transaction](ObjectID, AccountID, PeriodID, PretenseCode, BankJournalDate, BankValueDate, ValueDate, AccountingDate, ExchangeDate, Amount, CreationDate, CreationTime, CreationUserName) 
			Select
				@l_ObjectID as ObjectID,								@l_FINAccountID as AccountID, 												
				NULL as PeriodID,  /*Üresen marad*/						'PRETENSE_INITIAL_ARREARS' as PretenseCode, 
				@l_TransactionDate as BankJournalDate, 					@l_TransactionDate as BankValueDate, 							
				@l_TransactionDate as ValueDate, 						@l_TransactionDate as AccountingDate, 
				@l_TransactionDate as ExchangeDate, 					@ArrearsInterest as Amount, 											
				Cast( GetDate() AS Date ), 								Cast( GetDate() AS Time ), 								
				@CurrentUserName;


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- Késedelmi kamat - FIN INVOICEARREARS:
			If @l_Own = 'BOOLEAN_FALSE'
				Set @l_AcountTypeID = (Select AccountType.ID from fin.AccountType where MainClass = 'ACCOUNT_MAIN_CLASS_PENALTY_INTEREST' and Code = 'ACCOUNT_TYPE_DEBT_PENALTY_INTEREST_MANAGED' and Pending = 'boolean_false');
			Else
				Set @l_AcountTypeID = (Select AccountType.ID from fin.AccountType where MainClass = 'ACCOUNT_MAIN_CLASS_PENALTY_INTEREST' and Code = 'ACCOUNT_TYPE_DEBT_PENALTY_INTEREST' and Pending = 'boolean_false');
			
			Set @l_FINInvoiceArrearsID = 0;

			Insert Into FIN.InvoiceArrears(
				InvoiceID,  AccountTypeID, Amount, CurrencyCode, CreationDate, CreationUserName, CreationTime) 
			Select 
				@l_FINInvoiceID, @l_AcountTypeID, @ArrearsPenaltyInterest, @CurrencyCode, Cast( GetDate() AS Date ), @CurrentUserName, Cast( GetDate() AS Time );
			Set @l_InvoiceArrearsID	= SCOPE_IDENTITY();

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Késedelmi kamat - FIN Account:
			Set @l_FINAccountID = 0;

			-- New ObjectID:
			Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				Select @FINAccount as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
			Set @l_ObjectID = SCOPE_IDENTITY();

			Insert Into FIN.Account(
				ObjectID,												CalculationID, 
				AccountTypeID, 											CurrencyCode, 
				Balance, 												InvoiceLineID, 
				InvoiceArrearsID, 										CreationDate, 
				CreationTime, 											CreationUserName) 
			Select
				@l_ObjectID as ObjectID,								@l_CalculationID as CalculationID, 
				@l_AcountTypeID as AccountTypeID, 						@CurrencyCode as CurrencyCode, 
				@ArrearsPenaltyInterest as Balance, 					NULL as InvoiceLineID, 
				@l_InvoiceArrearsID, 									Cast( GetDate() AS Date ), 
				Cast( GetDate() AS Time ), 								@CurrentUserName;
			Set @l_FINAccountID	= SCOPE_IDENTITY();

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Késedelmi kamat - FIN Transaction:


			-- New ObjectID:
			Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				Select @FINTransaction as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
			Set @l_ObjectID = SCOPE_IDENTITY();

			Insert Into FIN.[Transaction](ObjectID, AccountID, PeriodID, PretenseCode, BankJournalDate, BankValueDate, ValueDate, AccountingDate, ExchangeDate, Amount, CreationDate, CreationTime, CreationUserName) 
			Select
				@l_ObjectID as ObjectID,								@l_FINAccountID as AccountID, 												
				NULL as PeriodID,  /*Üresen marad*/						'PRETENSE_INITIAL_ARREARS' as PretenseCode, 
				@l_TransactionDate as BankJournalDate, 					@l_TransactionDate as BankValueDate, 							
				@l_TransactionDate as ValueDate, 						@l_TransactionDate as AccountingDate, 
				@l_TransactionDate as ExchangeDate, 					@ArrearsPenaltyInterest as Amount, 											
				Cast( GetDate() AS Date ), 								Cast( GetDate() AS Time ), 								
				@CurrentUserName;


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --


-- Költség - FIN INVOICEARREARS:
			If @l_Own = 'BOOLEAN_FALSE'
				Set @l_AcountTypeID = (Select AccountType.ID from fin.AccountType where MainClass = 'ACCOUNT_MAIN_CLASS_COST' and Code = 'ACCOUNT_TYPE_DEBT_COST_MANAGED' and Pending = 'boolean_false');
			Else
				Set @l_AcountTypeID = (Select AccountType.ID from fin.AccountType where MainClass = 'ACCOUNT_MAIN_CLASS_COST' and Code = 'ACCOUNT_TYPE_DEBT_COST' and Pending = 'boolean_false');

			Set @l_FINInvoiceArrearsID = 0;

			Insert Into FIN.InvoiceArrears(
				InvoiceID,  AccountTypeID, Amount, CurrencyCode, CreationDate, CreationUserName, CreationTime) 
			Select 
				@l_FINInvoiceID, @l_AcountTypeID, @ArrearsCost, @CurrencyCode, Cast( GetDate() AS Date ), @CurrentUserName, Cast( GetDate() AS Time );
			Set @l_InvoiceArrearsID	= SCOPE_IDENTITY();

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Költség - FIN Account:
			Set @l_FINAccountID = 0;

			-- New ObjectID:
			Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				Select @FINAccount as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
			Set @l_ObjectID = SCOPE_IDENTITY();

			Insert Into FIN.Account(
				ObjectID,												CalculationID, 
				AccountTypeID, 											CurrencyCode, 
				Balance, 												InvoiceLineID, 
				InvoiceArrearsID, 										CreationDate, 
				CreationTime, 											CreationUserName) 
			Select
				@l_ObjectID as ObjectID,								@l_CalculationID as CalculationID, 
				@l_AcountTypeID as AccountTypeID, 						@CurrencyCode as CurrencyCode, 
				@ArrearsCost as Balance, 								NULL as InvoiceLineID, 
				@l_InvoiceArrearsID, 									Cast( GetDate() AS Date ), 
				Cast( GetDate() AS Time ), 								@CurrentUserName;
			Set @l_FINAccountID	= SCOPE_IDENTITY();

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Költség - FIN Transaction:

			-- New ObjectID:
			Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				Select @FINTransaction as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
			Set @l_ObjectID = SCOPE_IDENTITY();

			Insert Into FIN.[Transaction](ObjectID, AccountID, PeriodID, PretenseCode, BankJournalDate, BankValueDate, ValueDate, AccountingDate, ExchangeDate, Amount, CreationDate, CreationTime, CreationUserName) 
			Select
				@l_ObjectID as ObjectID,								@l_FINAccountID as AccountID, 												
				NULL as PeriodID,  /*Üresen marad*/						'PRETENSE_INITIAL_ARREARS' as PretenseCode, 
				@l_TransactionDate as BankJournalDate, 					@l_TransactionDate as BankValueDate, 							
				@l_TransactionDate as ValueDate, 						@l_TransactionDate as AccountingDate, 
				@l_TransactionDate as ExchangeDate, 					@ArrearsCost as Amount, 											
				Cast( GetDate() AS Date ), 								Cast( GetDate() AS Time ), 								
				@CurrentUserName;


-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

--If @l_LocalCurrencyCode <> @CurrencyCode /*'CURRENCY_HUF' : 2023-01-30 */
IF Isnull(@ArrearsCostLocalCurrency,0) <> 0 /* 2023-01-31 */
BEGIN
-- Költség Local Currency - FIN INVOICEARREARS:
			If @l_Own = 'BOOLEAN_FALSE'
				Set @l_AcountTypeID = (Select AccountType.ID from fin.AccountType where MainClass = 'ACCOUNT_MAIN_CLASS_COST' and Code = 'ACCOUNT_TYPE_DEBT_COST_MANAGED' and Pending = 'boolean_false');
			Else
				Set @l_AcountTypeID = (Select AccountType.ID from fin.AccountType where MainClass = 'ACCOUNT_MAIN_CLASS_COST' and Code = 'ACCOUNT_TYPE_DEBT_COST' and Pending = 'boolean_false');			
			Set @l_FINInvoiceArrearsID = 0;

			Insert Into FIN.InvoiceArrears(
				InvoiceID,  AccountTypeID, Amount, CurrencyCode, CreationDate, CreationUserName, CreationTime) 
			Select 
				@l_FINInvoiceID, @l_AcountTypeID, @ArrearsCostLocalCurrency, @l_LocalCurrencyCode, Cast( GetDate() AS Date ), @CurrentUserName, Cast( GetDate() AS Time );
			Set @l_InvoiceArrearsID	= SCOPE_IDENTITY();

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Késedelmi kamat Local Currency - FIN Account:
			Set @l_FINAccountID = 0;

			-- New ObjectID:
			Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				Select @FINAccount as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
			Set @l_ObjectID = SCOPE_IDENTITY();

			Insert Into FIN.Account(
				ObjectID,												CalculationID, 
				AccountTypeID, 											CurrencyCode, 
				Balance, 												InvoiceLineID, 
				InvoiceArrearsID, 										CreationDate, 
				CreationTime, 											CreationUserName) 
			Select
				@l_ObjectID as ObjectID,								@l_CalculationID as CalculationID, 
				@l_AcountTypeID as AccountTypeID, 						@l_LocalCurrencyCode as CurrencyCode, 
				@ArrearsCostLocalCurrency as Balance, 					NULL as InvoiceLineID, 
				@l_InvoiceArrearsID, 									Cast( GetDate() AS Date ), 
				Cast( GetDate() AS Time ), 								@CurrentUserName;
			Set @l_FINAccountID	= SCOPE_IDENTITY();

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Késedelmi kamat Local Currency - FIN Transaction:

			-- New ObjectID:
			Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				Select @FINTransaction as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
			Set @l_ObjectID = SCOPE_IDENTITY();

			Insert Into FIN.[Transaction](ObjectID, AccountID, PeriodID, PretenseCode, BankJournalDate, BankValueDate, ValueDate, AccountingDate, ExchangeDate, Amount, CreationDate, CreationTime, CreationUserName) 
			Select
				@l_ObjectID as ObjectID,								@l_FINAccountID as AccountID, 												
				NULL as PeriodID,  /*Üresen marad*/						'PRETENSE_INITIAL_ARREARS' as PretenseCode, 
				@l_TransactionDate as BankJournalDate, 					@l_TransactionDate as BankValueDate, 							
				@l_TransactionDate as ValueDate, 						@l_TransactionDate as AccountingDate, 
				@l_TransactionDate as ExchangeDate, 					@ArrearsCostLocalCurrency as Amount, 											
				Cast( GetDate() AS Date ), 								Cast( GetDate() AS Time ), 								
				@CurrentUserName;
END; /*If @l_LocalCurrencyCode <> @CurrencyCode */

    /*a Fin.FeeList mindig legyen létrehozva*/
    Insert Into FIN.FeeList(Code, UsageCode, Name, StatusCode, CreationDate,  CreationTime, CreationUserName)
  	  Select 'FEE_LIST_INDIVIDUAL', 'FEE_LIST_USAGE_CREDIT', 'Kondíciós lista' Name, 'STATUS_NORMAL', GetDate(), GetDate(), @CurrentUserName
    Set @feeListID = SCOPE_IDENTITY()
		UpDate FIN.Calculation Set FeeListID = @feeListID where ID = @l_CalculationID

		If @InterestRate is not NULL
		or @PenaltyInterestRate is not NULL
		or @CostRate is not NULL
		Begin
			Set @dailyCostMin = NULL;
			Set @dailyCostMax = NULL;

      select @feeValidDate = dc.PurchaseDate
      from DCS.DebtCase dc
      where ID = @l_DebtCaseID

			If @InterestRate is not NULL
			Begin
				exec FIN.RefreshFee @feeListID = @feeListID, 
									@code = 'FEE_INTEREST', 
									@typeCode = 'FEE_TYPE_INTEREST_PERCENT', 
									@validDate = @feeValidDate, 
									@feeRate = @InterestRate,  
									@periodTypeCode = null, 
									@periodMinimumValue = null, 
									@periodMaximumValue = null, 
									@currencyCode = @CurrencyCode,
									@correlationID = @p_correlationID, 
									@username = @CurrentUserName,
                  @isFeeRateInPercentFormat = 1
			End;
            
			If @PenaltyInterestRate is not NULL
			Begin
				exec FIN.RefreshFee @feeListID = @feeListID, 
									@code = 'FEE_PENALTY_INTEREST', 
									@typeCode = 'FEE_TYPE_INTEREST_PERCENT', 
									@validDate = @feeValidDate, 
									@feeRate = @PenaltyInterestRate,  
									@periodTypeCode = null, 
									@periodMinimumValue = null, 
									@periodMaximumValue = null, 
									@currencyCode = @CurrencyCode,
									@correlationID = @p_correlationID, 
									@username = @CurrentUserName,
                  @isFeeRateInPercentFormat = 1
			End;
            
			If @CostRate is not NULL
			Begin
        select @CostRatePeriodTypeCode = Case when @dailyCostMin is null and @dailyCostMax is null then null else 'PERIOD_TYPE_DAY' end

				exec FIN.RefreshFee @feeListID = @feeListID, 
									@code = 'FEE_MANAGEMENT_FEE', 
									@typeCode = 'FEE_TYPE_INTEREST_PERCENT', 
									@validDate = @feeValidDate, 
									@feeRate = @CostRate,  
									@periodTypeCode = @CostRatePeriodTypeCode, 
									@periodMinimumValue = @dailyCostMin, 
									@periodMaximumValue = @dailyCostMax, 
									@currencyCode = @CurrencyCode,
									@correlationID = @p_correlationID, 
									@username = @CurrentUserName,
                  @isFeeRateInPercentFormat = 1
				End;
		End;
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- Diszkont:

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 

/*
If @l_Own <> 'BOOLEAN_FALSE' -- Nem Kezelt ügy
Begin

Set @l_AcountTypeID = (Select AccountType.ID from fin.AccountType where MainClass = 'ACCOUNT_MAIN_CLASS_GENERAL' and Code = 'ACCOUNT_TYPE_BOOK_VALUE_DISCOUNT' and Pending = 'BOOLEAN_FALSE');


Set @l_Discount = 0;

If @l_PurchasePriceCurrencyCode = @l_LocalCurrencyCode and @CurrencyCode <> @l_LocalCurrencyCode
BEGIN
	Set @l_Arfolam = (Select Top 1 Rate from FIN.ExchangeRate where SourceCurrencyCode = @CurrencyCode and TargetCurrencyCode = @l_LocalCurrencyCode and ExchangeRateSystemCode = 'EXCHANGE_RATE_SYSTEM_MNB' 
						and ExchangeRate.ExchangeDate = (Select max(ExchangeDate) from FIN.ExchangeRate 
															where SourceCurrencyCode = @CurrencyCode 
																and TargetCurrencyCode = @l_LocalCurrencyCode 
																and ExchangeRateSystemCode = 'EXCHANGE_RATE_SYSTEM_MNB' 
																and ExchangeDate <= @l_PurchaseDate) order by ExchangeRate.ID Desc);
	Set @l_Discount = 
				( @ArrearsCapital -- Tőke
				+ @ArrearsInterest -- Ügyleti kamat
				+ @ArrearsPenaltyInterest -- Késedelmi kamat
				+ @ArrearsCost -- Költség
				--+ @ArrearsCostLocalCurrency-- Költség Local Currency
				) * @l_Arfolam - @l_PurchasePrice;
END
ELSE
BEGIN
	Set @l_Discount = 
				( @ArrearsCapital -- Tőke
				+ @ArrearsInterest -- Ügyleti kamat
				+ @ArrearsPenaltyInterest -- Késedelmi kamat
				+ @ArrearsCost -- Költség
				--+ @ArrearsCostLocalCurrency-- Költség Local Currency
				) - @l_PurchasePrice;
END;
				
-- Discount - FIN Account:
-- Új FIN.Account ha szükséges:
			Set @l_FINAccountID = 0;
				Begin
				-- Nem létezik FIN.Account, létre kell hozni:

				-- New ObjectID:
						Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
							Select @FINAccount as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
						Set @l_ObjectID = SCOPE_IDENTITY();

						Insert Into FIN.Account(
							ObjectID,												
							CalculationID, 
							AccountTypeID, 											
							CurrencyCode, 
							Balance, 												
							InvoiceLineID, 
							InvoiceArrearsID, 										
							CreationDate, 
							CreationTime, 											
							CreationUserName) 
						Select
							@l_ObjectID as ObjectID,								
							@l_CalculationID as CalculationID, 
							@l_AcountTypeID as AccountTypeID, 						
							@l_PurchasePriceCurrencyCode /*@CurrencyCode*/ as CurrencyCode, 
							@l_Discount as Balance, 							
							NULL as InvoiceLineID, /* nem kell tölteni */
							NULL as InvoiceArrearsID,
							Cast( GetDate() AS Date ), 
							Cast( GetDate() AS Time ), 								
							@CurrentUserName;
						Set @l_FINAccountID	= SCOPE_IDENTITY();
				END;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Discount - FIN Transaction:
-- Új FIN.Transaction ha szükséges:
				Begin
				-- Nem létezik FIN.Transaction, létre kell hozni:
				-- New ObjectID:
						Insert Into Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
							Select @FINTransaction as ObjectType, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, '1.0.0';
						Set @l_ObjectID = SCOPE_IDENTITY();

						Insert Into FIN.[Transaction](ObjectID, AccountID, PeriodID, PretenseCode, BankJournalDate, BankValueDate, ValueDate, AccountingDate, ExchangeDate, Amount, CreationDate, CreationTime, CreationUserName) 
						Select
							@l_ObjectID as ObjectID,								@l_FINAccountID as AccountID, 												
							NULL as PeriodID,  /*Üresen marad*/						'PRETENSE_INITIAL_DISCOUNT_VALUE' as PretenseCode, 
							@l_TransactionDate as BankJournalDate, 					@l_TransactionDate as BankValueDate, 							
							@l_TransactionDate as ValueDate, 						@l_TransactionDate as AccountingDate, 
							@l_TransactionDate as ExchangeDate, 					@l_Discount as Amount, 											
							Cast( GetDate() AS Date ), 								Cast( GetDate() AS Time ), 								
							@CurrentUserName;
						
				END;
end;  -- Nem Kezelt ügy
*/


      /*DV-1592: insert Inkasso sync record*/
      if @l_InkassoSyncOnDebtCase  = 1
      begin
        declare @today Date = GetDate()

        declare inkassoCur cursor local fast_forward for
          select null ID, @l_DebtCaseID DebtCaseID, 'DebtCase' syncType
          union all
          select d.ID ID, null DebtCaseID, 'Debtor' syncType
          from DCS.Debtor d
          where d.DebtCaseID = @l_DebtCaseID
            and @l_InkassoSyncOnDebtor = 1
          union all
          /*if the debtcase and the asset sync was successful earlier, we have to generate asset sync records here as well*/
          select distinct /*just in case*/ dca.AssetID ID, dca.DebtCaseID, 'Asset' syncType
          from AST.EntityAsset ea join AST.DebtCaseAsset dca on dca.AssetID = ea.AssetId
          where ea.EntityAssetRelationTypeCode = 'ENTITY_ASSET_RELATION_TYPE_OWNER'
            and ea.StatusCode = 'STATUS_NORMAL' 
            and IsNull(ea.ValidFrom, @today) <= @today
            and @today <= IsNull(ea.ValidUntil, @today)
            and dca.DebtCaseID = @l_DebtCaseID
            and dca.StatusCode = 'STATUS_NORMAL'
            and IsNull(dca.ValidFrom, @today) <= @today
            and @today <= IsNull(dca.ValidUntil, @today)
            and @l_InkassoSyncOnAsset  = 1
        
        

        open inkassoCur
        while 1 = 1
        begin
          fetch next from inkassoCur into @l_inkassoSyncID, @l_inkassoSyncDebtCaseID, @l_inkassoSyncType 

          if @@fetch_status <> 0
              break

          begin try 
            exec IFC.GenerateSendInkassoSyncData @syncType = @l_inkassoSyncType, 
                                                             @syncEventType = 'insert', 
                                                             @entityID = null, 
                                                             @ID = @l_inkassoSyncID, 
                                                             @debtCaseID = @l_inkassoSyncDebtCaseID, 
                                                             @dataChangedUserName = @CurrentUserName,
                                                             @correlationID = @p_correlationID,
                                                             @moduleInstanceID = @p_moduleInstanceIDInkasso output,
                                                             @isBatch = 1
          end try
          begin catch
            close inkassoCur
            deallocate inkassoCur

            ;throw
          end catch
        end
        close inkassoCur
        deallocate inkassoCur
      end

      /*event kiírás a konszolidált product alapján*/
      select @l_objectidDebtCase = null, @l_eventTypeForConstructionCode = null

      select @l_objectidDebtCase = dc.ObjectID, @l_eventTypeForConstructionCode = cp.EventTypeCode
      from DCS.DebtCase dc join FIN.ConsolidatedProduct cp on dc.ConsolidatedProductCode = cp.Code
      where dc.ID = @l_DebtCaseID

      if @l_eventTypeForConstructionCode is not null
      begin
        select @now = GetDate()

        exec ORG.CreateEvent  @EventDate = @now, 
                              @EventTime = @now,
                              @EventType = @l_eventTypeForConstructionCode,
                              @Comments = null,
                              @RelatedObjectID = @l_objectidDebtCase,
                              @CreationUserName = @CurrentUserName,
                              @ProcessCode = null,
                              @moduleInstanceIDInkasso = @p_moduleInstanceIDInkasso output,
                              @isBatch = 1,
                              @correlationid = @p_correlationID
      end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- -- -- -- -- -- -- -- --

			If Isnull(@ErrorMessage,'') = ''
				Set @ErrorMessage = NULL;
			Update IFC.Invoice Set InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage = @ErrorMessage, InvoiceId = SCOPE_IDENTITY(),
				LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName	WHERE ID = @ID;

				
      COMMIT /*Nem létező FIN.Invoice*/
		END; /*Nem létező FIN.Invoice*/
---------------------------------------------------------------------------------------------------------------------------------------------

	END;  /*@ErrorMessage = NULL*/

  END TRY /*Belső-1*/
	BEGIN CATCH /*Belső-1*/
    if @@TRANCOUNT > 0
       rollback

    SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
		Set @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
		Update IFC.Invoice Set InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = Trim(Isnull(@ErrorMessage,'')),
			LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
	END CATCH /*Belső-1*/

			FETCH NEXT FROM db_cursor INTO @ID, 
			@ObjectID, @InvoiceTypeText, @InvoiceTypeCode, @SellerPartyID, @BuyerPartyID, @InvoiceNr, @RegistrationNr, /*@CreditTypeCode, @CreditTypeText,*/ @ProductCode, @ProductText, 
			@ContractDate, @FulfillmentDate, @IssueDate, @DueDate, @TerminationDate, @PaymentMethodCode, @PaymentMethodText, @CurrencyCode, @CurrencyText, @TotalNetAmount, @TotalVATAmount, 
			@TotalGrossAmount, @TotalCredit, @TotalInstalment, @ArrearsCapital, @ArrearsInterest, @ArrearsPenaltyInterest, @ArrearsCost, @ArrearsCostLocalCurrency, @InterestRate, @PenaltyInterestRate, 
			@InvoiceID, @SourceID, @SourceDebtCaseID, @SourceContractID, @SourceInterfaceType, @InterfaceStatusCode, @ErrorMessage, @OperationCode, @ImportTableID, @PaymentMethodText, @PaymentMethodCode,
			@SellerPartyName, @BuyerPartyName, @CostRate;

		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;

    END TRY


    Begin CATCH

        Select   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        Set @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

		Select @l_cursorStatus = CURSOR_STATUS('global', 'db_cursor');
		IF @l_cursorStatus <> -3
		Begin
			IF @l_cursorStatus = 1
				CLOSE db_cursor;

			DEALLOCATE db_cursor;
		END;

		Insert Into LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		Select 
			Cast( GetDate() AS Date ),	-- LogDate,	
			Cast( GetDate() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',				-- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			'IFC.InvoiceLoader',		-- ServiceName
			'1.0',						-- ServiceVersion
			'FATAL',					-- SeverityLevel
			NULL,						-- MessageCategory
			@ErrorMessage;


        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        Select @ErrorMessage;

    END CATCH;
------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
		
	Set @LogMessage = @LogMessage + 'InvoiceLoader Ended at ' + Cast(Cast( GetDate() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	Insert Into LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	Select 
		Cast( GetDate() AS Date ),	-- LogDate,	
		Cast( GetDate() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.InvoiceLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + Cast(@l_AllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ImportedRowsCount: ' + Cast(@l_ImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ExistingRowsCount: ' + Cast(@l_ExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ErrorRowsCount: ' + Cast(@l_ErrorRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ @LogMessage;



	Insert Into LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	Select 
		Cast( GetDate() AS Date ),	-- LogDate,	
		Cast( GetDate() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.InvoiceLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage

	If Isnull(@ErrorMessage,'') <> ''
		Return 99;
	else
		Return 1;

END;

go

/*Author: Gyenese Katalin
  Create date: 2023.10.09. - DV-1524
  Last modified date: 2023.10.09.
  Description: Returns if the Incasso synchronization is turned on (1)/off (0)

  - @logicalDirectionCode: INTERFACE_DIRECTION_INPUT / INTERFACE_DIRECTION_OUTPUT
  - @syncType: the type of the synchronization: Company/Person/Address/Phone/Event/Document/ConstructionCode/DebtCase/Debtor/Asset
  - @syncEventType: the type of the event that indicated the synchronization: insert/update
*/

create   function [IFC].[IsInkassoSyncOn](@logicalDirectionCode NVarChar(200), @syncType NVarChar(200), @syncEventType NVarChar(200))
returns int
as
begin
  declare @today Date = GetDate(), @res int

  if exists(select *
            from IFC.Interface i
            where i.EnabledCode = 'BOOLEAN_TRUE'
              and IsNull(i.ValidFrom, @today) <= @today
              and @today <= IsNull(i.ValidUntil, @today)
              and i.LogicalDirectionCode = @logicalDirectionCode
              and i.Code = Case when @logicalDirectionCode = 'INTERFACE_DIRECTION_OUTPUT' then 
                                     Case when @syncType in('Company', 'Person') then Case when @syncEventType = 'insert' then 'INTERFACE_INK_BASEDATA_CREATE_SYNC'
                                                                                           when @syncEventType = 'update' then 'INTERFACE_INK_BASEDATA_MODIFY_SYNC'
                                                                                      end
                                          when @syncType = 'Address' then Case when @syncEventType = 'insert' then 'INTERFACE_INK_ADDRESS_CREATE_SYNC'
                                                                               when @syncEventType = 'update' then 'INTERFACE_INK_ADDRESS_MODIFY_SYNC'
                                                                          end
                                          when @syncType = 'Phone' then Case when @syncEventType = 'insert' then 'INTERFACE_INK_PHONE_CREATE_SYNC'
                                                                             when @syncEventType = 'update' then 'INTERFACE_INK_PHONE_MODIFY_SYNC'
                                                                        end
                                          when @syncType = 'Event' and @syncEventType = 'insert' then 'INTERFACE_INK_WORKFLOWCHANGE_SYNC'
                                          when @syncType = 'Document' and @syncEventType = 'insert' then 'INTERFACE_INK_DOCUMENTCHANGE_SYNC'
                                          when @syncType = 'ConstructionCode' then Case when @syncEventType = 'insert' then 'INTERFACE_INK_CONSTRUCTIONCODE_CREATE_SYNC'
                                                                                        when @syncEventType = 'update' then 'INTERFACE_INK_CONSTRUCTIONCODE_MODIFY_SYNC'
                                                                                   end                             
                                          when @syncType = 'DebtCase' and @syncEventType = 'insert' then 'INTERFACE_INK_DEALCHANGE_SYNC'
                                          when @syncType = 'Debtor' then Case when @syncEventType = 'insert' then 'INTERFACE_INK_DEBTOR_CREATE_SYNC'
                                                                              when @syncEventType = 'update' then 'INTERFACE_INK_DEBTOR_MODIFY_SYNC'
                                                                         end
                                          when @syncType = 'Asset' and @syncEventType = 'insert' then 'INTERFACE_INK_COLLATERALCHANGE_SYNC'  
                                     end
                                when @logicalDirectionCode = 'INTERFACE_DIRECTION_INPUT' then 
                                     Case when @syncType = 'DebtCase' and @syncEventType = 'update' then 'INTERFACE_IND_DEALCHANGE_UPDATE_SYNC'
                                          when @syncType = 'Event' and @syncEventType = 'insert' then 'INTERFACE_IND_WORKFLOWCHANGE_CREATE_SYNC'
                                     end
                           end  
           )
  begin
    set @res = 1   
  end
  else
  begin
    set @res = 0
  end

  return @res
end
go

/*Author: Gyenese Katalin
  Create date: 2023.11.07. - DV-1680
  Last modified date: 2023.11.07.
  Description: Returns if the given eventType has to be sent to the Inkasso or not (1/0)


  @eventTypeCode: eventType
*/

CREATE   function [IFC].[IsInkassoSyncSendEvent](@eventTypeCode NVarChar(200))
returns int
as
begin
  return Case when @eventTypeCode in ('EVENT_TYPE_20555', 'EVENT_TYPE_20556', 'EVENT_TYPE_10873', 'EVENT_TYPE_10902', 'EVENT_TYPE_10903', 'EVENT_TYPE_10904', 'EVENT_TYPE_21463', 'EVENT_TYPE_20040', 'EVENT_TYPE_5095', 'EVENT_TYPE_21422', 
                                      'EVENT_TYPE_21433', 'EVENT_TYPE_21434', 'EVENT_TYPE_21435', 'EVENT_TYPE_21464', 'EVENT_TYPE_21465', 'EVENT_TYPE_21466', 'EVENT_TYPE_21467', 'EVENT_TYPE_21468', 'EVENT_TYPE_21446', 'EVENT_TYPE_10738', 
                                      'EVENT_TYPE_10745', 'EVENT_TYPE_10761', 'EVENT_TYPE_10762', 'EVENT_TYPE_10763', 'EVENT_TYPE_20138', 'EVENT_TYPE_20139', 'EVENT_TYPE_20140',
                                      'EVENT_TYPE_21458', 'EVENT_TYPE_21459', 'EVENT_TYPE_21460', 'EVENT_TYPE_21461'
                                     ) then 1 else 0 end

end
go


CREATE   PROCEDURE [IFC].[LakcimkeresesKiadas](@p_correlationID NVARCHAR(200),  @p_TaskListID NUMERIC(16), @p_SourceInterfaceType NVARCHAR(200))

/*
==========================================================================================
 Author:		Tóth Gábor
 Creation date:			2023.02.27.
 Last modified date:	2023.03.01: Tesztelésre leválogatás beállítása
						2023.03.20: @p_SourceInterfaceType
						2023.04.05: @TaskListTypeID
						2023.04.18: Task.ProcessID
						
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUserName = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.LakcimkeresesKiadas',	-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);

    BEGIN TRANSACTION

    BEGIN TRY
        SET @LogMessage = 'LakcimkeresesKiadas Started at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
		
		Declare @l_Company nvarchar(1); -- Company = 'T'
-----------------------------------------------
-- Kurzorhoz:
		Declare @ID NUMERIC(16);
		Declare @ObjectID numeric(16, 0);

		Declare @Gender nvarchar(200);		/* Gender (HU: F / N) */
		Declare @LastName nvarchar(200);
		Declare @MiddleName nvarchar(200);
		Declare @FirstName nvarchar(200);
		Declare @MothersLastName nvarchar(200);
		Declare @MothersFirstName nvarchar(200);
		Declare @MaidenLastName nvarchar(200);
		Declare @MaidenMiddleName nvarchar(200);
		Declare @MaidenFirstName nvarchar(200);
		Declare @BirthDate date;
		Declare @BirthPlace nvarchar(200);
		Declare @DeregistrationReason nvarchar(200);
		Declare @DeregistrationDate date;
		Declare @TaskListTypeID nvarchar(200);
		Declare @ProcessID numeric(16);

-- Statisztikához:
		Declare @l_ImportedRowCounts numeric(16);
-- Egyedi:
		Declare @l_SequenceNr numeric(16);

/* *************************************************************************************************************** */

		Set @l_ImportedRowCounts = 0;
		Set @l_SequenceNr = 0;

		DECLARE db_cursor CURSOR FOR 
		-- ez lesz az éles:
		SELECT 
			Task.ReferencedObjectID,
			TaskList.TaskListTypeID,
			Task.ProcessID
			From Org.TaskList
			join Org.Task on Task.TaskListID = TaskList.Id
			where Task.TaskTypeID in ('TASK_TYPE_ADDRESS_SEARCH_WAITING_FOR_COLLECTOR', 'TASK_TYPE_ADDRESS_VALIDATION_WAITING_FOR_COLLECTOR')
				and Task.StatusCode = 'TASK_MAIN_STATUS_FINISHED'
				and Task.DetailsStatusCode='TASK_DETAILED_STATUS_WAITING_TO_BE_PROCESSED'
				and TaskList.Id = @p_TaskListID
		
		/* ez a tesztelés */
		 /* select Object.Id from Prt.Person
			join prt.Entity on Entity.Id = Person.EntityID
			join gen.Object on Object.id = Entity.ObjectID
			where lastname is not null and firstname is not null 
				and Isnull(MotherFirstName,'') <> '' 
				and Isnull(MotherLastName,'') <>''
				and Isnull(sex,'') <> ''
				and BirthDate is not null 
				and Isnull(BirthPlace,'') <> '' */



		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO
			@ObjectId, @TaskListTypeID, @ProcessID

		WHILE @@FETCH_STATUS = 0  
		BEGIN 

---------------------------------------------------------------------------------------------------------------------------------------------
-- Error Section:
			SET @ErrorMessage = NULL;
---------------------------------------------------------------------------------------------------------------------------------------------

			IF @ErrorMessage is NULL
			BEGIN

				Set @l_SequenceNr = @l_SequenceNr + 1;
				Select 
					@Gender = Person.Sex,
					@LastName = Person.Lastname,
					@MiddleName = Person.MiddleName,
					@FirstName = Person.FirstName,
					@MothersLastName = Person.MotherLastName,
					@MothersFirstName = Person.MotherFirstName,
					@MaidenLastName = Person.MaidenLastName,
					@MaidenMiddleName = Person.MiddleName,
					@MaidenFirstName = Person.MaidenFirstName,
					@BirthDate = Person.BirthDate,
					@BirthPlace = Person.BirthPlace
				from Prt.Entity join Prt.Person on Person.EntityID = Entity.ID where Entity.ObjectID = @ObjectId;


				Insert Into IFC.AddressRegister
					(SequenceNr,
					ObjectID,
					Gender,
					LastName,
					MiddleName,
					FirstName,
					MothersLastName,
					MothersFirstName,
					MaidenLastName,
					MaidenMiddleName,
					MaidenFirstName,
					BirthDate,
					BirthPlace,
					StatusCode,
					CreationDate,
					CreationTime,
					CreationUserName,
					ExportImportCode,
					SourceInterfaceType,
					ValidationRecordCode,
					ProcessID)

		

				Select
					@l_SequenceNr,
					@ObjectID,
					Case @Gender
						when 'GENDER_MALE' then 'F'
						when 'GENDER_FEMALE' then 'N'
						else 'NULL'
						end as Gender,
					@LastName,
					@MiddleName,
					@FirstName,
					@MothersLastName,
					@MothersFirstName,
					@MaidenLastName,
					@MaidenMiddleName,
					@MaidenFirstName,
					@BirthDate,
					@BirthPlace,
					'ADDRESS_REGISTER_STATUS_WAITING_FOR_SENDING' as StatusCode,
					CAST( GETDATE() AS Date ) as CreationDate,
					CAST( GETDATE() AS Time ) as CreationTime,
					@CurrentUserName as CreationUserName,
					'EXPORT_IMPORT_EXPORT',
					@p_SourceInterfaceType,
					Case @TaskListTypeID 
						when 'TASK_LIST_TYPE_ADDRESS_SEARCH_WAITING_FOR_COLLECTOR' then 'BOOLEAN_FALSE'
						when 'TASK_LIST_TYPE_ADDRESS_VALIDATION_WAITING_FOR_COLLECTOR' then 'BOOLEAN_TRUE'
						else NULL
						end as TaskListTypeID,
					@ProcessID as ProcessID;


					commit;
---------------------------------------------------------------------------------------------------------------------------------------------
				Set @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
---------------------------------------------------------------------------------------------------------------------------------------------
			END;  /*@ErrorMessage = NULL*/

		FETCH NEXT FROM db_cursor INTO
			@ObjectId, @TaskListTypeID, @ProcessID

		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;

    COMMIT TRANSACTION;

    END TRY


    BEGIN CATCH

        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.LakcimkeresesKiadas',	-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        ROLLBACK TRANSACTION;

        SELECT @ErrorMessage;

    END CATCH;


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
    BEGIN TRANSACTION
		
	SET @LogMessage = @LogMessage + 'LakcimkeresesKiadas Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.LakcimkeresesKiadas',	-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ @LogMessage;



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.LakcimkeresesKiadas',	-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return 1;

	COMMIT TRANSACTION;
END;


go


CREATE        PROCEDURE [IFC].[LakcimkeresesVisszatoltes](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16), @p_SourceInterfaceType NVARCHAR(200))

/*
==========================================================================================
 Author:		Tóth Gábor
 Creation date:			2023.03.12.
 Last modified date:	2023.03.13, Plevel
						2023.02.27, SourceInterfaceType
						2023.02.27, Gen.ObjectType
						2023.04.13, Lakcímkeresés (újból) + Validálás
						2023.04.14, Külföldi cím - Current Date
						2023.04.18, Task.ProcessID

Kérdések:
 State ?
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	--DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.LakcimkeresesVisszatoltes',	-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);

    BEGIN TRANSACTION

    BEGIN TRY
        SET @LogMessage = 'LakcimkeresesVisszatoltes Started at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
		
		Declare @l_Company nvarchar(1); -- Company = 'T'
-----------------------------------------------
-- Kurzorhoz:
		Declare @ID NUMERIC(16);
		Declare @ObjectID numeric(16, 0);
		Declare @DeregistrationReason nvarchar(200);
		Declare @DeregistrationDate date;
		Declare @PZipCode nvarchar(200);
		Declare @PCity nvarchar(200);
		Declare @PPublicPlaceName nvarchar(200);
		Declare @PPublicPlaceType nvarchar(200);
		Declare @PHouseNr nvarchar(200);
		Declare @PBuilding nvarchar(200);
		Declare @PStaircase nvarchar(200);
		Declare @PFloor nvarchar(200);
		Declare @PDoor nvarchar(200);
		Declare @PRegistrationDate date;
		Declare @PLevel nvarchar(200);
		Declare @TZipCode nvarchar(200);
		Declare @TCity nvarchar(200);
		Declare @TPublicPlaceName nvarchar(200);
		Declare @TPublicPlaceType nvarchar(200);
		Declare @THouseNr nvarchar(200);
		Declare @TBuilding nvarchar(200);
		Declare @TStaircase nvarchar(200);
		Declare @TFloor nvarchar(200);
		Declare @TDoor nvarchar(200);
		Declare @TRegistrationDate date;
		Declare @FCountry nvarchar(200);
		Declare @FZipCode nvarchar(200);
		Declare @FState nvarchar(200);
		Declare @FCity nvarchar(200);
		Declare @FAddress nvarchar(200);
		Declare @StatusCode nvarchar(200);		-- Status of the address search -> value set ADDRESS_REGISTER_STATUS
		Declare @ExportImportCode nvarchar(200);
		Declare @ReturnedAddressRegisterID numeric(16, 0);
		Declare @ValidationRecordCode nvarchar(200);
		Declare @ProcessID numeric(16);

-- Statisztikához:
		Declare @l_AllRowCounts numeric(16);
		Declare @l_ImportedRowCounts numeric(16);
		Declare @l_ErrorRowCounts numeric(16);
		Declare @l_NotFoundRowCounts numeric(16);
-- Egyedi:
		Declare @l_EntityID numeric(16);
		Declare @l_EntitySourceID nvarchar(200);
		Declare @l_ObjectID numeric(16);
		Declare @CodePPublicPlaceType nvarchar(200);
		Declare @CodeTPublicPlaceType nvarchar(200);
		Declare @CodeFCountry nvarchar(200);
		Declare @CodeFState nvarchar(200);
		Declare @l_ProcessID numeric(16);

		Declare @l_CountryIDHUN nvarchar(200);
		Declare @l_vege nvarchar(1);
		Declare @l_ObjectTypeCode nvarchar(200);
		Declare @Eredmeny nvarchar(200);  /*  {'elhunyt', 'nincsujcim', 'ujcimerkezett' } */

		Set @l_ObjectTypeCode = (Select Top 1 Code from GEN.ObjectType where TableName = 'PRT.ADDRESS' order by TableName desc);



/* *************************************************************************************************************** */
	/*
		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END
	*/


		IF COALESCE(@p_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);

		If not exists (SELECT 1 FROM IFC.AddressRegister
			WHERE StatusCode = 'ADDRESS_REGISTER_STATUS_UPLOADED'
			and ExportImportCode = 'EXPORT_IMPORT_IMPORT'
			and SourceInterfaceType = @p_SourceInterfaceType)
			RAISERROR('Data Not Found!', 16, 1);

		SET @l_AllRowCounts = (Select Count(*) FROM Org.TaskList WHERE TaskListTypeID in ('TASK_TYPE_ADDRESS_SEARCH_WAITING_FOR_COLLECTOR', 'TASK_TYPE_ADDRESS_VALIDATION_WAITING_FOR_COLLECTOR'));
		Set @l_ImportedRowCounts = 0;
		Set @l_ErrorRowCounts = 0;
		Set @l_CountryIDHUN = (Select Top 1 CodeID from Gen.Translation where CodeId Like 'Country_%' and text = 'Magyarország' order by CodeID desc)


/* Előválogatás */
    BEGIN TRANSACTION
		DECLARE db_cursor CURSOR FOR 
		SELECT	texport.ID as export_ID, 
				texport.ObjectID as export_ObjectID, 
				texport.ProcessID as export_ProcessID
		FROM IFC.AddressRegister texport
		WHERE '1' = '1'
			and texport.StatusCode = 'ADDRESS_REGISTER_STATUS_SENT'
			and texport.ExportImportCode = 'EXPORT_IMPORT_EXPORT'
			and texport.SourceInterfaceType = @p_SourceInterfaceType;

		Set @l_NotFoundRowCounts = 0;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID, 
			@ObjectID,
			@ProcessID
		WHILE @@FETCH_STATUS = 0  
		BEGIN  
				If Not exists (Select 1 from IFC.AddressRegister 
								where ReturnedAddressRegisterID = @ID
								and StatusCode = 'ADDRESS_REGISTER_STATUS_UPLOADED'
								and ExportImportCode = 'EXPORT_IMPORT_IMPORT'
								and SourceInterfaceType = @p_SourceInterfaceType)
				Begin
					SET @l_NotFoundRowCounts = @l_NotFoundRowCounts + 1;
					--Update IFC.AddressRegister Set StatusCode = 'ADDRESS_REGISTER_STATUS_PROCESSED' where Id = @ID;
					Update ORG.Process Set Process.DetailedStatusCode = 'TASK_DETAILED_STATUS_NO_ANSWER' where Process.ID = @ProcessID;
				End;
		FETCH NEXT FROM db_cursor INTO @ID, 
			@ObjectID,
			@ProcessID
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;
    COMMIT TRANSACTION;

/* *********************************************************************************************************************************************** */

		DECLARE db_cursor_2 CURSOR FOR 
		SELECT ID, 
				ObjectID, 
				DeregistrationReason,
				DeregistrationDate,
				PZipCode,
				PCity,
				PPublicPlaceName,
				PPublicPlaceType,
				PHouseNr,
				PBuilding,
				PStaircase,
				PFloor,
				PDoor,
				PRegistrationDate,
				PLevel,
				TZipCode,
				TCity,
				TPublicPlaceName,
				TPublicPlaceType,
				THouseNr,
				TBuilding,
				TStaircase,
				TFloor,
				TDoor,
				TRegistrationDate,
				FCountry,
				FZipCode,
				FState,
				FCity,
				FAddress,
				StatusCode,
				ExportImportCode,
				ReturnedAddressRegisterID,
				ValidationRecordCode,
				ProcessID
			FROM IFC.AddressRegister
			WHERE '1' = '1'
			and StatusCode = 'ADDRESS_REGISTER_STATUS_UPLOADED'
			and ExportImportCode = 'EXPORT_IMPORT_IMPORT'
			and ReturnedAddressRegisterID is not NULL
			--and ID = 27592
			--and ID = 27603
			--and id = 27902
			--and ID = 27673
			and SourceInterfaceType = @p_SourceInterfaceType;

		OPEN db_cursor_2;
		FETCH NEXT FROM db_cursor_2 INTO @ID, 
			@ObjectID,
			@DeregistrationReason,
			@DeregistrationDate,
			@PZipCode,
			@PCity,
			@PPublicPlaceName,
			@PPublicPlaceType,
			@PHouseNr,
			@PBuilding,
			@PStaircase,
			@PFloor,
			@PDoor,
			@PRegistrationDate,
			@PLevel,
			@TZipCode,
			@TCity,
			@TPublicPlaceName,
			@TPublicPlaceType,
			@THouseNr,
			@TBuilding,
			@TStaircase,
			@TFloor,
			@TDoor,
			@TRegistrationDate,
			@FCountry,
			@FZipCode,
			@FState,
			@FCity,
			@FAddress,
			@StatusCode,
			@ExportImportCode,
			@ReturnedAddressRegisterID,
			@ValidationRecordCode,
			@ProcessID

		WHILE @@FETCH_STATUS = 0  
		BEGIN  

---------------------------------------------------------------------------------------------------------------------------------------------

-- ProccessID:
	Set @l_ProcessID = NULL;
	If Exists (Select 1 FROM IFC.AddressRegister where ID = @ReturnedAddressRegisterID)
		Set @l_ProcessID = (Select ProcessID FROM IFC.AddressRegister where ID = @ReturnedAddressRegisterID);

-- EntityID:
	Select @l_EntityID = Entity.ID, @l_EntitySourceID = Entity.SourceID from PRT.Entity where Entity.ObjectID = @ObjectID;

-- PPublicPlaceType-Code:
	Set @CodePPublicPlaceType = NULL;
	If exists (Select 1 from Gen.Code join Gen.Translation on Translation.CodeID = Code.ID where Code.ID like 'PUBLIC_PLACE_TYPE_%' and Translation.Text = @PPublicPlaceType)
	Begin
		Set @CodePPublicPlaceType = (Select Top 1 Code.ID from Gen.Code join Gen.Translation on Translation.CodeID = Code.ID where Code.ID like 'PUBLIC_PLACE_TYPE_%' and Translation.Text = @PPublicPlaceType);
	End;

-- TPublicPlaceType-Code:
	Set @CodeTPublicPlaceType = NULL;
	If exists (Select 1 from Gen.Code join Gen.Translation on Translation.CodeID = Code.ID where Code.ID like 'PUBLIC_PLACE_TYPE_%' and Translation.Text = @TPublicPlaceType)
	Begin
		Set @CodeTPublicPlaceType = (Select Top 1 Code.ID from Gen.Code join Gen.Translation on Translation.CodeID = Code.ID where Code.ID like 'PUBLIC_PLACE_TYPE_%' and Translation.Text = @TPublicPlaceType);
	End;

-- FCountry-Code:
	Set @CodeFCountry = NULL;
	If exists (Select 1 from Gen.Code join Gen.Translation on Translation.CodeID = Code.ID where Code.ID like 'COUNTRY_%' and Translation.Text = @FCountry)
	Begin
		Set @CodeFCountry = (Select Top 1 Code.ID from Gen.Code join Gen.Translation on Translation.CodeID = Code.ID where Code.ID like 'COUNTRY_%' and Translation.Text = @FCountry);
	End;

-- FState-Code:
	Set @CodeFState = NULL;

-- Budapest
	If Upper(@PCity) Like '%BUDAPEST%'
		Set @PCity = 'Budapest';
	If Upper(@TCity) Like '%BUDAPEST%'
		Set @TCity = 'Budapest';

-- ValidationRecordCode
	Set @ValidationRecordCode = ISNULL(@ValidationRecordCode, 'BOOLEAN_FALSE');

	Set @l_vege = 'F';
	Set @Eredmeny = 'TASK_DETAILED_STATUS_NO_NEW_ADDRESS' /* nincsujcim */;

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
-- A Nyil.kikerülés értéke "meghalt" ?
	If Trim(Isnull(@DeregistrationReason,'')) = 'meghalt'
	and @DeregistrationDate is not NULL
	Begin
		/* Az objektum "aktuális állapota" mező beállítása= "Elhunyt személy (bejelentve)" értékre (erre fog elindulni az örökös keresés) */
		Update PRT.Person Set StatusCode = 'ENTITY_STATUS_PERSON_DECEASED_ANNOUNCED', LastmodifiedDate = CAST( GETDATE() AS Date ), LastmodifiedTime = CAST( GETDATE() AS Time ), LastmodifiedUserName = @CurrentUserName Where EntityID = @l_EntityID;
		Set @Eredmeny = 'TASK_DETAILED_STATUS_DECEASED' /* elhunyt */;
		Set @l_vege = 'T'; 
	End;

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	If @l_vege = 'F' 
	and @DeregistrationDate is not NULL
	Begin
		/* 11. NEM TÖLTÜNK BE CÍMET */
		Set @l_vege = 'T';
		Set @Eredmeny = 'TASK_DETAILED_STATUS_NO_NEW_ADDRESS' /* nincsujcim */;
	End;

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* - ÚJ cím  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
IF @ValidationRecordCode = 'BOOLEAN_FALSE'
Begin /* 0 */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

	If @l_vege = 'F' 
	and ISNULL(@pLevel,'') ='érvénytelen lakcím'
	Begin /* 1 */
		IF Trim(Trim(Isnull(@FCountry,'')) + Trim(Isnull(@FZipCode,'')) + Trim(Isnull(@FState,'')) + Trim(Isnull(@FCity,'')) + Trim(Isnull(@FAddress,''))) <> ''
		Begin /* 2 */ /*  Van külföldi cím ? */

			If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
					and 
						Replace(Trim(Replace(Replace(
						Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,'')) 
						+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
						+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
						+ Trim(Isnull(f0.HouseNr,'')) + Trim(Isnull(f0.LandRegisterReference,''))
						+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
						+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
					= 
						Replace(Trim(Replace(Replace(
						Trim(Isnull(@CodeFCountry,'')) + Trim(Isnull(@FZipCode,'')) 
						+ /*Trim(Isnull(@FState,'')) +*/ Trim(Isnull(@FCity,'')) 
						+ Trim(Isnull(@FAddress,'')),' ',''),'.','')),' ','')   )
			Begin /* 3 */ /* Új "Külföldi cím" egyezik korábbi  "Levelezési címmel" ? */
			-- előző levelezési Cím érvénytelenítése:
				Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED', 
					LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
					where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE';
			-- új külföldi levelezési cím felvitele:
				-- New ObjectID:
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
					SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				SET @l_ObjectID = @@Identity;

				INSERT INTO PRT.Address(
					AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
					PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
					StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
					CreationUserName, Comments, AssetID, DataOriginCode)
				SELECT
					'ADDRESS_TYPE_PERSON_RESIDENCE' as AddressType, 
					'SPECIAL_ADDRESS_STRUCTURE_NORMAL' as AddressStructure, 
					@CodeFCountry as CountryID,
					NULL as CountryClassCode, 
					@FZipCode as ZipCode, 
					@FCity as Settlement, 
					NULL as District, 
					@FAddress as PublicPlaceName, 
					--@CodeFPublicPlaceType as PublicPlaceType, 
					NULL as PublicPlaceType, 
					NULL as HouseNr, 
					NULL as LandRegisterReference, 
					NULL as Staircase, 
					NULL as Building, 
					NULL as [Floor], 
					NULL as Door, 
					CAST( GETDATE() AS Date ) as ValidFrom, 
					NULL as ValidUntil, 
					'STATUS_NORMAL' as StatusCode, 
					(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
					@l_ObjectID as ObjectID, 
					NULL as PropertyID, 
					NULL as DataSource, 
					--'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
					@p_SourceInterfaceType as SourceInterfaceType, 
					@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
					CAST( GETDATE() AS Date ) as CreationDate, 
					CAST( GETDATE() AS Time ) as CreationTime, 
					@CurrentUserName as CreationUserName, 
					NULL as Comments, 
					NULL as AssetID, 
					'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
				SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
			End; /*3 */

		End; /* 2 */
		Set @l_vege = 'T';
	End; /* 1 */ /* and ISNULL(@pLevel,'') ='érvénytelen lakcím' */ 
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/

	If @l_vege = 'F' 
	and ISNULL(@pLevel,'') ='településszintű'
	Begin /* 1 */
		If Trim(Trim(Isnull(@PZipCode,'')) + Trim(Isnull(@PCity,''))
			+ Trim(Isnull(@PPublicPlaceName,'')) + Trim(Isnull(@PPublicPlaceType,''))
			+ Trim(Isnull(@PHouseNr,'')) + Trim(Isnull(@PBuilding,''))
			+ Trim(Isnull(@PStaircase,'')) + Trim(Isnull(@PFloor,''))
			+ Trim(Isnull(@PDoor,''))) <> ''
		Begin /* 2 */

			-- Új állandó lakcím egyezik korábbi állandó lakcímmel?
			If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_PERMANENT'
				and 
					Replace(Trim(Replace(Replace(
					Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
					+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
					+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
					+ Trim(Isnull(f0.HouseNr,'')) /*+ Trim(Isnull(f0.LandRegisterReference,''))*/
					+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
					+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
				= 
					Replace(Trim(Replace(Replace(
					Trim(Isnull(@l_CountryIDHUN,'')) + Trim(Isnull(@PZipCode,'')) 
					+ /*Trim(Isnull(@PFState,'')) +*/ Trim(Isnull(@PCity,'')) 
					+ Trim(Isnull(@PPublicPlaceName,'')) + Trim(Isnull(@CodePPublicPlaceType,''))
					+ Trim(Isnull(@PHouseNr,'')) /*+ Trim(Isnull(@PLandRegisterReference,''))*/
					+ Trim(Isnull(@PStaircase,'')) + Trim(Isnull(@PBuilding,''))
					+ Trim(Isnull(@PFloor,'')) + Trim(Isnull(@PDoor,'')),' ',''),'.','')),' ',''))
			Begin /* 3 */
			-- előző állandó Cím érvénytelenítése:
				Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED',
					LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
					where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_PERMANENT';
			-- új állandó cím felvitele:
				-- New ObjectID:
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
					SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				SET @l_ObjectID = @@Identity;

				INSERT INTO PRT.Address(
					AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
					PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
					StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
					CreationUserName, Comments, AssetID, DataOriginCode)
				SELECT
					'ADDRESS_TYPE_PERSON_PERMANENT' as AddressType, 
					'SPECIAL_ADDRESS_STRUCTURE_CITY' as AddressStructure, 
					@l_CountryIDHUN as CountryID,
					NULL as CountryClassCode, 
					@PZipCode as ZipCode, 
					@PCity as Settlement, 
					NULL as District, 
					@PPublicPlaceName as PublicPlaceName, 
					@CodePPublicPlaceType as PublicPlaceType, 
					@PHouseNr as HouseNr, 
					NULL as LandRegisterReference, 
					@PStaircase as Staircase, 
					@PBuilding as Building, 
					@PFloor as [Floor], 
					@PDoor as Door, 
					CAST( GETDATE() AS Date ) as ValidFrom, 
					NULL as ValidUntil, 
					'STATUS_NORMAL' as StatusCode, 
					(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
					@l_ObjectID as ObjectID, 
					NULL as PropertyID, 
					NULL as DataSource, 
					--'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
					@p_SourceInterfaceType as SourceInterfaceType, 
					@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
					CAST( GETDATE() AS Date ) as CreationDate, 
					CAST( GETDATE() AS Time ) as CreationTime, 
					@CurrentUserName as CreationUserName, 
					NULL as Comments, 
					NULL as AssetID, 
					'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
				SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
			End; /* 3 */
		End; /* 2 */
		--Set @l_vege = 'T';
	End; /* 1 */
	
	If @l_vege = 'F' 
	and ISNULL(@pLevel,'') ='településszintű'
	Begin /* 1 */
		If Trim(Trim(Isnull(@TZipCode,'')) + Trim(Isnull(@TCity,''))
			+ Trim(Isnull(@TPublicPlaceName,'')) + Trim(Isnull(@TPublicPlaceType,''))
			+ Trim(Isnull(@THouseNr,'')) + Trim(Isnull(@TBuilding,''))
			+ Trim(Isnull(@TStaircase,'')) + Trim(Isnull(@TFloor,''))
			+ Trim(Isnull(@TDoor,''))) <> ''
		Begin /* 2 */

			/* Új ideiglenes lakcím egyezik korábbi levelezési címmel ? */
			If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
				and 
					Replace(Trim(Replace(Replace(
					Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
					+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
					+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
					+ Trim(Isnull(f0.HouseNr,'')) /*+ Trim(Isnull(f0.LandRegisterReference,''))*/
					+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
					+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
				= 
					Replace(Trim(Replace(Replace(
					Trim(Isnull(@l_CountryIDHUN,'')) + Trim(Isnull(@TZipCode,'')) 
					+ /*Trim(Isnull(@TFState,'')) +*/ Trim(Isnull(@TCity,'')) 
					+ Trim(Isnull(@TPublicPlaceName,'')) + Trim(Isnull(@CodeTPublicPlaceType,''))
					+ Trim(Isnull(@THouseNr,'')) /*+ Trim(Isnull(@TLandRegisterReference,''))*/
					+ Trim(Isnull(@TStaircase,'')) + Trim(Isnull(@TBuilding,''))
					+ Trim(Isnull(@TFloor,'')) + Trim(Isnull(@TDoor,'')),' ',''),'.','')),' ',''))
			Begin /* 3 */
			-- előző állandó Cím érvénytelenítése:
				Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED',
					LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
					where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE';
			-- új állandó cím felvitele:
				-- New ObjectID:
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
					SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				SET @l_ObjectID = @@Identity;

				INSERT INTO PRT.Address(
					AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
					PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
					StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
					CreationUserName, Comments, AssetID, DataOriginCode)
				SELECT
					'ADDRESS_TYPE_PERSON_RESIDENCE' as AddressType, 
					'SPECIAL_ADDRESS_STRUCTURE_CITY' as AddressStructure, 
					@l_CountryIDHUN as CountryID,
					NULL as CountryClassCode, 
					@TZipCode as ZipCode, 
					@TCity as Settlement, 
					NULL as District, 
					@TPublicPlaceName as PublicPlaceName, 
					@CodeTPublicPlaceType as PublicPlaceType, 
					@THouseNr as HouseNr, 
					NULL as LandRegisterReference, 
					@TStaircase as Staircase, 
					@TBuilding as Building, 
					@TFloor as [Floor], 
					@TDoor as Door, 
					CAST( GETDATE() AS Date ) as ValidFrom, 
					NULL as ValidUntil, 
					'STATUS_NORMAL' as StatusCode, 
					(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
					@l_ObjectID as ObjectID, 
					NULL as PropertyID, 
					NULL as DataSource, 
--					'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
					@p_SourceInterfaceType as SourceInterfaceType, 
					@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
					CAST( GETDATE() AS Date ) as CreationDate, 
					CAST( GETDATE() AS Time ) as CreationTime, 
					@CurrentUserName as CreationUserName, 
					NULL as Comments, 
					NULL as AssetID, 
					'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
				SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
			End; /* 3 */
		End; /* 2 */
		Set @l_vege = 'T';
	End; /* 1 */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	If @l_vege = 'F' 
	 /* Van érvényes "Állandó lakcím" ? */
	Begin /* 1 */
		If Trim(Trim(Isnull(@PZipCode,'')) + Trim(Isnull(@PCity,''))
			+ Trim(Isnull(@PPublicPlaceName,'')) + Trim(Isnull(@PPublicPlaceType,''))
			+ Trim(Isnull(@PHouseNr,'')) + Trim(Isnull(@PBuilding,''))
			+ Trim(Isnull(@PStaircase,'')) + Trim(Isnull(@PFloor,''))
			+ Trim(Isnull(@PDoor,''))) <> ''
		and ISNULL(@pLevel,'') =''
		Begin /* 2 */
		-- Új állandó lakcím egyezik korábbi állandó lakcímmel?
			If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_PERMANENT'
				and 
					Replace(Trim(Replace(Replace(
					Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
					+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
					+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
					+ Trim(Isnull(f0.HouseNr,'')) /*+ Trim(Isnull(f0.LandRegisterReference,''))*/
					+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
					+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
				= 
					Replace(Trim(Replace(Replace(
					Trim(Isnull(@l_CountryIDHUN,'')) + Trim(Isnull(@PZipCode,'')) 
					+ /*Trim(Isnull(@PFState,'')) +*/ Trim(Isnull(@PCity,'')) 
					+ Trim(Isnull(@PPublicPlaceName,'')) + Trim(Isnull(@CodePPublicPlaceType,''))
					+ Trim(Isnull(@PHouseNr,'')) /*+ Trim(Isnull(@PLandRegisterReference,''))*/
					+ Trim(Isnull(@PStaircase,'')) + Trim(Isnull(@PBuilding,''))
					+ Trim(Isnull(@PFloor,'')) + Trim(Isnull(@PDoor,'')),' ',''),'.','')),' ',''))
			Begin /* 3 */
			-- előző állandó Cím érvénytelenítése:
				Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED',
					LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
					where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_PERMANENT';
			-- új állandó cím felvitele:
				-- New ObjectID:
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
					SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				SET @l_ObjectID = @@Identity;

				INSERT INTO PRT.Address(
					AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
					PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
					StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
					CreationUserName, Comments, AssetID, DataOriginCode)
				SELECT
					'ADDRESS_TYPE_PERSON_PERMANENT' as AddressType, 
					'SPECIAL_ADDRESS_STRUCTURE_NORMAL' as AddressStructure, 
					@l_CountryIDHUN as CountryID,
					NULL as CountryClassCode, 
					@PZipCode as ZipCode, 
					@PCity as Settlement, 
					NULL as District, 
					@PPublicPlaceName as PublicPlaceName, 
					@CodePPublicPlaceType as PublicPlaceType, 
					@PHouseNr as HouseNr, 
					NULL as LandRegisterReference, 
					@PStaircase as Staircase, 
					@PBuilding as Building, 
					@PFloor as [Floor], 
					@PDoor as Door, 
					CAST( GETDATE() AS Date ) as ValidFrom, 
					NULL as ValidUntil, 
					'STATUS_NORMAL' as StatusCode, 
					(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
					@l_ObjectID as ObjectID, 
					NULL as PropertyID, 
					NULL as DataSource, 
					--'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
					@p_SourceInterfaceType as SourceInterfaceType, 
					@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
					CAST( GETDATE() AS Date ) as CreationDate, 
					CAST( GETDATE() AS Time ) as CreationTime, 
					@CurrentUserName as CreationUserName, 
					NULL as Comments, 
					NULL as AssetID, 
					'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
				SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
			End; /* 3 */
		/* Van külföldi és ideiglenes cím is ? */
			IF Trim(Trim(Isnull(@FCountry,'')) + Trim(Isnull(@FZipCode,'')) + Trim(Isnull(@FState,'')) + Trim(Isnull(@FCity,'')) + Trim(Isnull(@FAddress,''))) <> ''

				AND
		
			Trim(Trim(Isnull(@TZipCode,'')) + Trim(Isnull(@TCity,''))
			+ Trim(Isnull(@TPublicPlaceName,'')) + Trim(Isnull(@TPublicPlaceType,''))
			+ Trim(Isnull(@THouseNr,'')) + Trim(Isnull(@TBuilding,''))
			+ Trim(Isnull(@TStaircase,'')) + Trim(Isnull(@TFloor,''))
			+ Trim(Isnull(@TDoor,''))) <> ''
			Begin /* 3 */
				If 
				'1' = '1'
				Begin /* 4 */
				/* Ideiglenes cím -> levelezési cím */
					/* Új ideiglenes lakcím egyezik korábbi levelezési címmel ? */
					If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
						and Isnull(f0.ValidFrom,'1901-01-01') < Isnull(@TRegistrationDate,'1901-01-01')
						and 
							Replace(Trim(Replace(Replace(
							Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
							+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
							+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
							+ Trim(Isnull(f0.HouseNr,'')) /*+ Trim(Isnull(f0.LandRegisterReference,''))*/
							+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
							+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
						= 
							Replace(Trim(Replace(Replace(
							Trim(Isnull(@l_CountryIDHUN,'')) + Trim(Isnull(@TZipCode,'')) 
							+ /*Trim(Isnull(@TFState,'')) +*/ Trim(Isnull(@TCity,'')) 
							+ Trim(Isnull(@TPublicPlaceName,'')) + Trim(Isnull(@CodeTPublicPlaceType,''))
							+ Trim(Isnull(@THouseNr,'')) /*+ Trim(Isnull(@TLandRegisterReference,''))*/
							+ Trim(Isnull(@TStaircase,'')) + Trim(Isnull(@TBuilding,''))
							+ Trim(Isnull(@TFloor,'')) + Trim(Isnull(@TDoor,'')),' ',''),'.','')),' ',''))
					
					Begin /* 5 */
					-- előző állandó Cím érvénytelenítése:
						Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED',
							LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
							where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE';
					-- új állandó cím felvitele:
						-- New ObjectID:
						INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
							SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
						SET @l_ObjectID = @@Identity;

						INSERT INTO PRT.Address(
							AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
							PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
							StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
							CreationUserName, Comments, AssetID, DataOriginCode)
						SELECT
							'ADDRESS_TYPE_PERSON_RESIDENCE' as AddressType, 
							'SPECIAL_ADDRESS_STRUCTURE_CITY' as AddressStructure, 
							@l_CountryIDHUN as CountryID,
							NULL as CountryClassCode, 
							@TZipCode as ZipCode, 
							@TCity as Settlement, 
							NULL as District, 
							@TPublicPlaceName as PublicPlaceName, 
							@CodeTPublicPlaceType as PublicPlaceType, 
							@THouseNr as HouseNr, 
							NULL as LandRegisterReference, 
							@TStaircase as Staircase, 
							@TBuilding as Building, 
							@TFloor as [Floor], 
							@TDoor as Door, 
							CAST( GETDATE() AS Date ) as ValidFrom, 
							NULL as ValidUntil, 
							'STATUS_NORMAL' as StatusCode, 
							(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
							@l_ObjectID as ObjectID, 
							NULL as PropertyID, 
							NULL as DataSource, 
		--					'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
							@p_SourceInterfaceType as SourceInterfaceType, 
							@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
							CAST( GETDATE() AS Date ) as CreationDate, 
							CAST( GETDATE() AS Time ) as CreationTime, 
							@CurrentUserName as CreationUserName, 
							NULL as Comments, 
							NULL as AssetID, 
							'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
						SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
					End; /* 5 */
				End; /* 4 */
				
				--If Isnull(@PRegistrationDate,'1901-01-01') < Isnull(@TRegistrationDate,'1901-01-01')
				If '1' = '1'
				Begin /* 4 */
				/* Külföldi cím -> levelezési cím */
					If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
						and Isnull(f0.ValidFrom,'1901-01-01') < CAST( GETDATE() AS Date )
						and 
							Replace(Trim(Replace(Replace(
							Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
							+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
							+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
							+ Trim(Isnull(f0.HouseNr,'')) + Trim(Isnull(f0.LandRegisterReference,''))
							+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
							+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
						= 
							Replace(Trim(Replace(Replace(
							Trim(Isnull(@CodeFCountry,'')) + Trim(Isnull(@FZipCode,'')) 
							+ /*Trim(Isnull(@FState,'')) +*/ Trim(Isnull(@FCity,'')) 
							+ Trim(Isnull(@FAddress,'')),' ',''),'.','')),' ',''))
					Begin /* 5 */
					-- előző levelezési Cím érvénytelenítése:
						Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED', 
							LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
							where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE';
					-- új külföldi levelezési cím felvitele:
						-- New ObjectID:
						INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
							SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
						SET @l_ObjectID = @@Identity;

						INSERT INTO PRT.Address(
							AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
							PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
							StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
							CreationUserName, Comments, AssetID, DataOriginCode)
						SELECT
							'ADDRESS_TYPE_PERSON_RESIDENCE' as AddressType, 
							'SPECIAL_ADDRESS_STRUCTURE_NORMAL' as AddressStructure, 
							@CodeFCountry as CountryID,
							NULL as CountryClassCode, 
							@FZipCode as ZipCode, 
							@FCity as Settlement, 
							NULL as District, 
							@FAddress as PublicPlaceName, 
							--@CodePPublicPlaceType as PublicPlaceType, 
							NULL as PublicPlaceType, 
							NULL as HouseNr, 
							NULL as LandRegisterReference, 
							NULL as Staircase, 
							NULL as Building, 
							NULL as [Floor], 
							NULL as Door, 
							CAST( GETDATE() AS Date ) as ValidFrom, 
							NULL as ValidUntil, 
							'STATUS_NORMAL' as StatusCode, 
							(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
							@l_ObjectID as ObjectID, 
							NULL as PropertyID, 
							NULL as DataSource, 
							--'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
							@p_SourceInterfaceType as SourceInterfaceType, 
							@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
							CAST( GETDATE() AS Date ) as CreationDate, 
							CAST( GETDATE() AS Time ) as CreationTime, 
							@CurrentUserName as CreationUserName, 
							NULL as Comments, 
							NULL as AssetID, 
							'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
						SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
					End; /* 5 */
				End; /* 4 */
			End /* 3 */
			Set @l_vege = 'T';
		End; /* 2 */
	End; /* 1 */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	If @l_vege = 'F' 
	 /* NINCS érvényes "Állandó lakcím" ? */
	Begin /* 1 */
		If Trim(Trim(Isnull(@PZipCode,'')) + Trim(Isnull(@PCity,''))
			+ Trim(Isnull(@PPublicPlaceName,'')) + Trim(Isnull(@PPublicPlaceType,''))
			+ Trim(Isnull(@PHouseNr,'')) + Trim(Isnull(@PBuilding,''))
			+ Trim(Isnull(@PStaircase,'')) + Trim(Isnull(@PFloor,''))
			+ Trim(Isnull(@PDoor,''))) = ''
		Begin /* 2 */
		/* Van külföldi és ideiglenes cím is ? */
			IF Trim(Trim(Isnull(@FCountry,'')) + Trim(Isnull(@FZipCode,'')) + Trim(Isnull(@FState,'')) + Trim(Isnull(@FCity,'')) + Trim(Isnull(@FAddress,''))) <> ''

				AND
		
			Trim(Trim(Isnull(@TZipCode,'')) + Trim(Isnull(@TCity,''))
			+ Trim(Isnull(@TPublicPlaceName,'')) + Trim(Isnull(@TPublicPlaceType,''))
			+ Trim(Isnull(@THouseNr,'')) + Trim(Isnull(@TBuilding,''))
			+ Trim(Isnull(@TStaircase,'')) + Trim(Isnull(@TFloor,''))
			+ Trim(Isnull(@TDoor,''))) <> ''
			Begin /* 3 */
				--If Isnull(@PRegistrationDate,'1901-01-01') >= Isnull(@TRegistrationDate,'1901-01-01')
				If '1' = '1'
				Begin /* 4 */
				/* Ideiglenes cím -> levelezési cím */
				/* Új ideiglenes lakcím egyezik korábbi levelezési címmel ? */
					If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
						and Isnull(f0.ValidFrom,'1901-01-01') < Isnull(@TRegistrationDate,'1901-01-01')
						and 
							Replace(Trim(Replace(Replace(
							Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
							+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
							+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
							+ Trim(Isnull(f0.HouseNr,'')) /*+ Trim(Isnull(f0.LandRegisterReference,''))*/
							+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
							+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
						= 
							Replace(Trim(Replace(Replace(
							Trim(Isnull(@l_CountryIDHUN,'')) + Trim(Isnull(@TZipCode,'')) 
							+ /*Trim(Isnull(@TFState,'')) +*/ Trim(Isnull(@TCity,'')) 
							+ Trim(Isnull(@TPublicPlaceName,'')) + Trim(Isnull(@CodeTPublicPlaceType,''))
							+ Trim(Isnull(@THouseNr,'')) /*+ Trim(Isnull(@TLandRegisterReference,''))*/
							+ Trim(Isnull(@TStaircase,'')) + Trim(Isnull(@TBuilding,''))
							+ Trim(Isnull(@TFloor,'')) + Trim(Isnull(@TDoor,'')),' ',''),'.','')),' ',''))
					Begin /* 5 */
					-- előző állandó Cím érvénytelenítése:
						Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED',
							LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
							where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE';
					-- új állandó cím felvitele:
						-- New ObjectID:
						INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
							SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
						SET @l_ObjectID = @@Identity;

						INSERT INTO PRT.Address(
							AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
							PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
							StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
							CreationUserName, Comments, AssetID, DataOriginCode)
						SELECT
							'ADDRESS_TYPE_PERSON_RESIDENCE' as AddressType, 
							'SPECIAL_ADDRESS_STRUCTURE_CITY' as AddressStructure, 
							@l_CountryIDHUN as CountryID,
							NULL as CountryClassCode, 
							@TZipCode as ZipCode, 
							@TCity as Settlement, 
							NULL as District, 
							@TPublicPlaceName as PublicPlaceName, 
							@CodeTPublicPlaceType as PublicPlaceType, 
							@THouseNr as HouseNr, 
							NULL as LandRegisterReference, 
							@TStaircase as Staircase, 
							@TBuilding as Building, 
							@TFloor as [Floor], 
							@TDoor as Door, 
							CAST( GETDATE() AS Date ) as ValidFrom, 
							NULL as ValidUntil, 
							'STATUS_NORMAL' as StatusCode, 
							(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
							@l_ObjectID as ObjectID, 
							NULL as PropertyID, 
							NULL as DataSource, 
		--					'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
							@p_SourceInterfaceType as SourceInterfaceType, 
							@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
							CAST( GETDATE() AS Date ) as CreationDate, 
							CAST( GETDATE() AS Time ) as CreationTime, 
							@CurrentUserName as CreationUserName, 
							NULL as Comments, 
							NULL as AssetID, 
							'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
						SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett*/;
					End; /* 5 */
				End; /* 4 */
				--If Isnull(@PRegistrationDate,'1901-01-01') < Isnull(@TRegistrationDate,'1901-01-01')
				If '1' = '1'
				Begin /* 4 */
				/* Külföldi cím -> levelezési cím */
					If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
						and Isnull(f0.ValidFrom,'1901-01-01') < CAST( GETDATE() AS Date )
						and 
							Replace(Trim(Replace(Replace(
							Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
							+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
							+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
							+ Trim(Isnull(f0.HouseNr,'')) + Trim(Isnull(f0.LandRegisterReference,''))
							+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
							+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
						= 
							Replace(Trim(Replace(Replace(
							Trim(Isnull(@CodeFCountry,'')) + Trim(Isnull(@FZipCode,'')) 
							+ /*Trim(Isnull(@FState,'')) +*/ Trim(Isnull(@FCity,'')) 
							+ Trim(Isnull(@FAddress,'')),' ',''),'.','')),' ',''))
					Begin /* 5 */
					-- előző levelezési Cím érvénytelenítése:
						Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED', 
							LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
							where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE';
					-- új külföldi levelezési cím felvitele:
						-- New ObjectID:
						INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
							SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
						SET @l_ObjectID = @@Identity;

						INSERT INTO PRT.Address(
							AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
							PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
							StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
							CreationUserName, Comments, AssetID, DataOriginCode)
						SELECT
							'ADDRESS_TYPE_PERSON_RESIDENCE' as AddressType, 
							'SPECIAL_ADDRESS_STRUCTURE_NORMAL' as AddressStructure, 
							@CodeFCountry as CountryID,
							NULL as CountryClassCode, 
							@FZipCode as ZipCode, 
							@FCity as Settlement, 
							NULL as District, 
							@FAddress as PublicPlaceName, 
							--@CodePPublicPlaceType as PublicPlaceType, 
							NULL as PublicPlaceType,
							NULL as HouseNr, 
							NULL as LandRegisterReference, 
							NULL as Staircase, 
							NULL as Building, 
							NULL as [Floor], 
							NULL as Door, 
							CAST( GETDATE() AS Date ) as ValidFrom, 
							NULL as ValidUntil, 
							'STATUS_NORMAL' as StatusCode, 
							(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
							@l_ObjectID as ObjectID, 
							NULL as PropertyID, 
							NULL as DataSource, 
							--'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
							@p_SourceInterfaceType as SourceInterfaceType, 
							@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
							CAST( GETDATE() AS Date ) as CreationDate, 
							CAST( GETDATE() AS Time ) as CreationTime, 
							@CurrentUserName as CreationUserName, 
							NULL as Comments, 
							NULL as AssetID, 
							'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
						SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
					End; /* 5 */
				End; /* 4 */
			End /* 3 */
			Set @l_vege = 'T';
		End; /* 2 */
	End; /* 1 */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	If @l_vege = 'F' 
	Begin /* 1 */
		 /* VAN Ideiglenes cím ? */
		If Trim(Trim(Isnull(@TZipCode,'')) + Trim(Isnull(@TCity,''))
			+ Trim(Isnull(@TPublicPlaceName,'')) + Trim(Isnull(@TPublicPlaceType,''))
			+ Trim(Isnull(@THouseNr,'')) + Trim(Isnull(@TBuilding,''))
			+ Trim(Isnull(@TStaircase,'')) + Trim(Isnull(@TFloor,''))
			+ Trim(Isnull(@TDoor,''))) <> ''
		Begin /* 2 */
			/* Új ideiglenes lakcím egyezik korábbi levelezési címmel ? */
			If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
				and 
					Replace(Trim(Replace(Replace(
					Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
					+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
					+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
					+ Trim(Isnull(f0.HouseNr,'')) /*+ Trim(Isnull(f0.LandRegisterReference,''))*/
					+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
					+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
				= 
					Replace(Trim(Replace(Replace(
					Trim(Isnull(@l_CountryIDHUN,'')) + Trim(Isnull(@TZipCode,'')) 
					+ /*Trim(Isnull(@TFState,'')) +*/ Trim(Isnull(@TCity,'')) 
					+ Trim(Isnull(@TPublicPlaceName,'')) + Trim(Isnull(@CodeTPublicPlaceType,''))
					+ Trim(Isnull(@THouseNr,'')) /*+ Trim(Isnull(@TLandRegisterReference,''))*/
					+ Trim(Isnull(@TStaircase,'')) + Trim(Isnull(@TBuilding,''))
					+ Trim(Isnull(@TFloor,'')) + Trim(Isnull(@TDoor,'')),' ',''),'.','')),' ',''))
			Begin /* 3 */
			-- előző állandó Cím érvénytelenítése:
				Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED',
					LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
					where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE';
			-- új állandó cím felvitele:
				-- New ObjectID:
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
					SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				SET @l_ObjectID = @@Identity;

				INSERT INTO PRT.Address(
					AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
					PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
					StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
					CreationUserName, Comments, AssetID, DataOriginCode)
				SELECT
					'ADDRESS_TYPE_PERSON_RESIDENCE' as AddressType, 
					'SPECIAL_ADDRESS_STRUCTURE_NORMAL' as AddressStructure, 
					@l_CountryIDHUN as CountryID,
					NULL as CountryClassCode, 
					@TZipCode as ZipCode, 
					@TCity as Settlement, 
					NULL as District, 
					@TPublicPlaceName as PublicPlaceName, 
					@CodeTPublicPlaceType as PublicPlaceType, 
					@THouseNr as HouseNr, 
					NULL as LandRegisterReference, 
					@TStaircase as Staircase, 
					@TBuilding as Building, 
					@TFloor as [Floor], 
					@TDoor as Door, 
					CAST( GETDATE() AS Date ) as ValidFrom, 
					NULL as ValidUntil, 
					'STATUS_NORMAL' as StatusCode, 
					(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
					@l_ObjectID as ObjectID, 
					NULL as PropertyID, 
					NULL as DataSource, 
--					'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
					@p_SourceInterfaceType as SourceInterfaceType, 
					@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
					CAST( GETDATE() AS Date ) as CreationDate, 
					CAST( GETDATE() AS Time ) as CreationTime, 
					@CurrentUserName as CreationUserName, 
					NULL as Comments, 
					NULL as AssetID, 
					'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
				SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
			End; /* 3 */
			Set @l_vege = 'T';
		End; /* 2 */
	End; /* 1 */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
	If @l_vege = 'F' 
	Begin /* 1 */
		IF Trim(Trim(Isnull(@FCountry,'')) + Trim(Isnull(@FZipCode,'')) + Trim(Isnull(@FState,'')) + Trim(Isnull(@FCity,'')) + Trim(Isnull(@FAddress,''))) <> ''
		Begin /* 2 */
			If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
					and 
						Replace(Trim(Replace(Replace(
						Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
						+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
						+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
						+ Trim(Isnull(f0.HouseNr,'')) + Trim(Isnull(f0.LandRegisterReference,''))
						+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
						+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
					= 
						Replace(Trim(Replace(Replace(
						Trim(Isnull(@CodeFCountry,'')) + Trim(Isnull(@FZipCode,'')) 
						+ /*Trim(Isnull(@FState,'')) +*/ Trim(Isnull(@FCity,'')) 
						+ Trim(Isnull(@FAddress,'')),' ',''),'.','')),' ',''))
			Begin /* 3 */
			-- előző levelezési Cím érvénytelenítése:
				Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED', 
					LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
					where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE';
			-- új külföldi levelezési cím felvitele:
				-- New ObjectID:
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
					SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				SET @l_ObjectID = @@Identity;

				INSERT INTO PRT.Address(
					AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
					PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
					StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
					CreationUserName, Comments, AssetID, DataOriginCode)
				SELECT
					'ADDRESS_TYPE_PERSON_RESIDENCE' as AddressType, 
					'SPECIAL_ADDRESS_STRUCTURE_NORMAL' as AddressStructure, 
					@CodeFCountry as CountryID,
					NULL as CountryClassCode, 
					@FZipCode as ZipCode, 
					@FCity as Settlement, 
					NULL as District, 
					@FAddress as PublicPlaceName, 
					--@CodePPublicPlaceType as PublicPlaceType, 
					NULL as PublicPlaceType, 
					NULL as HouseNr, 
					NULL as LandRegisterReference, 
					NULL as Staircase, 
					NULL as Building, 
					NULL as [Floor], 
					NULL as Door, 
					CAST( GETDATE() AS Date ) as ValidFrom, 
					NULL as ValidUntil, 
					'STATUS_NORMAL' as StatusCode, 
					(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
					@l_ObjectID as ObjectID, 
					NULL as PropertyID, 
					NULL as DataSource, 
					--'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
					@p_SourceInterfaceType as SourceInterfaceType, 
					@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
					CAST( GETDATE() AS Date ) as CreationDate, 
					CAST( GETDATE() AS Time ) as CreationTime, 
					@CurrentUserName as CreationUserName, 
					NULL as Comments, 
					NULL as AssetID, 
					'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
				SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett*/ ;
			End; /*3 */
		End; /* 2 */
		Set @l_vege = 'T';
	End; /* 1 */
End; /* 0 - @ValidationRecordCode = 'BOOLEAN_FALSE'*/

---------------------------------------------------------------------------------------------------------------------------------------------
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
/* - - Validáció - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
IF @ValidationRecordCode = 'BOOLEAN_TRUE'
Begin /* 0 */
	If @l_vege = 'F' 
	 /* Van érvényes "Állandó lakcím" ? */
	Begin /* 1 */
		If Trim(Trim(Isnull(@PZipCode,'')) + Trim(Isnull(@PCity,''))
			+ Trim(Isnull(@PPublicPlaceName,'')) + Trim(Isnull(@PPublicPlaceType,''))
			+ Trim(Isnull(@PHouseNr,'')) + Trim(Isnull(@PBuilding,''))
			+ Trim(Isnull(@PStaircase,'')) + Trim(Isnull(@PFloor,''))
			+ Trim(Isnull(@PDoor,''))) <> ''
		Begin /* 2 */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
			If Isnull(@PLevel,'') = '' /* A "Lakóhely érvényessége" üres? */
			Begin /* 3 */
			-- Új állandó lakcím egyezik korábbi állandó lakcímmel?
				If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_PERMANENT'
					--and f0.ValidUntil is NULL
					and Isnull(f0.ValidFrom,'1901-01-01') < Isnull(@PRegistrationDate,'1901-01-01')
					and 
						Replace(Trim(Replace(Replace(
						Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
						+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
						+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
						+ Trim(Isnull(f0.HouseNr,'')) /*+ Trim(Isnull(f0.LandRegisterReference,''))*/
						+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
						+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
					= 
						Replace(Trim(Replace(Replace(
						Trim(Isnull(@l_CountryIDHUN,'')) + Trim(Isnull(@PZipCode,'')) 
						+ /*Trim(Isnull(@PFState,'')) +*/ Trim(Isnull(@PCity,'')) 
						+ Trim(Isnull(@PPublicPlaceName,'')) + Trim(Isnull(@CodePPublicPlaceType,''))
						+ Trim(Isnull(@PHouseNr,'')) /*+ Trim(Isnull(@PLandRegisterReference,''))*/
						+ Trim(Isnull(@PStaircase,'')) + Trim(Isnull(@PBuilding,''))
						+ Trim(Isnull(@PFloor,'')) + Trim(Isnull(@PDoor,'')),' ',''),'.','')),' ',''))
				Begin /* 4 */
				-- előző állandó Cím érvénytelenítése:
					Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED',
						LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
						where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_PERMANENT';
				-- új állandó cím felvitele:
					-- New ObjectID:
					INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
						SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
					SET @l_ObjectID = @@Identity;

					INSERT INTO PRT.Address(
						AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
						PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
						StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
						CreationUserName, Comments, AssetID, DataOriginCode)
					SELECT
						'ADDRESS_TYPE_PERSON_PERMANENT' as AddressType, 
						'SPECIAL_ADDRESS_STRUCTURE_NORMAL' as AddressStructure,
						@l_CountryIDHUN as CountryID,
						NULL as CountryClassCode, 
						@PZipCode as ZipCode, 
						@PCity as Settlement, 
						NULL as District, 
						@PPublicPlaceName as PublicPlaceName, 
						@CodePPublicPlaceType as PublicPlaceType, 
						@PHouseNr as HouseNr, 
						NULL as LandRegisterReference, 
						@PStaircase as Staircase, 
						@PBuilding as Building, 
						@PFloor as [Floor], 
						@PDoor as Door, 
						CAST( GETDATE() AS Date ) as ValidFrom, 
						NULL as ValidUntil, 
						'STATUS_NORMAL' as StatusCode, 
						(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
						@l_ObjectID as ObjectID, 
						NULL as PropertyID, 
						NULL as DataSource, 
						--'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
						@p_SourceInterfaceType as SourceInterfaceType, 
						@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
						CAST( GETDATE() AS Date ) as CreationDate, 
						CAST( GETDATE() AS Time ) as CreationTime, 
						@CurrentUserName as CreationUserName, 
						NULL as Comments, 
						NULL as AssetID, 
						'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
					SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
				End; /* 4 */
			End; /* 3 */

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
			If Isnull(@PLevel,'') = 'településszintű'
			Begin /* 3 */
			-- Új állandó lakcím egyezik korábbi állandó lakcímmel?
				If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_PERMANENT'
					--and f0.ValidUntil is NULL
					and Isnull(f0.ValidFrom,'1901-01-01') < Isnull(@PRegistrationDate,'1901-01-01')
					/*
					and 
						Replace(Trim(Replace(Replace(
						Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
						+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
						+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
						+ Trim(Isnull(f0.HouseNr,'')) /*+ Trim(Isnull(f0.LandRegisterReference,''))*/
						+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
						+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
					= 
						Replace(Trim(Replace(Replace(
						Trim(Isnull(@l_CountryIDHUN,'')) + Trim(Isnull(@PZipCode,'')) 
						+ /*Trim(Isnull(@PFState,'')) +*/ Trim(Isnull(@PCity,'')) 
						+ Trim(Isnull(@PPublicPlaceName,'')) + Trim(Isnull(@CodePPublicPlaceType,''))
						+ Trim(Isnull(@PHouseNr,'')) /*+ Trim(Isnull(@PLandRegisterReference,''))*/
						+ Trim(Isnull(@PStaircase,'')) + Trim(Isnull(@PBuilding,''))
						+ Trim(Isnull(@PFloor,'')) + Trim(Isnull(@PDoor,'')),' ',''),'.','')),' ','')
					*/
					)

				Begin /* 4 */
				-- előző állandó Cím érvénytelenítése:
					Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED',
						LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
						where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_PERMANENT';
				-- új állandó cím felvitele:
					-- New ObjectID:
					INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
						SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
					SET @l_ObjectID = @@Identity;

					INSERT INTO PRT.Address(
						AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
						PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
						StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
						CreationUserName, Comments, AssetID, DataOriginCode)
					SELECT
						'ADDRESS_TYPE_PERSON_PERMANENT' as AddressType, 
						'SPECIAL_ADDRESS_STRUCTURE_CITY' as AddressStructure, 
						@l_CountryIDHUN as CountryID,
						NULL as CountryClassCode, 
						@PZipCode as ZipCode, 
						@PCity as Settlement, 
						NULL as District, 
						@PPublicPlaceName as PublicPlaceName, 
						@CodePPublicPlaceType as PublicPlaceType, 
						@PHouseNr as HouseNr, 
						NULL as LandRegisterReference, 
						@PStaircase as Staircase, 
						@PBuilding as Building, 
						@PFloor as [Floor], 
						@PDoor as Door, 
						CAST( GETDATE() AS Date ) as ValidFrom, 
						NULL as ValidUntil, 
						'STATUS_NORMAL' as StatusCode, 
						(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
						@l_ObjectID as ObjectID, 
						NULL as PropertyID, 
						NULL as DataSource, 
						--'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
						@p_SourceInterfaceType as SourceInterfaceType, 
						@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
						CAST( GETDATE() AS Date ) as CreationDate, 
						CAST( GETDATE() AS Time ) as CreationTime, 
						@CurrentUserName as CreationUserName, 
						NULL as Comments, 
						NULL as AssetID, 
						'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
					SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
				End; /* 4 */
			End; /* 3 */
			
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -*/
			If Isnull(@PLevel,'') = 'érvénytelen lakcím'
			Begin /* 3 */
			-- Új állandó lakcím egyezik korábbi állandó lakcímmel?
				If Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_PERMANENT'
					and f0.DataOriginCode <> 'DATA_ORIGIN_CLIENT'
					and 
						Trim(Replace(Replace(
						Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
						+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
						+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
						+ Trim(Isnull(f0.HouseNr,'')) /*+ Trim(Isnull(f0.LandRegisterReference,''))*/
						+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
						+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.',''))
					= 
						Trim(Replace(Replace(
						Trim(Isnull(@l_CountryIDHUN,'')) + Trim(Isnull(@PZipCode,'')) 
						+ /*Trim(Isnull(@PFState,'')) +*/ Trim(Isnull(@PCity,'')) 
						+ Trim(Isnull(@PPublicPlaceName,'')) + Trim(Isnull(@CodePPublicPlaceType,''))
						+ Trim(Isnull(@PHouseNr,'')) /*+ Trim(Isnull(@PLandRegisterReference,''))*/
						+ Trim(Isnull(@PStaircase,'')) + Trim(Isnull(@PBuilding,''))
						+ Trim(Isnull(@PFloor,'')) + Trim(Isnull(@PDoor,'')),' ',''),'.','')))
				Begin /* 4 */
				-- előző állandó Cím érvénytelenítése:
					Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED',
						LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
						where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_PERMANENT' and StatusCode <> 'DATA_ORIGIN_CLIENT';
				End; /* 4 */

				-- Új állandó lakcím egyezik korábbi levelezési címmel?
				If Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
					and f0.DataOriginCode <> 'DATA_ORIGIN_CLIENT'
					and 
						Trim(Replace(Replace(
						Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
						+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
						+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
						+ Trim(Isnull(f0.HouseNr,'')) /*+ Trim(Isnull(f0.LandRegisterReference,''))*/
						+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
						+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.',''))
					= 
						Trim(Replace(Replace(
						Trim(Isnull(@l_CountryIDHUN,'')) + Trim(Isnull(@PZipCode,'')) 
						+ /*Trim(Isnull(@PFState,'')) +*/ Trim(Isnull(@PCity,'')) 
						+ Trim(Isnull(@PPublicPlaceName,'')) + Trim(Isnull(@CodePPublicPlaceType,''))
						+ Trim(Isnull(@PHouseNr,'')) /*+ Trim(Isnull(@PLandRegisterReference,''))*/
						+ Trim(Isnull(@PStaircase,'')) + Trim(Isnull(@PBuilding,''))
						+ Trim(Isnull(@PFloor,'')) + Trim(Isnull(@PDoor,'')),' ',''),'.','')))
				Begin /* 4 */
				-- előző állandó Cím érvénytelenítése:
					Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED',
						LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
						where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE' and StatusCode <> 'DATA_ORIGIN_CLIENT';
				End; /* 4 */
			End; /* 3 */
			Set @l_vege = 'T';
		End;  /* 2 */
		Else
		Begin  /* 2 */
			If Isnull(@PLevel,'') <> 'érvénytelen lakcím'
			Begin /* 3 */
				--Van ideiglenes cím ?
				If Trim(Trim(Isnull(@TZipCode,'')) + Trim(Isnull(@TCity,''))
					+ Trim(Isnull(@TPublicPlaceName,'')) + Trim(Isnull(@TPublicPlaceType,''))
					+ Trim(Isnull(@THouseNr,'')) + Trim(Isnull(@TBuilding,''))
					+ Trim(Isnull(@TStaircase,'')) + Trim(Isnull(@TFloor,''))
					+ Trim(Isnull(@TDoor,''))) <> ''
				Begin /* 4 */
					If ISNULL(@pLevel,'') <> 'településszintű'
					Begin /* 5 */
						-- megegyezik az indecsben tárolt levelezési címmel ?
						If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
							and 
								Replace(Trim(Replace(Replace(
								Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
								+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
								+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
								+ Trim(Isnull(f0.HouseNr,'')) /*+ Trim(Isnull(f0.LandRegisterReference,''))*/
								+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
								+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
							= 
								Replace(Trim(Replace(Replace(
								Trim(Isnull(@l_CountryIDHUN,'')) + Trim(Isnull(@TZipCode,'')) 
								+ /*Trim(Isnull(@TFState,'')) +*/ Trim(Isnull(@TCity,'')) 
								+ Trim(Isnull(@TPublicPlaceName,'')) + Trim(Isnull(@CodeTPublicPlaceType,''))
								+ Trim(Isnull(@THouseNr,'')) /*+ Trim(Isnull(@TLandRegisterReference,''))*/
								+ Trim(Isnull(@TStaircase,'')) + Trim(Isnull(@TBuilding,''))
								+ Trim(Isnull(@TFloor,'')) + Trim(Isnull(@TDoor,'')),' ',''),'.','')),' ',''))
						Begin /* 6 */
						-- előző állandó Cím érvénytelenítése:
							Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED',
								LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
								where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE';
						-- új állandó cím felvitele:
							-- New ObjectID:
							INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
								SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
							SET @l_ObjectID = @@Identity;

							INSERT INTO PRT.Address(
								AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
								PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
								StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
								CreationUserName, Comments, AssetID, DataOriginCode)
							SELECT
								'ADDRESS_TYPE_PERSON_RESIDENCE' as AddressType, 
								'SPECIAL_ADDRESS_STRUCTURE_NORMAL' as AddressStructure, 
								@l_CountryIDHUN as CountryID,
								NULL as CountryClassCode, 
								@TZipCode as ZipCode, 
								@TCity as Settlement, 
								NULL as District, 
								@TPublicPlaceName as PublicPlaceName, 
								@CodeTPublicPlaceType as PublicPlaceType, 
								@THouseNr as HouseNr, 
								NULL as LandRegisterReference, 
								@TStaircase as Staircase, 
								@TBuilding as Building, 
								@TFloor as [Floor], 
								@TDoor as Door, 
								CAST( GETDATE() AS Date ) as ValidFrom, 
								NULL as ValidUntil, 
								'STATUS_NORMAL' as StatusCode, 
								(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
								@l_ObjectID as ObjectID, 
								NULL as PropertyID, 
								NULL as DataSource, 
			--					'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
								@p_SourceInterfaceType as SourceInterfaceType, 
								@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
								CAST( GETDATE() AS Date ) as CreationDate, 
								CAST( GETDATE() AS Time ) as CreationTime, 
								@CurrentUserName as CreationUserName, 
								NULL as Comments, 
								NULL as AssetID, 
								'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
							SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
						End; /* 6 */

					End; /* 5 */
					If ISNULL(@pLevel,'') = 'településszintű'
					Begin /* 5 */
						-- megegyezik az indecsben tárolt levelezési címmel ?
						If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
						and Isnull(f0.ValidFrom,'1901-01-01') < Isnull(@TRegistrationDate,'1901-01-01')
							and 
								Replace(Trim(Replace(Replace(
								Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
								+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
								+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
								+ Trim(Isnull(f0.HouseNr,'')) /*+ Trim(Isnull(f0.LandRegisterReference,''))*/
								+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
								+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
							= 
								Replace(Trim(Replace(Replace(
								Trim(Isnull(@l_CountryIDHUN,'')) + Trim(Isnull(@TZipCode,'')) 
								+ /*Trim(Isnull(@TFState,'')) +*/ Trim(Isnull(@TCity,'')) 
								+ Trim(Isnull(@TPublicPlaceName,'')) + Trim(Isnull(@CodeTPublicPlaceType,''))
								+ Trim(Isnull(@THouseNr,'')) /*+ Trim(Isnull(@TLandRegisterReference,''))*/
								+ Trim(Isnull(@TStaircase,'')) + Trim(Isnull(@TBuilding,''))
								+ Trim(Isnull(@TFloor,'')) + Trim(Isnull(@TDoor,'')),' ',''),'.','')),' ',''))
						Begin /* 6 */
						-- előző állandó Cím érvénytelenítése:
							Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED',
								LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
								where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE';
						-- új állandó cím felvitele:
							-- New ObjectID:
							INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
								SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
							SET @l_ObjectID = @@Identity;

							INSERT INTO PRT.Address(
								AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
								PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
								StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
								CreationUserName, Comments, AssetID, DataOriginCode)
							SELECT
								'ADDRESS_TYPE_PERSON_RESIDENCE' as AddressType, 
								'SPECIAL_ADDRESS_STRUCTURE_CITY' as AddressStructure, 
								@l_CountryIDHUN as CountryID,
								NULL as CountryClassCode, 
								@TZipCode as ZipCode, 
								@TCity as Settlement, 
								NULL as District, 
								@TPublicPlaceName as PublicPlaceName, 
								@CodeTPublicPlaceType as PublicPlaceType, 
								@THouseNr as HouseNr, 
								NULL as LandRegisterReference, 
								@TStaircase as Staircase, 
								@TBuilding as Building, 
								@TFloor as [Floor], 
								@TDoor as Door, 
								CAST( GETDATE() AS Date ) as ValidFrom, 
								NULL as ValidUntil, 
								'STATUS_NORMAL' as StatusCode, 
								(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
								@l_ObjectID as ObjectID, 
								NULL as PropertyID, 
								NULL as DataSource, 
			--					'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
								@p_SourceInterfaceType as SourceInterfaceType, 
								@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
								CAST( GETDATE() AS Date ) as CreationDate, 
								CAST( GETDATE() AS Time ) as CreationTime, 
								@CurrentUserName as CreationUserName, 
								NULL as Comments, 
								NULL as AssetID, 
								'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
							SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
						End; /* 6 */
					End; /* 5 */
				End; /* 4 */

				--Van Külfüldi cím ?
				IF Trim(Trim(Isnull(@FCountry,'')) + Trim(Isnull(@FZipCode,'')) + Trim(Isnull(@FState,'')) + Trim(Isnull(@FCity,'')) + Trim(Isnull(@FAddress,''))) <> ''
				Begin /* 4 */
					If ISNULL(@pLevel,'') <> 'településszintű'
					Begin /* 5 */
						If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
							and 
								Replace(Trim(Replace(Replace(
								Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
								+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
								+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
								+ Trim(Isnull(f0.HouseNr,'')) + Trim(Isnull(f0.LandRegisterReference,''))
								+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
								+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
							= 
								Replace(Trim(Replace(Replace(
								Trim(Isnull(@CodeFCountry,'')) + Trim(Isnull(@FZipCode,'')) 
								+ /*Trim(Isnull(@FState,'')) +*/ Trim(Isnull(@FCity,'')) 
								+ Trim(Isnull(@FAddress,'')),' ',''),'.','')),' ',''))
						Begin /* 6 */ /* Új "Külföldi cím" egyezik korábbi  "Levelezési címmel" ? */
						-- előző levelezési Cím érvénytelenítése:
							Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED', 
								LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
								where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE';
						-- új külföldi levelezési cím felvitele:
							-- New ObjectID:
							INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
								SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
							SET @l_ObjectID = @@Identity;

							INSERT INTO PRT.Address(
								AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
								PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
								StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
								CreationUserName, Comments, AssetID, DataOriginCode)
							SELECT
								'ADDRESS_TYPE_PERSON_RESIDENCE' as AddressType, 
								'SPECIAL_ADDRESS_STRUCTURE_NORMAL' as AddressStructure, 
								@CodeFCountry as CountryID,
								NULL as CountryClassCode, 
								@FZipCode as ZipCode, 
								@FCity as Settlement, 
								NULL as District, 
								@FAddress as PublicPlaceName, 
								--@CodeFPublicPlaceType as PublicPlaceType, 
								NULL as PublicPlaceType, 
								NULL as HouseNr, 
								NULL as LandRegisterReference, 
								NULL as Staircase, 
								NULL as Building, 
								NULL as [Floor], 
								NULL as Door, 
								CAST( GETDATE() AS Date ) as ValidFrom, 
								NULL as ValidUntil, 
								'STATUS_NORMAL' as StatusCode, 
								(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
								@l_ObjectID as ObjectID, 
								NULL as PropertyID, 
								NULL as DataSource, 
								--'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
								@p_SourceInterfaceType as SourceInterfaceType, 
								@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
								CAST( GETDATE() AS Date ) as CreationDate, 
								CAST( GETDATE() AS Time ) as CreationTime, 
								@CurrentUserName as CreationUserName, 
								NULL as Comments, 
								NULL as AssetID, 
								'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
							SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
						End; /* 6 */
					End; /* 5 */
					If ISNULL(@pLevel,'') = 'településszintű'
					Begin /* 5 */
						If not Exists (Select 1 from PRT.Address f0 where f0.EntityID = @l_EntityID and f0.AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE'
							and 
								Replace(Trim(Replace(Replace(
								Trim(Isnull(cast(f0.CountryID as nvarchar(50)),'')) + Trim(Isnull(f0.ZipCode,''))
								+ /*Trim(Isnull(f0.FState,'')) +*/ Trim(Isnull(f0.Settlement,'')) 
								+ Trim(Isnull(f0.PublicPlaceName,'')) + Trim(Isnull(f0.PublicPlaceType,''))
								+ Trim(Isnull(f0.HouseNr,'')) + Trim(Isnull(f0.LandRegisterReference,''))
								+ Trim(Isnull(f0.Staircase,'')) + Trim(Isnull(f0.Building,''))
								+ Trim(Isnull(f0.Floor,'')) + Trim(Isnull(f0.Door,'')),' ',''),'.','')),' ','')
							= 
								Replace(Trim(Replace(Replace(
								Trim(Isnull(@CodeFCountry,'')) + Trim(Isnull(@FZipCode,'')) 
								+ /*Trim(Isnull(@FState,'')) +*/ Trim(Isnull(@FCity,'')) 
								+ Trim(Isnull(@FAddress,'')),' ',''),'.','')),' ',''))
						Begin /* 6 */ /* Új "Külföldi cím" egyezik korábbi  "Levelezési címmel" ? */
						-- előző levelezési Cím érvénytelenítése:
							Update Prt.Address Set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED', 
								LastmodifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName 
								where ValidUntil is NULL and EntityID = @l_EntityID and AddressType = 'ADDRESS_TYPE_PERSON_RESIDENCE';
						-- új külföldi levelezési cím felvitele:
							-- New ObjectID:
							INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
								SELECT @l_ObjectTypeCode as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
							SET @l_ObjectID = @@Identity;

							INSERT INTO PRT.Address(
								AddressType, AddressStructure, CountryID, CountryClassCode, ZipCode, Settlement, District, PublicPlaceName, 
								PublicPlaceType, HouseNr, LandRegisterReference, Staircase, Building, [Floor], Door, ValidFrom, ValidUntil, 
								StatusCode, EntityID, ObjectID, PropertyID, DataSource, SourceInterfaceType, SourceID, CreationDate, CreationTime, 
								CreationUserName, Comments, AssetID, DataOriginCode)
							SELECT
								'ADDRESS_TYPE_PERSON_RESIDENCE' as AddressType, 
								'SPECIAL_ADDRESS_STRUCTURE_CITY' as AddressStructure, 
								@CodeFCountry as CountryID,
								NULL as CountryClassCode, 
								@FZipCode as ZipCode, 
								@FCity as Settlement, 
								NULL as District, 
								@FAddress as PublicPlaceName, 
								--@CodeFPublicPlaceType as PublicPlaceType, 
								NULL as PublicPlaceType, 
								NULL as HouseNr, 
								NULL as LandRegisterReference, 
								NULL as Staircase, 
								NULL as Building, 
								NULL as [Floor], 
								NULL as Door, 
								CAST( GETDATE() AS Date ) as ValidFrom, 
								NULL as ValidUntil, 
								'STATUS_NORMAL' as StatusCode, 
								(Select Entity.ID from PRT.Entity where Entity.ObjectID = @ObjectID) as EntityID, 
								@l_ObjectID as ObjectID, 
								NULL as PropertyID, 
								NULL as DataSource, 
								--'BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceInterfaceType, 
								@p_SourceInterfaceType as SourceInterfaceType, 
								@l_EntitySourceID + '/BMNYHAT/' + cast(CAST( GETDATE() AS Date ) as nvarchar(10)) as SourceID, 
								CAST( GETDATE() AS Date ) as CreationDate, 
								CAST( GETDATE() AS Time ) as CreationTime, 
								@CurrentUserName as CreationUserName, 
								NULL as Comments, 
								NULL as AssetID, 
								'DATA_ORIGIN_OFFICIAL_REGISTRY' as DataOriginCode;
							SET @Eredmeny = 'TASK_DETAILED_STATUS_NEW_ADDRESS_RECEIVED' /* ujcimerkezett */;
						End; /* 6 */
					End; /* 5 */
				
				End; /* 4 */



			End;  /* 3 */
			Set @l_vege = 'T';
		End;  /* 2 */
	End; /* 1 */
End; /* 0 - @ValidationRecordCode = 'BOOLEAN_TRUE'*/
	
---------------------------------------------------------------------------------------------------------------------------------------------
				If @l_vege = 'T'
				Begin
					SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
					Update IFC.AddressRegister Set StatusCode = 'ADDRESS_REGISTER_STATUS_PROCESSED' where Id = @ID;

					Update ORG.Process Set Process.DetailedStatusCode = @Eredmeny where Process.ID = @l_ProcessID;

				End;
				Else
				Begin
					SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
				End;
---------------------------------------------------------------------------------------------------------------------------------------------

		FETCH NEXT FROM db_cursor_2 INTO @ID, 
			@ObjectID,
			@DeregistrationReason,
			@DeregistrationDate,
			@PZipCode,
			@PCity,
			@PPublicPlaceName,
			@PPublicPlaceType,
			@PHouseNr,
			@PBuilding,
			@PStaircase,
			@PFloor,
			@PDoor,
			@PRegistrationDate,
			@PLevel,
			@TZipCode,
			@TCity,
			@TPublicPlaceName,
			@TPublicPlaceType,
			@THouseNr,
			@TBuilding,
			@TStaircase,
			@TFloor,
			@TDoor,
			@TRegistrationDate,
			@FCountry,
			@FZipCode,
			@FState,
			@FCity,
			@FAddress,
			@StatusCode,
			@ExportImportCode,
			@ReturnedAddressRegisterID,
			@ValidationRecordCode,
			@ProcessID
		END;

		CLOSE db_cursor_2;
		DEALLOCATE db_cursor_2;

    COMMIT TRANSACTION;


    END TRY


    BEGIN CATCH

        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.LakcimkeresesVisszatoltes',	-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        ROLLBACK TRANSACTION;

        SELECT @ErrorMessage;

    END CATCH;


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
		
	SET @LogMessage = @LogMessage + 'LakcimkeresesVisszatoltes Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.LakcimkeresesVisszatoltes',	-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) + @CRLF
		+ 'NotFoundRowsCount: ' + CAST(@l_NotFoundRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ @LogMessage;



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.LakcimkeresesVisszatoltes',	-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return 1;

END;

go

-- =============================================
-- Author:		GURBAN
-- Create date:		2022.07.26
-- Description:	
--  List the translations of all elements of the 
--    given ValueSete. The list is empty if 
--    no data found
-- =============================================
CREATE PROCEDURE [GEN].[ListTranslations]
(
   @pValueSet  NUMERIC(16,0),
   @pLang      NVARCHAR(5) = 'HU'   
)

AS
BEGIN

   SELECT GEN.Code.ID, GEN.Translation.Text
   FROM GEN.Code 
   JOIN GEN.Translation ON GEN.Code.ID = GEN.Translation.CodeID
   WHERE GEN.Code.ValueSetID = @pValueSet AND 
      GEN.Translation.Language = @pLang ;

END
go

CREATE   PROCEDURE [IFC].[MainIFCLoader]

/*
==========================================================================================
	2022-12-16: CurrentUserID <-> CurrentUserName 
 Author:		Tóth Gábor and Aranyi  Balázs
 Creation date:			2022.10.17.
						2023.01.27, Set @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
						2023.03.08: IFC.MainIFCPreControl
						2023.04.13: Hibakezelés
						2023.05.10 kivéve: MainIFCPreControl
						2023.05.11: vissza helyezve MainIFCPreControl
						2023-08-10: ModuleInstanceID ellenőrzése
						2023-08-10: ObjectGroupMemberLoader
            2023-11-03: Inkasso szinkron DV-1592
            2023-12-12: @p_result visszatérési érték jav. DV-1592
            2023-12-18: DebtCaseLoader-nek is @p_moduleInstanceIDInkasso paraméter DV-1920
            2023-12-19: ContractPreparationItemLoader, ContractLoader, ContractTenderItemLoader, PreparationLoader, MainIFCPreControl újra elérhetővé tétele
==========================================================================================
*/

	-- Tárolt eljárás bemenő paraméterei
	@p_correlationID NVARCHAR(200), --Kötelező paraméter a Session kezelés miatt 
	@p_moduleInstanceID NUMERIC(16), --Amennyiben a tárolt eljárás egy modul (definiálva van az ORG.Module táblában)
	@p_result nvarchar(200) OUTPUT /*az Inkasso szinkron kapcsán megváltoztatva Zoli kérésére (reméljük, átmeneti állapot:
                                     0: rendben lefutott az IFC modul, de nem jött létre Inkasso-s modul, amit el kéne indítani
                                     pozitív szám: jött létre Inkasso-s modul, amit el kéne indítani (ettől függetlenül lehetett akár hiba is, de a backend semmit nem kezdene a hibával, úgyhogy most egyelőre így lesz)
                                    -1/bármi egyéb: hibára futott az IFC modul és nem jött létre Inkasso-s modul, amit el kéne indítani
                                 */
	--További szükséges bemenő paraméterek
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_logMsg2 NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt

	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'IFC.MainIFCLoader'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	Declare @l_ModuleCount Numeric(6,3);
	Declare @l_ProcessedModuleCount Numeric(6,3);
	Declare @l_SourceInterfaceType nvarchar(200);
	Declare @l_NotCodedModuleName nvarchar(500);
	Declare @l_InterfacePackageID numeric(16);
	Declare @ErrorMessage nvarchar(200);
	Declare @l_ObjectID numeric(16);

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Declare @CRLF nvarchar(10);
	Declare @l_NotificMsg Nvarchar(MAX);
	DECLARE @l_ErrorExists int; /* Nem volt hiba: 1, Volt hiba: 99, Default 1 */
	
	Set @CRLF = CHAR(10)+CHAR(13);
	Set @l_NotificMsg = NULL;
	Set @l_ErrorExists = 1;

  /*ha aktív az Inkasso szinkron, akkor ebben fog visszajönni az ezzel kapcsolatosan kiírt taskok feldolgozásáért felelős modulInstanceID*/
  declare @p_moduleInstanceIDInkasso Numeric(16) 

	Set @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
	--...
	
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--...
	--Amennyiben alkalmazunk cursor-okat, akkor azok definiálása (opcionális)
	--...
	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		--Ha példányosított modul (kérés), akkor a példány adatainak módosítása
		/* ORG.ModuleInstance.StatusCode:
		MODULE_INSTANCE_STATUS_FAILED
		MODULE_INSTANCE_STATUS_FINISHED
		MODULE_INSTANCE_STATUS_PREPARATION
		MODULE_INSTANCE_STATUS_READY_TO_RUN
		MODULE_INSTANCE_STATUS_RUNNING
		MODULE_INSTANCE_STATUS_STOP_REQUESTED
		*/
		
		IF COALESCE(@p_moduleInstanceID, 0) = 0
		Begin
			INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				@p_CorrelationID,			-- CorrelationID
				'INDECS 3.0',				-- ApplicationName
				DB_NAME(),					-- Environment
				'BACKEND',					-- Layer
				'IFC.MainIFCLoader',		-- ServiceName
				'1.0',						-- ServiceVersion
				'FATAL',					-- SeverityLevel
				NULL,						-- MessageCategory
				'The ModuleInstanceID is not defined!';	-- LogMessage

			RAISERROR('The ModuleInstanceID is not defined!', 16, 1);
		End;

		UPDATE [ORG].[ModuleInstance] SET 
			[StatusCode] = 'MODULE_INSTANCE_STATUS_RUNNING',
			[BeginDate] = CAST(GETDATE() AS Date),
			[BeginTime] = CAST(GETDATE() AS Time)
		WHERE [ModuleInstance].[ID] = @p_moduleInstanceID;

		--select * from gen.code where id = 'MODULE_INSTANCE_STATUS_RUNNING'
		
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);
		
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,           -- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',						-- SeverityLevel
			NULL,						-- MessageCategory
			'START';				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
-- Fejléc:
		SELECT @l_logMsg = 'Checing parameters... ';
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- Ellenőrzés:
		Set @l_errorMsg = NULL;
		If Isnull(@p_correlationID,'') = ''
			Set @l_errorMsg = 'CorrelationID is not defined';
		If Isnull(@p_moduleInstanceID,0) = 0
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' ModuleInstanceID is not defined';

		Set @l_SourceInterfaceType = '';
		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_SourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END;
/*
		IF COALESCE(@l_SourceInterfaceType, '') = '' 
					Set @l_errorMsg = Isnull(@l_errorMsg,'') + 'The SourceInterfaceType field is not defined!';
*/
/* 2022-12-09, TG
		Set @l_NotCodedModuleName = '';
		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			Set @l_NotCodedModuleName =
			(SELECT STRING_AGG(ModuleInstanceParameter.ParameterCode,',')
				FROM ORG.ModuleInstanceParameter
				WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
				AND ModuleInstanceParameter.ParameterValue = 'BOOLEAN_TRUE'
				AND ModuleInstanceParameter.ParameterCode NOT IN (
				'MODULE_PARAMETER_IFC_ADDRESS',
				'MODULE_PARAMETER_IFC_COMPANY',
				'MODULE_PARAMETER_IFC_CONTACT',
				'MODULE_PARAMETER_IFC_CONTRACT',
				'MODULE_PARAMETER_IFC_CONTRACT_ITEM',
				'MODULE_PARAMETER_IFC_CONTRACT_ITEM_COLLECTION',
				'MODULE_PARAMETER_IFC_CONTRACT_PREPARATION_ITEM',
				'MODULE_PARAMETER_IFC_CONTRACT_SUMMARY_COLLECTION',
				'MODULE_PARAMETER_IFC_CONTRACT_TENDER_ITEM',
				'MODULE_PARAMETER_IFC_DEBT_CASE',
				'MODULE_PARAMETER_IFC_DEBTOR',
				'MODULE_PARAMETER_IFC_INVOICE',
				'MODULE_PARAMETER_IFC_PERSON',
				'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE',
				'MODULE_PARAMETER_FK_DOCUMENT_ID',
				'MODULE_PARAMETER_FC_DOCUMENT_ID',
				'MODULE_PARAMETER_FF_DOCUMENT_ID',
				'MODULE_PARAMETER_FU_DOCUMENT_ID',
				'MODULE_PARAMETER_IFC_IDENTIFIER',
				'MODULE_PARAMETER_IFC_ASSETALL'
				));
		END;

		IF @l_NotCodedModuleName <> '' 
					Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' The Coded ModuleName: ' + @l_NotCodedModuleName;
*/

		IF @l_errorMsg is not NULL
		BEGIN
			INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				@p_CorrelationID,			-- CorrelationID
				'INDECS 3.0',			    -- ApplicationName
				DB_NAME(),					-- Environment
				'BACKEND',					-- Layer
				ERROR_PROCEDURE(),   		-- ServiceName
				'1.0',						-- ServiceVersion
				'ERROR',					        -- SeverityLevel
				NULL,						-- MessageCategory
				@l_errorMsg;				-- LogMessage

				RAISERROR(@l_errorMsg, 16, 1);
		END;
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 

		--TODO: Paraméterek ellenőrzése

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Feldolgozás. 
		--Amennyiben példányosított modul, akkor a példány feldolgozottságának frissítése az ORG.ModuleInstance.Progress mező módosítása
		
		
		Set @l_ModuleCount = (SELECT Count(*) FROM ORG.ModuleInstanceParameter
								WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
								and ParameterValue = 'BOOLEAN_TRUE');
		Set @l_ProcessedModuleCount = 0;

		Set @l_InterfacePackageID = 0;
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
-- 'ContractPreparationItemLoader'
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_CONTRACT_PREPARATION_ITEM')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			
			-- InterfacePackageID:
			-- New ObjectID:
			IF @l_InterfacePackageID = 0
			BEGIN
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName)
				SELECT 'OBJECT_TYPE_IFC_INTERFACEPACKAGE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName;
				SET @l_ObjectID = @@Identity;
				
				Insert into IFC.InterfacePackage(ObjectId, SourceInterfaceType, CostumerID, CreditorCode, ImportDate, Status, ImportType, CreationDAte, CreationTime, CreationUserName, PartyId, ContractId)
				Select 
					@l_ObjectID as ObjectId, 
					@l_SourceInterfaceType as SourceInterfaceType, 
					NULL as CustomerId, 
					NULL as CreditorCode, 
					CAST( GETDATE() AS Date ) as ImportDate,
					NULL as Status, 
					NULL as ImportType, 
					CAST( GETDATE() AS Date ) as CreationDate, 
					CAST( GETDATE() AS Time ) as CreationTime, 
					@CurrentUserName as CreationUserName, 
					NULL as PartId, 
					NULL as ContractId
				where not exists (select 1 from IFC.InterfacePackage where SourceInterfaceType = @l_SourceInterfaceType);
				SET @l_InterfacePackageID = (select Top 1 Id from IFC.InterfacePackage where SourceInterfaceType = @l_SourceInterfaceType order by ID desc);
			END;
			begin transaction
				exec @l_logMsg = IFC.ContractPreparationItemLoader @p_correlationID, @l_InterfacePackageID;
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			commit;
		END;
		/*
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.ContractPreparationItemLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.ContractPreparationItem, ' + @CRLF;
		*/

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'TA_FU_Loader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				--and ParameterCode = 'MODULE_PARAMETER_IFC_TA_FU') /* 2022-11-25 */
				and ParameterCode = 'MODULE_PARAMETER_FU_DOCUMENT_ID')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			
			-- InterfacePackageID:
			-- New ObjectID:
			IF @l_InterfacePackageID = 0
			BEGIN
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName)
				SELECT 'OBJECT_TYPE_IFC_INTERFACEPACKAGE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName;
				SET @l_ObjectID = @@Identity;

				Insert into IFC.InterfacePackage(ObjectId, SourceInterfaceType, CostumerID, CreditorCode, ImportDate, Status, ImportType, CreationDAte, CreationTime, CreationUserName, PartyId, ContractId)
				Select 
					@l_ObjectID as ObjectId, 
					@l_SourceInterfaceType as SourceInterfaceType, 
					NULL as CustomerId, 
					NULL as CreditorCode, 
					CAST( GETDATE() AS Date ) as ImportDate,
					NULL as Status, 
					NULL as ImportType, 
					CAST( GETDATE() AS Date ) as CreationDate, 
					CAST( GETDATE() AS Time ) as CreationTime, 
					@CurrentUserName as CreationUserName, 
					NULL as PartId, 
					NULL as ContractId
				where not exists (select 1 from IFC.InterfacePackage where SourceInterfaceType = @l_SourceInterfaceType);
				SET @l_InterfacePackageID = (select Top 1 Id from IFC.InterfacePackage where SourceInterfaceType = @l_SourceInterfaceType order by ID desc);
			END;
			begin transaction
				exec @l_logMsg = IFC.TA_FU_Loader @p_correlationID, @l_SourceInterfaceType, @l_InterfacePackageID;
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.TA_FU_Loader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.OTP_TA_FU, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'TA_FC_Loader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				--and ParameterCode = 'MODULE_PARAMETER_IFC_TA_FC') /* 2022-11-25 */
				and ParameterCode = 'MODULE_PARAMETER_FC_DOCUMENT_ID')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			
			-- InterfacePackageID:
			-- New ObjectID:
			IF @l_InterfacePackageID = 0
			BEGIN
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName)
				SELECT 'OBJECT_TYPE_IFC_INTERFACEPACKAGE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName;
				SET @l_ObjectID = @@Identity;

				Insert into IFC.InterfacePackage(ObjectId, SourceInterfaceType, CostumerID, CreditorCode, ImportDate, Status, ImportType, CreationDAte, CreationTime, CreationUserName, PartyId, ContractId)
				Select 
					@l_ObjectID as ObjectId, 
					@l_SourceInterfaceType as SourceInterfaceType, 
					NULL as CustomerId, 
					NULL as CreditorCode, 
					CAST( GETDATE() AS Date ) as ImportDate,
					NULL as Status, 
					NULL as ImportType, 
					CAST( GETDATE() AS Date ) as CreationDate, 
					CAST( GETDATE() AS Time ) as CreationTime, 
					@CurrentUserName as CreationUserName, 
					NULL as PartId, 
					NULL as ContractId
				where not exists (select 1 from IFC.InterfacePackage where SourceInterfaceType = @l_SourceInterfaceType);
				SET @l_InterfacePackageID = (select Top 1 Id from IFC.InterfacePackage where SourceInterfaceType = @l_SourceInterfaceType order by ID desc);
			END;
			begin transaction
				exec @l_logMsg = IFC.TA_FC_Loader @p_correlationID, @l_SourceInterfaceType, @l_InterfacePackageID;
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.TA_FC_Loader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.OTP_TA_FC, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'TA_FK_Loader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				--and ParameterCode = 'MODULE_PARAMETER_IFC_TA_FK')
				and ParameterCode = 'MODULE_PARAMETER_FK_DOCUMENT_ID')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;

			-- InterfacePackageID:
			-- New ObjectID:
			IF @l_InterfacePackageID = 0
			BEGIN
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName)
				SELECT 'OBJECT_TYPE_IFC_INTERFACEPACKAGE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName;
				SET @l_ObjectID = @@Identity;

				Insert into IFC.InterfacePackage(ObjectId, SourceInterfaceType, CostumerID, CreditorCode, ImportDate, Status, ImportType, CreationDAte, CreationTime, CreationUserName, PartyId, ContractId)
				Select 
					@l_ObjectID as ObjectId, 
					@l_SourceInterfaceType as SourceInterfaceType, 
					NULL as CustomerId, 
					NULL as CreditorCode, 
					CAST( GETDATE() AS Date ) as ImportDate,
					NULL as Status, 
					NULL as ImportType, 
					CAST( GETDATE() AS Date ) as CreationDate, 
					CAST( GETDATE() AS Time ) as CreationTime, 
					@CurrentUserName as CreationUserName, 
					NULL as PartId, 
					NULL as ContractId
				where not exists (select 1 from IFC.InterfacePackage where SourceInterfaceType = @l_SourceInterfaceType);
				SET @l_InterfacePackageID = (select Top 1 Id from IFC.InterfacePackage where SourceInterfaceType = @l_SourceInterfaceType order by ID desc);
			END;
			begin transaction
				exec @l_logMsg = IFC.TA_FK_Loader @p_correlationID, @l_SourceInterfaceType, @l_InterfacePackageID;
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.TA_FK_Loader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.OTP_TA_FK, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'ContractLoader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_CONTRACT')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			begin transaction
				exec @l_logMsg = IFC.ContractLoader @p_correlationID, @p_moduleInstanceID;
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.ContractLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.Contract, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'ContractTenderItemLoader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_CONTRACT_TENDER_ITEM')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			begin transaction
				exec @l_logMsg = IFC.ContractTenderItemLoader @p_correlationID, @p_moduleInstanceID;
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.ContractTenderItemLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.ContractTenderItem, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'PreparationLoader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'PREPARATION_LOADER')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			begin transaction
				exec @l_logMsg = IFC.PreparationLoader @p_correlationID, @p_moduleInstanceID;
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.PreparationLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.ContractPreparation, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'Előellenőrzés':

		Set @l_logMsg = '';
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;

			begin transaction
				exec @l_logMsg = IFC.MainIFCPreControl @p_correlationID, @p_moduleInstanceID;
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.MainIFCPreControl';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.ContractItem-OTP_TA_FK, ' + @CRLF;
-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'CompanyLoader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_COMPANY')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			--begin transaction /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/
				exec @l_logMsg = IFC.CompanyLoader @p_correlationID, @p_moduleInstanceID, @p_moduleInstanceIDInkasso output
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			--commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.CompanyLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.Company, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'PersonLoader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_PERSON')
		BEGIN

			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			--begin transaction /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/
				exec @l_logMsg = IFC.PersonLoader @p_correlationID, @p_moduleInstanceID, @p_moduleInstanceIDInkasso output
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			--commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.PersonLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.Person, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'AddressLoader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_ADDRESS')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			--begin transaction /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/
				exec @l_logMsg = IFC.AddressLoader @p_correlationID, @p_moduleInstanceID, @p_moduleInstanceIDInkasso output
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			--commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.AddressLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.Address, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'ContactLoader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_CONTACT')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			--begin transaction /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/
				exec @l_logMsg = IFC.ContactLoader @p_correlationID, @p_moduleInstanceID, @p_moduleInstanceIDInkasso output
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			--commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.ContactLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.Contact, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'DebtCaseLoader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_DEBT_CASE')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			begin transaction
				exec @l_logMsg = IFC.DebtCaseLoader @p_correlationID, @p_moduleInstanceID,  @p_moduleInstanceIDInkasso output
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.DebtCaseLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.DebtCase, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'DebtorLoader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_DEBTOR')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			begin transaction
				exec @l_logMsg = IFC.DebtorLoader @p_correlationID, @p_moduleInstanceID;
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.DebtorLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.Debtor, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'InvoiceLoader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_INVOICE')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			--begin transaction /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/
				exec @l_logMsg = IFC.InvoiceLoader @p_correlationID, @p_moduleInstanceID, @p_moduleInstanceIDInkasso output
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			--commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.InvoiceLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.Invoice, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'IdentifierLoader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_IDENTIFIER')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			--begin transaction /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/
				exec @l_logMsg = IFC.ObjectIdentifierLoader @p_correlationID, @p_moduleInstanceID, @p_moduleInstanceIDInkasso output
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			--commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.ObjectIdentifierLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.ObjectIdentifier, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'ObjectGroupMemberLoader':
		Set @l_logMsg = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_OBJECT_GROUP_MEMBER')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			begin transaction
				exec @l_logMsg = IFC.ObjectGroupMemberLoader @p_correlationID, @p_moduleInstanceID;
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			commit;
		END;
		IF @l_logMsg = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.ObjectGroupMemberLoader';
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.ObjectGroupMemberLoader, ' + @CRLF;

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
--		'AssetLoader + AddressLoader:
		Set @l_logMsg = '';
		Set @l_logMsg2 = '';
		IF Exists (Select 1 from ORG.ModuleInstanceParameter 
				where ModuleInstanceID = @p_moduleInstanceID 
				and ParameterValue = 'BOOLEAN_TRUE' 
				and ParameterCode = 'MODULE_PARAMETER_IFC_ASSETALL')
		BEGIN
			Set @l_ProcessedModuleCount = @l_ProcessedModuleCount + 1;
			--Update ORG.ModuleInstance Set Progress = (Cast(@l_ProcessedModuleCount as Numeric(6,3))/ @l_ModuleCount) * 100, LastHeartbeatDate = CAST( GETDATE() AS Date ), LastHeartbeatTime = CAST( GETDATE() AS Time) Where ID = @p_moduleInstanceID;
			--begin transaction /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/
				exec @l_logMsg = IFC.AssetLoader @p_correlationID, @p_moduleInstanceID, @p_moduleInstanceIDInkasso output;
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			--commit;
			--begin transaction /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/
				exec @l_logMsg2 = IFC.AddressLoader @p_correlationID, @p_moduleInstanceID;
				if Isnull(@l_logMsg,'') = '99' 
					Set @l_ErrorExists = 99;
			--commit;

		END;

		IF @l_logMsg = '99' or @l_logMsg2 = '99'
			Set @l_errorMsg = Isnull(@l_errorMsg,'') + ' IFC.AssetLoader';
		/*
		IF @l_logMsg = '88'
			Set @l_NotificMsg = Isnull(@l_NotificMsg,'') + 'IFC.Asset..., ' + @CRLF;
		*/


    /*Inkasso moduleInstance status setting*/
    if @p_moduleInstanceIDInkasso is not null
    begin
      update ORG.ModuleInstance
      set StatusCode = 'MODULE_INSTANCE_STATUS_READY_TO_RUN'
      where ID = @p_moduleInstanceIDInkasso
    end

-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 
		IF COALESCE(@l_errorMsg, '') <> ''
		BEGIN
			-- ha hiba van, akkor az "@l_errorMsg" értéke nem üres
			INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				@p_CorrelationID,			-- CorrelationID
				'INDECS 3.0',			    -- ApplicationName
				DB_NAME(),					-- Environment
				'BACKEND',					-- Layer
				@l_procedureName,   		-- ServiceName
				'1.0',						-- ServiceVersion
				'ERROR',					        -- SeverityLevel
				NULL,						-- MessageCategory
				@l_errorMsg;                  --LogMessage
		END;

		IF COALESCE(@l_NotificMsg, '') <> ''
		BEGIN
			-- ha hiba van, akkor az "@l_errorMsg" értéke nem üres
			INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				@p_CorrelationID,			-- CorrelationID
				'INDECS 3.0',			    -- ApplicationName
				DB_NAME(),					-- Environment
				'BACKEND',					-- Layer
				@l_procedureName,   		-- ServiceName
				'1.0',						-- ServiceVersion
				'INFO',				        -- SeverityLevel
				NULL,						-- MessageCategory
				@l_NotificMsg;              --LogMessage
		END;
		
		/*
		A csillaggal jelöltekre már van betöltő eljársá írva, a többire nincs. A sorrend számít !!
		--CompanyIdentification
		*Company
		Founded
		*Person
		CrefoExtension
		Employment
		*Address
		*Contact
		CrefoIdentifier
		*DebtCase
		*Debtor
		MainDebtor
		*Invoice
		InvoiceExtension
		DebtorRegister
		LegalAction
		Journal
		Property
		PropertyRelation
		PropertyRight
		PropertyValuation
		PropertyIdentifier
		DebtorProperty
		Collateral
		Interaction
		FlexProperty
		ObjectGroup
		Task
*/
		
		--Naplóbejegyzés a befejezésről (kötelező)
		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',						-- SeverityLevel
			NULL,						-- MessageCategory
			'END';	                  --LogMessage
			
		--Ha példányosított modul (kérés), akkor a példány adatainak módosítása
		UPDATE [ORG].[ModuleInstance] SET 
			[StatusCode] = 'MODULE_INSTANCE_STATUS_FINISHED',
			[Progress] = 100,
			[EndDate] = CAST(GETDATE() AS Date),
			[EndTime] = CAST(GETDATE() AS Time),
			ErrorMessage = NULL
		WHERE [ModuleInstance].[ID] = @p_moduleInstanceID;

		/*
		If Isnull(@l_NotificMsg,'') <> ''
			SELECT @p_result = 88;
		If Isnull(@l_errorMsg,'') <> ''
			SELECT @p_result = 99;
		If Isnull(@l_NotificMsg,'') = '' and Isnull(@l_errorMsg,'') = ''
			SELECT @p_result = 1;
		*/


    if @p_moduleInstanceIDInkasso is not null
       select @p_result = @p_moduleInstanceIDInkasso
    else
    begin
		  If @l_ErrorExists = 99
		     select @p_result = -1; /*Inkasso szinkron kapcsán átírva -1-re a hibás ág (Zoli kérte)*/
			  --Select 99;
		  Else
		  select @p_result = 0;
			  --Select 1;
    end
    
    SELECT @p_result;

		RETURN;
	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
/*
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'cursor neve');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE tenderItem_cursor;

			DEALLOCATE tenderItem_cursor;
		END
*/
		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
			
		--Ha példányosított modul (kérés), akkor a példány adatainak módosítása
		UPDATE [ORG].[ModuleInstance] SET 
			[StatusCode] = 'MODULE_INSTANCE_STATUS_FAILED',
			[ErrorMessage] = @l_errorMsg,
			[EndDate] = CAST(GETDATE() AS Date),
			[EndTime] = CAST(GETDATE() AS Time)
		WHERE [ModuleInstance].[ID] = @p_moduleInstanceID;

    
    /*Inkasso moduleInstance status setting*/
    if @p_moduleInstanceIDInkasso is not null
    begin
      if exists(select *
                from ORG.ModuleInstance
                where ID = @p_moduleInstanceIDInkasso
                  and StatusCode = 'MODULE_INSTANCE_STATUS_PREPARATION'
               )
      begin 
        update ORG.ModuleInstance
        set StatusCode = 'MODULE_INSTANCE_STATUS_READY_TO_RUN'
        where ID = @p_moduleInstanceIDInkasso

        select @p_result = @p_moduleInstanceIDInkasso
     end
    end
    else
    begin
  		select @p_result = @l_errorMsg;

    end
	 
    select @p_result;

		RETURN;
	END CATCH
END
go

CREATE   PROCEDURE [IFC].[MainIFCPreControl](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16))

/*
==========================================================================================
 Author:		Tóth Gábor
 Creation date:			2023.03.07
 Last modified date:	2023.03.08: CamelCase, ErrorCode
						2023.03.21: @BankAccountNumber
						2023.04.14: Hibakezelés-99
 						2023.04.14: Szerződésösszeg ellenőrzés
						2023.04.15: Error message
						2023.05.09: Error message kivétele
						2023.05.11: Csak a szerződés ellenőrzés megőrzése, a többi egyelőre kikapcsolva
						2023.06.09: PurchasePrive Control: PurchasePrice, PurchasePriceCurrencyCode
						2023.06.20: Szerződés ellenőrzése: pénznem ellenőrzés javítása
						2023.08.10: ModuleInstanceID ellenőrzése
						2023.08.28: Szerződés ellenőrzése: pénznem ellenőrzés javítása - II.
						2023.08.29: Contract ellenőrzés paraméterhez kötés
						2023.10.02: PurchasePrice Control @PurchasePriceCurrencyCode "hátrébb" sorolása DV-1195
						2023.10.27: '[Precontrol]: '
						2023.11.06: PurchasePrice Control @PurchasePriceCurrencyCode DV-1672
						2023.11.22: @CreditType áthelyezése az IFC.OTP_TA_FK loaderből ebbe a programba, kurzor 2-fecth hiányzott
						2023.11.22: Az ellenőrzésben @CreditType --> @CreditTypeCode
						2023.12.03: Kritikus és Blokkoló hibák kezelése
						2023.12.04: Event "beszúrása"
						2023.12.04: NULL, --'EVENT_TYPE_INTERFACE_ERROR_BLOCKING_CRITICAL'
						2023.12.07: DV-1818 Konstrukciós kód ellenőrzés
            2023.12.18. CreditTypeCode változás DV-2005 és ConsolidatedProductCode bevezetése DV-1980
						2023.12.30: PurchaseDate DV-1998
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(MAX);
	DECLARE @LargeErrorMessage NVARCHAR(MAX);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	DECLARE @CreditTypeCode NVARCHAR(200);
	DECLARE @CreditType NVARCHAR(200);
	DECLARE @l_MappingId numeric(18);
	DECLARE @CaseTypeCode NVARCHAR(200);
	DECLARE @EventTypeCode NVARCHAR(200);
  Declare @ConsolidatedProductID Numeric(16)
  Declare @ConsolidatedProductCode NVARCHAR(200)


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Alternatív Hibakódok:
	Declare @ERR_PORTFOLIOID_CANNOT_BE_NULL as Nvarchar(500);
		Set @ERR_PORTFOLIOID_CANNOT_BE_NULL = Isnull((Select Id From Gen.Code where Id = 'ERR_PORTFOLIOID_CANNOT_BE_NULL'), 'ERR_INTERNAL_CONNECTION');
	Declare @ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH as Nvarchar(500);
		Set @ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH = Isnull((Select Id From Gen.Code where Id = 'ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH'), 'ERR_INTERNAL_CONNECTION');
	Declare @ERR_PORTFOLIO_TREATMENT_TYPE_TECHNICAL as Nvarchar(500);
		Set @ERR_PORTFOLIO_TREATMENT_TYPE_TECHNICAL = Isnull((Select Id From Gen.Code where Id = 'ERR_PORTFOLIO_TREATMENT_TYPE_TECHNICAL'), 'ERR_INTERNAL_CONNECTION');
	Declare @ERR_PORTFOLIOID_CASE_PORTFOLIOID_MISMATCH as Nvarchar(500);
		Set @ERR_PORTFOLIOID_CASE_PORTFOLIOID_MISMATCH = Isnull((Select Id From Gen.Code where Id = 'ERR_PORTFOLIOID_CASE_PORTFOLIOID_MISMATCH'), 'ERR_INTERNAL_CONNECTION');
	Declare @ERR_ASSET_DEBTCASE_PORTFOLIO_NOT_MATCH as Nvarchar(500);
		Set @ERR_ASSET_DEBTCASE_PORTFOLIO_NOT_MATCH = Isnull((Select Id From Gen.Code where Id = 'ERR_ASSET_DEBTCASE_PORTFOLIO_NOT_MATCH'), 'ERR_INTERNAL_CONNECTION');
	Declare @ERR_ASSET_DEBTCASE_NOT_FOUND as Nvarchar(500);
		Set @ERR_ASSET_DEBTCASE_NOT_FOUND = Isnull((Select Id From Gen.Code where Id = 'ERR_ASSET_DEBTCASE_NOT_FOUND'), 'ERR_INTERNAL_CONNECTION');
	Declare @ERR_ASSET_DEBTCASE_ASSIGMENT as Nvarchar(500);
		Set @ERR_ASSET_DEBTCASE_ASSIGMENT = Isnull((Select Id From Gen.Code where Id = 'ERR_ASSET_DEBTCASE_ASSIGMENT'), 'ERR_INTERNAL_CONNECTION');
	Declare @ERR_DEBTCASEASSET_ASSET_ASSIGMENT as Nvarchar(500);
		Set @ERR_DEBTCASEASSET_ASSET_ASSIGMENT = Isnull((Select Id From Gen.Code where Id = 'ERR_DEBTCASEASSET_ASSET_ASSIGMENT'), 'ERR_INTERNAL_CONNECTION');
	DECLARE @ERR_CANNOT_BE_EMPTY nvarchar(200);
		SET @ERR_CANNOT_BE_EMPTY = Isnull((Select Id From Gen.Code where Id = 'ERR_CANNOT_BE_EMPTY'), 'ERR_GENERAL');
	DECLARE @ERR_CODE_NAME_NOT_VALID nvarchar(200);
		SET @ERR_CODE_NAME_NOT_VALID = Isnull((Select Id From Gen.Code where Id = 'ERR_CODE_NAME_NOT_VALID'), 'ERR_GENERAL');
	DECLARE @ERR_CODE_CODE_NOT_VALID nvarchar(200);
		SET @ERR_CODE_CODE_NOT_VALID = Isnull((Select Id From Gen.Code where Id = 'ERR_CODE_CODE_NOT_VALID'), 'ERR_GENERAL');
	DECLARE @ERR_ConsolidatedProductCode_IS_NOT_VALID nvarchar(200);
		SET @ERR_ConsolidatedProductCode_IS_NOT_VALID = 'ERR_GENERAL';
	DECLARE @ERR_ConsolidatedProductCaseTypeCode_IS_NOT_VALID nvarchar(200);
		SET @ERR_ConsolidatedProductCaseTypeCode_IS_NOT_VALID = 'ERR_GENERAL';
	DECLARE @ERR_ConsolidatedProductEventTypeCode_IS_NOT_VALID nvarchar(200);
		SET @ERR_ConsolidatedProductEventTypeCode_IS_NOT_VALID = 'ERR_GENERAL';
	DECLARE @ERR_ConstructionCode_IS_EMPTY nvarchar(200);
		SET @ERR_ConstructionCode_IS_EMPTY = 'ERR_GENERAL';
	DECLARE @ERR_ConsolidatedProductID_IS_EMPTY nvarchar(200);
		SET @ERR_ConsolidatedProductID_IS_EMPTY = 'ERR_GENERAL';
	DECLARE @ERR_ConsolidatedProduct_IS_NOT_FOUND nvarchar(200);
		SET @ERR_ConsolidatedProduct_IS_NOT_FOUND = 'ERR_GENERAL';
	DECLARE @ERR_ConsolidatedProduct_INCOMPLETED nvarchar(200);
		SET @ERR_ConsolidatedProduct_INCOMPLETED = 'ERR_GENERAL';
	DECLARE @ERR_ACCOUNTNUMBER_CANNOT_BE_EMPTY nvarchar(200);
		SET @ERR_ACCOUNTNUMBER_CANNOT_BE_EMPTY = 'ERR_ACCOUNTNUMBER_CANNOT_BE_EMPTY';
	DECLARE @ERR_DEBTOR_NOT_BELONGS_TO_DEBTCASE nvarchar(200);
		SET @ERR_DEBTOR_NOT_BELONGS_TO_DEBTCASE = 'ERR_DEBTOR_NOT_BELONGS_TO_DEBTCASE';
	DECLARE @ERR_Different_Capital_Between_Contract_and_Details nvarchar(200);
		SET @ERR_Different_Capital_Between_Contract_and_Details = 'ERR_GENERAL';
	DECLARE @ERR_Different_Interest_Between_Contract_and_Details nvarchar(200);
		SET @ERR_Different_Interest_Between_Contract_and_Details = 'ERR_GENERAL';
	DECLARE @ERR_Different_PenaltyInterest_Between_Contract_and_Details nvarchar(200);
		SET @ERR_Different_PenaltyInterest_Between_Contract_and_Details = 'ERR_GENERAL';
	DECLARE @ERR_Different_Cost_Between_Contract_and_Details nvarchar(200);
		SET @ERR_Different_Cost_Between_Contract_and_Details = 'ERR_GENERAL';
	DECLARE @ERR_Different_Total_Between_Contract_and_Details nvarchar(200);
		SET @ERR_Different_Total_Between_Contract_and_Details = 'ERR_GENERAL';
	DECLARE @ERR_Different_CostLocalCurrency_Between_Contract_and_Details nvarchar(200);
		SET @ERR_Different_CostLocalCurrency_Between_Contract_and_Details = 'ERR_GENERAL';
	DECLARE @ERR_Different_CurrencyCode_Between_Contract_and_Details nvarchar(200);
		SET @ERR_Different_CurrencyCode_Between_Contract_and_Details = 'ERR_GENERAL';
	DECLARE @ERR_PurchaseCurrency_IS_EMPTY nvarchar(200);
		SET @ERR_PurchaseCurrency_IS_EMPTY = 'ERR_GENERAL';
	DECLARE @ERR_PurchaseCurrencyCode_IS_EMPTY nvarchar(200);
		SET @ERR_PurchaseCurrencyCode_IS_EMPTY = 'ERR_GENERAL';
	DECLARE @ERR_PurchaseCurrency_IS_INVALID nvarchar(200);
		SET @ERR_PurchaseCurrency_IS_INVALID = 'ERR_GENERAL';
	DECLARE @ERR_PurchaseCurrencyCode_IS_INVALID nvarchar(200);
		SET @ERR_PurchaseCurrencyCode_IS_INVALID = 'ERR_GENERAL';
	DECLARE @ERR_PurchaseCurrency_Difference nvarchar(200);
		SET @ERR_PurchaseCurrency_Difference = 'ERR_GENERAL';
	DECLARE @ERR_PurchasePrice_Difference nvarchar(200);
		SET @ERR_PurchasePrice_Difference = 'ERR_GENERAL';
	DECLARE @ERR_PurchaseDate_IS_EMPTY nvarchar(200);
		SET @ERR_PurchaseDate_IS_EMPTY = 'ERR_GENERAL';

	Set @l_MappingId = (Select Top 1 Id from IFC.Mapping where Mapping.Name = 'Konstrukciós kód alapján termék típus meghatározás(TA)' order by Mapping.Id desc);
-- End of Alternatív Hibakódok:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);
	Declare @l_ErrorExists int; /* Nem volt hiba: 1, Volt hiba: 99, Default 1 */

	Set @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
	Set @l_ErrorExists = 1;
   

	DECLARE @PRTEvent nvarchar(200);
	SET @PRTEvent = (Select Top 1 Code from GEN.ObjectType where TableName = 'ORG.Event' order by TableName desc);

	DECLARE @l_ObjectID numeric(16);
	DECLARE @l_InstanceObjectID numeric(16);


	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.MainIFCPreControl',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);


    BEGIN TRY
        SET @LogMessage = 'MainIFCPreControl Started at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
		
		Declare @l_DebtCase nvarchar(1); -- DebtCase = 'T'
-----------------------------------------------
		Declare @ID NUMERIC(16);
		Declare @SourceInterfaceType NVARCHAR(200);
		Declare @SourceID NVARCHAR(200);
		--Declare @l_contractCheck NVARCHAR(200) = NULL;

		Declare @l_AllRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);
		Declare @l_AllDebtCaseRowCounts numeric(18);
		Declare @l_ErrorDebtCaseRowCounts numeric(18);
		Declare @l_AllPersonRowCounts numeric(18);
		Declare @l_ErrorPersonRowCounts numeric(18);
		Declare @l_AllCompanyRowCounts numeric(18);
		Declare @l_ErrorCompanyRowCounts numeric(18);
		Declare @l_AllAssetRowCounts numeric(18);
		Declare @l_ErrorAssetRowCounts numeric(18);

		DECLARE @l_collectionContractItemID NUMERIC(16) = NULL;
		DECLARE @l_invoiceDebtCapital MONEY = NULL;
		DECLARE @l_invoiceDebtInterest MONEY = NULL;
		DECLARE @l_invoiceDebtPenaltyInterest MONEY = NULL;
		DECLARE @l_invoiceDebtCost MONEY = NULL;
		DECLARE @l_invoiceDebtTotal MONEY = NULL;
		DECLARE @l_invoiceDebtCostLocalCurrency MONEY = NULL;
		DECLARE @l_invoiceCurrencyCode NVARCHAR(200) = NULL;
		DECLARE @l_contractItemDebtCapital MONEY = NULL;
		DECLARE @l_contractItemDebtInterest MONEY = NULL;
		DECLARE @l_contractItemDebtPenaltyInterest MONEY = NULL;
		DECLARE @l_contractItemDebtCost MONEY = NULL;
		DECLARE @l_contractItemDebtTotal MONEY = NULL;
		DECLARE @l_contractItemDebtCostLocalCurrency MONEY = NULL;
		DECLARE @l_contractItemCurrencyCode NVARCHAR(200) = NULL;
		Declare @l_ContractId numeric(18);
		Declare @BankAccountNumber NVARCHAR(200);
		Declare @PortfolioName Nvarchar(50);
		Declare @PortfolioID numeric(18);
		Declare @Rel_PortfolioName Nvarchar(50); /* Related DebtCase Portfolio */
		Declare @Rel_PortfolioID numeric(18);	/* Related DebtCase Portfolio */
		Declare @SourceAssetID nvarchar(200);
		Declare @SourceDebtCaseID nvarchar(200);
		Declare @PurchasePrice Money;
		Declare @PurchasePriceCurrency nvarchar(200);
		Declare @PurchasePriceCurrencyCode nvarchar(200);
		Declare @ConstructionCode  nvarchar(200);

		Declare @l_PurchasePrice Money;
		Declare @l_PurchasePriceCurrencyCode nvarchar(200);

		Declare @PurchaseDate Date;

		SET @l_AllDebtCaseRowCounts = 0;
		SET @l_ErrorDebtCaseRowCounts = 0;
		SET @l_AllPersonRowCounts = 0;
		SET @l_ErrorPersonRowCounts = 0;
		SET @l_AllCompanyRowCounts = 0;
		SET @l_ErrorCompanyRowCounts = 0;
		SET @l_AllAssetRowCounts = 0;
		SET @l_ErrorAssetRowCounts = 0;

		SET @l_AllDebtCaseRowCounts = (Select Count(*) FROM IFC.DebtCase where 
					SourceInterfaceType = @l_sourceInterfaceType 
					and
					(
					(DebtCase.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or 
					(DebtCase.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.DebtCase' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));
		SET @l_AllPersonRowCounts = (Select Count(*) FROM IFC.Person where 
					SourceInterfaceType = @l_sourceInterfaceType 
					and
					(
					(Person.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or 
					(Person.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Person' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));
		SET @l_AllCompanyRowCounts = (Select Count(*) FROM IFC.Company where 
							SourceInterfaceType = @l_sourceInterfaceType 
					and
					(
					(Company.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or 
					(Company.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Company' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));
		SET @l_AllAssetRowCounts = (Select Count(*) FROM IFC.Asset where 
									SourceInterfaceType = @l_sourceInterfaceType 
					and
					(
					(Asset.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or 
					(Asset.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Asset' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					));

		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';

			--SELECT 
			--	@l_contractCheck = ModuleInstanceParameter.ParameterValue 
			--FROM ORG.ModuleInstanceParameter
			--WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			--AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_CONTRACT_CHECK';
		END
		Else
		Begin
			INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				@p_CorrelationID,			-- CorrelationID
				'INDECS 3.0',				-- ApplicationName
				DB_NAME(),					-- Environment
				'BACKEND',					-- Layer
				'IFC.MainIFCPreControl',		-- ServiceName
				'1.0',						-- ServiceVersion
				'FATAL',					-- SeverityLevel
				NULL,						-- MessageCategory
				'The ModuleInstanceID is not defined!';	-- LogMessage

			RAISERROR('The ModuleInstanceID is not defined!', 16, 1);
		End;

		IF COALESCE(@l_sourceInterfaceType, '') = '' 
		Begin
			INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				@p_CorrelationID,			-- CorrelationID
				'INDECS 3.0',				-- ApplicationName
				DB_NAME(),					-- Environment
				'BACKEND',					-- Layer
				'IFC.MainIFCPreControl',		-- ServiceName
				'1.0',						-- ServiceVersion
				'FATAL',					-- SeverityLevel
				NULL,						-- MessageCategory
				'The SourceInterfaceType field is not defined!';	-- LogMessage

			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);
		End;



------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- DebtCase:
		DECLARE db_cursor CURSOR FOR 
		SELECT ID, SourceInterfaceType, SourceID, PortfolioName, PortfolioID, BankAccountNumber, PurchasePrice, PurchasePriceCurrency, PurchasePriceCurrencyCode,
			     CreditTypeCode, CreditType, ConstructionCode, PurchaseDate
		FROM IFC.DebtCase
		where SourceInterfaceType = @l_sourceInterfaceType 
							and
					(
					(DebtCase.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or 
					(DebtCase.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.DebtCase' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
			order by id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor 
			INTO @ID, @SourceInterfaceType, @SourceID, @PortfolioName, @PortfolioID, @BankAccountNumber, @PurchasePrice, @PurchasePriceCurrency, @PurchasePriceCurrencyCode, @CreditTypeCode, @CreditType, @ConstructionCode, @PurchaseDate

		WHILE @@FETCH_STATUS = 0  
		BEGIN  

			SET @ErrorMessage = NULL;
			SET @ConsolidatedProductID = null;
			SET @ConsolidatedProductCode = null;
			SET @CaseTypeCode = null;
			SET	@EventTypeCode = null;
			Set @rel_PortfolioID = NULL;

			BEGIN TRY --Belső-1
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- DebtCase PortfolioName/PortfolioID is NULL:
				/* Kikapcsolva, mert felül kell vizsgálni az ellenőrzési logikát
				If @PortfolioName is null and @PortfolioID is null
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' PortfolioID/PortfolioName is Empty,');

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.DebtCase', @ID, 'portfolioName', @ERR_PORTFOLIOID_CANNOT_BE_NULL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.DebtCase', @ID, 'portfolioID', @ERR_PORTFOLIOID_CANNOT_BE_NULL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;;
				End
				ELSE If @PortfolioName is not null and 
						@PortfolioID is not null and 
						(Select Name from Gen.Portfolio where Portfolio.ID = @PortfolioID) <> @PortfolioName
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- DebtCase PortfolioName <-> PortfolioID:
				BEGIN
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' PortfolioID <-> PortfolioName,');

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.DebtCase', @ID, 'portfolioName', @ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.DebtCase', @ID, 'portfolioID', @ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				END
				ELSE If	@PortfolioName is not null and (Select Top 1 TreatmentTypeCode from Gen.Portfolio where Portfolio.Name = @PortfolioName order by ID desc) = 'TREATMENT_TYPE_TECHNICAL'
					 or 	@PortfolioID is not null and (Select TreatmentTypeCode from Gen.Portfolio where Portfolio.ID = @PortfolioID) = 'TREATMENT_TYPE_TECHNICAL'
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- DebtCase Technical:
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Portfolio Type is Technical !,');
				
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.DebtCase', @ID, 'portfolioName', @ERR_PORTFOLIO_TREATMENT_TYPE_TECHNICAL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.DebtCase', @ID, 'portfolioID', @ERR_PORTFOLIO_TREATMENT_TYPE_TECHNICAL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;*/


---------------------------------------------------------------------------------------------------------------------------------------------
-- BankAccountNumber:
				If @BankAccountNumber is NULL
				and @SourceInterfaceType like 'OTPTA_%'
				BEGIN
						SET @ErrorMessage = Concat(@ErrorMessage, ' BankAccountNumber is Empty,');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
						Select 'IFC.DEBTCASE', @ID, 'bankAccountNumber', @ERR_ACCOUNTNUMBER_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
				END;
---------------------------------------------------------------------------------------------------------------------------------------------
-- PurchaseDate:
				If @PurchaseDate is NULL
				and @SourceInterfaceType like 'OTPTA_%'
				BEGIN
						SET @ErrorMessage = Concat(@ErrorMessage, ' PurchaseDate is Empty,');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
						Select 'IFC.DEBTCASE', @ID, 'purchaseDate', @ERR_PurchaseDate_IS_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
				END;
---------------------------------------------------------------------------------------------------------------------------------------------
-- Az ügyhöz legalább egy kötelezett legyen:
				If Not exists(
								Select 1 from IFC.DebtCase
								join IFC.Debtor on Debtor.SourceInterfaceType = DebtCase.SourceInterfaceType and Debtor.SourceDebtCaseID = DebtCase.SourceID
								left join IFC.Company ifcc on ifcc.SourceInterfaceType = Debtor.SourceInterfaceType and ifcc.SourceID = Debtor.SourceCompanyID
								left join IFC.Person ifcp on ifcp.SourceInterfaceType = Debtor.SourceInterfaceType and ifcp.SourceID = Debtor.SourcePersonID

								left join PRT.Entity pec on pec.SourceInterfaceType = DebtCase.SourceInterfaceType and pec.SourceID = Debtor.SourceCompanyID
								left join Prt.Company on Company.EntityID = pec.ID

								left join PRT.Entity pep on pep.SourceInterfaceType = DebtCase.SourceInterfaceType and pep.SourceID = Debtor.SourceCompanyID
								left join Prt.Person on Person.EntityID = pep.ID

								where 
								Debtcase.SourceInterfaceType = @SourceInterfaceType and DebtCase.SourceID = @SourceID
								and
								(ifcc.id is not NULL or ifcp.Id is not NULL or pec.id is not NULL or pep.Id is not NULL)
								)
				BEGIN
						SET @ErrorMessage = Concat(@ErrorMessage, ' DebtCase has not any Debtor,');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
						Select 'IFC.DEBTCASE', @ID, 'sourceID', @ERR_DEBTOR_NOT_BELONGS_TO_DEBTCASE, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
				END;
---------------------------------------------------------------------------------------------------------------------------------------------


--Check contract:
				SELECT @l_collectionContractItemID = NULL;

-- ContractID beolvasása kézi (excel-es) betöltés esetén:
				Set @l_ContractId = NULL;

				If Exists (Select 1 From IFC.InterfacePackage where SourceInterfaceType = @l_sourceInterfaceType)
				Begin
					Set @l_ContractId = (Select Top 1 ContractId From IFC.InterfacePackage where SourceInterfaceType = @l_sourceInterfaceType order by id desc);
				End;

				IF COALESCE(@ErrorMessage, '') = ''
				BEGIN
					IF Exists (Select 1 from ORG.ModuleInstanceParameter 
					where ModuleInstanceID = @p_moduleInstanceID 
					and ParameterValue = 'BOOLEAN_TRUE' 
					and ParameterCode = 'MODULE_PARAMETER_IFC_CONTRACT_CHECK')
					BEGIN --IF COALESCE(@l_contractCheck, 'BOOLEAN_FALSE') = 'BOOLEAN_TRUE'
						IF @l_ContractId is NULL /* TA-s betöltés */
						Begin
							SELECT @l_collectionContractItemID = [CollectionContractItem].[ID] 
							FROM [CRM].[CollectionContractItem] 
							JOIN [CRM].[ContractItem] ON ([ContractItem].[ID] = [CollectionContractItem].[ContractItemID])
							JOIN [CRM].[Contract] ON ([Contract].[ID] = [ContractItem].[ContractID])
							WHERE [Contract].[ContractPhaseCode] = 'CONTRACT_PHASE_CONTRACT'
							AND [Contract].[StatusCode] = 'CONTRACT_STATUS_CONTRACT_VALID'
							AND [CollectionContractItem].[AccountNr] = @BankAccountNumber
							AND COALESCE([CollectionContractItem].[DebtCaseID], 0) = 0;

							SELECT @l_PurchasePrice = ContractItem.GrossValue,	@l_PurchasePriceCurrencyCode = ContractItem.CurrencyID
							FROM [CRM].[CollectionContractItem] 
							JOIN [CRM].[ContractItem] ON ([ContractItem].[ID] = [CollectionContractItem].[ContractItemID])
							JOIN [CRM].[Contract] ON ([Contract].[ID] = [ContractItem].[ContractID])
							join CRM.CollectionContractSummary on CollectionContractSummary.ContractID = Contract.ID
							WHERE [Contract].[ContractPhaseCode] = 'CONTRACT_PHASE_CONTRACT'
							AND [Contract].[StatusCode] = 'CONTRACT_STATUS_CONTRACT_VALID'
							AND [CollectionContractItem].[AccountNr] = @BankAccountNumber
							AND COALESCE([CollectionContractItem].[DebtCaseID], 0) = 0;

						End
						Else /* Kézi, Excel-es betöltés */
						Begin
							SELECT @l_collectionContractItemID = [CollectionContractItem].[ID] 
							FROM [CRM].[CollectionContractItem] 
							JOIN [CRM].[ContractItem] ON ([ContractItem].[ID] = [CollectionContractItem].[ContractItemID])
							JOIN [CRM].[Contract] ON ([Contract].[ID] = [ContractItem].[ContractID])
							WHERE [Contract].[ContractPhaseCode] = 'CONTRACT_PHASE_CONTRACT'
							AND [Contract].[StatusCode] = 'CONTRACT_STATUS_CONTRACT_VALID'
							AND [CollectionContractItem].[AccountNr] = @BankAccountNumber
							AND COALESCE([CollectionContractItem].[DebtCaseID], 0) = 0
							AND [Contract].[ID] = @l_ContractId;

							SELECT @l_PurchasePrice = ContractItem.GrossValue,	@l_PurchasePriceCurrencyCode = ContractItem.CurrencyID
							FROM [CRM].[CollectionContractItem] 
							JOIN [CRM].[ContractItem] ON ([ContractItem].[ID] = [CollectionContractItem].[ContractItemID])
							JOIN [CRM].[Contract] ON ([Contract].[ID] = [ContractItem].[ContractID])
							join CRM.CollectionContractSummary on CollectionContractSummary.ContractID = Contract.ID
							WHERE [Contract].[ContractPhaseCode] = 'CONTRACT_PHASE_CONTRACT'
							AND [Contract].[StatusCode] = 'CONTRACT_STATUS_CONTRACT_VALID'
							AND [CollectionContractItem].[AccountNr] = @BankAccountNumber
							AND COALESCE([CollectionContractItem].[DebtCaseID], 0) = 0
							AND [Contract].[ID] = @l_ContractId;
						End; /* IF @l_ContractId is NULL -- TA-s betöltés */

						IF COALESCE(@l_collectionContractItemID, 0) = 0
						Begin
							SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Contract item is not found,')
						End
						ELSE 
						BEGIN
							SELECT 
								@l_contractItemDebtCapital = [CollectionContractItem].[DebtCapital],
								@l_contractItemDebtInterest = [CollectionContractItem].[DebtInterest],
								@l_contractItemDebtPenaltyInterest = [CollectionContractItem].[DebtPenaltyInterest],
								@l_contractItemDebtCost = [CollectionContractItem].[DebtCost],
								@l_contractItemDebtTotal = [CollectionContractItem].[DebtTotal],
								@l_contractItemDebtCostLocalCurrency = [CollectionContractItem].[DebtCostLocalCurrency],
								@l_contractItemCurrencyCode = [CollectionContractItem].[CurrencyCode]
							FROM [CRM].[CollectionContractItem] 
							WHERE [CollectionContractItem].[ID] = @l_collectionContractItemID;

							SELECT 
								@l_invoiceDebtCapital = SUM([Invoice].[ArrearsCapital]),
								@l_invoiceDebtInterest = SUM([Invoice].[ArrearsInterest]),
								@l_invoiceDebtPenaltyInterest = SUM([Invoice].[ArrearsPenaltyInterest]),
								@l_invoiceDebtCost = SUM([Invoice].[ArrearsCost]),
								@l_invoiceDebtTotal = SUM([Invoice].[ArrearsCapital]) + 
									SUM([Invoice].[ArrearsInterest]) + 
									SUM([Invoice].[ArrearsPenaltyInterest]) + 
									SUM([Invoice].[ArrearsCost]),
								@l_invoiceDebtCostLocalCurrency = SUM([Invoice].[ArrearsCostLocalCurrency]),
								@l_invoiceCurrencyCode = 
									COALESCE(
										(SELECT TOP 1 [Inv].[CurrencyCode] 
										 FROM [IFC].[Invoice] AS Inv 
										 WHERE [Inv].[SourceInterfaceType] = @SourceInterfaceType 
										 AND [Inv].[SourceDebtCaseID] = [Invoice].[SourceDebtCaseID]
										 ORDER BY [Inv].[ID]),
										(SELECT TOP 1 [Code].[ID] 
										 FROM [GEN].[Translation]
										 JOIN [GEN].[Code] ON ([Code].[ID] = [Translation].[CodeID])
										 JOIN [GEN].[ValueSet] ON ([ValueSet].[ID] = [Code].[ValueSetID]) 
										 WHERE [ValueSet].[Code] = 'VALUESET_CURRENCY' 
										 AND [Translation].[Text] = 
											(SELECT TOP 1 [Inv].[CurrencyText] 
											 FROM [IFC].[Invoice] AS Inv 
											 WHERE [Inv].[SourceInterfaceType] = @SourceInterfaceType 
											 AND [Inv].[SourceDebtCaseID] = [Invoice].[SourceDebtCaseID] 
											 ORDER BY [Inv].[ID])))
							FROM [IFC].[DebtCase] 
							JOIN [IFC].[Invoice] ON 
								([Invoice].[SourceInterfaceType] = [DebtCase].[SourceInterfaceType] AND [Invoice].[SourceDebtCaseID] = [DebtCase].[SourceID])
							WHERE [DebtCase].[ID] = @ID
							AND [Invoice].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
							GROUP BY [Invoice].[SourceDebtCaseID];

							IF COALESCE(@l_contractItemDebtCapital, 0) <> COALESCE(@l_invoiceDebtCapital, 0)
							Begin
								SET @ErrorMessage = Concat(@ErrorMessage, ' The capital amount specified in the contract does not match the capital amount of the case,');
								Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
								Select 'IFC.DEBTCASE', @ID, NULL, @ERR_Different_Capital_Between_Contract_and_Details, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
							End;

							IF COALESCE(@l_contractItemDebtInterest, 0) <> COALESCE(@l_invoiceDebtInterest, 0)
								SET @ErrorMessage = Concat(@ErrorMessage, ' The interest amount specified in the contract does not match the interest amount of the case,');
								Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
								Select 'IFC.DEBTCASE', @ID, NULL, @ERR_Different_Interest_Between_Contract_and_Details, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';

							IF COALESCE(@l_contractItemDebtPenaltyInterest, 0) <> COALESCE(@l_invoiceDebtPenaltyInterest, 0)
								SET @ErrorMessage = Concat(@ErrorMessage, ' The penalty interest amount specified in the contract does not match the penalty interest amount of the case,');
								Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
								Select 'IFC.DEBTCASE', @ID, NULL, @ERR_Different_PenaltyInterest_Between_Contract_and_Details, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
								
							IF COALESCE(@l_contractItemDebtCost, 0) <> COALESCE(@l_invoiceDebtCost, 0)
								SET @ErrorMessage = Concat(@ErrorMessage, ' The cost amount specified in the contract does not match the cost amount of the case,');
								Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
								Select 'IFC.DEBTCASE', @ID, NULL, @ERR_Different_Cost_Between_Contract_and_Details, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';

							IF COALESCE(@l_contractItemDebtTotal, 0) <> COALESCE(@l_invoiceDebtTotal, 0)
								SET @ErrorMessage = Concat(@ErrorMessage, ' The total amount specified in the contract does not match the total amount of the case,');
								Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
								Select 'IFC.DEBTCASE', @ID, NULL, @ERR_Different_Total_Between_Contract_and_Details, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';

							IF COALESCE(@l_contractItemDebtCostLocalCurrency, 0) <> COALESCE(@l_invoiceDebtCostLocalCurrency, 0)
								SET @ErrorMessage = Concat(@ErrorMessage, ' The cost local currency amount specified in the contract does not match the cost local currency amount of the case,');
								Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
								Select 'IFC.DEBTCASE', @ID, NULL, @ERR_Different_CostLocalCurrency_Between_Contract_and_Details, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';

							IF COALESCE(@l_contractItemCurrencyCode, '') <> COALESCE(@l_invoiceCurrencyCode, '')
								SET @ErrorMessage = Concat(@ErrorMessage, ' The currency specified in the contract does not match the currency of the case,');
								Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
								Select 'IFC.DEBTCASE', @ID, NULL, @ERR_Different_CurrencyCode_Between_Contract_and_Details, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';

						END; /* IF COALESCE(@l_collectionContractItemID, 0) = 0 */

/* Átrakva "hátrébb"
-- PurchasePrice Control @PurchasePriceCurrencyCode:
						If Isnull(@PurchasePriceCurrencyCode,'') <> Isnull(@l_PurchasePriceCurrencyCode,'')
						Begin
							SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Different Purchase Price Currency between Contract and Details,');
							Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
							Select 'IFC.DEBTCASE', @ID, 'purchaseCurrencyCode', @ERR_CODE_CODE_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
						End;
*/
-- Visszarakva (2023.12.03):
-- PurchasePrice Control @Currency,@CurrencyCode:
						-- 0 - NULL:
						If Trim(Isnull(@PurchasePriceCurrency,'')) = ''
							Set @PurchasePriceCurrency = NULL;
						If Trim(Isnull(@PurchasePriceCurrencyCode,'')) = ''
							Set @PurchasePriceCurrencyCode = NULL;
						Set @PurchasePriceCurrency = Trim(@PurchasePriceCurrency);
						Set @PurchasePriceCurrencyCode = Trim(@PurchasePriceCurrencyCode);
					
						-- 1 - Üres:
						If @PurchasePriceCurrency is NULL and @PurchasePriceCurrencyCode is NULL
						BEGIN
							SET @ErrorMessage = Concat(@ErrorMessage, ' PurchaseCurrency/PurchaseCurrencyCode is Empty,');
							Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
							Select 'IFC.DEBTCASE', @ID, 'purchaseCurrency', @ERR_PurchaseCurrency_IS_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
							Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
							Select 'IFC.DEBTCASE', @ID, 'purchaseCurrencyCode', @ERR_PurchaseCurrencyCode_IS_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
						END;
						-- 2 - Text-NotValid:
						If @PurchasePriceCurrency is NOT NULL and @PurchasePriceCurrencyCode is NULL
						BEGIN
							If Not exists (
									select 1
									from Gen.ValueSet
									left Join Gen.Code on Code.ValueSetID = ValueSet.Id
									left join Gen.Translation on Translation.CodeID = Code.Id
									where CodePrefix like 'CURRENCY%'
									and Translation.Text = @PurchasePriceCurrency)
								Begin
									SET @ErrorMessage = Concat(@ErrorMessage, ' PurchaseCurrency is not Valid,');
									Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
									Select 'IFC.DEBTCASE', @ID, 'purchaseCurrency', @ERR_PurchaseCurrency_IS_INVALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
									SET @PurchasePriceCurrency = NULL;
								End;
							Else
								Set @PurchasePriceCurrencyCode = (select Top 1 Code.Id 
									from Gen.ValueSet
									left Join Gen.Code on Code.ValueSetID = ValueSet.Id
									left join Gen.Translation on Translation.CodeID = Code.Id
									where CodePrefix like 'CURRENCY%'
									and Translation.Text = @PurchasePriceCurrency order by Code.Id desc);
						END;
						-- 3 - Code-NotValid:
						If @PurchasePriceCurrency is NULL and @PurchasePriceCurrencyCode is not NULL
						and Not exists (select 1
									from Gen.ValueSet
									left Join Gen.Code on Code.ValueSetID = ValueSet.Id
									left join Gen.Translation on Translation.CodeID = Code.Id
									where CodePrefix like 'CURRENCY%'
									and Code.Id = @PurchasePriceCurrencyCode)
						BEGIN
									SET @ErrorMessage = Concat(@ErrorMessage, ' PurchaseCurrencyCode is not Valid,');
									Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
									Select 'IFC.DEBTCASE', @ID, 'purchaseCurrency', @ERR_PurchaseCurrencyCode_IS_INVALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
									SET @PurchasePriceCurrencyCode = NULL;
						END;

-- PurchasePrice Control @PurchasePriceCurrencyCode:
						If Isnull(@PurchasePriceCurrencyCode,'') <> Isnull(@l_PurchasePriceCurrencyCode,'')
						Begin
							SET @ErrorMessage = Concat(@ErrorMessage, ' Different Purchase Price Currency between Contract and Details,');
							Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
							Select 'IFC.DEBTCASE', @ID, 'purchaseCurrencyCode', @ERR_PurchaseCurrency_Difference, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
						End;

-- PurchasePrice Control @PurchasePrice:
						If Isnull(@PurchasePrice,0) <> Isnull(@l_PurchasePrice,0)
						Begin
							SET @ErrorMessage = Concat(@ErrorMessage, ' Different Purchase Price between Contract and Details,');
							Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
							Select 'IFC.DEBTCASE', @ID, 'purchasePrice', @ERR_PurchasePrice_Difference, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
						End;

					END; /* IF COALESCE(@l_contractCheck, 'BOOLEAN_FALSE') = 'BOOLEAN_TRUE' */
				END;


-- @CreditType,@CreditTypeCode:
/* 2023-11-17 */
/*
			If @CreditTypeCode like 'TAFK55/%'
			begin
				If not Exists (select 1 Code from IFC.MappingCode where MappingCode.ExternalCode = Replace(@CreditTypeCode,'TAFK55/','') 
						and Isnull(ValidFrom,CAST( GETDATE() AS Date )) >= CAST( GETDATE() AS Date ) 
						and Isnull(ValidUntil, CAST( GETDATE() AS Date )) <= CAST( GETDATE() AS Date )
							and MappingCode.MappingId = @l_MappingId)
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' CreditTypeCode is not exists in IFC.MappingCode,');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode)
					Select 'IFC.DEBTCASE', @ID, 'creditTypeCode', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR';
				End
				Else
				Begin
					Set @CreditTypeCode = (select top 1 Code from IFC.MappingCode where MappingCode.ExternalCode = Replace(@CreditTypeCode,'TAFK55/','') and Isnull(ValidFrom,CAST( GETDATE() AS Date )) >= CAST( GETDATE() AS Date ) and Isnull(ValidUntil, CAST( GETDATE() AS Date )) <= CAST( GETDATE() AS Date )
					and MappingCode.MappingId = @l_MappingId order by MappingCode.Id desc);
				End;
			end;
*/

			-- 0 - NULL:
			If Trim(Isnull(@CreditType,'')) = ''
				Set @CreditType = NULL;
			If Trim(Isnull(@CreditTypeCode,'')) = ''
				Set @CreditTypeCode = NULL;
			Set @CreditType = Trim(@CreditType);
			Set @CreditTypeCode = Trim(@CreditTypeCode);
			
			-- 1 - Üres:
			If @CreditType is NULL and @CreditTypeCode is NULL
			BEGIN
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' CreditType/CreditTypeCode is Empty,');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode)
				Select 'IFC.DEBTCASE', @ID, 'creditType', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName,'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR';
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode)
				Select 'IFC.DEBTCASE', @ID, 'creditTypeCode', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR';
			END;
			-- 2 - Text-NotValid:
			If @CreditType is NOT NULL and @CreditTypeCode is NULL
			BEGIN
				If Not exists (
						select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CREDIT_TYPE%'
						and Translation.Text = @CreditType)
					Begin
						Set @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' CreditType is not Valid,');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode)
						Select 'IFC.DEBTCASE', @ID, 'creditType', @ERR_CODE_NAME_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR';
					End;
				Else
					Set @CreditTypeCode = (select Top 1 Code.Id 
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CREDIT_TYPE%'
						and Translation.Text = @CreditType order by Code.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @CreditType is NULL and @CreditTypeCode is not NULL
			and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'CREDIT_TYPE%'
						and Code.Id = @CreditTypeCode)
			BEGIN
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' CreditTypeCode is not Valid,');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode)
				Select 'IFC.DEBTCASE', @ID, 'creditTypeCode', @ERR_CODE_CODE_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR';
			END;

---------------------------------------------------------------------------------------------------------------------------------------------
-- @ConstructionCode: ( 2023-12-07: )
	-- Üres a kód:
		IF Trim(Isnull(@ConstructionCode,'')) = ''
		BEGIN
			SET @ErrorMessage = Concat(@ErrorMessage, ' ConstructionCode is Empty,');
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
			Select 'IFC.DEBTCASE', @ID, 'constructionCode', @ERR_ConstructionCode_IS_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
		END;
		
    /*consolidated product, caseType, eventType*/
		Select @ConsolidatedProductID = fx.ConsolidatedProductID,
           @ConsolidatedProductCode = ConsolidatedProduct.Code, 
				   @CaseTypeCode = ConsolidatedProduct.CaseTypeCode,
				   @EventTypeCode = ConsolidatedProduct.EventTypeCode
		from FIN.ConstructionCode fx 
				 join FIN.ConsolidatedProduct on ConsolidatedProduct.Id = fx.ConsolidatedProductID
	  where fx.Code = @ConstructionCode and Isnull(fx.ConsolidatedProductID,0) <> 0;

		If not exists (Select 1 from Gen.Code where Id = @ConsolidatedProductCode)
		BEGIN
			SET @ErrorMessage = Case when @ConsolidatedProductID is null then 'ConsolidatedProductID not found in FIN.ConstructionCode' else 'ConsolidatedProductCode is not Valid in FIN.ConsolidatedProduct' end
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
			Select 'IFC.DEBTCASE', @ID, 'constructionCode', @ERR_ConsolidatedProductCode_IS_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
		END;
		If not exists (Select 1 from Gen.Code where Id = @CaseTypeCode)
		BEGIN
			SET @ErrorMessage = Concat(@ErrorMessage, ' CaseTypeCode is not Valid in FIN.ConsolidatedProduct,');
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
			Select 'IFC.DEBTCASE', @ID, 'constructionCode', @ERR_ConsolidatedProductCaseTypeCode_IS_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
		END;
		If not exists (Select 1 from Gen.Code where Id = @EventTypeCode)
		BEGIN
			SET @ErrorMessage = Concat(@ErrorMessage, ' EventTypeCode is not Valid in FIN.ConsolidatedProduct,');
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
			Select 'IFC.DEBTCASE', @ID, 'constructionCode', @ERR_ConsolidatedProductEventTypeCode_IS_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN';
		END;


-- Error Sign:
				If @ErrorMessage is not NULL
				Begin
					Set @l_ErrorDebtCaseRowCounts = @l_ErrorDebtCaseRowCounts + 1;
					Update IFC.DebtCase Set ErrorMessage = '[Precontrol]: ' + @ErrorMessage, InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName where ID = @ID;
					Set @l_ErrorExists = 99;
				End;
			END TRY --Belső-1

			BEGIN CATCH --Belső-1
				SELECT 
					@ErrorMessage = ERROR_MESSAGE()
					, @ErrorSeverity = ERROR_SEVERITY()
					, @ErrorState = ERROR_STATE()
					, @ErrorLine = ERROR_LINE();

				SET @l_ErrorDebtCaseRowCounts = @l_ErrorDebtCaseRowCounts + 1;
				Update IFC.DebtCase Set ErrorMessage = '[Precontrol]: ' + @ErrorMessage, InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName  where ID = @ID;
				Set @l_ErrorExists = 99;
			END CATCH --Belső-1

		FETCH NEXT FROM db_cursor 
			INTO @ID, @SourceInterfaceType, @SourceID, @PortfolioName, @PortfolioID, @BankAccountNumber, @PurchasePrice, @PurchasePriceCurrency, @PurchasePriceCurrencyCode,
			@CreditTypeCode, @CreditType, @ConstructionCode, @PurchaseDate

		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Person:
		/* Kikapcsolva, mert felül kell vizsgálni az ellenőrzési logikát
		DECLARE db_cursor CURSOR FOR 
		SELECT 
			ID, SourceInterfaceType, SourceID, PortfolioName, PortfolioID
		FROM IFC.Person
		where InterfaceStatusCode = 'INTERFACE_STATUS_NEW' and SourceInterfaceType = @l_sourceInterfaceType order by id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor 
			INTO @ID, @SourceInterfaceType, @SourceID, @PortfolioName, @PortfolioID

		WHILE @@FETCH_STATUS = 0  
		BEGIN  
			SET @ErrorMessage = NULL;
			Set @rel_PortfolioID = NULL;

			BEGIN TRY --Belső-2

-- Person PortfolioName/PortfolioID is NULL:
				If @PortfolioName is null and @PortfolioID is null
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' PortfolioID/PortfolioName is Empty,');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Person', @ID, 'portfolioName', @ERR_PORTFOLIOID_CANNOT_BE_NULL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Person', @ID, 'portfolioID', @ERR_PORTFOLIOID_CANNOT_BE_NULL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;

-- Person PortfolioName <-> PortfolioID:

				If @PortfolioName is not null and @PortfolioID is not null
				begin
					If (Select Name from Gen.Portfolio where Portfolio.ID = @PortfolioID) <> @PortfolioName
					Begin
						SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' PortfolioID <-> PortfolioName,');

						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
						Select 'IFC.Person', @ID, 'portfolioName', @ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
						Select 'IFC.Person', @ID, 'portfolioID', @ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
					End;
				End;

-- Person Technical:
				If	@PortfolioName is not null and (Select Top 1 TreatmentTypeCode from Gen.Portfolio where Portfolio.Name = @PortfolioName order by ID desc) = 'TREATMENT_TYPE_TECHNICAL'
					or 	@PortfolioID is not null and (Select TreatmentTypeCode from Gen.Portfolio where Portfolio.ID = @PortfolioID) = 'TREATMENT_TYPE_TECHNICAL'
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Portfolio Type is Technical !,');
				
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Person', @ID, 'portfolioName', @ERR_PORTFOLIO_TREATMENT_TYPE_TECHNICAL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Person', @ID, 'portfolioID', @ERR_PORTFOLIO_TREATMENT_TYPE_TECHNICAL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;
-- PortfolioID:
				If	@PortfolioName is not null and @PortfolioID is NULL
				Begin
					Set @PortfolioID = (Select Top 1 ID from Gen.Portfolio where Portfolio.Name = @PortfolioName order by ID desc);
				End;
-- Related DebtCase:
				If exists(Select 1 from Prt.Person
						join Prt.Entity on Entity.ID = Person.EntityID
						join DCS.Debtor on Debtor.EntityID = Person.EntityID
						join DCS.DebtCase on DebtCase.ID = Debtor.DebtCaseID
						join GEN.Object on Object.ID = DebtCase.ObjectID
					where Entity.SourceID = @SourceID and Entity.SourceInterfaceType = @SourceInterfaceType)
				Begin
					Set @rel_PortfolioID = (Select Top 1 Object.PortfolioID from Prt.Person
						join Prt.Entity on Entity.ID = Person.EntityID
						join DCS.Debtor on Debtor.EntityID = Person.EntityID
						join DCS.DebtCase on DebtCase.ID = Debtor.DebtCaseID
						join GEN.Object on Object.ID = DebtCase.ObjectID
						where Entity.SourceID = @SourceID and Entity.SourceInterfaceType = @SourceInterfaceType order by DebtCase.ID desc);
				End;
				Else
				Begin
					Select @rel_PortfolioName = PortfolioName, @rel_PortfolioID = PortfolioID from IFC.DebtCase
					Join IFC.Debtor on Debtor.SourceDebtCaseID = DebtCase.SourceID and Debtor.SourceInterfaceType = DebtCase.SourceInterfaceType and Debtor.InterfaceStatusCode = DebtCase.InterfaceStatusCode
					where Debtor.SourcePersonID = @SourceID and Debtor.SourceInterfaceType = @SourceInterfaceType;
				End;

				If	@rel_PortfolioName is not null and @rel_PortfolioID is NULL
				Begin
					Set @rel_PortfolioID = (Select Top 1 ID from Gen.Portfolio where Portfolio.Name = @rel_PortfolioName order by ID desc);
				End;

				If @rel_PortfolioID <> @PortfolioID
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Different Portfolio !,');
				
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Person', @ID, 'portfolioName', @ERR_PORTFOLIOID_CASE_PORTFOLIOID_MISMATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
	
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Person', @ID, 'portfolioID', @ERR_PORTFOLIOID_CASE_PORTFOLIOID_MISMATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;
			

				If @ErrorMessage is not NULL
				Begin
					SET @l_ErrorPersonRowCounts = @l_ErrorPersonRowCounts + 1;
					Update IFC.Person Set ErrorMessage = '[Precontrol]: ' + @ErrorMessage, InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName  where ID = @ID;
					Set @l_ErrorExists = 99;
				End;
			END TRY --Belső-2

			BEGIN CATCH --Belső-2
				SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
				SET @l_ErrorPersonRowCounts = @l_ErrorPersonRowCounts + 1;
				Update IFC.Person Set ErrorMessage = '[Precontrol]: ' + @ErrorMessage, InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName  where ID = @ID;
				Set @l_ErrorExists = 99;
			END CATCH --Belső-2

			FETCH NEXT FROM db_cursor 
				INTO @ID, @SourceInterfaceType, @SourceID, @PortfolioName, @PortfolioID
			
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;*/

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Company:
		/* Kikapcsolva, mert felül kell vizsgálni az ellenőrzési logikát
		DECLARE db_cursor CURSOR FOR 
		SELECT 
			ID, SourceInterfaceType, SourceID, PortfolioName, PortfolioID
		FROM IFC.Company
		where InterfaceStatusCode = 'INTERFACE_STATUS_NEW'  and SourceInterfaceType = @l_sourceInterfaceType order by id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor 
			INTO @ID, @SourceInterfaceType, @SourceID, @PortfolioName, @PortfolioID

		WHILE @@FETCH_STATUS = 0  
		BEGIN  
			SET @ErrorMessage = NULL;
			Set @rel_PortfolioID = NULL;

			BEGIN TRY --Belső-3
-- Company PortfolioName/PortfolioID is NULL:
				If @PortfolioName is null and @PortfolioID is null
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' PortfolioID/PortfolioName is Empty,');
					
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Company', @ID, 'portfolioName', @ERR_PORTFOLIOID_CANNOT_BE_NULL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Company', @ID, 'portfolioID', @ERR_PORTFOLIOID_CANNOT_BE_NULL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End
				ELSE If @PortfolioName is not null and 
						@PortfolioID is not null and 
						(Select Name from Gen.Portfolio where Portfolio.ID = @PortfolioID) <> @PortfolioName
-- Company PortfolioName <-> PortfolioID:
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' PortfolioID <-> PortfolioName,');
					
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Company', @ID, 'portfolioName', @ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Company', @ID, 'portfolioID', @ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End
				ELSE If	@PortfolioName is not null and (Select Top 1 TreatmentTypeCode from Gen.Portfolio where Portfolio.Name = @PortfolioName order by ID desc) = 'TREATMENT_TYPE_TECHNICAL'
					 or 	@PortfolioID is not null and (Select TreatmentTypeCode from Gen.Portfolio where Portfolio.ID = @PortfolioID) = 'TREATMENT_TYPE_TECHNICAL'
-- Company Technical:
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Portfolio Type is Technical !,');

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Company', @ID, 'portfolioName', @ERR_PORTFOLIO_TREATMENT_TYPE_TECHNICAL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Company', @ID, 'portfolioID', @ERR_PORTFOLIO_TREATMENT_TYPE_TECHNICAL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;

-- PortfolioID:
				If	@PortfolioName is not null and @PortfolioID is NULL
				Begin
					Set @PortfolioID = (Select Top 1 ID from Gen.Portfolio where Portfolio.Name = @PortfolioName order by ID desc);
				End;
			
-- Related DebtCase:
				If exists(Select 1 from Prt.Company
					join Prt.Entity on Entity.ID = Company.EntityID
					join DCS.Debtor on Debtor.EntityID = Company.EntityID
					join DCS.DebtCase on DebtCase.ID = Debtor.DebtCaseID
					join GEN.Object on Object.ID = DebtCase.ObjectID
					where Entity.SourceID = @SourceID and Entity.SourceInterfaceType = @SourceInterfaceType)
				Begin
					Set @rel_PortfolioID = (Select Top 1 Object.PortfolioID from Prt.Company
						join Prt.Entity on Entity.ID = Company.EntityID
						join DCS.Debtor on Debtor.EntityID = Company.EntityID
						join DCS.DebtCase on DebtCase.ID = Debtor.DebtCaseID
						join GEN.Object on Object.ID = DebtCase.ObjectID
						where Entity.SourceID = @SourceID and Entity.SourceInterfaceType = @SourceInterfaceType order by DebtCase.ID desc);
				End;
				Else
				Begin
					Select @rel_PortfolioName = PortfolioName, @rel_PortfolioID = PortfolioID from IFC.DebtCase
					Join IFC.Debtor on Debtor.SourceDebtCaseID = DebtCase.SourceID and Debtor.SourceInterfaceType = DebtCase.SourceInterfaceType and Debtor.InterfaceStatusCode = DebtCase.InterfaceStatusCode
					where Debtor.SourceCompanyID = @SourceID and Debtor.SourceInterfaceType = @SourceInterfaceType;
				End;

				If	@rel_PortfolioName is not null and @rel_PortfolioID is NULL
				Begin
					Set @rel_PortfolioID = (Select Top 1 ID from Gen.Portfolio where Portfolio.Name = @rel_PortfolioName order by ID desc);
				End;

				If @rel_PortfolioID <> @PortfolioID
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Different Portfolio !,');
				
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Company', @ID, 'portfolioName', @ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Company', @ID, 'portfolioID', @ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;

				If @ErrorMessage is not NULL
				Begin
					SET @l_ErrorCompanyRowCounts = @l_ErrorCompanyRowCounts + 1;
					Update IFC.Company Set ErrorMessage = '[Precontrol]: ' + @ErrorMessage, InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName  where ID = @ID;
					Set @l_ErrorExists = 99;
				End;
			END TRY --Belső-3

			BEGIN CATCH --Belső-3
				SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
				SET @l_ErrorCompanyRowCounts = @l_ErrorCompanyRowCounts + 1;
				Update IFC.Company Set ErrorMessage = '[Precontrol]: ' + @ErrorMessage, InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName  where ID = @ID;
				Set @l_ErrorExists = 99
			END CATCH --Belső-3

			FETCH NEXT FROM db_cursor 
				INTO @ID, @SourceInterfaceType, @SourceID, @PortfolioName, @PortfolioID
			
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;*/

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Asset:
		/* Kikapcsolva, mert felül kell vizsgálni az ellenőrzési logikát
		DECLARE db_cursor CURSOR FOR 
		SELECT 
			ID, SourceInterfaceType, SourceID, PortfolioName, PortfolioID
		FROM IFC.Asset
		where InterfaceStatusCode = 'INTERFACE_STATUS_NEW'  and SourceInterfaceType = @l_sourceInterfaceType order by id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor 
			INTO @ID, @SourceInterfaceType, @SourceID, @PortfolioName, @PortfolioID

		WHILE @@FETCH_STATUS = 0  
		BEGIN  
			SET @ErrorMessage = NULL;
			Set @rel_PortfolioID = NULL;

			BEGIN TRY --Belső-4

-- Asset PortfolioName/PortfolioID is NULL:
				If @PortfolioName is null and @PortfolioID is null
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' PortfolioID/PortfolioName is Empty,');
					If @PortfolioName is null 
					Begin
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
						Select 'IFC.Asset', @ID, 'portfolioName', @ERR_PORTFOLIOID_CANNOT_BE_NULL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName
					End;

					If @PortfolioID is null 
					Begin
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
						Select 'IFC.Asset', @ID, 'portfolioID', @ERR_PORTFOLIOID_CANNOT_BE_NULL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
					End;
				End;
-- Asset PortfolioName <-> PortfolioID:
				If @PortfolioName is not null and @PortfolioID is not null
				Begin
					If (Select Name from Gen.Portfolio where Portfolio.ID = @PortfolioID) <> @PortfolioName
					Begin
						SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' PortfolioID <-> PortfolioName,');
					
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
						Select 'IFC.Asset', @ID, 'portfolioName', @ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
						Select 'IFC.Asset', @ID, 'portfolioID', @ERR_PORTFOLIOID_PORTFOLIONAME_MISMATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
					End;
				End;
-- Asset Technical:
				If	@PortfolioName is not null and (Select Top 1 TreatmentTypeCode from Gen.Portfolio where Portfolio.Name = @PortfolioName order by ID desc) = 'TREATMENT_TYPE_TECHNICAL'
					or 	@PortfolioID is not null and (Select TreatmentTypeCode from Gen.Portfolio where Portfolio.ID = @PortfolioID) = 'TREATMENT_TYPE_TECHNICAL'
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Portfolio Type is Technical !,');
				
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Asset', @ID, 'portfolioName', @ERR_PORTFOLIO_TREATMENT_TYPE_TECHNICAL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Asset', @ID, 'portfolioID', @ERR_PORTFOLIO_TREATMENT_TYPE_TECHNICAL, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;

-- PortfolioID:
				If	@PortfolioName is not null and @PortfolioID is NULL
				Begin
					Set @PortfolioID = (Select Top 1 ID from Gen.Portfolio where Portfolio.Name = @PortfolioName order by ID desc);
				End;
-- Related DebtCase:
				If exists(Select 1 from AST.Asset
					join AST.DebtCaseAsset on DebtCaseAsset.AssetID = Asset.ID
					join DCS.DebtCase on DebtCase.ID = DebtCaseAsset.DebtCaseID
					join GEN.Object on Object.ID = DebtCase.ObjectID
					where Asset.SourceID = @SourceID and Asset.SourceInterfaceType = @SourceInterfaceType)
				Begin
					Set @rel_PortfolioID = (Select Top 1 Object.PortfolioID from AST.Asset
					join AST.DebtCaseAsset on DebtCaseAsset.AssetID = Asset.ID
					join DCS.DebtCase on DebtCase.ID = DebtCaseAsset.DebtCaseID
					join GEN.Object on Object.ID = DebtCase.ObjectID
					where Asset.SourceID = @SourceID and Asset.SourceInterfaceType = @SourceInterfaceType order by DebtCase.ID desc);
				End
				Else
				Begin
					Select @rel_PortfolioName = PortfolioName, @rel_PortfolioID = PortfolioID from IFC.DebtCase
					Join IFC.DebtCaseAsset on DebtCaseAsset.SourceDebtCaseID = DebtCase.SourceID and DebtCaseAsset.SourceInterfaceType = DebtCase.SourceInterfaceType and DebtCaseAsset.InterfaceStatusCode = DebtCase.InterfaceStatusCode
					where DebtCaseAsset.SourceAssetID = @SourceID and DebtCaseAsset.SourceInterfaceType = @SourceInterfaceType;
				End;

				If	@rel_PortfolioName is not null and @rel_PortfolioID is NULL
				Begin
					Set @rel_PortfolioID = (Select Top 1 ID from Gen.Portfolio where Portfolio.Name = @rel_PortfolioName order by ID desc);
				End;

				If @rel_PortfolioID <> @PortfolioID
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Different Portfolio,');
				
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Asset', @ID, 'portfolioName', @ERR_ASSET_DEBTCASE_PORTFOLIO_NOT_MATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Asset', @ID, 'portfolioID', @ERR_ASSET_DEBTCASE_PORTFOLIO_NOT_MATCH, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;

-- DebtCase
				If @rel_PortfolioID is NULL
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' DebtCase not Found,');
				
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Asset', @ID, 'sourceInterfaceType', @ERR_ASSET_DEBTCASE_NOT_FOUND, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Asset', @ID, 'sourceID', @ERR_ASSET_DEBTCASE_NOT_FOUND, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;

-- DebtCaseAsset:
				if not exists(Select 1 from IFC.DebtCaseAsset where DebtCaseAsset.SourceInterfaceType = @SourceInterfaceType
					and DebtCaseAsset.SourceAssetID = @SourceID
					and InterfaceStatusCode = 'INTERFACE_STATUS_NEW')
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' DebtCaseAsset not found !,');

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Asset', @ID, 'sourceInterfaceType', @ERR_ASSET_DEBTCASE_ASSIGMENT, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.Asset', @ID, 'SourceID', @ERR_ASSET_DEBTCASE_ASSIGMENT, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;

				If @ErrorMessage is not NULL
				Begin
					SET @l_ErrorAssetRowCounts = @l_ErrorAssetRowCounts + 1;
					Update IFC.Asset Set ErrorMessage = '[Precontrol]: ' + @ErrorMessage, InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName  where ID = @ID;
					Set @l_ErrorExists = 99;
				End;

			END TRY --Belső-4

			BEGIN CATCH --Belső-4
				SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
				SET @l_ErrorAssetRowCounts = @l_ErrorAssetRowCounts + 1;
				Update IFC.Asset Set ErrorMessage = '[Precontrol]: ' + @ErrorMessage, InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName  where ID = @ID;
				Set @l_ErrorExists = 99;
			END CATCH --Belső-4

			FETCH NEXT FROM db_cursor 
				INTO @ID, @SourceInterfaceType, @SourceID, @PortfolioName, @PortfolioID
			
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;*/

------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- DebtCaseAsset:
		/* Kikapcsolva, mert felül kell vizsgálni az ellenőrzési logikát
		DECLARE db_cursor CURSOR FOR 
		SELECT 
			ID, SourceInterfaceType, SourceID, SourceAssetID, SourceDebtCaseID
		FROM IFC.DebtCaseAsset
		where InterfaceStatusCode = 'INTERFACE_STATUS_NEW'  and SourceInterfaceType =  @l_sourceInterfaceType order by id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor 
			INTO @ID, @SourceInterfaceType, @SourceID, @SourceAssetID, @SourceDebtCaseID

		WHILE @@FETCH_STATUS = 0  
		BEGIN  
			SET @ErrorMessage = NULL;
			Set @rel_PortfolioID = NULL;

			BEGIN TRY --Belső-5
				if not exists(Select 1 from IFC.Asset where Asset.SourceInterfaceType = @SourceInterfaceType
					and Asset.SourceID = @SourceAssetID
					and Asset.InterfaceStatusCode = 'INTERFACE_STATUS_NEW')
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Asset not found !,');
				
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.DebtCaseAsset', @ID, 'sourceInterfaceType', @ERR_DEBTCASEASSET_ASSET_ASSIGMENT, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.DebtCaseAsset', @ID, 'sourceAssetID', @ERR_DEBTCASEASSET_ASSET_ASSIGMENT, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;

				if not exists(Select 1 from IFC.DebtCase where DebtCase.SourceInterfaceType = @SourceInterfaceType
					and DebtCase.SourceID = @SourceDebtCaseID
					and DebtCase.InterfaceStatusCode = 'INTERFACE_STATUS_NEW')
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' DebtCase not found !,');

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.DebtCaseAsset', @ID, 'sourceInterfaceType', @ERR_DEBTCASEASSET_ASSET_ASSIGMENT, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;

					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.DebtCaseAsset', @ID, 'sourceDebtCaseID', @ERR_DEBTCASEASSET_ASSET_ASSIGMENT, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;

				If @ErrorMessage is not NULL
				Begin
					--SET @l_ErrorAssetRowCounts = @l_ErrorAssetRowCounts + 1;
					Update IFC.DebtCaseAsset Set ErrorMessage = '[Precontrol]: ' + @ErrorMessage, InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName  where ID = @ID;
					Set @l_ErrorExists = 99;
				End;

			END TRY --Belső-5

			BEGIN CATCH --Belső-5
				SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
				--SET @l_ErrorAssetRowCounts = @l_ErrorAssetRowCounts + 1;
				Update IFC.DebtCaseAsset Set ErrorMessage = '[Precontrol]: ' + @ErrorMessage, InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName  where ID = @ID;
				Set @l_ErrorExists = 99
			END CATCH --Belső-5

			FETCH NEXT FROM db_cursor 
				INTO @ID, @SourceInterfaceType, @SourceID, @SourceAssetID, @SourceDebtCaseID;
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;*/
    END TRY
 
    BEGIN CATCH
        SELECT   
			@ErrorMessage = ERROR_MESSAGE(),  
			@ErrorSeverity = ERROR_SEVERITY(),  
			@ErrorState = ERROR_STATE(),
			@ErrorLine = ERROR_LINE();

		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'db_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE db_cursor;

			DEALLOCATE db_cursor;
		END

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.MainIFCPreControl',		-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;						-- LogMessage

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        --SELECT @ErrorMessage;
		Return 99;

    END CATCH;


------------------------------------------------------------------
-- Hibalisták "megmutatás":
------------------------------------------------------------------
If exists (Select 1 from IFC.InterfaceError
where ModuleInstanceID = @p_ModuleInstanceID)
Begin
	Set @l_InstanceObjectID = (Select ObjectID from ORG.Moduleinstance where ID = @p_ModuleInstanceID);
	-- New ObjectID:
	INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr,  PortfolioID)
		SELECT @PRTEvent as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @PortfolioID;
	SET @l_ObjectID = SCOPE_IDENTITY();

	Insert Into Org.Event (ObjectId, EventTypeCode, Subject, EventDate, EventTime, RelatedObjectID)
	Select 
		@l_ObjectID, 
		NULL, --'EVENT_TYPE_INTERFACE_ERROR_BLOCKING_CRITICAL', 
		ISNULL(
		(Select Text from GEN.Translation where codeid = 'EVENT_TYPE_INTERFACE_ERROR_BLOCKING_CRITICAL'
			and Language = (Select Settingvalue from GEN.Setting where SettingCode = 'SETTING_SYSTEM_LANGUAGE')),
		'EVENT_TYPE_INTERFACE_ERROR_BLOCKING_CRITICAL is not in GEN.Translation'),
		CAST( GETDATE() AS Date), 
		CAST( GETDATE() AS Time),
		@l_InstanceObjectID
End;

------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
		
	SET @LogMessage = @LogMessage + 'MainIFCPreControl Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	If ISNULL(@ErrorMessage,'') <> ''
	Begin
	/* ez nem jó:
			Set @LargeErrorMessage = (Select STRING_AGG(Distinct ErrorMessage,',') from IFC.DebtCase where SourceInterfaceType = @l_sourceInterfaceType and ErrorMessage is not NULL)
							+
							(Select STRING_AGG(Distinct ErrorMessage,',') from IFC.Person where SourceInterfaceType = @l_sourceInterfaceType and ErrorMessage is not NULL)
							+
							(Select STRING_AGG(Distinct ErrorMessage,',') from IFC.Company where SourceInterfaceType = @l_sourceInterfaceType and ErrorMessage is not NULL)
							+
							(Select STRING_AGG(Distinct ErrorMessage,',') from IFC.Asset where SourceInterfaceType = @l_sourceInterfaceType and ErrorMessage is not NULL);
	*/
		Set @LargeErrorMessage = 'Debtcase:' + (select STRING_AGG(cast(H.ErrorMessage as nvarchar(max)),',')  ErrorMessage
									From 
									(select Distinct ErrorMessage
									from IFC.DebtCase
									where SourceInterfaceType = @l_sourceInterfaceType and ErrorMessage is not NULL) H)
								+
								'Person:' + (select STRING_AGG(cast(H.ErrorMessage as nvarchar(max)),',')  ErrorMessage
									From 
									(select Distinct ErrorMessage
									from IFC.Person
									where SourceInterfaceType = @l_sourceInterfaceType and ErrorMessage is not NULL) H)
								+
								'Company:' + (select STRING_AGG(cast(H.ErrorMessage as nvarchar(max)),',')  ErrorMessage
									From 
									(select Distinct ErrorMessage
									from IFC.Company
									where SourceInterfaceType = @l_sourceInterfaceType and ErrorMessage is not NULL) H)
								+
								'Asset:' + (select STRING_AGG(cast(H.ErrorMessage as nvarchar(max)),',')  ErrorMessage
									From 
									(select Distinct ErrorMessage
									from IFC.Asset
									where SourceInterfaceType = @l_sourceInterfaceType and ErrorMessage is not NULL) H);

		INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',				-- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			'IFC.MainIFCPreControl',		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',						-- SeverityLevel
			NULL,						-- MessageCategory
			'ERROR: ' + @LargeErrorMessage;
	End;

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.MainIFCPreControl',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'ErrorDebtCaseRowCounts: ' + CAST(@l_ErrorDebtCaseRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ 'AllDebtCaseRowCounts: ' + CAST(@l_AllDebtCaseRowCounts as NVARCHAR(18)) + @CRLF
		+ @LogMessage;

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.MainIFCPreControl',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'ErrorPersonRowCounts: ' + CAST(@l_ErrorPersonRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ 'AllPersonRowCounts: ' + CAST(@l_AllPersonRowCounts as NVARCHAR(18)) + @CRLF
		+ @LogMessage;

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.MainIFCPreControl',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'ErrorCompanyRowCounts: ' + CAST(@l_ErrorCompanyRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ 'AllCompanyRowCounts: ' + CAST(@l_AllCompanyRowCounts as NVARCHAR(18)) + @CRLF
		+ @LogMessage;

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.MainIFCPreControl',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'ErrorAssetRowCounts: ' + CAST(@l_ErrorAssetRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ 'AllAssetRowCounts: ' + CAST(@l_AllAssetRowCounts as NVARCHAR(18)) + @CRLF
		+ @LogMessage;


	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.MainIFCPreControl',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return @l_ErrorExists;


END;
go


CREATE PROCEDURE [ORG].[MassConditionHeirSearchObjectID](@p_correlationID NVARCHAR(200))

/*
==========================================================================================
 Author:		Bognár Dávid
  Creation date:			2023.02.26.
 Last modified date:	
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @SettingInterfaceType NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	declare @l_objectid nvarchar(max);
	declare @l_count numeric;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUserName = 'Admin';


	select @SettingInterfaceType=SettingValue from gen.Setting where SettingCode='SETTING_ADDRESS_SEARCH_INTERFACE_TYPE'

	print @SettingInterfaceType;

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);



	/* select prt.Entity.objectid from

	prt.person left join prt.Entity on prt.Person.EntityID=prt.Entity.id
	where prt.Entity.ObjectID is not null
	and prt.Entity.ID in (10052,23,41,42) */



	/*select 
  PRT.Entity.ObjectID
from 
  PRT.Person 
  left join PRT.Entity on PRT.Person.EntityID = PRT.Entity.ID 
where 
  PRT.Entity.ObjectID is not null 
  and PRT.Person.StatusCode = 'ENTITY_STATUS_PERSON_LIVE'
  and PRT.Entity.ID not in (
    select 
      coalesce(PRT.Address.EntityID, -1) 
    from 
      PRT.Address 
    where 
      statuscode = 'STATUS_NORMAL'
  ) 
  /*and
  PRT.Entity.ObjectID not in (
    select 
      ReferencedObjectID 
    from 
      GEN.ObjectTag ) 
	  */
	and not exists (select 1  from  GEN.ObjectTag where  ReferencedObjectID  = PRT.Entity.ObjectID)
	and prt.Entity.objectid not in (select    ReferencedObjectID  from    ORG.Process  where    ProcessDefinitionID =(select id from org.ProcessDefinition where ProcessCode='PROCESS_ADDRESS_SEARCH')   and STATUSCODE in ('PROCESS_INSTANCE_STATUS_FINISHED' ) and DATEDIFF(day,EndDate,GETDATE() )<=180   )
  and PRT.Entity.SourceInterfaceType='Lakcim_teszt_adat_20230213_170540'
 -- and PRT.Entity.ID in (10052, 23, 41, 42)*/



 --Ideiglenes táblák létrehozása 
		IF OBJECT_ID('tempdb..#Criterium', 'U') IS NOT NULL
			DROP TABLE #Criterium;

		CREATE TABLE #Criterium (
			ObjectID numeric,
			Count numeric
		);



 DECLARE object_cursor CURSOR FOR 
					SELECT 
						ObjectID
					from PRT.Person
                           left join PRT.Entity on PRT.Person.EntityID=PRT.Entity.ID
               -- where PRT.Entity.SourceInterfaceType=@SettingInterfaceType
				    --and ObjectID between 1090772 and 1090869
					
					;

					OPEN object_cursor;

					FETCH NEXT FROM object_cursor
					INTO 
						@l_objectid
						;


						WHILE @@FETCH_STATUS = 0
					BEGIN 
          		      

					  insert into #Criterium (Count)

				  exec @l_count= [ORG].[ConditionPersonValidAddress_Count] @p_correlationid='1', @p_objectid=@l_objectid, @p_conditionsetcode='CONDITION_SET_HEIR_SEARCH_ENTRY';


				  update #Criterium 
				  set ObjectID=@l_objectid
				  where ObjectID is null;

				

				select 	@l_objectid=null
				;


							FETCH NEXT FROM object_cursor
						INTO
							@l_objectid;

							END

							CLOSE object_cursor;
				DEALLOCATE object_cursor;


				select ObjectID from #Criterium where Count=0;
	
	IF OBJECT_ID('tempdb..#Criterium', 'U') IS NOT NULL
			DROP TABLE #Criterium;



------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	
	SET @LogMessage = @LogMessage + 'DebtorLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: '



	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return 1;


END;

go

CREATE PROCEDURE [ORG].[MassConditionKPProcessObjectID](@p_correlationID NVARCHAR(200))

/*
==========================================================================================
 Author:Bognár Dávid
  Creation date:2023.11.26.
 Last modified date:
==========================================================================================
*/

AS

BEGIN
SET NOCOUNT ON;

DECLARE @LogMessage NVARCHAR(MAX);
DECLARE @CRLF NVARCHAR(20);
DECLARE @ErrorMessage NVARCHAR(200);
DECLARE @SettingInterfaceType NVARCHAR(200);
DECLARE @ErrorSeverity INT;
DECLARE @ErrorState INT;
DECLARE @ErrorLine INT;
DECLARE @l_objectid nvarchar(max);
DECLARE @l_count numeric;
DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve
DECLARE @CurrentUserName nvarchar(200);
DECLARE @CurrentUser nvarchar(50);
DECLARE @CurrentDate date;
DECLARE @CurrentTime time;
DECLARE @l_logMsg NVARCHAR(MAX) = NULL --Működéssel kapcsolatos üzenetek tárolása miatt
DECLARE @l_procedureName NVARCHAR(100) = 'ORG.MassConditionKPProcessObjectID'; --Naplózás miatt a tárolt eljárás neve
select @CurrentDate=CAST( GETDATE() AS Date ) ;
select @CurrentTime=CAST( GETDATE() AS Time ) ;
Set @CurrentUserName = 'Admin';



--Naplóbejegyzés a kezdésről (kötelező)
select @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                       @p_UserName = @CurrentUserName,
                       @p_ServiceName = @l_procedureName, 
                       @p_LogMessage = @l_logMsg

SET @CRLF = CHAR(10)+CHAR(13);



--===========================================================
--BLOCK      : CREATE TMP TABLE
--DESCRIPTION: 
--===========================================================

select @l_logMsg = CONCAT('Create temptable ', @l_procedureName);
exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                       @p_UserName = @CurrentUserName,
                       @p_ServiceName = @l_procedureName, 
                       @p_LogMessage = @l_logMsg


IF OBJECT_ID('tempdb..#Criterium', 'U') IS NOT NULL
DROP TABLE #Criterium;

CREATE TABLE #Criterium (
ObjectID numeric,
ProcessFlag numeric,
--InkassoFlag numeric,
AddressSearchFlag numeric
);

--===========================================================
--BLOCK      : CREATE CURSOR
--DESCRIPTION: 
--===========================================================

select @l_logMsg = CONCAT('Create cursor ', @l_procedureName);
exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                       @p_UserName = @CurrentUserName,
                       @p_ServiceName = @l_procedureName, 
                       @p_LogMessage = @l_logMsg


 DECLARE object_cursor CURSOR FOR 


SELECT
  
    ogm.ReferencedObjectID
FROM
    GEN.ObjectGroupMember ogm
LEFT JOIN
    GEN.ObjectGroup b on ogm.ObjectGroupID=b.ID
WHERE
    b.Name = 'KP folyamat ügy tesztcsoport'  
--AND ReferencedObjectID=2327659
           
;
--Kurzor ami végigfut a vizsgálandó objektumokon
OPEN object_cursor;

FETCH NEXT FROM object_cursor
INTO 
@l_objectid
;


WHILE @@FETCH_STATUS = 0
BEGIN 
                
--===========================================================
--BLOCK      : ENTRY CRITERIUM
--DESCRIPTION: 
--===========================================================

select @l_logMsg = CONCAT('Entry crit ', @l_procedureName);

exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                       @p_UserName = @CurrentUserName,
                       @p_ServiceName = @l_procedureName, 
                       @p_LogMessage = @l_logMsg
      insert into #Criterium (ProcessFlag)

   exec @l_count= [ORG].[ConditionSetTester_Count] @p_correlationid=@p_correlationID, @p_objectid=@l_objectid, @p_conditionsetcode='CONDITION_SET_PROCESS_KP_ENTRY';

update #Criterium 
set ObjectID=@l_objectid
where ObjectID is null;



/*--1: Inkassonak átadni 0: Inkassonak nem átadni
 UPDATE #Criterium 
 set InkassoFlag=(select case when SUM(DataSourceResult) > 0 then 0 else 1 end as InkassoFlag  FROM (
SELECT ObjectID, 
       CASE 
         WHEN EXISTS (
           SELECT 1 
           FROM PRT.Address ad 
           WHERE ad.EntityID = DataSource.ID AND ad.StatusCode='STATUS_NORMAL'
         ) THEN 1
         ELSE 0
       END AS DataSourceResult
FROM (
  SELECT dc.ObjectID, e.ID
  FROM DCS.Debtor d 
  LEFT JOIN DCS.DebtCase dc ON d.DebtCaseID = dc.ID 
  LEFT JOIN PRT.Entity e    ON e.ID = d.EntityID 
  LEFT JOIN PRT.Person p    ON e.ID=p.EntityID
  LEFT JOIN PRT.Company c   ON e.ID=c.EntityID

  WHERE (p.StatusCode='ENTITY_STATUS_PERSON_LIVE' or c.StatusCode='ENTITY_STATUS_COMPANY_ACTIVE')
  AND dc.ObjectID=@l_objectid
) AS DataSource) alap
GROUP BY ObjectID
HAVING ObjectID=@l_objectid)

;*/


--Lakcímkeresés 1:Lakcímkeresést indítani 0: Lakcímkeresést nem indítani
 UPDATE #Criterium 
 set AddressSearchFlag=(
select case when SUM(DataSourceResult)> 0 then 1 else 0 end as AddressFlag  FROM (
SELECT ObjectID, 
       CASE 
         WHEN NOT EXISTS (
           SELECT 1 
           FROM PRT.Address ad 
           WHERE ad.EntityID = DataSource.ID AND ad.StatusCode='STATUS_NORMAL'
         ) THEN 1
         ELSE 0
       END AS DataSourceResult
FROM (
  SELECT dc.ObjectID, e.ID
  FROM DCS.Debtor d 
  LEFT JOIN DCS.DebtCase dc ON d.DebtCaseID = dc.ID 
  LEFT JOIN PRT.Entity e    ON e.ID = d.EntityID 
  LEFT JOIN PRT.Person p    ON e.ID=p.EntityID
  LEFT JOIN PRT.Company c   ON e.ID=c.EntityID

  WHERE (p.StatusCode='ENTITY_STATUS_PERSON_LIVE' or c.StatusCode='ENTITY_STATUS_COMPANY_ACTIVE')
  AND dc.ObjectID=@l_objectid
) AS DataSource) alap
GROUP BY ObjectID
HAVING ObjectID=@l_objectid)

;





select @l_objectid=null
;


FETCH NEXT FROM object_cursor
INTO
@l_objectid;

END

CLOSE object_cursor;
DEALLOCATE object_cursor;


--Események kiírása

/*--Akinél nincsen kamat azt "pihentessük"

UPDATE #Criterium
SET InkassoFlag = 0
WHERE #Criterium.ObjectID NOT IN (
    SELECT dc.ObjectID
    FROM DCS.DebtCase dc
    WHERE NOT EXISTS (
        SELECT 1
        FROM FIN.Calculation c
        JOIN FIN.FeeList fl ON c.FeeListID = fl.ID
        WHERE dc.MainCalculationID = c.ID
        AND fl.ID IN (
            SELECT FeeListID
            FROM FIN.Fee
            WHERE Code IN ('FEE_INTEREST', 'FEE_PENALTY_INTEREST')
        )
    )
) AND #Criterium.InkassoFlag <> 0;  -- csak ahol a jelenlegi érték nem 0

*/

--Inkasszónak átadás

 DECLARE inkasso_event_object_cursor CURSOR FOR 

SELECT ObjectID
from #Criterium
where ProcessFlag>0 

--Vannak neki kamatértékei
AND #Criterium.ObjectID  in
(
SELECT dc.ObjectID
FROM DCS.DebtCase dc
WHERE EXISTS (
    SELECT 1
    FROM FIN.Calculation c
    JOIN FIN.FeeList fl ON c.FeeListID = fl.ID
    WHERE dc.MainCalculationID = c.ID
    AND fl.ID IN (
        SELECT FeeListID
        FROM FIN.Fee
        WHERE Code = 'FEE_INTEREST'
    )
)
AND EXISTS (
    SELECT 1
    FROM FIN.Calculation c
    JOIN FIN.FeeList fl ON c.FeeListID = fl.ID
    WHERE dc.MainCalculationID = c.ID
    AND fl.ID IN (
        SELECT FeeListID
        FROM FIN.Fee
        WHERE Code = 'FEE_PENALTY_INTEREST'
    )
))
--URBIS számlaszám nincs töltve, de kell neki késöbb
AND #Criterium.ObjectID not in 
(

select objectid from dcs.DebtCase
where DebtCase.RepaymentBankAccountNr is null AND DebtCase.OriginalAccountingSystemCode in 
(select code from IFC.AccountingSystem where RepaymentAccountRequiredCode='BOOLEAN_TRUE'
)

)

;  -- csak ahol a jelenlegi érték nem 0

           
;
--Kurzor ami végigfut a vizsgálandó objektumokon
OPEN inkasso_event_object_cursor;

FETCH NEXT FROM inkasso_event_object_cursor
INTO 
@l_objectid
;


WHILE @@FETCH_STATUS = 0
BEGIN 
          
declare @moduleInstanceIDInkasso Numeric(16) ;

exec ORG.CreateEvent 
@EventDate=@CurrentDate, 
@EventTime =@CurrentTime,
@EventType ='EVENT_TYPE_21435',
@Comments ='KP folyamat tesztadat átadás inkasszónak',
@RelatedObjectID=@l_objectid,
@CreationUserName='bognar.david',
@ProcessCode=null,
@moduleInstanceIDInkasso = @moduleInstanceIDInkasso output,
@isBatch = 1,
@correlationid=@p_correlationID



FETCH NEXT FROM inkasso_event_object_cursor
INTO
@l_objectid;

END

CLOSE inkasso_event_object_cursor;
DEALLOCATE inkasso_event_object_cursor;

--Lakcímkeresésre átadni


 DECLARE address_search_event_object_cursor CURSOR FOR 

SELECT ObjectID
from #Criterium
where AddressSearchFlag>0
           
;
--Kurzor ami végigfut a vizsgálandó objektumokon
OPEN address_search_event_object_cursor;

FETCH NEXT FROM address_search_event_object_cursor
INTO 
@l_objectid
;


WHILE @@FETCH_STATUS = 0
BEGIN 
          

exec ORG.CreateEvent 
@EventDate=@CurrentDate,
@EventTime =@CurrentTime,
@EventType ='EVENT_TYPE_ADDRESS_VALIDATION_SUBMITTED',
@Comments ='KP folyamat tesztadat lakcímkeresésre átadás',
@RelatedObjectID=@l_objectid,
@CreationUserName='bognar.david',
@ProcessCode=null,
@moduleInstanceIDInkasso = @moduleInstanceIDInkasso output,
@isBatch = 1,
@correlationid=@p_correlationID



FETCH NEXT FROM address_search_event_object_cursor
INTO
@l_objectid;

END

CLOSE address_search_event_object_cursor;
DEALLOCATE address_search_event_object_cursor;


select cr.ObjectID, mi.ID as ModuleInstanceID from (select * from  #Criterium where ProcessFlag=0) cr
full join (select @moduleInstanceIDInkasso as ID ) mi on 1=2
;
--select * from #Criterium;

/*Inkasso moduleInstance status setting*/
    if @moduleInstanceIDInkasso is not null
    begin
      update ORG.ModuleInstance
      set StatusCode = 'MODULE_INSTANCE_STATUS_READY_TO_RUN'
      where ID = @moduleInstanceIDInkasso
    end;


IF OBJECT_ID('tempdb..#Criterium', 'U') IS NOT NULL
DROP TABLE #Criterium;



------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------

select @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                       @p_UserName = @CurrentUserName,
                       @p_ServiceName = @l_procedureName, 
                       @p_LogMessage = @l_logMsg


If @ErrorMessage is not null
Return 99;
else
Return 1;


END;

go

CREATE PROCEDURE [ORG].[MassConditionPersonObjectID](@p_correlationID NVARCHAR(200))

/*
==========================================================================================
 Author:		Bognár Dávid
  Creation date:			2023.02.23.
 Last modified date:	
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @SettingInterfaceType NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	declare @l_objectid nvarchar(max);
	declare @l_count numeric;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUserName = 'Admin';


	select @SettingInterfaceType=SettingValue from gen.Setting where SettingCode='SETTING_ADDRESS_SEARCH_INTERFACE_TYPE'

	print @SettingInterfaceType;

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);



	/* select prt.Entity.objectid from

	prt.person left join prt.Entity on prt.Person.EntityID=prt.Entity.id
	where prt.Entity.ObjectID is not null
	and prt.Entity.ID in (10052,23,41,42) */



	/*select 
  PRT.Entity.ObjectID
from 
  PRT.Person 
  left join PRT.Entity on PRT.Person.EntityID = PRT.Entity.ID 
where 
  PRT.Entity.ObjectID is not null 
  and PRT.Person.StatusCode = 'ENTITY_STATUS_PERSON_LIVE'
  and PRT.Entity.ID not in (
    select 
      coalesce(PRT.Address.EntityID, -1) 
    from 
      PRT.Address 
    where 
      statuscode = 'STATUS_NORMAL'
  ) 
  /*and
  PRT.Entity.ObjectID not in (
    select 
      ReferencedObjectID 
    from 
      GEN.ObjectTag ) 
	  */
	and not exists (select 1  from  GEN.ObjectTag where  ReferencedObjectID  = PRT.Entity.ObjectID)
	and prt.Entity.objectid not in (select    ReferencedObjectID  from    ORG.Process  where    ProcessDefinitionID =(select id from org.ProcessDefinition where ProcessCode='PROCESS_ADDRESS_SEARCH')   and STATUSCODE in ('PROCESS_INSTANCE_STATUS_FINISHED' ) and DATEDIFF(day,EndDate,GETDATE() )<=180   )
  and PRT.Entity.SourceInterfaceType='Lakcim_teszt_adat_20230213_170540'
 -- and PRT.Entity.ID in (10052, 23, 41, 42)*/



 --Ideiglenes táblák létrehozása 
		IF OBJECT_ID('tempdb..#Criterium', 'U') IS NOT NULL
			DROP TABLE #Criterium;

		CREATE TABLE #Criterium (
			ObjectID numeric,
			Count numeric
		);



 DECLARE object_cursor CURSOR FOR 
					SELECT 
						ObjectID
					from PRT.Person
                           left join PRT.Entity on PRT.Person.EntityID=PRT.Entity.ID
                where PRT.Entity.SourceInterfaceType=@SettingInterfaceType
				    --and ObjectID between 1090772 and 1090869
					
					;

					OPEN object_cursor;

					FETCH NEXT FROM object_cursor
					INTO 
						@l_objectid
						;


						WHILE @@FETCH_STATUS = 0
					BEGIN 
          		      

					  insert into #Criterium (Count)

				  exec @l_count= [ORG].[ConditionPersonValidAddress_Count] @p_correlationid='1', @p_objectid=@l_objectid, @p_conditionsetcode='CONDITION_SET_ADDRESS_SEARCH';


				  update #Criterium 
				  set ObjectID=@l_objectid
				  where ObjectID is null;

				

				select 	@l_objectid=null
				;


							FETCH NEXT FROM object_cursor
						INTO
							@l_objectid;

							END

							CLOSE object_cursor;
				DEALLOCATE object_cursor;


				select ObjectID from #Criterium where Count=0;

	
	IF OBJECT_ID('tempdb..#Criterium', 'U') IS NOT NULL
			DROP TABLE #Criterium;



------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	
	SET @LogMessage = @LogMessage + 'DebtorLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: '



	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return 1;


END;

go

/*----------------------------------------------------------------------------------------------
  Author: Gyenese Katalin
  Create date: 2023.11.02. - DV-1524
  Last modified date: 2023.11.02.
  Description: creates a new instance of the given module
  
  Parameters: 
    - @p_moduleCode: the code of the module
    - @p_statusCode: the statusCode of the inserted moduleInstance ('MODULE_INSTANCE_STATUS_PREPARATION' if null)
    - @p_CorrelationID: the correlationID of the caller
    - @p_UserName: the userName of the caller
    - @p_moduleInstanceID: output parameter, the id of the inserted moduleInstance
----------------------------------------------------------------------------------------------*/
create procedure ORG.ModuleInstanceInsert(@p_moduleCode NVarChar(200), @p_statusCode NVarChar(200) = null, @p_CorrelationID NVarChar(200), @p_UserName NVarChar(200), @p_moduleInstanceID Numeric(16) output)
as
begin
  set NOCOUNT ON
  set XACT_ABORT ON

  /*variables for logging*/
	declare @errormsg NVarChar(max),	@logMessage nvarchar(max), @procedureName nvarchar(100) = 'ORG.ModuleInstanceInsert',
          @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max)

  /*variables inner logic*/ 
  declare @moduleID Numeric(16), @messageQueueTopic NVarChar(200), @objectID Numeric(16)


  begin try
    /*Logging procedure start*/
    set @logMessage = Concat('Start procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    /*Logging parameter check*/
    set @logMessage = 'Checking parameters...'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    if IsNull(@p_moduleCode, '') = ''
       raiserror('The @p_moduleCode parameter is compulsory.', 16, 1)

    select @moduleID = m.ID, @messageQueueTopic = m.MessageQueueTopic
		from ORG.Module m 
		where m.ModuleCode = @p_moduleCode
		  and m.StatusCode = 'MODULE_STATUS_CAN_RUN'
    
    if @moduleID is null
    begin
      select @errormsg = Concat('Based on the code ', @p_moduleCode, ' no executable module can be found in the system.')
      raiserror(@errormsg, 16, 1)
    end

    if @p_statusCode is null
       set @p_statusCode = 'MODULE_INSTANCE_STATUS_PREPARATION'

    ------------------------------------------------------------------------------------------------------------------------
    /*Logging start processing*/
    set @logMessage = 'Start processing'
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

    begin tran 
      insert into GEN.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
			                select 'OBJECT_TYPE_ORG_MODULEINSTANCE' ObjectType, GetDate() CreationDate, GetDate() CreationTime, @p_UserName CreationUserName, 
                             Concat(@p_moduleCode, ' module instance object') Comments, '1.0.0' VersionNr

		  select @objectID = SCOPE_IDENTITY()

      insert into ORG.ModuleInstance(ObjectID, ModuleID, StatusCode, CorrelationID, MessageQueueTopic, CreationDate, CreationTime, CreationUserName)
                              select @objectID, @moduleID, @p_statusCode StatusCode, @p_correlationID, @messageQueueTopic,
                                     GetDate() CreationDate, GetDate() CreationTime, @p_UserName CreationUserName

      select @p_moduleInstanceID = SCOPE_IDENTITY()
    commit


    /*Logging processing end*/
    set @logMessage = Concat('End procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @p_UserName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

	end try
  begin catch
    if @@trancount > 0
       rollback

    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage

    ;throw
  end catch
end
go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2023-04-11
-- Last modified date: 2023-04-17
-- Description:	Performing operations related to object groups
-- =============================================
CREATE   PROCEDURE [GEN].[ObjectGroupManager] 
	-- Add the parameters for the stored procedure here
	@p_correlationID NVARCHAR(200), 
	@p_moduleInstanceID NUMERIC(16),
	@p_result nvarchar(200) OUTPUT
AS
BEGIN
	-- SET NOCOUNT ON added to prevent extra result sets from
	-- interfering with SELECT statements.
	SET NOCOUNT ON;
    --Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'GEN.ObjectGroupManager'; --Naplózás miatt a tárolt eljárás neve
	DECLARE @l_technicalUserName NVARCHAR(200) = NULL;
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_taskCount NUMERIC(16) = NULL;
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_taskID NUMERIC(16) = NULL;
	DECLARE @l_taskTaskTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_relatedObjectID NUMERIC(16) = NULL;
	DECLARE @l_objectGroupID NUMERIC(16) = NULL;
	DECLARE @l_objectGroupMemberID NUMERIC(16) = NULL;

	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		IF COALESCE(@p_moduleInstanceID, 0) > 0 
			SELECT @l_technicalUserName = Module.TechnicalUserName 
			FROM ORG.Module 
			JOIN ORG.ModuleInstance ON (ModuleInstance.ModuleID = Module.ID)
			WHERE ModuleInstance.ID = @p_moduleInstanceID;

		IF COALESCE(@l_technicalUserName, '') = '' 
			SELECT @l_technicalUserName = SUSER_SNAME();

		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			@l_technicalUserName,		-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			@l_technicalUserName,		-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			@l_technicalUserName,		-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Új feladatok
		DECLARE newTask_cursor CURSOR FOR
		SELECT Task.ID 
		FROM ORG.Task 
		WHERE Task.TaskTypeID IN ('TASK_TYPE_OBJECT_GROUP_ADD', 'TASK_TYPE_OBJECT_GROUP_REMOVE')
		AND Task.StatusCode = 'TASK_MAIN_STATUS_NEW'
		AND NOT EXISTS 
			(SELECT 1 
			 FROM ORG.ModuleInstance 
			 JOIN ORG.ModuleInstanceParameter ON (ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID)
			 JOIN ORG.Module ON (Module.ID = ModuleInstance.ModuleID)
			 WHERE Module.ModuleCode = 'MODULE_OBJECT_GROUP_MANAGEMENT'
			 AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_TASK_ID'
			 AND ModuleInstanceParameter.ParameterID = Task.ID)
		ORDER BY Task.ID;

		OPEN newTask_cursor;
		FETCH NEXT FROM newTask_cursor
		INTO 
			@l_taskID;

		WHILE @@FETCH_STATUS = 0 
		BEGIN
			SELECT @l_objectID = 0;

			INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr]) 
			VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 
				@l_technicalUserName, CONCAT('MODULE_PARAMETER_TASK_ID', ' module instance parameter object'), '1.0');

			SELECT @l_objectID = @@IDENTITY;

			IF COALESCE(@l_objectID, 0) > 0
			BEGIN
				INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterID], 
					[CreationDate], [CreationTime], [CreationUserName])
				VALUES (@l_objectID, @p_moduleInstanceID, 'MODULE_PARAMETER_TASK_ID', @l_taskID, 
					CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_technicalUserName);
			END;

			FETCH NEXT FROM newTask_cursor
			INTO 
				@l_taskID;
		END;

		CLOSE newTask_cursor;
		DEALLOCATE newTask_cursor;

		--Beragadt feladatok (korábban elhalt modul)
		DECLARE stuckedTask_cursor CURSOR FOR
		SELECT Task.ID 
		FROM ORG.Task 
		WHERE Task.TaskTypeID IN ('TASK_TYPE_OBJECT_GROUP_ADD', 'TASK_TYPE_OBJECT_GROUP_REMOVE')
		AND Task.StatusCode NOT IN ('TASK_MAIN_STATUS_FINISHED', 'TASK_MAIN_STATUS_FAILED')
		AND EXISTS 
			(SELECT 1 
			 FROM ORG.ModuleInstance 
			 JOIN ORG.ModuleInstanceParameter ON (ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID)
			 JOIN ORG.Module ON (Module.ID = ModuleInstance.ModuleID)
			 WHERE Module.ModuleCode = 'MODULE_OBJECT_GROUP_MANAGEMENT'
			 AND ModuleInstance.StatusCode = 'MODULE_INSTANCE_STATUS_FAILED'
			 AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_TASK_ID'
			 AND ModuleInstanceParameter.ParameterID = Task.ID)
		ORDER BY Task.ID;

		OPEN stuckedTask_cursor;
		FETCH NEXT FROM stuckedTask_cursor
		INTO 
			@l_taskID;

		WHILE @@FETCH_STATUS = 0 
		BEGIN
			SELECT @l_objectID = 0;

			INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr]) 
			VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 
				@l_technicalUserName, CONCAT('MODULE_PARAMETER_TASK_ID', ' module instance parameter object'), '1.0');

			SELECT @l_objectID = @@IDENTITY;

			IF COALESCE(@l_objectID, 0) > 0
			BEGIN
				INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterID], 
					[CreationDate], [CreationTime], [CreationUserName])
				VALUES (@l_objectID, @p_moduleInstanceID, 'MODULE_PARAMETER_TASK_ID', @l_taskID, 
					CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_technicalUserName);
			END;

			FETCH NEXT FROM stuckedTask_cursor
			INTO 
				@l_taskID;
		END;

		CLOSE stuckedTask_cursor;
		DEALLOCATE stuckedTask_cursor;

		--Elvégzendő feladatok száma
		SELECT @l_taskCount = COUNT(*)
		FROM ORG.ModuleInstance 
		JOIN ORG.ModuleInstanceParameter ON (ModuleInstanceParameter.ModuleInstanceID = ModuleInstance.ID)
		WHERE ModuleInstance.ID = @p_moduleInstanceID;

		SELECT @l_logMsg = CONCAT('Number of tasks to be executed: ', @l_taskCount);
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			@l_technicalUserName,		-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		IF COALESCE(@l_taskCount, 0) > 0
		BEGIN 
			DECLARE performedTask_cursor CURSOR FOR
			SELECT Task.ID, Task.TaskTypeID 
			FROM ORG.Task 
			JOIN ORG.ModuleInstanceParameter ON (ModuleInstanceParameter.ParameterID = Task.ID)
			JOIN ORG.ModuleInstance ON (ModuleInstance.ID = ModuleInstanceParameter.ModuleInstanceID)
			WHERE ModuleInstance.ID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_TASK_ID'
			AND COALESCE(ModuleInstanceParameter.ParameterID, 0) > 0
			ORDER BY Task.ID;

			OPEN performedTask_cursor;
			FETCH NEXT FROM performedTask_cursor
			INTO 
				@l_taskID,
				@l_taskTaskTypeCode;

			WHILE @@FETCH_STATUS = 0 
			BEGIN
				SELECT @l_errorMsg = '';
				SELECT @l_objectGroupMemberID = NULL;

				UPDATE [ORG].[Task] SET 
					[StatusCode] = 'TASK_MAIN_STATUS_IN_PROGRESS',
					[BeginDate] = CAST( GETDATE() AS Date ),
					[BeginTime] = CAST( GETDATE() AS Time ),
					[LastModifiedDate] = CAST( GETDATE() AS Date),
					[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108), 
					[LastModifiedUserName] = @l_technicalUserName
				WHERE [Task].[ID] = @l_taskID;

				--Kapcsolódó objektum ellenőrzése
				SELECT @l_relatedObjectID = Task.ReferencedObjectID 
				FROM ORG.Task 
				WHERE Task.ID = @l_taskID;

				IF COALESCE(@l_relatedObjectID, 0) = 0 
				BEGIN
					SELECT @l_errorMsg = CONCAT('The ', @l_taskID, ' task does not belong to an object.');

					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						@l_technicalUserName,		-- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						'INFO',					        -- SeverityLevel
						NULL,						-- MessageCategory
						@l_errorMsg;
				END;

				--Objektum csoport ellenőrzése
				BEGIN TRY 
					SELECT @l_objectGroupID = ObjectGroup.ID 
					FROM GEN.ObjectGroup 
					JOIN ORG.TaskParameter ON (COALESCE(TaskParameter.ParameterID, CAST(TaskParameter.ParameterValue AS NUMERIC(16))) = ObjectGroup.ID)
					WHERE TaskParameter.TaskID = @l_taskID 
					AND TaskParameter.ParameterCode = 'MODULE_PARAMETER_OBJECT_GROUP_ID';

					IF COALESCE(@l_objectGroupID, 0) = 0
					BEGIN
						SELECT @l_errorMsg = 'The object group is not defined.';

						INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
						SELECT 
							CAST( GETDATE() AS Date ),	-- LogDate,	
							CAST( GETDATE() AS Time ),	-- LogTime,
							@l_technicalUserName,		-- UserName
							@p_CorrelationID,			-- CorrelationID
							'INDECS 3.0',			    -- ApplicationName
							DB_NAME(),					-- Environment
							'BACKEND',					-- Layer
							@l_procedureName,   		-- ServiceName
							'1.0',						-- ServiceVersion
							'INFO',					        -- SeverityLevel
							NULL,						-- MessageCategory
							@l_errorMsg;
					END;
				END TRY 
				BEGIN CATCH
					SELECT @l_errorMsg = 'An unexpected error occurred while checking the "MODULE_PARAMETER_OBJECT_GROUP_ID" parameter.';
				END CATCH

				IF COALESCE(@l_errorMsg, '') = '' 
				BEGIN
					IF COALESCE(@l_taskTaskTypeCode, '') = 'TASK_TYPE_OBJECT_GROUP_ADD' 
					BEGIN 
						SELECT @l_objectGroupMemberID = ObjectGroupMember.ID 
						FROM GEN.ObjectGroupMember 
						WHERE ObjectGroupMember.ObjectGroupID = @l_objectGroupID 
						AND ObjectGroupMember.ReferencedObjectID = @l_relatedObjectID;

						IF COALESCE(@l_objectGroupMemberID, 0) = 0 
						BEGIN
							INSERT INTO [GEN].[ObjectGroupMember] ([ObjectGroupID], [ReferencedObjectID], [StatusCode], 
								[CreationDate], [CreationTime], [CreationUserName])
							SELECT @l_objectGroupID, @l_relatedObjectID, 'OBJECT_GROUP_MEMBER_STATUS_MEMBER', 
								CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_technicalUserName;

							SELECT @l_objectGroupMemberID = @@IDENTITY;

							IF COALESCE(@l_objectGroupMemberID, 0) > 0
								SELECT @l_logMsg = CONCAT('Object ', @l_relatedObjectID, ' was successfully added to group ', @l_objectGroupID, '.');
							ELSE
								SELECT @l_logMsg = CONCAT('Failed to add object ', @l_relatedObjectID, ' to object group ', @l_objectGroupID, '.');
						END
						ELSE
							SELECT @l_logMsg = CONCAT('Object ', @l_relatedObjectID, ' already exists in group ', @l_objectGroupID, '.');

						INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
						SELECT 
							CAST( GETDATE() AS Date ),	-- LogDate,	
							CAST( GETDATE() AS Time ),	-- LogTime,
							@l_technicalUserName,		-- UserName
							@p_CorrelationID,			-- CorrelationID
							'INDECS 3.0',			    -- ApplicationName
							DB_NAME(),					-- Environment
							'BACKEND',					-- Layer
							@l_procedureName,   		-- ServiceName
							'1.0',						-- ServiceVersion
							'INFO',					        -- SeverityLevel
							NULL,						-- MessageCategory
							@l_logMsg;
					END
					ELSE IF COALESCE(@l_taskTaskTypeCode, '') = 'TASK_TYPE_OBJECT_GROUP_REMOVE'
					BEGIN
						SELECT @l_objectGroupMemberID = ObjectGroupMember.ID 
						FROM GEN.ObjectGroupMember 
						WHERE ObjectGroupMember.ObjectGroupID = @l_objectGroupID 
						AND ObjectGroupMember.ReferencedObjectID = @l_relatedObjectID;
						--AND [ObjectGroupMember].[StatusCode] = 'OBJECT_GROUP_MEMBER_STATUS_DELETED'; Ideiglenesen eltávolítva, mert a VIR keresőben gond van.

						--IF COALESCE(@l_objectGroupMemberID, 0) = 0 Ideiglenesen eltávolítva, mert a VIR keresőben gond van.
						IF COALESCE(@l_objectGroupMemberID, 0) > 0
						BEGIN
							/*UPDATE [GEN].[ObjectGroupMember] SET 
								[StatusCode] = 'OBJECT_GROUP_MEMBER_STATUS_DELETED', 
								[LastModifiedDate] = CAST( GETDATE() AS Date),
								[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108), 
								[LastModifiedUserName] = @l_technicalUserName 
							WHERE [ObjectGroupMember].[ObjectGroupID] = @l_objectGroupID
							AND [ObjectGroupMember].[ReferencedObjectID] = @l_relatedObjectID 
							AND [ObjectGroupMember].[StatusCode] <> 'OBJECT_GROUP_MEMBER_STATUS_DELETED';
							
							SELECT @l_objectGroupMemberID = ObjectGroupMember.ID 
							FROM GEN.ObjectGroupMember 
							WHERE ObjectGroupMember.ObjectGroupID = @l_objectGroupID 
							AND ObjectGroupMember.ReferencedObjectID = @l_relatedObjectID
							AND [ObjectGroupMember].[StatusCode] = 'OBJECT_GROUP_MEMBER_STATUS_DELETED';

							IF COALESCE(@l_objectGroupMemberID, 0) > 0
								SELECT @l_logMsg = CONCAT('Object ', @l_relatedObjectID, ' was successfully removed from group ', @l_objectGroupID, '.')
							ELSE 
								SELECT @l_logMsg = CONCAT('Failed to remove object ', @l_relatedObjectID, ' from object group ', @l_objectGroupID, '.')
							
							Ideiglenesen eltávolítva, mert a VIR keresőben gond van.*/

							DELETE FROM [GEN].[ObjectGroupMember] WHERE [ObjectGroupMember].[ID] = @l_objectGroupMemberID;

							SELECT @l_objectGroupMemberID = ObjectGroupMember.ID 
							FROM GEN.ObjectGroupMember 
							WHERE ObjectGroupMember.ObjectGroupID = @l_objectGroupID 
							AND ObjectGroupMember.ReferencedObjectID = @l_relatedObjectID;

							IF COALESCE(@l_objectGroupMemberID, 0) = 0
								SELECT @l_logMsg = CONCAT('Object ', @l_relatedObjectID, ' was successfully removed from group ', @l_objectGroupID, '.')
							ELSE 
								SELECT @l_logMsg = CONCAT('Failed to remove object ', @l_relatedObjectID, ' from object group ', @l_objectGroupID, '.')
						END
						ELSE
							SELECT @l_logMsg = CONCAT('Object ', @l_relatedObjectID, ' already been removed from the ', @l_objectGroupID, ' group.');

						INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
						SELECT 
							CAST( GETDATE() AS Date ),	-- LogDate,	
							CAST( GETDATE() AS Time ),	-- LogTime,
							@l_technicalUserName,		-- UserName
							@p_CorrelationID,			-- CorrelationID
							'INDECS 3.0',			    -- ApplicationName
							DB_NAME(),					-- Environment
							'BACKEND',					-- Layer
							@l_procedureName,   		-- ServiceName
							'1.0',						-- ServiceVersion
							'INFO',					        -- SeverityLevel
							NULL,						-- MessageCategory
							@l_logMsg;
					END;
				END;

				--Feladat lezárása
				SELECT @l_objectID = NULL;

				IF COALESCE(@l_errorMsg, '') = ''
				BEGIN
					UPDATE [ORG].[Task] SET 
						[StatusCode] = 'TASK_MAIN_STATUS_FINISHED',
						[EndDate] = CAST( GETDATE() AS Date ),
						[EndTime] = CAST( GETDATE() AS Time ),
						[LastModifiedDate] = CAST( GETDATE() AS Date),
						[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108), 
						[LastModifiedUserName] = @l_technicalUserName
					WHERE [Task].[ID] = @l_taskID;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr]) 
					VALUES ('OBJECT_TYPE_ORG_EVENT', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 
						@l_technicalUserName, CONCAT('EVENT_TYPE_TASK_COMPLETED', ' event object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
						INSERT INTO [ORG].[Event] ([ObjectID], [TaskID], [EventTypeCode], [Subject], [EventDate], [EventTime], 
							[RelatedObjectID], [UserName], [CreationDate], [CreationTime], [CreationUserName])
						SELECT @l_objectID, @l_taskID, 'EVENT_TYPE_TASK_COMPLETED', GEN.TranslateCode('EVENT_TYPE_TASK_COMPLETED', 'HU'), 
							CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 
							(SELECT [Task].[ObjectID] FROM [ORG].[Task] WHERE [Task].[ID] = @l_taskID), @l_technicalUserName, 
							CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_technicalUserName;
				END
				ELSE 
				BEGIN
					UPDATE [ORG].[Task] SET 
						[StatusCode] = 'TASK_MAIN_STATUS_FAILED',
						[EndDate] = CAST( GETDATE() AS Date ),
						[EndTime] = CAST( GETDATE() AS Time ),
						[LastModifiedDate] = CAST( GETDATE() AS Date),
						[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108), 
						[LastModifiedUserName] = @l_technicalUserName
					WHERE [Task].[ID] = @l_taskID;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr]) 
					VALUES ('OBJECT_TYPE_ORG_EVENT', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 
						@l_technicalUserName, CONCAT('EVENT_TYPE_TASK_COMPLETED', ' event object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
						INSERT INTO [ORG].[Event] ([ObjectID], [TaskID], [EventTypeCode], [Subject], [Comments], [EventDate], [EventTime], 
							[RelatedObjectID], [UserName], [CreationDate], [CreationTime], [CreationUserName])
						SELECT @l_objectID, @l_taskID, 'EVENT_TYPE_TASK_COMPLETED', GEN.TranslateCode('EVENT_TYPE_TASK_COMPLETED', 'HU'), 
							@l_errorMsg, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 
							(SELECT [Task].[ObjectID] FROM [ORG].[Task] WHERE [Task].[ID] = @l_taskID), @l_technicalUserName, 
							CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @l_technicalUserName;
				END;

				FETCH NEXT FROM performedTask_cursor
				INTO 
					@l_taskID, 
					@l_taskTaskTypeCode;
			END;

			CLOSE performedTask_cursor;
			DEALLOCATE performedTask_cursor;
		END;

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			@l_technicalUserName,		-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;

		SELECT @p_result = 0;
		SELECT @p_result;
		RETURN;
	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'performedTask_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE performedTask_cursor;

			DEALLOCATE performedTask_cursor;
		END
		
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'stuckedTask_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE stuckedTask_cursor;

			DEALLOCATE stuckedTask_cursor;
		END

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'newTask_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE newTask_cursor;

			DEALLOCATE newTask_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			@l_technicalUserName,		-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage

		SELECT @p_result = @l_errorMsg;
		SELECT @p_result;
		RETURN;
	END CATCH
END
go

CREATE       PROCEDURE [IFC].[ObjectGroupMemberLoader](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16))


/*
==========================================================================================
 Author:				Tóth Gábor
 Creation date:			2023.07.31.
 Last modified date:	2023.09.26.
						2023.09.27.
						2023.10.27. InterfaceStatusCode = 'INTERFACE_STATUS_NEW' --> InterfaceStatusCode in ('INTERFACE_STATUS_NEW', 'INTERFACE_STATUS_FIXED')
==========================================================================================
*/

/*
V1:
•	ObjectGroupID
•	IdentifierID

1.	az IdentifierID kitöltése alapján a konkrét ObjectID megállapítása a következőképpen:
	a.	az ObjectGroupID alapján megállapítható az objektum csoport típusa, azaz, hogy milyen érték szerepel a GEN.ObjectGroup.ObjectTypeCode mezőben
	b.	az ObjectTypeCode mezőben tárolt adat alapján az IdentifierID mező értékének kezelése, azaz, ha az ObjectTypeCode mező értéke OBJECT_TYPE_DCS_DEBTCASE, akkor az IdentifierID mezőben DCS.DebtCase.ID érték szerepel, így az alapján le kell kérdezni a DCS.DebtCase.ObjectID mező értékét
2.	új adatsor létrehozása a GEN.ObjectGroupMember táblában a következő összerendelés szerint:
	a.	ObjectGroupID: értéke az IFC.ObjectGroupMember.ObjectGroupID
	b.	ReferencedObjectID: a megállapított ObjectID
	c.	StatusCode: értéke ’OBJECT_GROUP_MEMBER_STATUS_MEMBER’
	d.	Creation mezők értéke: aktuális dátum, idő és felhasználó
3.	az adott IFC.ObjectGroupMember adatsor feldolgozott állapotra állítása


Amennyiben az alábbi hibák egyike is igaz az adott adatsorra, akkor az adatsor InterfaceStatusCode értéke ’INTERFACE_STATUS_ERROR’, valamint az adatsor feldolgozása nem történik meg. 


*/

AS

BEGIN
	SET NOCOUNT ON;

    DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'SQL',					-- Layer
		'IFC.ObjectGroupMemberLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);


    BEGIN TRANSACTION

    BEGIN TRY
        SET @LogMessage = 'ObjectGroupMemberLoader Started at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
		
		Declare @ID as NUMERIC (16);
		Declare @InterfaceTableID as NUMERIC (16);
		Declare @SourceInterfaceType as NVARCHAR (200);
		Declare @SourceID as NVARCHAR (200);
		Declare @ObjectGroupID as NUMERIC (16);
		Declare @DataSourceID as NUMERIC (16);
		Declare @ReferencedObjectID as NUMERIC (16);
		Declare @ObjectGroupMemberID as NUMERIC (16);
		Declare @IdentifierID as NVARCHAR (250);


	
		Declare @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		Declare @l_EntityID numeric(18);
		Declare @l_ObjectID numeric(18);
		Declare @l_ObjectTypeCode nvarchar(200);
		Declare @l_Code nvarchar(200);

		
		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ExistingRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);


		Declare @l_DataOriginCode nvarchar(200);

		DECLARE @ERR_CANNOT_BE_EMPTY nvarchar(200);
		DECLARE @ERR_CODE_NAME_NOT_VALID nvarchar(200);
		DECLARE @ERR_CODE_OVER_DETERMINATED nvarchar(200);
		DECLARE @ERR_NOT_FOUND nvarchar(200);
		DECLARE @ERR_CODE_NOT_VALID nvarchar(200);


		SET @ERR_CANNOT_BE_EMPTY = Isnull((Select Id From Gen.Code where Id = 'ERR_CANNOT_BE_EMPTY'), 'ERR_GENERAL');
		SET @ERR_CODE_NAME_NOT_VALID = Isnull((Select Id From Gen.Code where Id = 'ERR_CODE_NAME_NOT_VALID'), 'ERR_GENERAL');
		SET @ERR_CODE_OVER_DETERMINATED = Isnull((Select Id From Gen.Code where Id = 'ERR_CODE_OVER_DETERMINATED'), 'ERR_GENERAL');
		SET @ERR_NOT_FOUND = Isnull((Select Id From Gen.Code where Id = 'ERR_NOT_FOUND'), 'ERR_GENERAL');
		SET @ERR_CODE_NOT_VALID = Isnull((Select Id From Gen.Code where Id = 'ERR_CODE_CODE_NOT_VALID'), 'ERR_GENERAL');



		SET @l_AllRowCounts = 0;
		SET @l_ImportedRowCounts = 0;
		SET @l_ExistingRowCounts = 0;
		SET @l_ErrorRowCounts = 0;

		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END
		Else
		Begin
			INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				@p_CorrelationID,			-- CorrelationID
				'INDECS 3.0',				-- ApplicationName
				DB_NAME(),					-- Environment
				'SQL',					-- Layer
				'IFC.ObjectGroupMemberLoader',		-- ServiceName
				'1.0',						-- ServiceVersion
				'FATAL',					-- SeverityLevel
				NULL,						-- MessageCategory
				'The ModuleInstanceID is not defined!';	-- LogMessage

			RAISERROR('The ModuleInstanceID is not defined!', 16, 1);
		End;


		IF COALESCE(@l_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);

		SET @l_AllRowCounts = (Select Count(*) FROM IFC.ObjectGroupMember where InterfaceStatusCode in ('INTERFACE_STATUS_NEW', 'INTERFACE_STATUS_FIXED') and SourceInterfaceType = @l_sourceInterfaceType);

		DECLARE db_cursor CURSOR FOR 
		SELECT ID, InterfaceTableID, SourceInterfaceType, SourceID, ObjectGroupID, IdentifierID,
				DataSourceID, ReferencedObjectID, ErrorMessage, ObjectGroupMemberID
		FROM IFC.ObjectGroupMember
		where InterfaceStatusCode in ('INTERFACE_STATUS_NEW', 'INTERFACE_STATUS_FIXED') and SourceInterfaceType = @l_sourceInterfaceType Order by Id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO 
			@ID, @InterfaceTableID, @SourceInterfaceType, @SourceID, @ObjectGroupID, @IdentifierID, 
			@DataSourceID, @ReferencedObjectID, @ErrorMessage, @ObjectGroupMemberID
		WHILE @@FETCH_STATUS = 0  
		BEGIN  

			BEGIN TRY /* Belső-1 */
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Error Section:
			SET @ErrorMessage = NULL;

-- @SourceInterfaceType:
			If Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
				SET @ErrorMessage = 'SourceInterfaceType is Empty,';
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select 'IFC.ObjectGroupMember', @ID, 'sourceInterfaceType', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
			END;

-- @SourceID:
			--If Trim(Isnull(@SourceID,'')) = ''
			--BEGIN
			--	SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' SourceID is Empty,');
			--	Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
			--	Select 'IFC.ObjectGroupMember', @ID, 'sourceID', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
			--END;

-- @InterfaceTableID:
			--If Isnull(@InterfaceTableID,0) = 0
			--BEGIN
			--	SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' InterfaceTableID is Empty,');
			--	Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
			--	Select 'IFC.ObjectGroupMember', @ID, 'interfaceTableID', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
			--END;

-- @ObjectGroupID:
			If Isnull(@ObjectGroupID,0) = 0
			BEGIN
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' ObjectGroupID is Empty,');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select 'IFC.ObjectGroupMember', @ID, 'objectGroupID', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
			END;

-- @ObjectGroupID Validation:
			If Isnull(@ObjectGroupID,0) <> 0
			and not exists (select 1 from GEN.ObjectGroup where ID = @ObjectGroupID)
			BEGIN
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' ObjectGroupID is Not Valid,');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select 'IFC.ObjectGroupMember', @ID, 'objectGroupID', @ERR_CODE_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
			END;

-- @IdentifierID:
			If Trim(Isnull(@IdentifierID,'')) = ''
			BEGIN
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' IdentifierID is Empty,');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select 'IFC.ObjectGroupMember', @ID, 'identifierID', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
			END;

-- @IdentifierID Validation:
			Set @l_ObjectID = 0;
			IF Isnull(@ErrorMessage,'') = ''
			BEGIN
				select @l_ObjectTypeCode = ObjectTypeCode from GEN.ObjectGroup where ID = @ObjectGroupID;
				If @l_ObjectTypeCode = 'OBJECT_TYPE_PRT_PERSON'
					Set @l_ObjectID = 
						(Select Object.ID from PRT.Person
						join PRT.Entity on Entity.ID = Person.EntityID
						join GEN.Object on Object.ID = Entity.ObjectID
						where Person.ID = Cast(@IdentifierID as numeric));
				else
				If @l_ObjectTypeCode = 'OBJECT_TYPE_PRT_COMPANY'
					Set @l_ObjectID = 
						(Select Object.ID from PRT.Company
						join PRT.Entity on Entity.ID = Company.EntityID
						join GEN.Object on Object.ID = Entity.ObjectID
						where Company.ID = Cast(@IdentifierID as numeric));
				else
				If @l_ObjectTypeCode = 'OBJECT_TYPE_AST_ASSET'
					Set @l_ObjectID = 
						(Select Object.ID from AST.Asset
						join GEN.Object on Object.ID = Asset.ObjectID
						where Asset.ID = Cast(@IdentifierID as numeric));
				else
				If @l_ObjectTypeCode = 'OBJECT_TYPE_DCS_DEBTCASE'
					Set @l_ObjectID = 
						(Select Object.ID from DCS.DebtCase
						join GEN.Object on Object.ID = DebtCase.ObjectID
						where DebtCase.ID = Cast(@IdentifierID as numeric));
				--else
					--Set @l_ObjectID = 0;

				If Isnull(@l_ObjectID,0) = 0
				Begin
					SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' IdentifierID is Not Valid,');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.ObjectGroupMember', @ID, 'objectGroupID', @ERR_CODE_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;
			END;


		IF Isnull(@ErrorMessage,'') = ''
		BEGIN
			If not exists (select 1 from GEN.ObjectGroupMember where ObjectGroupID = @ObjectGroupID and ReferencedObjectID = @l_ObjectID)
			begin
				Insert Into GEN.ObjectGroupMember(ObjectGroupID, ReferencedObjectID, StatusCode, CreationDate, CreationTime, CreationUserName)
				Select @ObjectGroupID, @l_ObjectID, 'OBJECT_GROUP_MEMBER_STATUS_MEMBER', Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName

				SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
				UPDATE IFC.ObjectGroupMember SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage = NULL, LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
			end
			else
			begin
				SET @l_ExistingRowCounts = @l_ExistingRowCounts + 1;
				UPDATE IFC.ObjectGroupMember SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED', ErrorMessage = NULL, LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
			end;
		END; /*IF Isnull(@ErrorMessage,'') = '' */
		Else
		Begin
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			UPDATE IFC.ObjectGroupMember SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage, LastModifiedDate = Cast( GetDate() AS Date ), LastModifiedTime = Cast( GetDate() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
		End;



---------------------------------------------------------------------------------------------------------------------------------------------

		   END TRY /*Belső-1*/
		   BEGIN CATCH /*Belső-1*/
				SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
				SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
				UPDATE IFC.ObjectGroupMember SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage WHERE ID = @ID;
		   END CATCH /*Belső-1*/

		FETCH NEXT FROM db_cursor INTO 
			@ID, @InterfaceTableID, @SourceInterfaceType, @SourceID, @ObjectGroupID, @IdentifierID, 
			@DataSourceID, @ReferencedObjectID, @ErrorMessage, @ObjectGroupMemberID


		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    COMMIT TRANSACTION;

    END TRY


    BEGIN CATCH

        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'SQL',					-- Layer
		'IFC.ObjectGroupMemberLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;				-- LogMessage

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        ROLLBACK TRANSACTION;

        SELECT @ErrorMessage;

    END CATCH;

------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	SET @LogMessage = @LogMessage + 'ObjectGroupMemberLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'SQL',					-- Layer
		'IFC.ObjectGroupMemberLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ExistingRowsCount: ' + CAST(@l_ExistingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ @LogMessage



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'SQL',					-- Layer
		'IFC.ObjectGroupMemberLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage

	If Isnull(@ErrorMessage,'') <> ''
		Return 99;
	else
		Return 1;

END;
go

CREATE   PROCEDURE [IFC].[ObjectIdentifierLoader](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16), @p_moduleInstanceIDInkasso Numeric(16) = null output)

-- =============================================
/*
 Author:		Tóth Gábor
 Creation date:			2022.12.05.
 Last modified date:	2022.12.06: @SourceID <-> @SourceRelatedObjectID
						2022.12.09: PRT.ENTITY
						2023.02.08: DataOriginCode
						2023.02.16: @l_DataOriginCode
						2023.03.06: ValueSet vizsgálat: IdentifierTypeText, IdentifierTypeCode
						2023.03.27: ErrorCode-ok
						2023.03.31: @SourceRelatedObjectType
						2023.04.03: 'OBJECT_TYPE_PRT_PERSON' <-> 'OBJECT_TYPE_PRT_ENTITY'
						2023.10.31: Hibaüzenetek javítása ('SourceRelatedObjectType')
									Ki kell tölteni az IFC.ObjectIdentifier táblában a 
									- IdentifierTypeCode vagy IdentifierTypeText
									- Identifier
									- SourceInterfactype
									- SourceId (betöltéskor egyedi)
									- SourceRelatedObjectID (Vonatkozó Person-, Company-, Debtor-, Asset SourceID-ja)
									- SourceRelatedObjectType = ('OBJECT_TYPE_PRT_PERSON', 'OBJECT_TYPE_PRT_COMPANY', 'OBJECT_TYPE_AST_ASSET', 'OBJECT_TYPE_DCS_DEBTCASE')
									Kérésnél meg kell adni a SourceInterfacetype-ot.
						2023.11.03: 'OBJECT_TYPE_PRT_ENTITY' --> {'OBJECT_TYPE_PRT_PERSON', 'OBJECT_TYPE_PRT_COMPANY'}
						2023.11.03: Inkasso szinkron DV-1592
						2023.11.07: @IdentifierTypeCode type === @SourceRelatedObjectType DV-1647
						2023.11.26: @CurrentUserName
            2023.11.27: Inkasso szinkron - GenerateSendInkassoSyncData rendesen hibát dob DV-1592
            2023.12.12: Inkasso szinkron ellenőrzés módosítás DV-1775
*/
-- =============================================

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	--Declare @CurrentUserID NVARCHAR(200);
	--Declare @CurrentUser NVARCHAR(200);
	Declare @CurrentUserName nVarchar(200);

	--Set @CurrentUser = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));
	
	--Set @CurrentUserID = null;
	/*
	If exists (select 1 from PRT.AppUser where UserName = @CurrentUser)
		Set @CurrentUserName = (select Top 1 UserName from PRT.AppUser where UserName = @CurrentUser order by ID);
	ELSE
     Set @ErrorMessage = 'Current user id not defined (' + @CurrentUser + ')';
	*/
	Set @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);;
   
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.ObjectIdentifierLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);

    --BEGIN TRANSACTION

    BEGIN TRY
        SET @LogMessage = 'ObjectIdentifierLoader Started at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
		
		Declare @l_ObjectIdentifier nvarchar(1); -- ObjectIdentifier = 'T'
-----------------------------------------------
		Declare @ID Numeric(16);
		Declare @IdentifierTypeText NvarChar(200);
		Declare @IdentifierTypeCode NvarChar(200);
		Declare @Identifier NvarChar(200);
		Declare @ValidFrom [Date];
		Declare @ValidUntil [Date];
		Declare @ObjectIdentifierID Numeric(16);
		Declare @SourceInterfaceType NvarChar(200);
		Declare @SourceID NvarChar(200);
		Declare @SourceRelatedObjectID NvarChar(200);
		Declare @InterfaceStatusCode NvarChar(200);
		Declare @InterfaceTableID Numeric(16);
		Declare @CreationDate [Date];
		Declare @CreationTime [Time];
		Declare @CreationUserName NvarChar(200);
		Declare @LastModifiedDate [Date];
		Declare @LastModifiedTime [Time];
		Declare @LastModifiedUserName NvarChar(200);
		Declare @SourceRelatedObjectType NvarChar(200);
	
		Declare @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		Declare @l_EntityID numeric(18);
		Declare @l_ObjectID numeric(18);
		Declare @l_LegalFormID  NVARCHAR(50);

		
		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ExisingRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);
		Declare @l_ObjectIdentifierID numeric(18);
		Declare @l_Comments NVARCHAR(MAX);

		Declare @ObjectIdentifierEgyezik nvarchar(1);

		Declare @l_PortfolioID Numeric(16);
		Declare @l_DataOriginCode nvarchar(200);

    DECLARE @l_InkassoSyncOn int = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'Person', 'update')
    DECLARE @inkassoEntityID Numeric(16)
	
		DECLARE @ERR_CANNOT_BE_EMPTY nVarchar(500);
		DECLARE @ERR_CODE_NAME_NOT_VALID nVarchar(500);
		DECLARE @ERR_CODE_CODE_NOT_VALID nVarchar(500);
		DECLARE @ERR_NOT_FOUND_ASSIGNED_ENTITY nVarchar(500);

		SET @ERR_CANNOT_BE_EMPTY = Isnull((Select Id From Gen.Code where Id = 'ERR_CANNOT_BE_EMPTY'), 'ERR_GENERAL');
		SET @ERR_CODE_NAME_NOT_VALID = Isnull((Select Id From Gen.Code where Id = 'ERR_CODE_NAME_NOT_VALID'), 'ERR_GENERAL');
		SET @ERR_CODE_CODE_NOT_VALID = Isnull((Select Id From Gen.Code where Id = 'ERR_CODE_CODE_NOT_VALID'), 'ERR_GENERAL');


/* *************************************************************************************************************** */

		SET @l_AllRowCounts = 0;
		SET @l_ImportedRowCounts = 0;
		SET @l_ExisingRowCounts = 0;
		SET @l_ErrorRowCounts = 0;

		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END


		IF COALESCE(@l_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);

		SET @l_AllRowCounts = (Select Count(*) FROM IFC.COMPANY where InterfaceStatusCode = 'INTERFACE_STATUS_NEW' and SourceInterfaceType = @l_sourceInterfaceType);

		SET @l_AllRowCounts = (Select Count(*) FROM IFC.ObjectIdentifier where InterfaceStatusCode = 'INTERFACE_STATUS_NEW' and SourceInterfaceType = @l_sourceInterfaceType);
		
		DECLARE db_cursor CURSOR FOR 
		Select
			ID, IdentifierTypeText, IdentifierTypeCode, Identifier, ValidFrom, ValidUntil, ObjectIdentifierID, SourceInterfaceType, SourceID, SourceRelatedObjectID, 
			InterfaceStatusCode, ErrorMessage, InterfaceTableID, CreationDate, CreationTime, CreationUserName, LastModifiedDate, LastModifiedTime, LastModifiedUserName, SourceRelatedObjectType
		FROM IFC.ObjectIdentifier
		where InterfaceStatusCode = 'INTERFACE_STATUS_NEW' and SourceInterfaceType = @l_sourceInterfaceType Order by Id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO 
		@ID, @IdentifierTypeText, @IdentifierTypeCode, @Identifier, @ValidFrom, @ValidUntil, @ObjectIdentifierID, @SourceInterfaceType, @SourceID, @SourceRelatedObjectID, 
		@InterfaceStatusCode, @ErrorMessage, @InterfaceTableID, @CreationDate, @CreationTime, @CreationUserName, @LastModifiedDate, @LastModifiedTime, @LastModifiedUserName, @SourceRelatedObjectType

		WHILE @@FETCH_STATUS = 0  
		BEGIN  

---------------------------------------------------------------------------------------------------------------------------------------------
	BEGIN TRY /* Belső-1 */
-- Error Section:
		SET @ErrorMessage = NULL;

		If Trim(Isnull(@SourceID,''))  = ''
		BEGIN
			SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' SourceID is Empty,');
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
			Select 'IFC.OBJECTIDENTIFIER', @ID, 'sourceID', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
		END;

		-- 1 - Üres:
		If Trim(Isnull(@IdentifierTypeText,''))  = ''
		and Trim(Isnull(@IdentifierTypeCode,''))  = ''
		BEGIN
			SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Identifier Type Text/Code is Empty,');
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
			Select 'IFC.OBJECTIDENTIFIER', @ID, 'identifierTypeText', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
			Select 'IFC.OBJECTIDENTIFIER', @ID, 'identifierTypeCode', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
		END;
		-- 2 - Text-NotValid:
		If @IdentifierTypeText is NOT NULL and @IdentifierTypeCode is NULL
		BEGIN
			If Not exists (
					select 1
					from Gen.ValueSet
					left Join Gen.Code on Code.ValueSetID = ValueSet.Id
					left join Gen.Translation on Translation.CodeID = Code.Id
					where CodePrefix like 'IDENTIFIER_TYPE%'
					and Translation.Text = @IdentifierTypeText)
				Begin
					Set @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Identifier Type Text is not Valid,');
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select 'IFC.OBJECTIDENTIFIER', @ID, 'identifierTypeText', @ERR_CODE_NAME_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
				End;
			Else
				Set @IdentifierTypeCode = (select Top 1 Code.Id
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'IDENTIFIER_TYPE%'
						and Translation.Text = @IdentifierTypeText order by Id Desc);
		END;
		-- 3 - Code-NotValid:
		If @IdentifierTypeText is NULL and @IdentifierTypeCode is not NULL
		and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix like 'IDENTIFIER_TYPE%'
						and Code.Id = @IdentifierTypeCode)
		BEGIN
			SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Identifier Type Code is not Valid,');
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
			Select 'IFC.OBJECTIDENTIFIER', @ID, 'identifierTypeCode', @ERR_CODE_CODE_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
		END;



		If Trim(Isnull(@Identifier,''))  = ''
		BEGIN
			SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Identifier is Empty,');
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
			Select 'IFC.OBJECTIDENTIFIER', @ID, 'identifier', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
		END;


		If Isnull(@SourceRelatedObjectType,'') = ''
		Begin
			SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' SourceRelatedObjectType is empty,' );
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
			Select 'IFC.OBJECTIDENTIFIER', @ID, 'sourceRelatedObjectType', @ERR_NOT_FOUND_ASSIGNED_ENTITY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
		End
		Else
		Begin
			If Not exists (select 1 from GEN.Code where id like 'OBJECT_TYPE_%' and ID = Upper(Trim(Isnull(@SourceRelatedObjectType,''))))
			BEGIN
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Not Valid SourceRelatedObjectType,' );
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select 'IFC.OBJECTIDENTIFIER', @ID, 'sourceRelatedObjectType', @ERR_NOT_FOUND_ASSIGNED_ENTITY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
			END;

			If Upper(Trim(Isnull(@SourceRelatedObjectType,''))) not in ('OBJECT_TYPE_PRT_PERSON', 'OBJECT_TYPE_PRT_COMPANY', 'OBJECT_TYPE_AST_ASSET', 'OBJECT_TYPE_DCS_DEBTCASE')
			BEGIN
				SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Not Programed SourceRelatedObjectType,');
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select 'IFC.OBJECTIDENTIFIER', @ID, 'sourceRelatedObjectType', @ERR_NOT_FOUND_ASSIGNED_ENTITY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
			END;
		End; /* If Isnull(@SourceRelatedObjectType,'') = '' */

		If Trim(Isnull(@SourceRelatedObjectID,'')) = ''
		BEGIN
			SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Source Related Object Id is empty,');
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
			Select 'IFC.OBJECTIDENTIFIER', @ID, 'sourceRelatedObjectID', @ERR_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
		END;


		Set @l_ObjectID = 0;
-- DebtCase:
		If @SourceRelatedObjectType = 'OBJECT_TYPE_DCS_DEBTCASE' and exists (Select 1 from DCS.DebtCase
					join GEN.Object on Object.ID = DebtCase.ObjectID and Object.ObjectType = @SourceRelatedObjectType
					where Debtcase.SourceInterfaceType = @SourceInterfaceType and DebtCase.SourceID = @SourceRelatedObjectID)
		BEGIN
			Set @l_ObjectID = (Select Top 1 Object.ID from DCS.DebtCase
					join GEN.Object on Object.ID = DebtCase.ObjectID and Object.ObjectType = @SourceRelatedObjectType
					where Debtcase.SourceInterfaceType = @SourceInterfaceType and DebtCase.SourceID = @SourceRelatedObjectID order by Object.ID desc);
		END;
-- Asset:
		If @l_ObjectID = 0 and @SourceRelatedObjectType = 'OBJECT_TYPE_AST_ASSET' and exists (Select * from AST.Asset
					join GEN.Object on Object.ID = Asset.ObjectID and Object.ObjectType = @SourceRelatedObjectType
					where Asset.SourceInterfaceType = @SourceInterfaceType and Asset.SourceID = @SourceRelatedObjectID)
		BEGIN
			Set @l_ObjectID = (Select Top 1 Object.ID from AST.Asset
					join GEN.Object on Object.ID = Asset.ObjectID and Object.ObjectType = @SourceRelatedObjectType
					where Asset.SourceInterfaceType = @SourceInterfaceType and Asset.SourceID = @SourceRelatedObjectID order by Object.ID desc);
		END;
-- Person:
		If @l_ObjectID = 0 and @SourceRelatedObjectType = 'OBJECT_TYPE_PRT_PERSON' and exists (Select * from PRT.Person
					Join PRT.Entity on Entity.ID = Person.EntityID
					join GEN.Object on Object.ID = Entity.ObjectID and Object.ObjectType = 'OBJECT_TYPE_PRT_PERSON'
					where Entity.SourceInterfaceType = @SourceInterfaceType and Entity.SourceID = @SourceRelatedObjectID)
		BEGIN
			Set @l_ObjectID = (Select Top 1 Object.ID from PRT.Person
					Join PRT.Entity on Entity.ID = Person.EntityID
					join GEN.Object on Object.ID = Entity.ObjectID and Object.ObjectType = 'OBJECT_TYPE_PRT_PERSON' /*@SourceRelatedObjectType*/
					where Entity.SourceInterfaceType = @SourceInterfaceType and Entity.SourceID = @SourceRelatedObjectID order by Object.ID desc);
		END;
-- Company:
		If @l_ObjectID = 0 and @SourceRelatedObjectType = 'OBJECT_TYPE_PRT_COMPANY' and exists (Select * from PRT.Company
					Join PRT.Entity on Entity.ID = Company.EntityID
					join GEN.Object on Object.ID = Entity.ObjectID and Object.ObjectType = 'OBJECT_TYPE_PRT_COMPANY'
					where Entity.SourceInterfaceType = @SourceInterfaceType and Entity.SourceID = @SourceRelatedObjectID)
		BEGIN
			Set @l_ObjectID = (Select Top 1 Object.ID from PRT.Company
					Join PRT.Entity on Entity.ID = Company.EntityID
					join GEN.Object on Object.ID = Entity.ObjectID and Object.ObjectType = 'OBJECT_TYPE_PRT_COMPANY' /*@SourceRelatedObjectType*/
					where Entity.SourceInterfaceType = @SourceInterfaceType and Entity.SourceID = @SourceRelatedObjectID order by Object.ID desc);
		END;


		If @l_ObjectID = 0
		BEGIN
			SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' SourceInterfaceType + SourceRelatedObjectID + SourceRelatedObjectType are not determined the Object.');
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
			Select 'IFC.OBJECTIDENTIFIER', @ID, 'sourceRelatedObjectType', @ERR_NOT_FOUND_ASSIGNED_ENTITY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
		END;

-- @IdentifierTypeCode type === @SourceRelatedObjectType
		If not exists (
			Select 1
			from Gen.Code
			join GEN.ValueSet on ValueSet.ID = Code.ValueSetID
			where Code.Id like 'IDENTIFIER_TYPE_%'
			and Code.ID = @IdentifierTypeCode
			and 
			(
				(Valueset.CodePrefix = 'IDENTIFIER_TYPE_ASSET' and @SourceRelatedObjectType = 'OBJECT_TYPE_AST_ASSET')
				or
				(Valueset.CodePrefix = 'IDENTIFIER_TYPE_COMPANY' and @SourceRelatedObjectType = 'OBJECT_TYPE_PRT_COMPANY')
				or
				(Valueset.CodePrefix = 'IDENTIFIER_TYPE_PERSON' and @SourceRelatedObjectType = 'OBJECT_TYPE_PRT_PERSON')
				or
				(Valueset.CodePrefix = 'IDENTIFIER_TYPE_DEBTCASE' and @SourceRelatedObjectType = 'OBJECT_TYPE_DCS_DEBTCASE')
			)
		)
		BEGIN
			SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' Not Valid SourceRelatedObjectType,' );
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
			Select 'IFC.OBJECTIDENTIFIER', @ID, 'sourceRelatedObjectType', @ERR_CODE_CODE_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
			Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
			Select 'IFC.OBJECTIDENTIFIER', @ID, 'identifierTypeCode', @ERR_CODE_CODE_NOT_VALID, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName;
		END;

		IF @ErrorMessage is not NULL
		BEGIN
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			UPDATE IFC.ObjectIdentifier SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage WHERE ID = @ID;
		END;

		IF @ErrorMessage is NULL
		BEGIN
---------------------------------------------------------------------------------------------------------------------------------------------

			IF ISNULL(@Identifier,'') <> ''
			BEGIN

				Set @l_PortfolioID = (Select Top 1 Object.PortfolioID from  PRT.Entity
					join GEN.Object on Object.ID = Entity.ObjectID and Object.ObjectType = @SourceRelatedObjectType
					where Entity.SourceInterfaceType = @SourceInterfaceType and Entity.SourceID = @SourceRelatedObjectID order by Object.ID desc);
				SELECT @l_DataOriginCode = 
				CASE (Select TreatmentTypeCode from Gen.Portfolio where Id = @l_PortfolioID)
					WHEN 'TREATMENT_TYPE_MANDATE' THEN 'DATA_ORIGIN_PRINCIPAL' /* Megbízásos */
					WHEN 'TREATMENT_TYPE_ASSIGNMENT' THEN 'DATA_ORIGIN_LEGAL_PREDECESSOR'  /* Engedményzett */
					ELSE 'DATA_ORIGIN_LEGAL_PREDECESSOR' /* Engedményzett */
				END;


			
-- Létezik ObjectIdentifier rekord + típus + érték:
				IF exists (Select 1 from Gen.ObjectIdentifier where 
										ObjectIdentifier.ReferencedObjectID = @l_ObjectID 
										and Identifier = @Identifier
										and IdentifierTypeCode = @IdentifierTypeCode
										and ValidUntil is NULL)
				BEGIN
-- Típus Létezik és Érték megegyzik --> semmi:
					SET @l_ObjectIdentifierID = (Select Top 1 ObjectIdentifier.ID from Gen.ObjectIdentifier where 
										ObjectIdentifier.ReferencedObjectID = @l_ObjectID 
										and Identifier = @Identifier
										and IdentifierTypeCode = @IdentifierTypeCode order by ObjectIdentifier.Id desc);
					SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
					UPDATE IFC.ObjectIdentifier SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED',
							ObjectIdentifierID = @l_ObjectIdentifierID WHERE ID = @ID;
				
							
				END
				ELSE
				BEGIN
-- Típus és érték nem Létezik:

          BEGIN TRAN   
					  UPDATE Gen.ObjectIdentifier 
            SET 
						  StatusCode = 'STATUS_DELETED', 
						  ValidUntil =  CAST( GETDATE() AS Date ),
						  LastModifiedDate = CAST( GETDATE() AS Date ),
						  LastModifiedTime = CAST( GETDATE() AS Time ),
						  LastModifiedUserName = @CurrentUserName
            where ObjectIdentifier.ReferencedObjectID = @l_ObjectID and IdentifierTypeCode = @IdentifierTypeCode and ValidUntil is NULL;

					  INSERT INTO Gen.ObjectIdentifier (ReferencedObjectID,IdentifierTypeCode, Identifier, ValidFrom, ValidUntil, StatusCode, SourceInterfaceType, SourceID, CreationDate, CreationTime, CreationUserName, LastModifiedDate, LastModifiedTime, LastModifiedUserName, DataOriginCode)
						  Select @l_ObjectID, @IdentifierTypeCode, @Identifier, CAST( GETDATE() AS Date ), NULL, 'STATUS_NORMAL', @SourceInterfaceType, @SourceID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, NULL, NULL, NULL, @l_DataOriginCode;
					  SET @l_ObjectIdentifierID = @@Identity;


            /*DV-1592: insert Inkasso sync record*/
            if   @l_InkassoSyncOn = 1 
             and @SourceRelatedObjectType = 'OBJECT_TYPE_PRT_PERSON' 
             and @IdentifierTypeCode in ('IDENTIFIER_TYPE_PERSON_ID_CARD_NR', 'IDENTIFIER_TYPE_PERSON_PASSPORT_NR', 'IDENTIFIER_TYPE_PERSON_LICENSE_NR', 'IDENTIFIER_TYPE_PERSON_PENSIONER_ID')
            begin 
              set @inkassoEntityID = null

              select @inkassoEntityID = e.ID
              from PRT.Entity e
              where e.ObjectID = @l_ObjectID

              exec IFC.GenerateSendInkassoSyncData @syncType = 'Person', 
                                                   @syncEventType = 'update', 
                                                   @entityID = @inkassoEntityID, 
                                                   @ID = null, 
                                                   @dataChangedUserName = @CurrentUserName,
                                                   @correlationID = @p_correlationID,
                                                   @moduleInstanceID = @p_moduleInstanceIDInkasso output,
                                                   @isBatch = 1
            end

					  SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
					  UPDATE IFC.ObjectIdentifier SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED',
					  ObjectIdentifierID = @l_ObjectIdentifierID WHERE ID = @ID;

          COMMIT
				
				END;
		END;
				
---------------------------------------------------------------------------------------------------------------------------------------------


		END;  /*@ErrorMessage = NULL*/

		END TRY /*Belső-1*/
		BEGIN CATCH /*Belső-1*/
      if @@trancount > 0
         rollback

			SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			UPDATE IFC.ObjectIdentifier SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage WHERE ID = @ID;
		END CATCH /*Belső-1*/

		FETCH NEXT FROM db_cursor INTO 
		@ID, @IdentifierTypeText, @IdentifierTypeCode, @Identifier, @ValidFrom, @ValidUntil, @ObjectIdentifierID, @SourceInterfaceType, @SourceID, @SourceRelatedObjectID, 
		@InterfaceStatusCode, @ErrorMessage, @InterfaceTableID, @CreationDate, @CreationTime, @CreationUserName, @LastModifiedDate, @LastModifiedTime, @LastModifiedUserName, @SourceRelatedObjectType;


		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    --COMMIT TRANSACTION;

    END TRY


    BEGIN CATCH

        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.ObjectIdentifierLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        --ROLLBACK TRANSACTION;

        SELECT @ErrorMessage;

    END CATCH;


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------

	SET @LogMessage = @LogMessage + 'ObjectIdentifierLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.ObjectIdentifierLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ExistingRowsCount: ' + CAST(@l_ExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ @LogMessage;



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.ObjectIdentifierLoader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return 1;

END;
go


CREATE PROCEDURE [ORG].[OperatorAssignment](@p_correlationID NVARCHAR(200),@p_objectid NVARCHAR(200))

/*
==========================================================================================
 Author:		Bognár Dávid
  Creation date:			2023.02.23.
 Last modified date:	2023.03.20, "Not in" <-> "Not Exists"
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUserName = 'Admin';

	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);



	/* select prt.Entity.objectid from

	prt.person left join prt.Entity on prt.Person.EntityID=prt.Entity.id
	where prt.Entity.ObjectID is not null
	and prt.Entity.ID in (10052,23,41,42) */


	
select 
  top 1 coalesce(DCS.DebtCase.OperatorUserName,'tapodi.janos')
  
from 
  PRT.Entity 
  left join DCS.Debtor on DCS.Debtor.EntityID = PRT.Entity.ID 
  left join DCS.DebtCase on DCS.Debtor.DebtCaseID = DCS.DebtCase.ID 
  left join (
    select 
      debtcaseid, 
      totalinlocalcurrency 
    from 
      FIN.AccountSum_View 
    where 
      code = 'ACCOUNT_TYPE_TOTAL'
  ) Amount on Amount.DebtCaseID = DCS.DebtCase.ID 
where 
  PRT.Entity.ObjectID = @p_objectid
order by 
  totalinlocalcurrency desc;


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	
	SET @LogMessage = @LogMessage + 'DebtorLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: '



	INSERT INTO LOG.Log(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.DebtorLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return 1;


END;

go

CREATE   PROCEDURE [IFC].[PersonLoader](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16), @p_moduleInstanceIDInkasso Numeric(16) = null output)


/*
==========================================================================================
 Author:		Tóth Gábor
 Creation date:		2022.10.17.
 Last modified date:	2022.11.01.
						2022.11.02: ObjectID, AppUser, ReturnCode, Errormessage = NULL
						2022.11.08: InterfaceStatusCode, LOG
						2022-11-09: @p_moduleInstanceID, Átnevezés, 999 -> 99
						2022-11-13: "Demo" mód törlése, "SourceInterfaceType" <-> "MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE" csere
						2022-11-16: PRT.Person.StatusCode = 'ENTITY_STATUS_PERSON_LIVE', PRT.Entity.EntityType = 'P'
						2022-11-19: Adósnév egyezőség vizsgálat, Porfolió beszúrása, MothersFirstName, MothersLastName
						2022-11-20: Errormessage
						2022-11-24: NationalityName, NationalityCode,
						2022-11-24: BirthCountryName, BirthCountryCode
						2022-11-24: GenderName, GenderCode
						2022-11-24: DeceasedCode 'N'
						2022-11-24: CountryName, CountryCode
						2022-11-24: OrganizationUnitCode , OrganizationUnitID
						2022-11-24: DeathCountryName, DeathCountryCode
						2022-11-25: Azonosságvizsgálat kiterjesztése a PortfolioID-val
						2022-11-28: @PortfolioID
						2022-11-29: Ellenőrzés kihagyás
						2022-11-30: PersonID <-> CrefoId
						2022-12-02: Gen.ObjectIdentifier
						2022-12-16: @CurrentUserName
						2023-01-24: IDENTIFIER_TYPE_PERSON_ID_CARD_NR, IDENTIFIER_TYPE_PERSON_PENSIONER_ID
						2023.01.27: Set @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
						2023.02.02: IDENTIFIER_TYPE_PERSON_NR, IDENTIFIER_TYPE_PERSON_PENSIONER_ID
						2023.02.08: DataOriginCode
						2023.02.16: @l_DataOriginCode
						2023.02.21: Hibakezelés
						2023.03.01: Errormessage vesszővel lettek elválasztva
						2023.03.06: ValueSet ellenőrzés: GENDER, COUNTRY, NATIONALITY
						2023.03.06: Változott a neve
						2023.03.16: ErrorCode-ok
						2023.03.27: ErrorCode-ok, ObjectType
						2023.09.13: 'IDENTIFIER_TYPE_PERSON_NR' --> 'IDENTIFIER_TYPE_PERSON_ID_CARD_NR'
			      2023.11.03: Inkasso szinkron DV-1592
						2023.11.07: 'OBJECT_TYPE_PRT_ENTITY' --> 'OBJECT_TYPE_PRT_PERSON' DV-1676
						2023.11.13: @PRTName --> @PRTPerson
						2023.11.17: @NationalityCode
						2023.11.21: If not exists @..Code..
            2023.11.27: Inkasso szinkron - GenerateSendInkassoSyncData rendesen hibát dob DV-1592
						2023.12.01: @DeceasedCode DV-1822
						2023.12.01: Hibakezelés DV-136
						2023.12.08: Kritikus és Blokkoló hibák kezelése DV-1956 - Betöltő eljárás módosítása a IFC.InterfaceError.Errormessage mező töltésére
						2023.12.10: "InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'",  DV-1956
            2023.12.12: Inkasso szinkron ellenőrzés módosítás DV-1775
						2023.12.19: Title, DV-1981
						2023.12.19: LastName or FirstName is Empty DV-1892
						2023.12.19: NationalityName/Code DV-1984
==========================================================================================
*/

AS

BEGIN
	SET NOCOUNT ON;

    DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(MAX);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	DECLARE @l_BlockerError nvarchar(1);  
	-- ha van blokkoló hiba, akkor @l_BlockerError = 'T', 
	-- InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_BLOCKING', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	-- ha csak kritikus hiba van, akkor @l_BlockerError = 'T', 
	-- InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage ki lesz tölve, SeverityCode = 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', StatusCode = 'INTERFACE_ERROR_STATUS_OPEN'
	--DECLARE @l_Prev_ModuleInstanceID Numeric(16);
	DECLARE @l_ErrorMessage nvarchar(MAX);


	SET @CurrentUserName = (Select CreationUserName from Org.ModuleInstance where ModuleInstance.Id = @p_moduleInstanceID);
	--SET @l_Prev_ModuleInstanceID = (Select Top 1 ModuleInstanceID from IFC.InterfaceError where TableName = 'IFC.Person' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' order by id desc);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.PersonLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

	SET @CRLF = CHAR(10)+CHAR(13);


    --BEGIN TRANSACTION  /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/

    BEGIN TRY
        SET @LogMessage = 'PersonLoader Started at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
		
		Declare @l_Person nvarchar(1); -- Person = 'T'
-----------------------------------------------
		Declare @ID NUMERIC(16);
		Declare @ObjectID NUMERIC(16);
		Declare @l_PersonObjectID NUMERIC(16);
		Declare @SourceInterfaceType NVARCHAR(30);
		Declare @SourceID NVARCHAR(200);
		Declare @RegistrationNr NVARCHAR(30);
		Declare @TaxNr NVARCHAR(30);
		Declare @StatisticalNr NVARCHAR(30);
		Declare @Title NVARCHAR(10);
		Declare @LastName NVARCHAR(250);
		Declare @MiddleName NVARCHAR(250);
		Declare @FirstName NVARCHAR(250);
		Declare @FullName NVARCHAR(250);
		Declare @NationalityName NVARCHAR(250);
		Declare @NationalityCode NVARCHAR(250);
		Declare @BirthCountryName NVARCHAR(250);
		Declare @BirthCountryCode NVARCHAR(250);
		Declare @BirthPlace NVARCHAR(250);
		Declare @BirthDate DATE;
		Declare @MaidenLastName NVARCHAR(250);
		Declare @MaidenFirstName NVARCHAR(250);
		--Declare @MothersName NVARCHAR(250);
		Declare @MothersLastName NVARCHAR(250);
		Declare @MothersFirstName NVARCHAR(250);
		Declare @PhoneNr NVARCHAR(250);
		Declare @FaxNr NVARCHAR(250);
		Declare @EMail NVARCHAR(250);
		Declare @Web NVARCHAR(250);
		Declare @IdentityCardNr NVARCHAR(250);
		Declare @PensionerNr NVARCHAR(250);
		--Declare @Comments NVARCHAR(250);
		Declare @Field1 NVARCHAR(250);
		Declare @Field2 NVARCHAR(250);
		Declare @Field3 NVARCHAR(250);
		Declare @Field4 NVARCHAR(250);
		Declare @Field5 NVARCHAR(250);
		Declare @PersonID NUMERIC(16);
		Declare @InterfaceStatusCode NVARCHAR(200);

		Declare @ActualisationDate DATE;
		Declare @Operation NVARCHAR(1);
		Declare @InterfaceTableID NUMERIC(16);
		Declare @Gender NVARCHAR(1);
		Declare @GenderName NVARCHAR(200);
		Declare @GenderCode NVARCHAR(200);
		Declare @DeceasedCode NVARCHAR(200);
		Declare @CountryName Nvarchar(200);
		Declare @CountryCode Nvarchar(200);
		Declare @OrganizationUnitCode NVARCHAR(16);
		Declare @OrganizationUnitID NUMERIC(16);
		Declare @FathersName NVARCHAR(100);
		Declare @DeathDate NVARCHAR(10);
		Declare @DeathCountryName NVARCHAR(200);
		Declare @DeathCountryCode NVARCHAR(200);
		Declare @DeathZipCode NVARCHAR(50);
		Declare @DeathCity NVARCHAR(200);
		Declare @PortfolioID numeric(18);
		Declare @PortfolioName NVARCHAR(200);

	
		Declare @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		Declare @l_EntityID numeric(18);
		Declare @l_ObjectID numeric(18);

		
		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ExisingRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);
		Declare @l_PersonID numeric(18);

		Declare @AdosEgyezik nvarchar(1);

		Declare @l_MFirstName  nvarchar (200);
		Declare @l_MLastName  nvarchar (200);
		Declare @l_Pos numeric(3);

		Declare @l_DataOriginCode nvarchar(200);

		DECLARE @PRTPerson nvarchar(200);

    DECLARE @l_InkassoSyncInsertOn int = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'Person', 'insert')
    DECLARE @l_InkassoSyncUpdateOn int = IFC.IsInkassoSyncOn('INTERFACE_DIRECTION_OUTPUT', 'Person', 'update')
    DECLARE @l_InkassoSyncNeeded int = 0

		DECLARE @ERR_SIFTYPE_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SIFTYPE_CANNOT_BE_EMPTY = 'ERR_GENERAL';						-- SourceInterfaceTpye is empty
		DECLARE @ERR_SIDCANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_SIDCANNOT_BE_EMPTY = 'ERR_GENERAL';							-- SourceID is Empty
		DECLARE @ERR_PortfName_NOT_VALID nvarchar(200);
			SET @ERR_PortfName_NOT_VALID = 'ERR_GENERAL';							-- Portfolió Name is not Empty
		DECLARE @ERR_PortfID_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_PortfID_CANNOT_BE_EMPTY = 'ERR_PORTFOLIOID_CANNOT_BE_NULL';	-- Portfolió ID is not Empty
		DECLARE @ERR_LastName_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_LastName_CANNOT_BE_EMPTY = 'ERR_LASTNAME_CANNOT_BE_EMPTY';
		DECLARE @ERR_FirstName_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_FirstName_CANNOT_BE_EMPTY = 'ERR_FIRSTNAME_CANNOT_BE_EMPTY';
		DECLARE @ERR_MaidenLastName_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_MaidenLastName_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_MaidenFirstName_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_MaidenFirstName_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_MothersLastName_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_MothersLastName_CANNOT_BE_EMPTY = 'ERR_MOTHERLASTNAME_CANNOT_BE_EMPTY';
		DECLARE @ERR_MothersFirstName_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_MothersFirstName_CANNOT_BE_EMPTY = 'ERR_MOTHERFIRSTNAME_CANNOT_BE_EMPTY';
		DECLARE @ERR_BirthDate_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_BirthDate_CANNOT_BE_EMPTY = 'ERR_BIRTHDATE_CANNOT_BE_NULL';
		DECLARE @ERR_BirthPlace_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_BirthPlace_CANNOT_BE_EMPTY = 'ERR_INTERFACE_NO_BIRTH_PLACE';
		DECLARE @ERR_BirthCountryName_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_BirthCountryName_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_BirthCountryCode_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_BirthCountryCode_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_DeathCountryName_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_DeathCountryName_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_DeathCountryCode_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_DeathCountryCode_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_NationalityName_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_NationalityName_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_NationalityCode_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_NationalityCode_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_TitleName_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_TitleName_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_GenderName_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_GenderName_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_GenderCode_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_GenderCode_CANNOT_BE_EMPTY = 'ERR_GENERAL';
		DECLARE @ERR_DeceasedCode_CANNOT_BE_EMPTY nvarchar(200);
			SET @ERR_DeceasedCode_CANNOT_BE_EMPTY = 'ERR_GENERAL';


		SET @PRTPerson = (Select Top 1 Code from GEN.ObjectType where TableName = 'PRT.Person' order by TableName desc);



/* *************************************************************************************************************** */
		--Set @l_PortfolioID = (Select Portfolio.ID from GEN.Portfolio where Portfolio.[Name] = 'Portfolio3');
/* *************************************************************************************************************** */



		SET @l_AllRowCounts = 0;
		SET @l_ImportedRowCounts = 0;
		SET @l_ExisingRowCounts = 0;
		SET @l_ErrorRowCounts = 0;

		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			--AND ModuleInstanceParameter.ParameterCode = 'SOURCE_INTERFACE_TYPE';
			AND ModuleInstanceParameter.ParameterCode = 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE';
		END

		IF COALESCE(@l_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field is not defined in ModuleInstance !', 16, 1);

		SET @l_AllRowCounts = (Select Count(*) FROM IFC.Person
									where Person.SourceInterfaceType = @l_sourceInterfaceType
								AND
									(
									(Person.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
									or 
									(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
									and Person.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Person' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
									));

		DECLARE db_cursor CURSOR FOR 
		SELECT ID, SourceInterfaceType, SourceID, RegistrationNr, TaxNr, StatisticalNr, Title, LastName, MiddleName, FirstName, FullName, NationalityName, NationalityCode,
			BirthCountryName, BirthCountryCode, BirthPlace, BirthDate, MaidenLastName, MaidenFirstName, MothersLastName, MothersFirstName, PhoneNr, FaxNr, EMail, Web, IdentityCardNr, PensionerNr, 
			Field1, Field2, Field3, Field4, Field5, PersonID, InterfaceStatusCode, /*ErrorMessage,*/ ActualisationDate, InterfaceTableID, GenderName, GenderCode,
			DeceasedCode, CountryName, CountryCode, OrganizationUnitCode, OrganizationUnitID, FathersName, DeathDate, DeathCountryName, DeathCountryCode, DeathZipCode, DeathCity, PortfolioID, PortfolioName 
		FROM IFC.Person
		where Person.SourceInterfaceType = @l_sourceInterfaceType
				AND
					(
					(Person.InterfaceStatusCode = 'INTERFACE_STATUS_NEW' )
					or 
					(InterfaceStatusCode = 'INTERFACE_STATUS_ERROR'
					and Person.ID in (Select RecordId from IFC.InterfaceError where TableName = 'IFC.Person' and Isnull(StatusCode,'') = 'INTERFACE_ERROR_STATUS_CLOSED' /*and ModuleInstanceID = @l_Prev_ModuleInstanceID*/))
					)
		Order by Person.ID;


		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO 
			@ID, @SourceInterfaceType, @SourceID, @RegistrationNr, @TaxNr, @StatisticalNr, @Title, @LastName, @MiddleName, @FirstName, @FullName, @NationalityName, @NationalityCode,
			@BirthCountryName, @BirthCountryCode, @BirthPlace, @BirthDate, @MaidenLastName, @MaidenFirstName, @MothersLastName, @MothersFirstName, @PhoneNr, @FaxNr, @EMail, @Web, @IdentityCardNr, @PensionerNr,
			@Field1, @Field2, @Field3, @Field4, @Field5, @PersonID, @InterfaceStatusCode, /*@ErrorMessage,*/ @ActualisationDate, @InterfaceTableID, @GenderName, @GenderCode,
			@DeceasedCode, @CountryName, @CountryCode, @OrganizationUnitCode, @OrganizationUnitID, @FathersName, @DeathDate, @DeathCountryName, @DeathCountryCode, @DeathZipCode, @DeathCity, @PortfolioID, @PortfolioName
		WHILE @@FETCH_STATUS = 0  
		BEGIN  

			BEGIN TRY /* Belső-1 */
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
      SET @l_InkassoSyncNeeded = 0
-- Error Section:
			SET @ErrorMessage = NULL;
			SET @l_BlockerError = '';
-- @SourceInterfaceType:
			If Trim(Isnull(@SourceInterfaceType,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceInterfaceType is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'sourceInterfaceType', @ERR_SIFTYPE_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;
-- @SourceID:
			If Trim(Isnull(@SourceID,'')) = ''
			BEGIN
						Set @l_ErrorMessage = 'SourceID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'sourceID', @ERR_SIDCANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			END;

-- Portfolio ellenőrzése:
			IF Isnull(@PortfolioID, 0) = 0 and Trim(Isnull(@PortfolioName,'')) <> ''
			BEGIN
				If exists(select 1 from Gen.Portfolio where Portfolio.Name = Trim(Isnull(@PortfolioName,'')))
				Begin
					Set @PortfolioID = (select Top 1 ID from Gen.Portfolio where Portfolio.Name = Trim(Isnull(@PortfolioName,'')) order by Id Desc);
				End
				Else
				Begin
						Set @l_ErrorMessage = 'PortfolioName is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'portfolioName', @ERR_PortfName_NOT_VALID, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
				End;
			END;

			IF Isnull(@PortfolioID, 0) = 0
			Begin
						Set @l_ErrorMessage = 'PortfolioID is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'portfolioID', @ERR_PortfID_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
			End;

-- Nevek ellenőrzése:
		If Trim(Isnull(@LastName,'')) = ''
		BEGIN
						Set @l_ErrorMessage = 'LastName is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'lastname', @ERR_LastName_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;
		If Trim(Isnull(@FirstName,'')) = ''
		BEGIN
						Set @l_ErrorMessage = 'FirstName is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'firstName', @ERR_FirstName_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_BLOCKING', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						SET @l_BlockerError = 'T';
		END;

-- Hibakiírás:

		IF @l_BlockerError = 'T'
		BEGIN
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			UPDATE IFC.PERSON SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage,
				LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName	WHERE ID = @ID;
		END;
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
-- Betöltés:
		IF @l_BlockerError = ''
		BEGIN

-- Születéskori Név ellenőrzése:
		If Trim(Isnull(@MaidenLastName,'')) = ''
		BEGIN
						Set @l_ErrorMessage = 'MaidenLastName is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'maidenLastName', @ERR_MaidenLastName_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
		END;
		If Trim(Isnull(@MaidenFirstName,'')) = ''
		BEGIN
						Set @l_ErrorMessage = 'MaidenFirstName is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'maidenFirstName', @ERR_MaidenFirstName_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
		END;


-- Anyja Neve ellenőrzése:
		If Trim(Isnull(@MothersLastName,'')) = ''
		BEGIN
						Set @l_ErrorMessage = 'MothersLastName is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'mothersLastName', @ERR_MothersLastName_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
		END;
		If Trim(Isnull(@MothersFirstName,'')) = ''
		BEGIN
						Set @l_ErrorMessage = 'MothersFirstName is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'mothersFirstName', @ERR_MothersFirstName_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
		END;

-- Születési idő ellenőrzése:
		If @BirthDate is NULL
		BEGIN
						Set @l_ErrorMessage = 'BirthDate is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'birthDate', @ERR_BirthDate_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
		END;

-- Születési hely ellenőrzése:
		If IsNULL(@BirthPlace,'') = ''
		BEGIN
						Set @l_ErrorMessage = 'BirthPlace is Empty';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'birthPlace', @ERR_BirthPlace_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
		END;

-- @BirthCountryName,@BirthCountryCode:
			-- 0 - NULL:
			If Trim(Isnull(@BirthCountryName,'')) = ''
				Set @BirthCountryName = NULL;
			If Trim(Isnull(@BirthCountryCode,'')) = ''
				Set @BirthCountryCode = NULL;
			Set @BirthCountryName = Trim(@BirthCountryName);
			Set @BirthCountryCode = Trim(@BirthCountryCode);
			
			-- 1 - Üres:
			If @BirthCountryName is NULL and @BirthCountryCode is NULL
			BEGIN
				SET @ErrorMessage = @ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			If @BirthCountryName is NOT NULL and @BirthCountryCode is NULL
			BEGIN
				If Not exists (
						select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'COUNTRY'
						and Translation.Text = @BirthCountryName)
					BEGIN
						Set @l_ErrorMessage = 'BirthCountryName is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'birthCountryName', @ERR_BirthCountryName_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @BirthCountryName = NULL;
					END;
				Else
					Set @BirthCountryCode = (select Top 1 Code.Id 
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'COUNTRY'
						and Translation.Text = @BirthCountryName order by Code.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @BirthCountryName is NULL and @BirthCountryCode is not NULL
			and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'COUNTRY'
						and Code.Id = @BirthCountryCode)
			BEGIN
						Set @l_ErrorMessage = 'BirthCountryNameCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'birthCountryCode', @ERR_BirthCountryCode_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @BirthCountryCode = NULL;
			END;

-- @DeathCountryName,@DeathCountryCode:
			-- 0 - NULL:
			If Trim(Isnull(@DeathCountryName,'')) = ''
				Set @DeathCountryName = NULL;
			If Trim(Isnull(@DeathCountryCode,'')) = ''
				Set @DeathCountryCode = NULL;
			Set @DeathCountryName = Trim(@DeathCountryName);
			Set @DeathCountryCode = Trim(@DeathCountryCode);
			
			-- 1 - Üres:
			If @DeathCountryName is NULL and @DeathCountryCode is NULL
			BEGIN
				SET @ErrorMessage = @ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			If @DeathCountryName is NOT NULL and @DeathCountryCode is NULL
			BEGIN
				If Not exists (select 1
								from Gen.ValueSet
								left Join Gen.Code on Code.ValueSetID = ValueSet.Id
								left join Gen.Translation on Translation.CodeID = Code.Id
								where CodePrefix = 'COUNTRY'
								and Translation.Text = @DeathCountryName)
					Begin
						Set @l_ErrorMessage = 'DeathCountryName is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'deathCountryName', @ERR_DeathCountryName_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @DeathCountryName = NULL;
					End;
				Else
					Set @DeathCountryCode = (select Top 1 Code.Id 
											from Gen.ValueSet
											left Join Gen.Code on Code.ValueSetID = ValueSet.Id
											left join Gen.Translation on Translation.CodeID = Code.Id
											where CodePrefix = 'COUNTRY'
											and Translation.Text = @DeathCountryName
											order by Id desc);
			END;
			-- 3 - Code-NotValid:
			If @DeathCountryName is NULL and @DeathCountryCode is not NULL
			and Not exists (select 1
								from Gen.ValueSet
								left Join Gen.Code on Code.ValueSetID = ValueSet.Id
								left join Gen.Translation on Translation.CodeID = Code.Id
								where CodePrefix = 'COUNTRY'
								and Code.Id = @DeathCountryCode)
			BEGIN
						Set @l_ErrorMessage = 'DeathCountryNameCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'deathCountryCode', @ERR_DeathCountryCode_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @DeathCountryCode= NULL;
			END;


-- @NationalityName,@NationalityCode:
			-- 0 - NULL:
			If Trim(Isnull(@NationalityName,'')) = ''
				Set @NationalityName = NULL;
			If Trim(Isnull(@NationalityCode,'')) = ''
				Set @NationalityCode = NULL;
			Set @NationalityName = Trim(@NationalityName);
			Set @NationalityCode = Trim(@NationalityCode);
			
			-- 1 - Üres:
			If @NationalityName is NULL and @NationalityCode is NULL
			BEGIN
						Set @l_ErrorMessage = 'NationalityName/Code is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'nationalityName', @ERR_NationalityName_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'nationalityCode', @ERR_NationalityCode_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			If @NationalityName is NOT NULL and @NationalityCode is NULL
			BEGIN
				If Not exists (select 1
								from Gen.ValueSet
								left Join Gen.Code on Code.ValueSetID = ValueSet.Id
								left join Gen.Translation on Translation.CodeID = Code.Id
								where CodePrefix = 'NATIONALITY'
								and Translation.Text = @NationalityName)
					Begin
						Set @l_ErrorMessage = 'NationalityName is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'nationalityName', @ERR_NationalityName_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @NationalityName = NULL;
					End;
				Else
					Set @NationalityCode = (select Top 1 Code.Id
								from Gen.ValueSet
								left Join Gen.Code on Code.ValueSetID = ValueSet.Id
								left join Gen.Translation on Translation.CodeID = Code.Id
								where CodePrefix = 'NATIONALITY'
								and Translation.Text = @NationalityName order by code.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @NationalityName is NULL and @NationalityCode is not NULL
			and Not exists (select 1
								from Gen.ValueSet
								left Join Gen.Code on Code.ValueSetID = ValueSet.Id
								left join Gen.Translation on Translation.CodeID = Code.Id
								where CodePrefix = 'NATIONALITY'
								and Code.Id = @NationalityCode)
			BEGIN
						Set @l_ErrorMessage = 'NationalityCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'nationalityCode', @ERR_NationalityCode_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @NationalityCode = NULL;
			END;

-- @Title:
			-- 0 - NULL:
			If Trim(Isnull(@Title,'')) = ''
				Set @Title = NULL;
			Set @Title = Trim(@Title);
			
			-- 1 - Üres:
			If @Title is NULL
			BEGIN
				SET @ErrorMessage = @ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			If @Title is NOT NULL
			BEGIN
				If Not exists (select 1 from Gen.Translation where codeid like 'PERSON_TITLE_%' and Text = @Title)
				and Not exists (select 1 from Gen.Code where id like 'PERSON_TITLE_%' and id = @Title)
					Begin
						Set @l_ErrorMessage = 'TitleName is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'title', @ERR_TitleName_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @Title = NULL;
					End;
				Else
				Begin
					If exists (select 1 from Gen.Translation where codeid like 'PERSON_TITLE_%' and Text = @Title)
					Begin
						Set @Title = (select Top 1 CodeID from Gen.Translation where codeid like 'PERSON_TITLE_%' and Text = @Title order by Id desc);
					End
					Else
					Begin
						If exists (select 1 from Gen.Code where id like 'PERSON_TITLE_%' and Id = @Title)
						Begin
							Set @Title = @Title;
						End
					End;
				End;
			END; -- If @Title is NOT NULL

-- @GenderName,@GenderCode:
			-- 0 - NULL:
			If Trim(Isnull(@GenderName,'')) = ''
				Set @GenderName = NULL;
			If Trim(Isnull(@GenderCode,'')) = ''
				Set @GenderCode = NULL;
			Set @GenderName = Trim(@GenderName);
			Set @GenderCode = Trim(@GenderCode);
			
			-- 1 - Üres:
			If @GenderName is NULL and @GenderCode is NULL
			BEGIN
				SET @ErrorMessage = @ErrorMessage;
			END;
			-- 2 - Text-NotValid:
			If @GenderName is NOT NULL and @GenderCode is NULL
			BEGIN
				If Not exists (
						select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'GENDER'
						and Translation.Text = @GenderName)
					Begin
						Set @l_ErrorMessage = 'GenderName is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'genderName', @ERR_GenderName_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @GenderName = NULL;
					End;
				Else
					Set @GenderCode = (Select Top 1 Code.Id
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where CodePrefix = 'GENDER'
						and Translation.Text = @GenderName order by Code.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @GenderName is NULL and @GenderCode is not NULL
			and Not exists (select 1 from Gen.Code where Id like 'Gender_%' and Id = @GenderCode)
			BEGIN
						Set @l_ErrorMessage = 'GenderCode is not Valid';
						SET @ErrorMessage = Concat(@ErrorMessage, ' ', @l_ErrorMessage, ',');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode, ErrorMessage)
						Select 'IFC.PERSON', @ID, 'genderCode', @ERR_GenderCode_CANNOT_BE_EMPTY, @p_ModuleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN', @l_ErrorMessage;
						Set @GenderCode = NULL;
			END;


-- DeceasedCode:
			If Trim(Isnull(@DeceasedCode,'')) in ('I','ENTITY_STATUS_PERSON_DECEASED_ANNOUNCED')
				SET @DeceasedCode = 'ENTITY_STATUS_PERSON_DECEASED_ANNOUNCED'
			Else
				SET @DeceasedCode = 'ENTITY_STATUS_PERSON_LIVE';

			/* Ennek nincs értelme (2023-12-01)
			IF Isnull(@DeceasedCode,'') <> '' and Isnull(@DeceasedCode,'') like 'ENTITY_STATUS_PERSON_%'
				and not exists (select 1 from GEN.Code where ID like 'ENTITY_STATUS_PERSON_%' and Id = Isnull(@DeceasedCode,''))
				Begin
						SET @ErrorMessage = Concat(@ErrorMessage, ' DeceasedCode is not Valid,');
						Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName, SeverityCode, StatusCode)
						Select 'IFC.PERSON', @ID, 'deceasedCode', @ERR_DeceasedCode_CANNOT_BE_EMPTY, @p_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @CurrentUserName, 'INTERFACE_ERROR_SEVERITY_CRITICAL_ERROR', 'INTERFACE_ERROR_STATUS_OPEN';
						Set @DeceasedCode = NULL;
				End;
			*/

---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------------------------------


			Set @AdosEgyezik = 'F';
			If Isnull(@BirthPlace,'') <> '' and @BirthDate is not NULL and Isnull(@MothersLastName,'') <> '' and Isnull(@MothersFirstName,'') <> ''
			and Isnull(@LastName,'') <> '' and Isnull(@FirstName,'') <> ''
			Begin
				If exists (Select 1 from PRT.Person 
							Join PRT.Entity on Entity.ID = Person.EntityID
							Join Gen.Object on Object.Id = Entity.ObjectId
							where 
								Object.PortfolioID = @PortfolioID
							and 
							Trim(Replace(@BirthPlace,' ','')) = Trim(Replace(Person.BirthPlace,' ',''))
							and @BirthDate = Person.BirthDate
							and 
								(
								Replace(Isnull(@MothersLastName,'') + Isnull(@MothersFirstName,''),' ','') = Replace(Isnull(Person.MotherLastName,'') + Isnull(Person.MotherFirstName,''),' ','')
								)
							and
								Replace(Replace(Replace(@LastName + Isnull(@MiddleName,'') + @FirstName,' ',''),'dr',''),'.','') =
								Replace(Replace(Replace(Isnull(Person.LastName,'') + Isnull(Person.MiddleName,'') + Isnull(Person.FirstName,''),' ',''),'dr',''),'.','')
							)
				Begin
					Set @AdosEgyezik = 'T';

					Set @l_EntityID = (Select Top 1 Person.EntityID from PRT.Person 
							Join PRT.Entity on Entity.ID = Person.EntityID
							Join Gen.Object on Object.Id = Entity.ObjectId
							where 
								Object.PortfolioID = @PortfolioID
							and 
							Trim(Replace(@BirthPlace,' ','')) = Trim(Replace(Person.BirthPlace,' ',''))
							and @BirthDate = Person.BirthDate
							and 
								(
								Replace(Isnull(@MothersLastName,'') + Isnull(@MothersFirstName,''),' ','') = Replace(Isnull(Person.MotherLastName,'') + Isnull(Person.MotherFirstName,''),' ','')
								)
							and
								Replace(Replace(Replace(@LastName + Isnull(@MiddleName,'') + @FirstName,' ',''),'dr',''),'.','') =
								Replace(Replace(Replace(Isnull(Person.LastName,'') + Isnull(Person.MiddleName,'') + Isnull(Person.FirstName,''),' ',''),'dr',''),'.','')
							order by Person.Id desc);

				End;
			End;

---------------------------------------------------------------------------------------------------------------------------------------------
			-- Létezik a Person:
			If @AdosEgyezik = 'T'
				BEGIN
					Set @l_PersonObjectID = (Select ObjectID from PRT.Entity where ID = @l_EntityID);

					Set @l_DataOriginCode = NULL;
					SELECT @l_DataOriginCode = 
						CASE (Select TreatmentTypeCode from Gen.Portfolio where Id = @PortfolioID)
							WHEN 'TREATMENT_TYPE_MANDATE' THEN 'DATA_ORIGIN_PRINCIPAL' /* Megbízásos */
							WHEN 'TREATMENT_TYPE_ASSIGNMENT' THEN 'DATA_ORIGIN_LEGAL_PREDECESSOR'  /* Engedményzett */
							ELSE 'DATA_ORIGIN_LEGAL_PREDECESSOR' /* Engedményzett */
						END;

          BEGIN TRAN /*Létező Person*/
  ---------------------------------------------------------------------------------------------------------------------------------------------
  -- Személyigazolványszám:
					  -- Update
					  IF ISNULL(@IdentityCardNr,'') <> ''
					  BEGIN
					  /*
						  -- Update az előző 
						  IF exists (Select 1 from Gen.ObjectIdentifier where ObjectIdentifier.ReferencedObjectID = @l_PersonObjectID and IdentifierTypeCode = 'IDENTIFIER_TYPE_PERSON_NR'/* 'IDENTIFIER_TYPE_PERSON_ID_CARD_NR'*/ /*'ENTITY_IDENTIFIER_TYPE_PERSON_PERSONAL_IDENTITY'*/)
						  BEGIN
							  UPDATE Gen.ObjectIdentifier SET StatusCode = 'STATUS_DELETED', ValidUntil =  CAST( GETDATE() AS Date ) where ObjectIdentifier.ReferencedObjectID = @l_PersonObjectID and IdentifierTypeCode = 'IDENTIFIER_TYPE_PERSON_NR' /*'ENTITY_IDENTIFIER_TYPE_PERSON_PERSONAL_IDENTITY'*/;
						  END;
						  INSERT INTO Gen.ObjectIdentifier (ReferencedObjectID,IdentifierTypeCode, Identifier, ValidFrom, ValidUntil, StatusCode, SourceInterfaceType, SourceID, CreationDate, CreationTime, CreationUserName, LastModifiedDate, LastModifiedTime, LastModifiedUserName, DataOriginCode)
							  Select @l_PersonObjectID, 'IDENTIFIER_TYPE_PERSON_NR' /*'IDENTIFIER_TYPE_PERSON_ID_CARD_NR'*/ /*'ENTITY_IDENTIFIER_TYPE_PERSON_PERSONAL_IDENTITY'*/, @IdentityCardNr, CAST( GETDATE() AS Date ), NULL, 'STATUS_NORMAL', @SourceInterfaceType, @SourceID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, NULL, NULL, NULL, @l_DataOriginCode;
					  */
						  IF not exists (Select 1 from Gen.ObjectIdentifier 
										  where ObjectIdentifier.ReferencedObjectID = @l_PersonObjectID 
										  and IdentifierTypeCode = 'IDENTIFIER_TYPE_PERSON_ID_CARD_NR' /*'IDENTIFIER_TYPE_PERSON_NR' 2023-09-13*/
										  and Isnull(StatusCode,'') <> 'STATUS_DELETED'
										  and Isnull(Identifier,'') = @IdentityCardNr)
						  Begin
							  UPDATE Gen.ObjectIdentifier SET StatusCode = 'STATUS_DELETED', ValidUntil =  CAST( GETDATE() AS Date ) 
									  where ObjectIdentifier.ReferencedObjectID = @l_PersonObjectID 
									  and IdentifierTypeCode = 'IDENTIFIER_TYPE_PERSON_ID_CARD_NR' /*'IDENTIFIER_TYPE_PERSON_NR'*/
									  and Isnull(StatusCode,'') <> 'STATUS_DELETED'
									  and ValidUntil is NULL;
							  INSERT INTO Gen.ObjectIdentifier (ReferencedObjectID,IdentifierTypeCode, Identifier, ValidFrom, ValidUntil, StatusCode, SourceInterfaceType, SourceID, CreationDate, CreationTime, CreationUserName, LastModifiedDate, LastModifiedTime, LastModifiedUserName, DataOriginCode)
								  Select @l_PersonObjectID, 'IDENTIFIER_TYPE_PERSON_ID_CARD_NR' /*'IDENTIFIER_TYPE_PERSON_NR'*/ /*'IDENTIFIER_TYPE_PERSON_ID_CARD_NR'*/ /*'ENTITY_IDENTIFIER_TYPE_PERSON_PERSONAL_IDENTITY'*/, @IdentityCardNr, CAST( GETDATE() AS Date ), NULL, 'STATUS_NORMAL', @SourceInterfaceType, @SourceID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, NULL, NULL, NULL, @l_DataOriginCode;


                /*DV-1592: Inkasso sync needed*/
                if @l_InkassoSyncUpdateOn = 1
                   set @l_InkassoSyncNeeded = 1  
						  End;
					  END;
  ---------------------------------------------------------------------------------------------------------------------------------------------
  -- Nyugdíjas törzsszám:
					  -- Update
					  IF ISNULL(@PensionerNr,'') <> ''
					  BEGIN
						  /*
						  -- Update az előző 
						  IF exists (Select 1 from Gen.ObjectIdentifier where ObjectIdentifier.ReferencedObjectID = @l_PersonObjectID and IdentifierTypeCode = 'IDENTIFIER_TYPE_PERSON_PENSIONER_ID' /*'IDENTIFIER_TYPE_PERSON_PENSIONER_ID'*//*'ENTITY_IDENTIFIER_TYPE_PERSON_RETIREDNR'*/)
						  BEGIN
							  UPDATE Gen.ObjectIdentifier SET StatusCode = 'STATUS_DELETED', ValidUntil =  CAST( GETDATE() AS Date ) where ObjectIdentifier.ReferencedObjectID = @l_PersonObjectID and IdentifierTypeCode = 'IDENTIFIER_TYPE_PERSON_PENSIONER_ID' /*'ENTITY_IDENTIFIER_TYPE_PERSON_RETIREDNR'*/;
						  END; 
						  INSERT INTO Gen.ObjectIdentifier (ReferencedObjectID,IdentifierTypeCode, Identifier, ValidFrom, ValidUntil, StatusCode, SourceInterfaceType, SourceID, CreationDate, CreationTime, CreationUserName, LastModifiedDate, LastModifiedTime, LastModifiedUserName, DataOriginCode)
							  Select @l_PersonObjectID, 'IDENTIFIER_TYPE_PERSON_PENSIONER_ID' /*'IDENTIFIER_TYPE_PERSON_PENSIONER_ID'*//*'ENTITY_IDENTIFIER_TYPE_PERSON_RETIREDNR'*/, @PensionerNr, CAST( GETDATE() AS Date ), NULL, 'STATUS_NORMAL', @SourceInterfaceType, @SourceID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, NULL, NULL, NULL, @l_DataOriginCode;
						  */
						  IF not exists (Select 1 from Gen.ObjectIdentifier 
										  where ObjectIdentifier.ReferencedObjectID = @l_PersonObjectID 
										  and IdentifierTypeCode = 'IDENTIFIER_TYPE_PERSON_PENSIONER_ID'
										  and Isnull(StatusCode,'') <> 'STATUS_DELETED'
										  and Isnull(Identifier,'') = @PensionerNr)
						  Begin
							  UPDATE Gen.ObjectIdentifier SET StatusCode = 'STATUS_DELETED', ValidUntil =  CAST( GETDATE() AS Date ) 
									  where ObjectIdentifier.ReferencedObjectID = @l_PersonObjectID 
									  and IdentifierTypeCode = 'IDENTIFIER_TYPE_PERSON_PENSIONER_ID'
									  and Isnull(StatusCode,'') <> 'STATUS_DELETED'
									  and ValidUntil is NULL;
							  INSERT INTO Gen.ObjectIdentifier (ReferencedObjectID,IdentifierTypeCode, Identifier, ValidFrom, ValidUntil, StatusCode, SourceInterfaceType, SourceID, CreationDate, CreationTime, CreationUserName, LastModifiedDate, LastModifiedTime, LastModifiedUserName, DataOriginCode)
								  Select @l_PersonObjectID, 'IDENTIFIER_TYPE_PERSON_PENSIONER_ID' /*'IDENTIFIER_TYPE_PERSON_ID_CARD_NR'*/ /*'ENTITY_IDENTIFIER_TYPE_PERSON_PERSONAL_IDENTITY'*/, @PensionerNr, CAST( GETDATE() AS Date ), NULL, 'STATUS_NORMAL', @SourceInterfaceType, @SourceID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, NULL, NULL, NULL, @l_DataOriginCode;
						  End;

              /*DV-1592: Inkasso sync needed*/
                if @l_InkassoSyncUpdateOn = 1
                   set @l_InkassoSyncNeeded = 1  
					  END;

  ---------------------------------------------------------------------------------------------------------------------------------------------
  -- Változott a neve:
					  If @l_EntityID is not NULL
						  and (Select Trim(Isnull(Person.LastName,'')) + Trim(Isnull(Person.Title,'')) + Trim(Isnull(Person.FirstName,'')) from PRT.Person
							  Join PRT.Entity on Entity.ID = Person.EntityID
							  Join Gen.Object on Object.Id = Entity.ObjectId and Object.PortfolioID = @PortfolioID
						  where Person.EntityID = @l_EntityID) <> ''
						  /*
						  and Replace((Select Trim(Isnull(Person.LastName,'')) + Trim(Isnull(Person.Title,'')) + Trim(Isnull(Person.FirstName,'')) from PRT.Person where Person.EntityID = @l_EntityID),' ','') <> ''
						  */
					  Begin
						  IF 
							  /*
							  Replace((Select Trim(Isnull(Person.LastName,'')) + Trim(Isnull(Person.Title,'')) + Trim(Isnull(Person.FirstName,'')) from PRT.Person where Person.EntityID = @l_EntityID),' ','')
							  */
							  (Select Trim(Isnull(Person.LastName,'')) + Trim(Isnull(Person.Title,'')) + Trim(Isnull(Person.FirstName,'')) from PRT.Person
							  Join PRT.Entity on Entity.ID = Person.EntityID
							  Join Gen.Object on Object.Id = Entity.ObjectId and Object.PortfolioID = @PortfolioID
							  where Person.EntityID = @l_EntityID)
							  <> 
							  Replace(Trim(Isnull(@LastName,'')) + Trim(Isnull(@Title,'')) + Trim(Isnull(@FirstName,'')),' ','')
						  Begin
							  Update Prt.Name set ValidUntil = CAST( GETDATE() AS Date ), StatusCode = 'STATUS_DELETED', LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime =  CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName
									  where EntityID = @l_EntityID and ValidUntil = NULL and NameTypeCode = 'NAME_TYPE_PERSON_PREVIOUS';
							  -- New ObjectID:
							  INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr,  PortfolioID)
								  SELECT @PRTPerson as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @PortfolioID;
							  SET @l_ObjectID = @@Identity;
								  Insert Into Prt.Name(ObjectID, EntityID, Name, ValidFrom, StatusCode, NameTypeCode, SourceInterfaceType, SourceID, CreationDate, CreationTime, CreationUserName, DataOriginCode)
								  Select @l_ObjectID, @l_EntityID, (Select Trim(Trim(Isnull(Person.LastName,'')) + ' ' + Trim(Trim(Isnull(Person.Title,'')) + ' ' + Trim(Isnull(Person.FirstName,'')))) from PRT.Person where Person.EntityID = @l_EntityID),
								  CAST( GETDATE() AS Date ), 'STATUS_NORMAL', 'NAME_TYPE_PERSON_PREVIOUS', @SourceInterfaceType, @SourceID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, @l_DataOriginCode;

							  Update Prt.Person Set LastName = Trim(@LastName), Title = Trim(@Title), FirstName = @FirstName where EntityID = @l_EntityID;

                /*DV-1592: Inkasso sync needed*/
                if @l_InkassoSyncUpdateOn = 1
                   set @l_InkassoSyncNeeded = 1  
						  End;
					  End;


            /*DV-1592: insert Inkasso sync record*/
            if @l_InkassoSyncNeeded = 1
            begin
              exec IFC.GenerateSendInkassoSyncData @syncType = 'Person', 
                                                   @syncEventType = 'update', 
                                                   @entityID = @l_EntityID, 
                                                   @ID = null, 
                                                   @dataChangedUserName = @CurrentUserName,
                                                   @correlationID = @p_correlationID,
                                                   @moduleInstanceID = @p_moduleInstanceIDInkasso output,
                                                   @isBatch = 1
            end

					  SET @l_ExisingRowCounts = @l_ExisingRowCounts + 1;
					  UPDATE IFC.Person SET InterfaceStatusCode = 'INTERFACE_STATUS_IDENTIFIED', 
					  ErrorMessage = 'Identified by existing Person, EntityId: ' + Cast(@l_EntityID as nvarchar(18)) +
						  (Select Case When (Select Isnull(SourceID,'') from PRT.Entity where ID = @l_EntityID) <> @SourceID
						  then ' Other SourceId: ' + (Select Isnull(SourceID,'') from PRT.Entity where ID = @l_EntityID) end), 
					  CrefoId = @l_EntityID,
						LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName WHERE ID = @ID;
          
          COMMIT /*Létező Person*/
				END;
			ELSE
			-- Nem létezik a Person:
      BEGIN
---------------------------------------------------------------------------------------------------------------------------------------------
        BEGIN TRAN /*Nem létező Person*/

					-- New ObjectID:
					INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr,  PortfolioID)
						SELECT @PRTPerson as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @PortfolioID;
					SET @l_ObjectID = @@Identity;

					INSERT INTO PRT.Entity (ObjectID, EntityType, SourceInterfaceType, SourceID, CreationDate, CreationTime, CreationUserName, Status)
					SELECT @l_ObjectID, 'P', @SourceInterfaceType, @SourceID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, 'STATUS_NORMAL';
					SET @l_EntityID = @@Identity; /*(SELECT ID FROM PRT.Entity WHERE Entity.SourceInterfaceType = @SourceInterfaceType and Entity.SourceID = @SourceID);*/
---------------------------------------------------------------------------------------------------------------------------------------------

					Set @l_PersonObjectID = @l_ObjectID;

					Set @l_DataOriginCode = NULL;
					SELECT @l_DataOriginCode = 
						CASE (Select TreatmentTypeCode from Gen.Portfolio where Id = @PortfolioID)
							WHEN 'TREATMENT_TYPE_MANDATE' THEN 'DATA_ORIGIN_PRINCIPAL' /* Megbízásos */
							WHEN 'TREATMENT_TYPE_ASSIGNMENT' THEN 'DATA_ORIGIN_LEGAL_PREDECESSOR'  /* Engedményzett */
							ELSE 'DATA_ORIGIN_LEGAL_PREDECESSOR' /* Engedményzett */
						END;
---------------------------------------------------------------------------------------------------------------------------------------------
-- Személyigazolványszám:
					-- Update
					IF ISNULL(@IdentityCardNr,'') <> '' /*and ISNULL(@Operation,'') = 'U'*/
					BEGIN
						INSERT INTO Gen.ObjectIdentifier (ReferencedObjectID,IdentifierTypeCode, Identifier, ValidFrom, ValidUntil, StatusCode, SourceInterfaceType, SourceID, CreationDate, CreationTime, CreationUserName, LastModifiedDate, LastModifiedTime, LastModifiedUserName, DataOriginCode)
							Select @l_PersonObjectID, 'IDENTIFIER_TYPE_PERSON_ID_CARD_NR' /*'IDENTIFIER_TYPE_PERSON_NR'*/ /*'ENTITY_IDENTIFIER_TYPE_PERSON_PERSONAL_IDENTITY'*/, @IdentityCardNr, CAST( GETDATE() AS Date ), NULL, 'STATUS_NORMAL', @SourceInterfaceType, @SourceID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, NULL, NULL, NULL, @l_DataOriginCode;
					END;
---------------------------------------------------------------------------------------------------------------------------------------------
-- Nyugdíjas törzsszám:
					-- Update
					IF ISNULL(@PensionerNr,'') <> '' /*and ISNULL(@Operation,'') = 'U'*/
					BEGIN
						INSERT INTO Gen.ObjectIdentifier (ReferencedObjectID,IdentifierTypeCode, Identifier, ValidFrom, ValidUntil, StatusCode, SourceInterfaceType, SourceID, CreationDate, CreationTime, CreationUserName, LastModifiedDate, LastModifiedTime, LastModifiedUserName, DataOriginCode)
							Select @l_PersonObjectID, 'IDENTIFIER_TYPE_PERSON_PENSIONER_ID' /*'ENTITY_IDENTIFIER_TYPE_PERSON_RETIREDNR'*/, @PensionerNr, CAST( GETDATE() AS Date ), NULL, 'STATUS_NORMAL', @SourceInterfaceType, @SourceID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, NULL, NULL, NULL, @l_DataOriginCode;
					END;
---------------------------------------------------------------------------------------------------------------------------------------------
					-- Új person felvitele:

					-- New ObjectID:
					/*
					INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr,  PortfolioID)
						SELECT 'PRT.Person' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @PortfolioID;
					SET @l_ObjectID = @@Identity;
					*/

-- Portfólió:
/*
					Insert Into GEN.PortfolioSystemObject(SystemObjectID, PortfolioID, CreationDate, CreationTime, CreationUserName)
					Select @l_ObjectID, @l_PortfolioID, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName;
*/

/*
Nem kell, mert az IFC.Person-ban már szét van bontva
-- Anyja neve szétbontása:

					Set @l_MFirstName = '';
					Set @l_MLastName = '';
					Set @l_Pos = 0;
					Set @MothersName = Trim(@MothersName);
					Set @l_Pos = Charindex(' ', @MothersName);
					Set @l_MLastName = Trim(left(@MothersName, @l_Pos));
					Set @l_MFirstName = Trim(right(@MothersName, len(@MothersName)-@l_Pos));
*/ 

					INSERT INTO PRT.Person(
						/*ObjectID,*/							LastName, 									MiddleName, 
						FirstName, 								Title, 										MotherLastName, 
						MotherFirstName, 						BirthPlace, 								BirthDate, 
						/*GenderCode*/ SEX, 					MaidenLastName, 							MaidenFirstName, 
						FathersName, 							EntityID, 									CreationDate, 
						CreationUserName,						CreationTime,								StatusCode,
						DeathDate,								DeathCountryCode,							DeathZipCode,
						DeathPlace,								NationalityCode)
					SELECT
						/*@l_ObjectID,*/						Trim(@LastName),							Trim(@MiddleName),
						Trim(@FirstName),						Trim(@Title),								Trim(@MothersLastName),
						Trim(@MothersFirstName),				Trim(@BirthPlace), 							@BirthDate,
						Trim(@Gender),							Trim(@MaidenLastName), 						Trim(@MaidenFirstName),
						Trim(@FathersName),						@l_EntityID,								CAST( GETDATE() AS Date ),
						@CurrentUserName,						CAST( GETDATE() AS Time ),					@DeceasedCode,
						@DeathDate,								Trim(@DeathCountryCode),					Trim(@DeathZipCode), 
						Trim(@DeathCity),						Trim(@NationalityCode);

					SET @l_ImportID = 0;
					SET @l_ImportID = @@Identity;

          /*DV-1592: insert Inkasso sync record*/
          if @l_InkassoSyncInsertOn = 1
          begin
            exec IFC.GenerateSendInkassoSyncData @syncType = 'Person', 
                                                 @syncEventType = 'insert', 
                                                 @entityID = @l_EntityID, 
                                                 @ID = null, 
                                                 @dataChangedUserName = @CurrentUserName,
                                                 @correlationID = @p_correlationID,
                                                 @moduleInstanceID = @p_moduleInstanceIDInkasso output,
                                                 @isBatch = 1
          end

					SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
					IF Isnull(@ErrorMessage,'') = ''
						Set @ErrorMessage = NULL;
					UPDATE IFC.Person SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', Errormessage = @ErrorMessage, CrefoId = @l_EntityID,
						LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName	WHERE ID = @ID;

        COMMIT /*Nem létező Person*/
			END;
    END /* @l_ErrorMessage = NULL */

  END TRY /*Belső-1*/
	BEGIN CATCH /*Belső-1*/
    if @@TRANCOUNT > 0
       rollback

    SELECT @ErrorMessage = ERROR_MESSAGE(), @ErrorSeverity = ERROR_SEVERITY(), @ErrorState = ERROR_STATE(), @ErrorLine = ERROR_LINE();
    SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
    UPDATE IFC.Person SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage,
		LastModifiedDate = CAST( GETDATE() AS Date ), LastModifiedTime = CAST( GETDATE() AS Time ), LastModifiedUserName = @CurrentUserName	WHERE ID = @ID;
	END CATCH /*Belső-1*/

			FETCH NEXT FROM db_cursor INTO 
				@ID, @SourceInterfaceType, @SourceID, @RegistrationNr, @TaxNr, @StatisticalNr, @Title, @LastName, @MiddleName, @FirstName, @FullName, @NationalityName, @NationalityCode,
				@BirthCountryName, @BirthCountryCode, @BirthPlace, @BirthDate, @MaidenLastName, @MaidenFirstName, @MothersLastName, @MothersFirstName, @PhoneNr, @FaxNr, @EMail, @Web, @IdentityCardNr, @PensionerNr,
				@Field1, @Field2, @Field3, @Field4, @Field5, @PersonID, @InterfaceStatusCode, /*@ErrorMessage,*/ @ActualisationDate, @InterfaceTableID, @GenderName, @GenderCode,
				@DeceasedCode, @CountryName, @CountryCode, @OrganizationUnitCode, @OrganizationUnitID, @FathersName, @DeathDate, @DeathCountryName, @DeathCountryCode, @DeathZipCode, @DeathCity, @PortfolioID, @PortfolioName
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    --COMMIT TRANSACTION; /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592)*/

    END TRY


    BEGIN CATCH

        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.PersonLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;				-- LogMessage

        --RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );
        --ROLLBACK TRANSACTION; /*a tranzakciókezelés áttéve rekordonkénti szintre, hogy ne fogja meg a táblákat az egész import idejére (DV-1592), de ennek eredetileg is fentebb kellett volna lennie, hogy a logolás ne rollbackelődjön*/

        SELECT @ErrorMessage;

    END CATCH;

------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	SET @LogMessage = @LogMessage + 'PersonLoader Ended at ' + Cast(CAST( GETDATE() AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.PersonLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ExistingRowsCount: ' + CAST(@l_ExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ @LogMessage



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.PersonLoader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage

	If Isnull(@ErrorMessage,'') <> ''
		Return 99;
	else
		Return 1;

END;
go

/*Author:		Gyenese Katalin
  Create date: 2023.10.31. - DV-1524
  Last modified date:  2023.10.31.
  Description:	This function expects a phonenumber and it tries to separate the prefix and the rest of the phonenumber
                At the moment it only searches for +36
*/
CREATE   function GEN.PhoneNumberSeparate(@p_phoneNumber NVarChar(200))
returns @table table(prefix NVarChar(10)        /*prefix*/,
                     phoneNumber NVarChar(100)  /*rest of the phonenumber*/
                    )
as
begin 
  declare @areaCode NVarChar(10), 
          @areaCodeFinal NVarChar(10), @phoneNumberFinal NVarChar(100)
  
  set @areaCode = '+36'
  if Left(@p_phoneNumber, 3) = @areaCode
  begin
    select @areaCodeFinal = @areaCode, 
           @phoneNumberFinal = RIGHT(@p_phoneNumber, Len(@p_phoneNumber)-Len(@areaCode))
  end
  else
  begin
    select @phoneNumberFinal = @p_phoneNumber
  end


  insert into @table(prefix /*prefix*/, phoneNumber /*rest of the phonenumber*/)
    select @areaCodeFinal, @phoneNumberFinal

  return
end
go

CREATE   PROCEDURE [IFC].[PreparationLoader](@p_correlationID NVARCHAR(200), @p_moduleInstanceID NUMERIC(16))
/*
==========================================================================================
Author:				Tóth Gábor
 Creation date:			2022.11.08.
 Last modified date:	2022.11.09. @p_moduleInstanceID, Átnevezés
						2023.10.27. InterfaceStatusCode = 'InterfaceStatus_NEW' --> InterfaceStatusCode in ('INTERFACE_STATUS_NEW', 'INTERFACE_STATUS_FIXED')
========================================================================================== 
*/

AS

BEGIN
	SET NOCOUNT ON;

	DECLARE @LogMessage NVARCHAR(MAX);
	DECLARE @CRLF NVARCHAR(20);
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor váratlan hibák esetén annak kezelése, hogy a cursor mindig be legyen zárva és szüntetve
	Declare @CurrentUserID numeric(18);
	Declare @CurrentUser nvarchar(50);
	

	Set @CurrentUser = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));

	Set @CurrentUserID = 0;
	If exists (select 1 from PRT.AppUser where UserName = @CurrentUser)
		Set @CurrentUserID = (select Top 1 ID from PRT.AppUser where UserName = @CurrentUser order by ID);
	ELSE
		Set @ErrorMessage = 'Current user id not defined (' + @CurrentUser + ')';


		--Naplóbejegyzés a kezdésről (kötelező)
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			'IFC.PreparationLoader',    -- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			'START';				    -- LogMessage


		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			'IFC.PreparationLoader',    -- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			'Checing parameters... ';				    -- LogMessage


	SET @CRLF = CHAR(10)+CHAR(13);


		IF COALESCE(@p_moduleInstanceID, 0) > 0
		BEGIN
			SELECT 
				@l_sourceInterfaceType = ModuleInstanceParameter.ParameterValue 
			FROM ORG.ModuleInstanceParameter
			WHERE ModuleInstanceParameter.ModuleInstanceID = @p_moduleInstanceID
			AND ModuleInstanceParameter.ParameterCode = 'SOURCE_INTERFACE_TYPE';
		END

		IF COALESCE(@l_sourceInterfaceType, '') = '' 
			RAISERROR('The SourceInterfaceType field is not defined!', 16, 1);


		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			'IFC.PreparationLoader',    -- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			'Processing...';				    -- LogMessage

    IF @l_SourceInterfaceType <> 'DEMO'
	BEGIN

	BEGIN TRANSACTION

    BEGIN TRY
        SET @LogMessage = 'IFC.PreparationLoader Started at ' + Cast(CAST( GETDATE () AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
		
		Declare @ID NUMERIC(16);
		Declare @SequenceNr  numeric(16);
		Declare @DebtorName  nvarchar(250);
		Declare @AccountNr  nvarchar(200);
		Declare @GrossValue  money;
		Declare @CurrencyCode  nvarchar(200);
		Declare @DebtCapital  money;
		Declare @DebtTotal  money;
		Declare @DebtInterest  money;
		Declare @DebtPenaltyInterest  money;
		Declare @DebtCost  money;
		Declare @DebtCostLocalCurrency  money;
		Declare @ProductName  nvarchar(200);
		Declare @ContractNr  nvarchar(200);
		Declare @ContractDate  date;
		Declare @TerminationDate  date;
		Declare @DecisionNr  nvarchar(200);
		Declare @FinancialMilestoneDate  date;
		Declare @SourceInterfaceType  nvarchar(200);
		Declare @InterfaceStatusCode  nvarchar(200);
		--Declare @ErrorMessage  nvarchar(200);
		Declare @CreationDate  date;
		Declare @CreationTime  time;
		Declare @CreationUserName  nvarchar(200);
		Declare @LastModifiedDate  date;
		Declare @LastModifiedTime  time;
		Declare @LastModifiedUserName  numeric(16);

		Declare @l_ObjectID numeric(18);
		Declare @l_ContractID numeric(18);
		Declare @l_ContractItemID numeric(18);
		Declare @l_ProductID numeric(18);
		Declare @l_CurrencyID nvarchar(100);
		
		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ExisingRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);


		SET @l_AllRowCounts = 0;
		SET @l_ImportedRowCounts = 0;
		SET @l_ExisingRowCounts = 0;
		SET @l_ErrorRowCounts = 0;


		SET @l_AllRowCounts = (Select Count(*) FROM IFC.ContractPreparationItem where InterfaceStatusCode in ('INTERFACE_STATUS_NEW', 'INTERFACE_STATUS_FIXED') and SourceInterfaceType = @l_SourceInterfaceType);

		DECLARE db_cursor CURSOR FOR 
		SELECT ID, SequenceNr, DebtorName, AccountNr, GrossValue, CurrencyCode, DebtCapital, DebtTotal, DebtInterest, DebtPenaltyInterest, DebtCost, DebtCostLocalCurrency, 
			ProductName, ContractNr, ContractDate, TerminationDate, DecisionNr, FinancialMilestoneDate, SourceInterfaceType, InterfaceStatusCode, ErrorMessage, CreationDate, CreationTime, 
			CreationUserName, LastModifiedDate, LastModifiedTime, LastModifiedUserName 
		FROM IFC.ContractPreparationItem
		where InterfaceStatusCode in ('INTERFACE_STATUS_NEW', 'INTERFACE_STATUS_FIXED') and SourceInterfaceType = @l_SourceInterfaceType Order by Id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID, @SequenceNr, @DebtorName, @AccountNr, @GrossValue, @CurrencyCode, @DebtCapital, @DebtTotal, @DebtInterest, @DebtPenaltyInterest, @DebtCost, @DebtCostLocalCurrency, 
			@ProductName, @ContractNr, @ContractDate, @TerminationDate, @DecisionNr, @FinancialMilestoneDate, @SourceInterfaceType, @InterfaceStatusCode, @ErrorMessage, @CreationDate, @CreationTime, 
			@CreationUserName, @LastModifiedDate, @LastModifiedTime, @LastModifiedUserName 

		WHILE @@FETCH_STATUS = 0  
		BEGIN  

---------------------------------------------------------------------------------------------------------------------------------------------
-- Error Section:
		SET @ErrorMessage = NULL;

		If Trim(Isnull(@SourceInterfaceType,''))  = ''
		BEGIN
			SET @ErrorMessage = 'SourceInterfaceType is Empty';
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
		END;

		If Trim(Isnull(@ContractNr,''))  = ''
		BEGIN
			SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' ContractNr is Empty');
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
		END;

		If Trim(Isnull(@CurrencyCode,'')) <> '' 
		and Not exists (Select 1 from GEN.Code where ID LIKE 'CURRENCY_%' + Trim(Isnull(@CurrencyCode,'')))
		BEGIN
			SET @ErrorMessage = Trim(Isnull(@ErrorMessage,'') + ' CurrencyCode is not identified');
			SET @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
		END;

		IF @ErrorMessage is not NULL
		BEGIN
			UPDATE IFC.ContractPreparationItem SET InterfaceStatusCode = 'InterfaceStatus_Error', ErrorMessage = @ErrorMessage WHERE ID = @ID;
		END;
--------------------------------------------------------------------------------------------------------------------------------------

		IF @ErrorMessage is NULL
		BEGIN

		Set @ErrorMessage  = @ErrorMessage ;
		Set @l_ProductID = (Select TOP 1 ID from FIN.Product where Description =  @ProductName order by ID Desc);

		Set @l_CurrencyID = (Select 1 from GEN.Code where ID LIKE 'CURRENCY_%' + Trim(Isnull(@CurrencyCode,'')));
------------------------------------------------------------------
-- Contract:
	INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName)
						SELECT 'CRM.Contract' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserID;
					SET @l_ObjectID = @@Identity;

	Insert Into CRM.Contract(
		ObjectID,													SellerName, 
		SellerPartyID,												BuyerName, 
		BuyerPartyID,												ReferencedContractID, 
		ContractTypeCode,											ContractPhaseCode, 
		StatusCode,													ContractNr, 
		RegistrationNr,												ExternalContractNr, 
		ValidFrom,													ValidUntil, 
		CreationDate,												CreationTime, 
		CreationUserName,												DecisionNr, 
		ContractDate)
	Select 
		@l_ObjectID as ObjectID,									NULL as SellerName, 
		NULL as SellerPartyID,										NULL as BuyerName, 
		NULL as BuyerPartyID,										NULL as ReferencedContractID, 
		NULL as ContractTypeCode,									NULL as ContractPhaseCode, 
		NULL as StatusCode,											@ContractNr as ContractNr, 
		NULL as RegistrationNr,										NULL as ExternalContractNr, 
		NULL as ValidFrom,											NULL as ValidUntil, 
		CAST( GETDATE () AS Date ),									CAST( GETDATE () AS Time ),
		@CurrentUserID,												NULL as DecisionNr, 
		NULL as ContractDate;

	Set @l_ContractID = @@Identity;

------------------------------------------------------------------
-- ContractItem:
	INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName)
						SELECT 'CRM.ContractItem' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserID;
					SET @l_ObjectID = @@Identity;

	Insert Into CRM.ContractItem(
		ObjectID,													ContractID, 
		ReferencedContractItemID,									SequenceNr, 
		ReferenceNr,												NetValue, 
		VATValue,													GrossValue, 
		CurrencyID,													ProductID, 
		Description,												Status, 
		CreationDate,												CreationTime, 
		CreationUserName)
	Select
		@l_ObjectID as ObjectID,									@l_ContractID as ContractID, 
		null as ReferencedContractItemID,							@SequenceNr as SequenceNr, 
		null as ReferenceNr,										null as NetValue, 
		null as VATValue,											@GrossValue as GrossValue, 
		@CurrencyCode as CurrencyID,								@l_ProductID as ProductID, 
		null as Description,										null as Status, 
		CAST( GETDATE () AS Date ),									CAST( GETDATE () AS Time ),
		@CurrentUserID;

	Set @l_ContractItemID = @@Identity;

------------------------------------------------------------------
-- CollectionContractItem:
	INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName)
						SELECT 'CRM.CollectionContractItem' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserID;
					SET @l_ObjectID = @@Identity;

	Insert into CRM.CollectionContractItem(
		ObjectID,													ContractItemID, 
		DebtCaseID,													DebtCapital, 
		DebtInterest,												DebtCost, 
		DebtCostLocalCurrency,										DebtTotal, 
		ConstructionCode,											DebtorName, 
		PricingMethodID,											BusinessPercent, 
		BusinessPrice,												ContractNr, 
		DecisionNr,													AccountNr, 
		ContractDate,												TerminationDate, 
		FinancialMilestoneDate,										CreationDate, 
		CreationTime,												CreationUserName, 
		CurrencyCode,												DebtPenaltyInterest, 
		LegalActionCode,											SourceInterfaceType, 
		SourceID,													DaysPastDue)
	Select
		@l_ObjectID,												@l_ContractItemID as ContractItemID, 
		null as DebtCaseID,											@DebtCapital, 
		@DebtInterest,												@DebtCost, 
		null as DebtCostLocalCurrency,								null as DebtTotal, 
		null as ConstructionCode,									@DebtorName, 
		null as PricingMethodID,									null as BusinessPercent, 
		null as BusinessPrice,										@ContractNr, 
		@DecisionNr,												@AccountNr, 
		@ContractDate,												@TerminationDate, 
		@FinancialMilestoneDate,									CAST( GETDATE() AS Date ), 
		CAST( GETDATE() AS Time ),									@CurrentUserID,
		null as CurrencyCode,										null as DebtPenaltyInterest, 
		null as LegalActionCode,									null as SourceInterfaceType, 
		null as SourceID,											null as DaysPastDue;


------------------------------------------------------------------
-- ContractItem:
		Insert Into CRM.ContractItem (
			ObjectID, 
			ContractID, 
			ReferencedContractItemID, 
			SequenceNr, 
			ReferenceNr, 
			NetValue, 
			VATValue, 
			GrossValue, 
			CurrencyID, 
			ProductID, 
			Description, 
			Status, 
			CreationDate, 
			CreationTime, 
			CreationUserName)

		Select 
			@l_ObjectID as ObjectID, 
			NULL as ContractID, 
			NULL as ReferencedContractItemID, 
			NULL as SequenceNr, 
			NULL as ReferenceNr, 
			NULL as NetValue, 
			NULL as VATValue, 
			@GrossValue as GrossValue, 
			@l_CurrencyID as CurrencyID, 
			@l_ProductID as ProductID, 
			NULL as Description, 
			NULL as Status, 
			CAST( GETDATE () AS Date ),	
			CAST( GETDATE () AS Time ),
			@CurrentUserID


-- CollectionContractItem:
		Insert Into CRM.CollectionContractItem (
			ObjectID, 
			ContractItemID, 
			DebtCaseID, 
			DebtCapital, 
			DebtInterest, 
			DebtCost, 
			DebtCostLocalCurrency, 
			DebtTotal, 
			ConstructionCode, 
			DebtorName, 
			PricingMethodID, 
			BusinessPercent, 
			BusinessPrice, 
			ContractNr, 
			DecisionNr, 
			AccountNr, 
			ContractDate, 
			TerminationDate, 
			FinancialMilestoneDate, 
			CreationDate, 
			CreationTime, 
			CreationUserName, 
			CurrencyCode, 
			DebtPenaltyInterest, 
			LegalActionCode, 
			SourceInterfaceType, 
			SourceID, 
			DaysPastDue)

		Select 
			@l_ObjectID as ObjectID, 
			NULL as ContractItemID, 
			NULL as DebtCaseID, 
			@DebtCapital as DebtCapital, 
			@DebtInterest as DebtInterest, 
			@DebtCost as DebtCost, 
			@l_CurrencyID as DebtCostLocalCurrency, 
			@DebtTotal as DebtTotal, 
			NULL as ConstructionCode, 
			NULL as DebtorName, 
			NULL as PricingMethodID, 
			NULL as BusinessPercent, 
			NULL as BusinessPrice, 
			NULL as ContractNr, 
			NULL as DecisionNr, 
			NULL as AccountNr, 
			NULL as ContractDate, 
			NULL as TerminationDate, 
			NULL as FinancialMilestoneDate, 
			CAST( GETDATE () AS Date ),	
			CAST( GETDATE () AS Time ),
			@CurrentUserID,
			@l_CurrencyID as CurrencyCode, 
			@DebtPenaltyInterest as DebtPenaltyInterest, 
			NUll as LegalActionCode, 
			@SourceInterfaceType, 
			NULL as SourceID, 
			NULL as DaysPastDue;


------------------------------------------------------------------

		END;  /*@ErrorMessage = NULL*/
			



			FETCH NEXT FROM db_cursor INTO @ID, @SequenceNr, @DebtorName, @AccountNr, @GrossValue, @CurrencyCode, @DebtCapital, @DebtTotal, @DebtInterest, @DebtPenaltyInterest, @DebtCost, @DebtCostLocalCurrency, 
			@ProductName, @ContractNr, @ContractDate, @TerminationDate, @DecisionNr, @FinancialMilestoneDate, @SourceInterfaceType, @InterfaceStatusCode, @ErrorMessage, @CreationDate, @CreationTime, 
			@CreationUserName, @LastModifiedDate, @LastModifiedTime, @LastModifiedUserName 
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    COMMIT TRANSACTION;

    END TRY


    BEGIN CATCH
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'tenderItem_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE db_cursor;

			DEALLOCATE db_cursor;
		END

        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'TA Loader',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.PreparationLoader',	-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;				-- LogMessage

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        ROLLBACK TRANSACTION;

        SELECT @ErrorMessage;

    END CATCH;

	END -- 'DEMO'
------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	
	SET @LogMessage = @LogMessage + 'IFC.PreparationLoader Ended at ' + Cast(CAST( GETDATE () AS DateTime ) as NVARCHAR(20)) + 	@CRLF;
	
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE () AS Date ),	-- LogDate,	
		CAST( GETDATE () AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',			    -- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.PreparationLoader',	-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ExistingRowsCount: ' + CAST(@l_ExisingRowCounts as NVARCHAR(18)) + @CRLF
		+ 'ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) + @CRLF + @CRLF
		+ @LogMessage


	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE () AS Date ),	-- LogDate,	
		CAST( GETDATE () AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',			    -- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.PreparationLoader',	-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If @ErrorMessage is not null
		Return 99;
	else
		Return 1;


END;



/*
Delete PRT.Contact WHERE entityid in (
Select ID from prt.entity where sourceinterfacetype = 'elso');

delete prt.EntityIdentifier where entityid in (
Select ID from prt.entity where sourceinterfacetype = 'elso');

delete prt.entity where sourceinterfacetype = 'elso';


update IFC.ContractPreparationItem set interfacestatus = 'N';
go

CLOSE db_cursor;
DEALLOCATE db_cursor;


Declare @hiba NVARCHAR(200);
exec @hiba = IFC.PreparationLoader 1, 'elso', 2;
Select @hiba;

select interfacestatus,errormessage,* from IFC.ContractPreparationItem 

where isnull(contact,'') <> ''
select * from PRT.Contact where Creationdate = '2022-10-30' order by id desc


select * from LOG.LOG order by id desc

delete prt.contact
--select contact.* 
from prt.entity
join prt.contact on contact.entityid = Entity.ID
where entity.sourceinterfacetype = 'elso'

select * from IFC.ContractPreparationItem where id = 4377

*/

go

/*Author: Gyenese Katalin
  Create date: 2023.11.15. - DV-1749
  Description: it is used to refresh debtcase / insert event data to IFC and after that to prod tables in the Inkasso --> Indecs synchronization

  Parameters:
    - @taskID: the taskID to be processed
    - @correlationID: the correlationID of the caller
    - @errorMessage: the errorMessage if something went wrong (the backend needed it this way)
*/
CREATE   procedure [IFC].[ProcessReceiveInkassoSyncData](@taskID Numeric(16), @correlationID NVarChar(200), @errorMessage NVarChar(max) = null output)
as
begin
  set NOCOUNT ON
  set XACT_ABORT ON

  
  /*variables for logging*/
	declare @errormsg NVarChar(max),	@logMessage nvarchar(max), @procedureName nvarchar(100) = 'IFC.ProcessReceiveInkassoSyncData',
          @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @log_userName NVarChar(200)

  /*variables for the procedure logic*/
  declare @username NVarChar(200), @moduleCode NVarChar(200) = 'MODULE_INKASSO_INDECS_SYNC', @indecsInkassoSyncID Numeric(16), @json NVarChar(max), @webserviceName NVarChar(250), @syncDirectionCode NVarChar(200), 
          @taskTypeCode NVarChar(200), @taskTypeCodeDebtCase NVarChar(200) = 'TASK_TYPE_DATA_SYNC_DEBT_CASE_IND', @taskTypeCodeEvent NVarChar(200) = 'TASK_TYPE_DATA_SYNC_EVENT_IND',
          @InterfaceStatusCodeNew NVarChar(200) = 'INTERFACE_STATUS_NEW', @InterfaceStatusCodeError NVarChar(200) = 'INTERFACE_STATUS_ERROR', @InterfaceStatusCodeProcessed NVarChar(200) = 'INTERFACE_STATUS_PROCESSED', 

          /*debtcase*/
          @debtCaseID Numeric(16), @debtCaseIDProdTable Numeric(16), @debtCaseCurrencyProdTable NVarChar(200), @mainCalculationID Numeric(16), @feeListID Numeric(16), @urbisAccountNumber NVarChar(24), @debtCalcDate Date, @localCurrency NVarChar(200) = 'CURRENCY_HUF',
          @debtSumTotal Money, @debtInkCurrencyCode NVarChar(200), @debtCurrencyCode NVarChar(200), @debtCostLocalCurrency Money, @debtTotalLocalCurrency Money,
          @interestSetValidFrom Date, @normalInterestRate Numeric(16, 4), @penaltyInterestRate Numeric(16, 4),
          @costInterestRate Numeric(16, 4), @dailyCostMin Numeric(16, 4), @dailyCostMax Numeric(16, 4),
          @accountTypeCode NVarChar(200), @InkDebtTypeCode NVarChar(200), @accountType NVarChar(200), @amount Money, @amountDebtCaseCurrency Money, @amountLocalCurrency Money, @InkCurrencyCode NVarChar(200), @currencyCode NVarChar(200), @InkCreationDateTime DateTime,
          @accountingDate Date, @InkTransactionTypeCode NVarchar(200), @InkTransactionTypeCodeCredit NVarChar(200) = 'J', @InkTransactionTypeCodeTechnicalRecord NVarChar(200) = 'X', @transactionType NVarChar(200), @InkPretenseCode NVarChar(200), 
          @pretenseCode NVarChar(200), @InkCreditTypeCode NVarChar(200), @creditTypeCode NVarChar(200), @InkSectionName NVarChar(200), @sectionCode NVarChar(200), @InkPhaseName NVarChar(200), @phaseCode NVarChar(200), 
          @transactionID Numeric(16), @transactionObjectID Numeric(16), @flexibleFormID Numeric(16), @partyBankAccountNumber NVarChar(50), @partyName NVarChar(250),
          @defaultLanguageCode NVarchar(2) = 'HU', @now DateTime = GetDate(), @today Date = GetDate(), @EntityIDStr NVarChar(50), @EntityName NVarChar(200),

          /*Event*/
          @InkEventID Numeric(16), @EntityID Numeric(16), @InkEventTypeID Numeric(16), @eventTypeCode NVarChar(200), @InkDebtCaseID Numeric(16), @InkEntityID NVarChar(200), @InkAssetID Numeric(16), @InkAddressID Numeric(16), @InkCreationUser NVarChar(200), 
          @Comments NVarchar(max), @RelatedObjectID Numeric(16), @relatedObjectsReceivedCount int, @EventID Numeric(16) /*+ @InkCreationDateTime*/

  begin try 

    select @log_userName = m.TechnicalUserName
    from ORG.Module m
    where m.ModuleCode = @moduleCode

    select @username = IsNull(@log_userName, 'admin')

    /*Logging procedure start*/
    set @logMessage = Concat('Start procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @log_userName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    /*Logging parameter check*/
    set @logMessage = 'Checking parameters...'
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @log_userName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    if @taskID is null
       raiserror('The @taskID parameter is compulsory.', 16, 1)

    select @IndecsInkassoSyncID = s.ID, @syncDirectionCode = s.SyncDirectionCode, @json = s.Content, @webserviceName = s.WebserviceName, @taskTypeCode = t.TaskTypeID
    from IFC.IndecsInkassoSync s join ORG.Task t on s.TaskID = t.ID
    where s.TaskID = @taskID


    if @IndecsInkassoSyncID is null
    begin
      set @errorMessage = Concat('IFC.IndecsInkassoSync record with TaskID =  ', @taskID, ' does not exist.') 
      raiserror(@errorMessage, 16, 1)
    end

    if IsNull(@syncDirectionCode, '') <> 'SYNC_DIRECTION_INDECS'
    begin
      set @errorMessage = Concat('IFC.IndecsInkassoSync record with TaskID =  ', @taskID, ' has wrong SyncDirectionCode (actual: ', @syncDirectionCode, ', accepted: SYNC_DIRECTION_INDECS).') 
      raiserror(@errorMessage, 16, 1)
    end 
    
    if IsNull(@json, '') = ''
    begin
      set @errorMessage = Concat('The Content of the IFC.IndecsInkassoSync record with TaskID =  ', @taskID, ' is empty.') 
      raiserror(@errorMessage, 16, 1)
    end

    if IsJson(@json) = 0
    begin
      set @errorMessage = Concat('The Content of the IFC.IndecsInkassoSync record with TaskID =  ', @taskID, ' contains an invalid JSON (json: ', @json, ').') 
      raiserror(@errorMessage, 16, 1)
    end

    if IsNull(@taskTypeCode, '') not in(@taskTypeCodeDebtCase, @taskTypeCodeEvent) 
    begin
      set @errorMessage = Concat('The task with TaskID =  ', @taskID, ' has wrong tasktype (actual: ', @taskTypeCode, ', accepted: TASK_TYPE_DATA_SYNC_DEBT_CASE_IND / TASK_TYPE_DATA_SYNC_EVENT_IND).') 
      raiserror(@errorMessage, 16, 1)
    end 


    /*Logging start processing*/
    set @logMessage = 'Processing...'
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @log_userName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    
    /*DebtCase*/
    if @taskTypeCode = @taskTypeCodeDebtCase
    begin
      /*it was not inserted earlier to the IFC.InkassoSyncReceive... tables --> we do the insert*/ 
      if not exists(select *
                    from IFC.InkassoSyncReceiveDebtCase d
                    where d.IndecsInkassoSyncID = @IndecsInkassoSyncID
                   )
      begin
        begin tran
          /*InkassoSyncReceiveDebtCase*/
          

          insert into IFC.InkassoSyncReceiveDebtCase(IndecsInkassoSyncID, DebtCaseID, DebtCalcDate, DebtSumTotal, InkCurrencyCode, DebtCostLocalCurrency, DebtTotalLocalCurrency, CreditTypeCode, 
                                                     DealType, BankProduct, ConcessionDate, UrbisAccountNumber, GDPRDepersonalizationDateTime, SectionName, PhaseName, ActiveAgreement, OperatorUserName, OfficeID,
                                                     InterestSetValidFrom, NormalInterestRate, PenaltyInterestRate, CostInterestRate, DailyCostMin, DailyCostMax, 
                                                     InterfaceStatusCode, CreationDate, CreationTime, CreationUserName
                                                    )
            select @IndecsInkassoSyncID, d.dealId DebtCaseID, 
                   GEN.GetDateTimeFromUTC(d.balance_valueDateString, default) DebtCalcDate, d.balance_dealTotalDebt_amountInBase DebtSumTotal, d.balance_dealTotalDebt_baseCurrency InkCurrencyCode,
                   balance_otherAmountInHUF DebtCostLocalCurrency, balance_pastdueAmountInHUF DebtTotalLocalCurrency, d.dealData_dealBaseData_creditType CreditTypeCode, d.dealData_dealBaseData_dealType DealType, d.dealData_dealBaseData_bankProduct BankProduct,
                   GEN.GetDateTimeFromUTC(d.dealData_dealBaseData_grantDateString, default) ConcessionDate, d.dealData_dealBaseData_urbisAccno UrbisAccountNumber,
                   GEN.GetDateTimeFromUTC(d.dealData_dealBaseData_gdprdepersString, default) GDPRDepersonalizationDateTime, d.dealData_actualDealData_period SectionName, d.dealData_actualDealData_phase PhaseName,
                   d.dealData_actualDealData_activePTP ActiveAgreement, d.dealData_actualDealData_otpfclerk OperatorUserName, d.dealData_actualDealData_otpfbranch OfficeID, 
                   GEN.GetDateTimeFromUTC(d.interest_valueDateString, default) InterestSetValidFrom, d.interest_nominalInterestRate NormalInterestRate, d.interest_defaultInterestRate PenaltyInterestRate,
                   d.interest_adminFee_rate CostInterestRate, d.interest_adminFee_dailyMin DailyCostMin,  d.interest_adminFee_dailyMax DailyCostMax,
                   @InterfaceStatusCodeNew InterfaceStatusCode, GetDate() CreationDate, GetDate() CreationTime, @username CreationUserName
            from openjson(@json) 
            with  ( dealId NVarChar(200) '$.dealId',
			              balance_valueDateString NVarChar(200) '$.balance.valueDate',
                    balance_dealTotalDebt_amountInBase money '$.balance.dealTotalDebt.amountInBase',
                    balance_dealTotalDebt_baseCurrency NVarChar(200) '$.balance.dealTotalDebt.baseCurrency',
                    balance_otherAmountInHUF money '$.balance.dealTotalDebt.otherAmountInHUF',
                    balance_pastdueAmountInHUF money '$.balance.pastdueAmountInHUF',
                    dealData_dealBaseData_creditType NVarChar(200) '$.dealData.dealBaseData.creditType',
                    dealData_dealBaseData_dealType NVarChar(200) '$.dealData.dealBaseData.dealType',
                    dealData_dealBaseData_bankProduct NVarChar(200) '$.dealData.dealBaseData.bankProduct',
                    dealData_dealBaseData_grantDateString NVarChar(200) '$.dealData.dealBaseData.grantDate',
                    dealData_dealBaseData_urbisAccno NVarChar(24) '$.dealData.dealBaseData.urbisAccno',
                    dealData_dealBaseData_gdprdepersString NVarChar(200) '$.dealData.dealBaseData.gdprdepers',
                    dealData_actualDealData_period NVarChar(200) '$.dealData.actualDealData.period',
                    dealData_actualDealData_phase NVarChar(200) '$.dealData.actualDealData.phase',
                    dealData_actualDealData_activePTP NVarChar(200) '$.dealData.actualDealData.activePTP',
                    dealData_actualDealData_otpfclerk NVarChar(200) '$.dealData.actualDealData.otpfclerk',
                    dealData_actualDealData_otpfbranch NVarChar(200) '$.dealData.actualDealData.otpfbranch',
                    interest_valueDateString NVarChar(200) '$.interest.valueDate',
                    interest_nominalInterestRate Numeric(16,4) '$.interest.nominalInterestRate',
                    interest_defaultInterestRate Numeric(16,4) '$.interest.defaultInterestRate',
                    interest_adminFee_rate Numeric(16,4) '$.interest.adminFee.rate',
                    interest_adminFee_dailyMin Numeric(16,4) '$.interest.adminFee.dailyMin',
                    interest_adminFee_dailyMax Numeric(16,4) '$.interest.adminFee.dailyMax'
                  ) d
  
  
          insert into IFC.InkassoSyncReceiveDebt(IndecsInkassoSyncID, InkDebtTypeCode, DebtTotal, InkDebtCurrencyCode, InterfaceStatusCode, CreationDate, CreationTime, CreationUserName)
            select @IndecsInkassoSyncID, penaldeal.penaldealType InkDebtTypeCode, penaldeal.amount DebtTotal, penaldeal.currency InkDebtCurrencyCode, 
                   @InterfaceStatusCodeNew InterfaceStatusCode, GetDate() CreationDate, GetDate() CreationTime, @username CreationUserName
            from openjson(@json) 
            with (balance_penaldeals NVarChar(max) '$.balance.penaldeal' as json) basedata
                  cross apply openjson(basedata.balance_penaldeals)
                              with (penaldealType NVarChar(200) '$.penaldealType',
                                    amount money '$.amount',
                                    currency NVarChar(200) '$.currency'
                                   ) penaldeal



          insert into IFC.InkassoSyncReceiveTransaction(IndecsInkassoSyncID, InkTransactionID, InkEntityID, AccountingDate, InkCreationDateTime, InkTransactionTypeCode, InkPretenseCode, 
                                                        Amount, InkCurrencyCode, AmountDebtCaseCurrency, AmountLocalCurrency, PartyBankAccountNumber, PartyName, 
                                                        InterfaceStatusCode, CreationDate, CreationTime, CreationUserName
                                                       )
            select @IndecsInkassoSyncID, cashFlow.cashFlowId InkTransactionID, cashflow.actorId InkEntityID, 
                   GEN.GetDateTimeFromUTC(cashflow.valueDateString, default) AccountingDate, 
                   GEN.GetDateTimeFromUTC(cashflow.registryDateString, default) InkCreationDateTime, 
                   cashflow.cashFlowDirection InkTransactionTypeCode, cashflow.cashFlowTitle InkPretenseCode, cashflow.money_amount Amount, cashflow.money_currency InkCurrencyCode, 
                   cashflow.amountInBase AmountDebtCaseCurrency, cashflow.amountInHUF AmountLocalCurrency, 
                   cashflow.counterpartyBankAccNum PartyBankAccountNumber, cashFlow.counterpartyName PartyName, 
                   @InterfaceStatusCodeNew InterfaceStatusCode, GetDate() CreationDate, GetDate() CreationTime, @username CreationUserName
            from openjson(@json) 
            with (cashFlows NVarChar(max) '$.cashFlow' as json) basedata
                  cross apply openjson(basedata.cashFlows)
                              with (cashFlowId Numeric(16) '$.cashFlowId',
                                    actorId NVarChar(50) '$.actorId',
                                    valueDateString NVarChar(200) '$.valueDate',
                                    registryDateString NVarChar(200) '$.registryDate',
                                    cashFlowDirection NVarChar(200) '$.cashFlowDirection',
                                    cashFlowTitle NVarChar(200) '$.cashFlowTitle',
                                    money_amount money '$.money.amount',
                                    money_currency NVarChar(200) '$.money.currency',
                                    amountInBase money '$.amountInBase',
                                    amountInHUF money '$.amountInHUF',
                                    counterpartyBankAccNum NVarChar(50) '$.counterpartyBankAccNum',
                                    counterpartyName NVarChar(250) '$.counterpartyName'
                                   ) cashFlow
        commit
      end


      /*IFC.InkassoSyncReceive... tables are already filled --> we insert/update the records in the prod tables*/
      if exists(select *
                from IFC.InkassoSyncReceiveDebtCase
                where IndecsInkassoSyncID = @IndecsInkassoSyncID
                  and InterfaceStatusCode <> @InterfaceStatusCodeProcessed /*either all receive table records are processed or all are new/failed*/
               )
      begin
        begin try
          
          select @debtCaseID = d.DebtCaseID, @debtCaseIDProdTable = dc.ID, @debtCaseCurrencyProdTable = dc.CurrencyCode, @mainCalculationID = dc.MainCalculationID, @feeListID = mc.FeeListID, @debtCalcDate = d.DebtCalcDate,
                 @debtSumTotal = d.DebtSumTotal, 
                 @debtInkCurrencyCode = d.InkCurrencyCode, 
                 @debtCurrencyCode = IFC.GetMappedValueInkasso(2 /*Inkasso --> Indecs*/, d.InkCurrencyCode, 'VALUESET_CURRENCY', null /*@date*/), 
                 @debtCostLocalCurrency = d.DebtCostLocalCurrency, @debtTotalLocalCurrency = d.DebtTotalLocalCurrency,
                 @interestSetValidFrom = d.InterestSetValidFrom, @normalInterestRate = d.NormalInterestRate, @penaltyInterestRate =d.PenaltyInterestRate,
                 @costInterestRate = d.CostInterestRate, @dailyCostMin = NullIf(d.DailyCostMin, 0) /*0 = null*/, @dailyCostMax = NullIf(d.DailyCostMax, 0) /*0 = null*/,
                 @urbisAccountNumber = d.UrbisAccountNumber, 
                 @InkCreditTypeCode = d.CreditTypeCode,
                 @creditTypeCode = IFC.GetMappedValueInkasso(2 /*Inkasso --> Indecs*/, d.CreditTypeCode, 'VALUESET_CREDIT_TYPE', null /*@date*/),
                 @InkSectionName = d.SectionName,
                 @InkPhaseName = d.PhaseName,
                 @RelatedObjectID = dc.ObjectID
          from IFC.InkassoSyncReceiveDebtCase d left join DCS.DebtCase dc on d.DebtCaseID = dc.ID
                                                left join FIN.Calculation mc on dc.MainCalculationID = mc.ID
          where d.IndecsInkassoSyncID = @IndecsInkassoSyncID

          if @debtCaseIDProdTable is null
          begin
            select @errorMessage = Concat('DebtcaseID ', @debtCaseID, ' does not exist in the Indecs database.')
            raiserror(@errorMessage, 16, 1)
          end

          if @mainCalculationID is null
             raiserror('The main calculation is missing in the Indecs database.', 16, 1)
          
          if @feeListID is null
             raiserror('The feelist of the main calculation is missing in the Indecs database.', 16, 1)
          
          /*mapping check*/
          if @InkCreditTypeCode is not null and @creditTypeCode is null
             raiserror ('Missing mapping for CreditTypeCode (Inkasso CreditTypeCode: %s, ValueSet: VALUESET_CREDIT_TYPE.)', 16, 1, @InkCreditTypeCode)

          if @InkCurrencyCode is not null and @currencyCode is null
             raiserror ('Missing mapping for CurrencyCode (Inkasso CurrencyCode: %s, ValueSet: VALUESET_CURRENCY.)', 16, 1, @InkCurrencyCode)
        
          if @debtCurrencyCode <> @debtCaseCurrencyProdTable
             raiserror ('The received currencyCode (%s) of the debtCase and its currencyCode in the Indecs database (%s) cannot differ.', 16, 1, @debtCurrencyCode, @debtCaseCurrencyProdTable)
        
          /*section and phase lookup by name (HU)*/
          if IsNull(@InkSectionName, '') <> ''
          begin
            select top 1 @sectionCode = c.ID
            from gen.ValueSet vs join gen.Code c on vs.ID = c.ValueSetID
            where vs.Code = 'VALUESET_CASE_SECTION'
              and IsNull(c.ValidFrom, @today) <= @today
              and @today <= IsNull(c.ValidUntil, @today)
              and exists(select *
                         from Gen.Translation tr
                         where tr.CodeID = c.ID
                          and tr.Language = @defaultLanguageCode
                          and tr.Text = @InkSectionName
                        )

            if @sectionCode is null
               raiserror ('Missing SectionCode (Inkasso SectionName: %s.)', 16, 1, @InkSectionName)
          end
          
          if IsNull(@InkPhaseName, '') <> ''
          begin
            select top 1 @phaseCode = c.ID
            from gen.ValueSet vs join gen.Code c on vs.ID = c.ValueSetID
            where vs.Code = 'VALUESET_CASE_PHASE'
              and IsNull(c.ValidFrom, @today) <= @today
              and @today <= IsNull(c.ValidUntil, @today)
              and exists(select *
                         from Gen.Translation tr
                         where tr.CodeID = c.ID
                          and tr.Language = @defaultLanguageCode
                          and tr.Text = @InkPhaseName
                        )

            if @sectionCode is null
               raiserror ('Missing PhaseCode (Inkasso PhaseName: %s.)', 16, 1, @InkPhaseName)
          end

          /*start deploying to prod tables*/           
          begin tran 
            /*1. DebtCase refresh (based on IFC.InkassoSyncReceiveDebtCase)*/
            update DCS.DebtCase
            set CreditTypeCode = @creditTypeCode,
                RepaymentBankAccountNr = @urbisAccountNumber,
                SectionCode = @sectionCode,
                PhaseID = @phaseCode,
                LastModifiedDate = GetDate(),
                LastModifiedTime = GetDate(),
                LastModifiedUserName = @username
            where DebtCase.id = @debtCaseID
              and (   IsNull(DebtCase.CreditTypeCode, '') <> IsNull(@creditTypeCode, '')
                   or IsNull(DebtCase.RepaymentBankAccountNr, '') <> IsNull(@urbisAccountNumber, '')
                   or IsNull(DebtCase.SectionCode, '') <> IsNull(@sectionCode, '')
                   or IsNull(DebtCase.PhaseID, '') <> IsNull(@phaseCode, '')
                  )
         
            /*2. MainCalculation refresh*/
            update FIN.Calculation
            set CalculationDate = @debtCalcDate,
                LastModifiedDate = GetDate(),
                LastModifiedTime = GetDate(),
                LastModifiedUserName = @username
            where ID = @mainCalculationID
              and (IsNull(CalculationDate, '1900-01-01') <> IsNull(@debtCalcDate, '1900-01-01')
                  )
        
            /*3. Fee refresh (based on IFC.InkassoSyncReceiveDebtCase)*/
            /*3.a. NormalInterestRate*/ 
            if @normalInterestRate is not null
               exec FIN.RefreshFee @feeListID = @feeListID, 
                                   @code = 'FEE_INTEREST', 
                                   @typeCode = 'FEE_TYPE_INTEREST_PERCENT', 
                                   @validDate = @interestSetValidFrom, 
                                   @feeRate = @normalInterestRate,  
                                   @periodTypeCode = null, 
                                   @periodMinimumValue = null, 
                                   @periodMaximumValue = null, 
                                   @currencyCode = @debtCaseCurrencyProdTable,
                                   @correlationID = @correlationID, 
                                   @username = @username
            
            /*3.b. PenaltyInterestRate*/
            if @penaltyInterestRate is not null
               exec FIN.RefreshFee @feeListID = @feeListID, 
                                   @code = 'FEE_PENALTY_INTEREST', 
                                   @typeCode = 'FEE_TYPE_INTEREST_PERCENT', 
                                   @validDate = @interestSetValidFrom, 
                                   @feeRate = @penaltyInterestRate,  
                                   @periodTypeCode = null, 
                                   @periodMinimumValue = null, 
                                   @periodMaximumValue = null, 
                                   @currencyCode = @debtCaseCurrencyProdTable,
                                   @correlationID = @correlationID, 
                                   @username = @username
            
            /*3.c. CostInterestRate*/ 
            if @costInterestRate is not null or @dailyCostMin is not null or @dailyCostMax is not null
               exec FIN.RefreshFee @feeListID = @feeListID, 
                                   @code = 'FEE_MANAGEMENT_FEE', 
                                   @typeCode = 'FEE_TYPE_INTEREST_PERCENT', 
                                   @validDate = @interestSetValidFrom, 
                                   @feeRate = @costInterestRate,  
                                   @periodTypeCode = 'PERIOD_TYPE_DAY', 
                                   @periodMinimumValue = @dailyCostMin, 
                                   @periodMaximumValue = @dailyCostMax, 
                                   @currencyCode = @debtCaseCurrencyProdTable,
                                   @correlationID = @correlationID, 
                                   @username = @username            



            /*4. balance (FIN.Account) refresh (based on IFC.InkassoSyncReceiveDebtCase fields + IFC.InkassoSyncReceiveDebt records)*/
            declare cur cursor local fast_forward for
              /*based on IFC.InkassoSyncReceiveDebtCase fields:*/
              select 'ACCOUNT_TYPE_DEBT_TOTAL' accountType, @debtCaseCurrencyProdTable currencyCode, @debtSumTotal DebtTotal, null InkDebtTypeCode, null InkDebtCurrencyCode
              union all
              select 'ACCOUNT_TYPE_DEBT_COST_OWN' accountType, @localCurrency currencyCode, @debtCostLocalCurrency DebtTotal, null InkDebtTypeCode, null InkDebtCurrencyCode
              union all
              select 'ACCOUNT_TYPE_DEBT_TOTAL_LOCAL_CURRENCY' accountType, @localCurrency currencyCode, @debtTotalLocalCurrency DebtTotal, null InkDebtTypeCode, null InkDebtCurrencyCode
              union all
              /*based on IFC.InkassoSyncReceiveDebt records:*/
              select sel.accountType, sel.currencyCode, Sum(sel.DebtTotal) DebtTotal, 
                      /*just in case we have missing mappings:*/ Min(sel.InkDebtTypeCode) InkDebtTypeCode, Min(sel.InkDebtCurrencyCode) InkDebtCurrencyCode 
              from (select debt.InkDebtTypeCode, 
                           IFC.GetMappedValueInkasso(2 /*Inkasso --> Indecs*/, debt.InkDebtTypeCode, 'VALUESET_ACCOUNT_TYPE', null /*@date*/)  accountType,
                           debt.DebtTotal, 
                           debt.InkDebtCurrencyCode, 
                           IFC.GetMappedValueInkasso(2 /*Inkasso --> Indecs*/, debt.InkDebtCurrencyCode, 'VALUESET_CURRENCY', null /*@date*/) currencyCode
                    from IFC.InkassoSyncReceiveDebt debt
                    where debt.IndecsInkassoSyncID = @IndecsInkassoSyncID
                      and debt.DebtTotal is not null
                  ) sel
              group by sel.accountType, sel.currencyCode /*EKK and ENC are the same Indecs accountType, SNC and SLC are the same Indecs accountType, so we need a group by here*/  


            open cur
            while 1 = 1
            begin
              fetch next from cur into @accountType, @currencyCode, @amount, @InkDebtTypeCode, @InkCurrencyCode
          
              if @@FETCH_STATUS <> 0
                  break
 
              /*mapping check*/
              if @accountType is null
                  select @errorMessage = Concat(@errorMessage, 'Missing mapping for Account type (Inkasso DebtTypeCode: ',  @InkDebtTypeCode, ', ValueSet: VALUESET_ACCOUNT_TYPE.) ')
        
              if @currencyCode is null
                  select @errorMessage = Concat(@errorMessage, 'Missing mapping for CurrencyCode (Inkasso CurrencyCode: ',  @InkCurrencyCode, ', ValueSet: VALUESET_CURRENCY.) ')
       
              if IsNull(@errorMessage, '') <> ''
              begin
                /*TODO: send notification*/
                raiserror(@errorMessage, 16, 1)
              end

              /*insert/refresh balance*/
              exec FIN.CreateAccount @p_calculationID = @mainCalculationID, 
                                     @p_accountTypeCode = @accountType, 
                                     @p_currencyCode = @currencyCode, 
                                     @p_amount = @amount, 
                                     @p_CorrelationID = @correlationID, 
                                     @p_UserName = @username
            end
        
            close cur
            deallocate cur


        
            /*5. cashflow refresh (FIN.Transaction (+FIN.Account))*/
            declare cur cursor local fast_forward for
                select  tr.AccountingDate,
                        tr.InkCreationDateTime,
                        tr.InkTransactionTypeCode,
                        Case when tr.InkTransactionTypeCode = @InkTransactionTypeCodeTechnicalRecord then
                                  Case when @Amount < 0 then 'TRANSACTION_TYPE_DEBIT' /*we only have 2 types, so this is the only solution :( */
                                       else 'TRANSACTION_TYPE_CREDIT'
                                  end
                             else IFC.GetMappedValueInkasso(2 /*Inkasso --> Indecs*/, tr.InkTransactionTypeCode, 'VALUESET_TRANSACTION_TYPE', null /*@date*/)
                        end transactionType,
                        tr.InkPretenseCode,
                        IFC.GetMappedValueInkasso(2 /*Inkasso --> Indecs*/, tr.InkPretenseCode, 'VALUESET_PRETENSE', null /*@date*/) pretenseCode,
                        tr.Amount,
                        tr.InkCurrencyCode,
                        IFC.GetMappedValueInkasso(2 /*Inkasso --> Indecs*/, tr.InkCurrencyCode, 'VALUESET_CURRENCY', null /*@date*/) currencyCode,
                        tr.AmountLocalCurrency,
                        tr.PartyBankAccountNumber, 
                        tr.PartyName,
                        tr.InkEntityID
                from IFC.InkassoSyncReceiveTransaction tr
                where tr.IndecsInkassoSyncID = @IndecsInkassoSyncID
                union all
                /*if the currency of the payment and the currency of the debtcase differs, we have to insert 2 transactions with the 2 different currencies (the AmountLocalCurrency will be the same)*/
                select  tr.AccountingDate,
                        tr.InkCreationDateTime,
                        tr.InkTransactionTypeCode,
                        Case when tr.InkTransactionTypeCode = @InkTransactionTypeCodeTechnicalRecord then
                                  Case when @Amount < 0 then 'TRANSACTION_TYPE_DEBIT' /*we only have 2 types, so this is the only solution :( */
                                        else 'TRANSACTION_TYPE_CREDIT'
                                  end
                              else IFC.GetMappedValueInkasso(2 /*Inkasso --> Indecs*/, tr.InkTransactionTypeCode, 'VALUESET_TRANSACTION_TYPE', null /*@date*/)
                        end transactionType,
                        tr.InkPretenseCode,
                        IFC.GetMappedValueInkasso(2 /*Inkasso --> Indecs*/, tr.InkPretenseCode, 'VALUESET_PRETENSE', null /*@date*/) pretenseCode,
                        tr.AmountDebtCaseCurrency,
                        @debtInkCurrencyCode InkCurrencyCode,
                        @debtCaseCurrencyProdTable currencyCode,
                        tr.AmountLocalCurrency,
                        tr.PartyBankAccountNumber, 
                        tr.PartyName,
                        tr.InkEntityID
                from IFC.InkassoSyncReceiveTransaction tr
                where tr.IndecsInkassoSyncID = @IndecsInkassoSyncID
                  and tr.InkCurrencyCode <> @debtInkCurrencyCode

            open cur
            while 1 = 1
            begin
              fetch next from cur into @accountingDate, @InkCreationDateTime, @InkTransactionTypeCode, @transactionType, @InkPretenseCode, @pretenseCode, @amount, @InkCurrencyCode, @currencyCode, 
                                       @amountLocalCurrency, @partyBankAccountNumber, @partyName, @InkEntityID
          
              if @@FETCH_STATUS <> 0
                  break
 
              /*mapping check*/
              if @transactionType is null
                 select @errorMessage = Concat(@errorMessage, 'Missing mapping for TransactionType (Inkasso TransactionType: ',  @InkTransactionTypeCode, ', ValueSet: VALUESET_TRANSACTION_TYPE.) ')

              if @pretenseCode is null
                  select @errorMessage = Concat(@errorMessage, 'Missing mapping for PretenseCode (Inkasso cashFlowTitle: ',  @InkPretenseCode, ', ValueSet: VALUESET_PRETENSE.) ')

              if @currencyCode is null
                  select @errorMessage = Concat(@errorMessage, 'Missing mapping for CurrencyCode (Inkasso CurrencyCode: ',  @InkCurrencyCode, ', ValueSet: VALUESET_CURRENCY.) ')
       
              if IsNull(@errorMessage, '') <> ''
              begin
                /*TODO: send notification*/
                raiserror(@errorMessage, 16, 1)
              end

      
              /*5.a. transaction insert*/  
              exec FIN.CreateTransaction @p_calculationID = @mainCalculationID, 
                                         @p_accountTypeCode = 'ACCOUNT_TYPE_CASE', 
                                         @p_currencyCode = @currencyCode, 
                                         @p_accountingDate = @accountingDate,
                                         @p_transactionTypeCode = @transactionType,
                                         @p_pretenseCode = @pretenseCode,
                                         @p_creationDate = @InkCreationDateTime, 
                                         @p_creationTime = @InkCreationDateTime,
                                         @p_amount = @amount,
                                         @p_amountLocalCurrency = @amountLocalCurrency,
                                         @p_CorrelationID = @correlationID, 
                                         @p_UserName = @username,
                                         @p_transactionID = @transactionID output

              /*5.b. store partyBankAccountNumber, partyName and entity data of the actor in flexible form*/     
              if IsNull(@partyBankAccountNumber, '') <> '' or IsNull(@partyName, '') <> '' or IsNull(@InkEntityID , '') <> ''
              begin
                select @transactionObjectID = tr.ObjectID
                from FIN.[Transaction] tr
                where tr.ID = @transactionID

                /*insert FlexibleForm*/
                exec GEN.CreateFlexibleForm @p_ReferencedObjectID = @transactionObjectID, 
                                            @p_FlexibleFormTemplateID = null, 
                                            @p_CorrelationID = @correlationID, 
                                            @p_UserName = @username, 
                                            @p_FlexibleFormID = @flexibleFormID output

                /*insert partyBankAccountNumber*/ 
                if IsNull(@partyBankAccountNumber, '') <> '' 
                begin
                  exec GEN.CreateFlexibleFormField @p_FlexibleFormID = @flexibleFormID, 
                                                   @p_FieldTypeCode = 'FLEXIBLE_FIELD_TYPE_EDITBOX', 
                                                   @p_Caption = 'Ellenoldali számlaszám', 
                                                   @p_ValueSetCode = 'VALUESET_CHARACTER', 
                                                   @p_DataLength = 50, 
                                                   @p_FieldValue = @partyBankAccountNumber, 
                                                   @p_SequenceNr = 10,
                                                   @p_CorrelationID = @correlationID, 
                                                   @p_UserName = @username  
                end

                /*insert partyName*/ 
                if IsNull(@partyName, '') <> '' 
                begin
                  exec GEN.CreateFlexibleFormField @p_FlexibleFormID = @flexibleFormID, 
                                                   @p_FieldTypeCode = 'FLEXIBLE_FIELD_TYPE_EDITBOX', 
                                                   @p_Caption = 'Ellenoldali név', 
                                                   @p_ValueSetCode = 'VALUESET_CHARACTER', 
                                                   @p_DataLength = 250, 
                                                   @p_FieldValue = @partyName, 
                                                   @p_SequenceNr = 20,
                                                   @p_CorrelationID = @correlationID, 
                                                   @p_UserName = @username  
                end

                /*insert entity data of the actor*/
                if IsNull(@InkEntityID , '') <> ''
                begin
                  exec GEN.CreateFlexibleFormField @p_FlexibleFormID = @flexibleFormID, 
                                                   @p_FieldTypeCode = 'FLEXIBLE_FIELD_TYPE_EDITBOX', 
                                                   @p_Caption = 'Kötelezett (Inkasso entityID)', 
                                                   @p_ValueSetCode = 'VALUESET_CHARACTER', 
                                                   @p_DataLength = 50, 
                                                   @p_FieldValue = @InkEntityID, 
                                                   @p_SequenceNr = 30,
                                                   @p_CorrelationID = @correlationID, 
                                                   @p_UserName = @username

                  select @EntityID = IFC.GetEntityIDByInkassoEntityID(@InkEntityID)
                  select @EntityIDStr = Case when @EntityID is null then '?' else Cast(@EntityID as NVarChar(50)) end

                  exec GEN.CreateFlexibleFormField @p_FlexibleFormID = @flexibleFormID, 
                                                   @p_FieldTypeCode = 'FLEXIBLE_FIELD_TYPE_EDITBOX', 
                                                   @p_Caption = 'Kötelezett (Orca entityID)', 
                                                   @p_ValueSetCode = 'VALUESET_CHARACTER', 
                                                   @p_DataLength = 50, 
                                                   @p_FieldValue = @EntityIDStr, 
                                                   @p_SequenceNr = 40,
                                                   @p_CorrelationID = @correlationID, 
                                                   @p_UserName = @username

                  select @EntityName = Case when @EntityID is null then '?' else PRT.GetEntityName(@EntityID) end

                  exec GEN.CreateFlexibleFormField @p_FlexibleFormID = @flexibleFormID, 
                                                   @p_FieldTypeCode = 'FLEXIBLE_FIELD_TYPE_EDITBOX', 
                                                   @p_Caption = 'Kötelezett', 
                                                   @p_ValueSetCode = 'VALUESET_CHARACTER', 
                                                   @p_DataLength = 200, 
                                                   @p_FieldValue = @EntityName, 
                                                   @p_SequenceNr = 50,
                                                   @p_CorrelationID = @correlationID, 
                                                   @p_UserName = @username  
                end
              end
            end
        
            close cur
            deallocate cur

            
            /*6. if we received a payment, we insert an EVENT_TYPE_PAYMENT_RECEIVED event (for the KP process :D) - DV-1910*/
            if exists(select *
                      from IFC.InkassoSyncReceiveTransaction tr
                      where tr.IndecsInkassoSyncID = @IndecsInkassoSyncID
                        and tr.InkTransactionTypeCode = @InkTransactionTypeCodeCredit
                     )
            begin 
              exec ORG.CreateEvent @Subject = null,
	                                 @EventDate = @today,
	                                 @EventTime = @now,
	                                 @EventType = 'EVENT_TYPE_PAYMENT_RECEIVED',
	                                 @Comments = 'Befizetés érkezett',
	                                 @UserName = null,
	                                 @RelatedObjectID = @RelatedObjectID,
                                   @CreationUserName = @username,
	                                 @ProcessCode = null,
	                                 @TaskID = null,
	                                 @ProcessID = null,
                                   @correlationID = @correlationID,
                                   @EventID = null,
                                   @ForceInkassoSyncOff = 1
            end

            /*set statuses*/
            update IFC.InkassoSyncReceiveDebtCase
            set InterfaceStatusCode = @InterfaceStatusCodeProcessed,
                ErrorMessage = null,
                LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @username
            where IndecsInkassoSyncID = @IndecsInkassoSyncID  


            update IFC.InkassoSyncReceiveDebt
            set InterfaceStatusCode = @InterfaceStatusCodeProcessed,
                ErrorMessage = null,
                LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @username
            where IndecsInkassoSyncID = @IndecsInkassoSyncID  

            update IFC.InkassoSyncReceiveTransaction
            set InterfaceStatusCode = @InterfaceStatusCodeProcessed,
                ErrorMessage = null,
                LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @username
            where IndecsInkassoSyncID = @IndecsInkassoSyncID
          commit
        end try
        begin catch
          if @@trancount > 0
            rollback
            
          select @errorMessage = ERROR_MESSAGE()

          /*set statuses*/
          update IFC.InkassoSyncReceiveDebtCase
          set InterfaceStatusCode = @InterfaceStatusCodeError,
              ErrorMessage = @errorMessage,
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @username
          where IndecsInkassoSyncID = @IndecsInkassoSyncID  

          update IFC.InkassoSyncReceiveDebt
          set InterfaceStatusCode = @InterfaceStatusCodeError,
              ErrorMessage = @errorMessage,
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @username
          where IndecsInkassoSyncID = @IndecsInkassoSyncID  

          update IFC.InkassoSyncReceiveTransaction
          set InterfaceStatusCode = @InterfaceStatusCodeError,
              ErrorMessage = @errorMessage,
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @username
          where IndecsInkassoSyncID = @IndecsInkassoSyncID
          
          ;throw
        end catch
      end
    end
    else if @taskTypeCode = @taskTypeCodeEvent
    begin
      /*it was not inserted earlier to the IFC.InkassoSyncReceiveEvent table --> we do the insert*/ 
      if not exists(select *
                    from IFC.InkassoSyncReceiveEvent e
                    where e.IndecsInkassoSyncID = @IndecsInkassoSyncID
                   )
      begin
        insert into IFC.InkassoSyncReceiveEvent(IndecsInkassoSyncID, InkEventID, Description, InkDebtCaseID, InkEntityID, InkAssetID, InkAddressID, InkEventTypeID, ArrangeDateTime, InkCreationDateTime, 
                                                InkCreationUser, InkArrangeUser, InterfaceStatusCode, CreationDate, CreationTime, CreationUserName
                                               )
          select @IndecsInkassoSyncID, e.eventId InkEventID, e.Description, e.businessEntity_dealId InkDebtCaseID, e.businessEntity_actorId InkEntityID, e.businessEntity_collateralId InkAssetID,
                 e.businessEntity_addressid InkAddressID, e.event_eventType InkEventTypeID, 
                 GEN.GetDateTimeFromUTC(e.event_executionDateString, default) ArrangeDate, 
                 GEN.GetDateTimeFromUTC(e.event_dateOfEntryString, default) InkCreationDate, 
                 event_ruserId InkCreationUser,
                 e.event_vuserId InkArrangeUser,
                 @InterfaceStatusCodeNew InterfaceStatusCode, GetDate() CreationDate, GetDate() CreationTime, @username CreationUserName
          from openjson(@json)
               with (eventId Numeric(16) '$.eventId',
                     description NVarChar(max) '$.description',
                     businessEntity_dealId Numeric(16) '$.businessEntity.dealId',
                     businessEntity_actorId NVarChar(200) '$.businessEntity.actorId',
                     businessEntity_collateralId NVarChar(200) '$.businessEntity.collateralId',
                     businessEntity_addressid NVarChar(200) '$.businessEntity.addressid',
                     event_eventType NVarChar(200) '$.event.eventType',
                     event_executionDateString NVarChar(200) '$.event.executionDate',
                     event_dateOfEntryString NVarChar(200) '$.event.dateOfEntry',
                     event_ruserId NVarChar(200) '$.event.ruserId',
                     event_vuserId NVarChar(200) '$.event.vuserId'
                    ) e
      end


      /*IFC.InkassoSyncReceiveEvent table is already filled --> we insert the record to the prod table, if the status of the IFC record is not processed*/
      if exists(select *
                from IFC.InkassoSyncReceiveEvent e
                where e.IndecsInkassoSyncID = @IndecsInkassoSyncID
                 and e.InterfaceStatusCode <> @InterfaceStatusCodeProcessed
               )
      begin 
        select @InkEventID = e.InkEventID, 
               @InkEventTypeID = e.InkEventTypeID,
               @EventTypeCode = IFC.GetMappedValueInkasso(2 /*Inkasso --> Indecs*/, e.InkEventTypeID, 'VALUESET_EVENT_TYPE', null /*@date*/),
               @Comments = e.Description,
               @InkDebtCaseID = e.InkDebtCaseID,
               @InkEntityID = e.InkEntityID, 
               @EntityID = IFC.GetEntityIDByInkassoEntityID(e.InkEntityID),
               @InkAssetID = e.InkAssetID, 
               @InkAddressID = e.InkAddressID,
               @InkCreationUser = e.InkCreationUser,
               @InkCreationDateTime = e.InkCreationDateTime
        from IFC.InkassoSyncReceiveEvent e
        where e.IndecsInkassoSyncID = @IndecsInkassoSyncID
      

        if @InkEventTypeID is null
        begin
          select @errorMessage = Concat(@errorMessage, 'The InkEventTypeID can''t be empty. ')
        end
        else if @EventTypeCode is null
        begin
          select @errorMessage = Concat(@errorMessage, 'Missing mapping for EventTypeCode (Inkasso EventTypeCode: ',  @InkEventTypeID, ', ValueSet: VALUESET_EVENT_TYPE.) ')
        end

        /*finding proper @RelatedObjectID */  
        select @relatedObjectsReceivedCount = Case when @InkDebtCaseID is null then 0 else 1 end +
                                              Case when @InkEntityID is null then 0 else 1 end +
                                              Case when @InkAssetID is null then 0 else 1 end +
                                              Case when @InkAddressID is null then 0 else 1 end

        if @relatedObjectsReceivedCount = 0
        begin
          select @errorMessage = Concat(@errorMessage, 'InkDebtCaseID, InkEntityID, InkAssetID and InkAddressID can''t be all empty. ')
        end
        else
        begin
          /*we only process the first data provided*/
          if @InkDebtCaseID is not null
          begin
            select @RelatedObjectID = IsNull(d.ObjectID, 0)
            from DCS.DebtCase d
            where d.ID = @InkDebtCaseID

            if @RelatedObjectID is null
               select @errorMessage = Concat(@errorMessage, 'DebtCaseID ', @InkDebtCaseID, ' not found. ')
            else if @RelatedObjectID = 0
               select @errorMessage = Concat(@errorMessage, 'DebtCase (DebtCaseID = ', @InkDebtCaseID, ') has no ObjectID. ')
          end
          else if @InkEntityID is not null
          begin
            if @EntityID is null
            begin
              select @errorMessage = Concat(@errorMessage, 'Entity based on ', @InkEntityID, ' Inkasso EntityID not found. ')
            end
            else
            begin
              select @RelatedObjectID = e.ObjectID
              from PRT.Entity e
              where e.ID = @EntityID

              if @RelatedObjectID is null
                 select @errorMessage = Concat(@errorMessage, 'Entity (EntityID = ', @EntityID, ', Inkasso EntityID = ', @InkEntityID, ')  has no ObjectID. ')
            end 
          end
          else if @InkAssetID is not null
          begin
            select @RelatedObjectID = IsNull(a.ObjectID, 0)
            from AST.Asset a
            where a.ID = @InkAssetID

            if @RelatedObjectID is null
               select @errorMessage = Concat(@errorMessage, 'AssetID ', @InkAssetID, ' not found. ')
            else if @RelatedObjectID = 0
               select @errorMessage = Concat(@errorMessage, 'Asset (AssetID =', @InkAssetID, ') has no ObjectID. ')
          end
          else if @InkAddressID is not null
          begin
            select @RelatedObjectID = IsNull(a.ObjectID, 0)
            from PRT.Address a
            where a.ID = @InkAddressID

            if @RelatedObjectID is null
               select @errorMessage = Concat(@errorMessage, 'AddressID ', @InkAddressID, ' not found. ')
            else if @RelatedObjectID = 0
               select @errorMessage = Concat(@errorMessage, 'Address (AddressID = ', @InkAddressID, ') has no ObjectID. ')
          end
        end    

        if IsNull(@errorMessage, '') <> ''
        begin
          update IFC.InkassoSyncReceiveEvent
          set InterfaceStatusCode = @InterfaceStatusCodeError,
              ErrorMessage = @errorMessage,
              LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @username
          where IndecsInkassoSyncID = @IndecsInkassoSyncID

          raiserror(@errorMessage, 16, 1)
        end
        else
        begin
          begin tran          
            exec ORG.CreateEvent @Subject = null,
	                               @EventDate = @InkCreationDateTime /*?*/,
	                               @EventTime = @InkCreationDateTime /*?*/,
	                               @EventType = @EventTypeCode,
	                               @Comments = @Comments,
	                               @UserName = null /*?*/,
	                               @RelatedObjectID = @RelatedObjectID,
                                 @CreationUserName = @InkCreationUser,
	                               @ProcessCode = null /*?*/,
	                               @TaskID = null /*?*/,
	                               @ProcessID = null /*?*/,
                                 @correlationID = @correlationID,
                                 @EventID = @EventID output,
                                 @ForceInkassoSyncOff = 1

            update IFC.InkassoSyncReceiveEvent
            set InterfaceStatusCode = @InterfaceStatusCodeProcessed,
                ErrorMessage = null,
                LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @username
            where IndecsInkassoSyncID = @IndecsInkassoSyncID  
          commit


          set @logMessage = Concat('Event received from Inkasso created, Inkasso eventID =  ', @InkEventID, ', Indecs eventID: ', @EventID)
          exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                                 @p_UserName = @log_userName,
                                 @p_ServiceName = @procedurename, 
                                 @p_LogMessage = @logMessage
        end
      end
    end


    /*Logging processing end*/
    set @logMessage = Concat('End procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @log_userName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

    
    
  end try
  begin catch
    if @@TRANCOUNT > 0
       rollback
   
    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @correlationID,
                            @p_UserName = @log_userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage
    
    select @errorMessage = CONCAT('## ERROR', IsNull(Concat('(', @errorProcedure, ')'), ''), ': ERROR_NUMBER: ', @errorNumber, ' ERROR_SEVERITY: ', @errorSeverity, 
    		                          ' ERROR_STATE: ', @errorState, ' ERROR_LINE: ', @errorLine, ' ERROR_MESSAGE: ', @errorMessage
                                 )
    --;throw;
  end catch
end
go

/*Author: Gyenese Katalin
  Create date: 2023.11.15. - DV-1260
  Description: it is used to store incoming data for the Inkasso --> Indecs synchronization
                  1. it creates a new IFC.IndecsInkassoSync record 
                     - WebserviceName: @WebserviceName 
                     - CorrelationID: @@correlationID 
                     - Content: @json
                     - ContentDataID: the ID of the received debtcase / event from the @json
                  2. creates a task with the needed task type (based on the value of IFC.IndecsInkassoSync.WebserviceName). The ReferencedObjectID of the task is null, because in the IFC table there's no ObjectID.
                  3. sets the value of the TaskID field of the InkassoSync record to the id of the created Task
                  4. creates a new ModuleInstance of the MODULE_INKASSO_INDECS_SYNC module and returns the moduleInstanceID to the backend

  Parameters:
    - @WebserviceName: the name of the webservice calling this procedure
    - @json: the json content received by the backend
    - @correlationID: the correlationID of the caller
    - @moduleInstanceID: the ID of the created moduleInstance (MODULE_INKASSO_INDECS_SYNC module)
*/
CREATE   procedure [IFC].[ReceiveInkassoData](@WebserviceName NVarChar(250), @json NVarChar(max), @correlationID NVarChar(200), @moduleInstanceID Numeric(16) = null output )
as
begin
  set NOCOUNT ON
  set XACT_ABORT ON

  
  /*variables for logging*/
	declare @errormsg NVarChar(max),	@logMessage nvarchar(max), @procedureName nvarchar(100) = 'IFC.ReceiveInkassoData',
          @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max), @log_userName NVarChar(200)

  /*variables for the procedure logic*/
  declare @username NVarChar(200), @moduleCode NVarChar(200) = 'MODULE_INKASSO_INDECS_SYNC', @indecsInkassoSyncID Numeric(16), @taskID Numeric(16), @taskTypeCode NVarChar(200), @contentDataID NVarChar(200),
          @webserviceNameDebtCase NVarChar(200) = 'IND001_dealChanged', @webserviceNameEvent NVarChar(200) = 'IND003_workflowChanged'

  begin try 

    select @log_userName = m.TechnicalUserName
    from ORG.Module m
    where m.ModuleCode = @moduleCode

    select @username = IsNull(@log_userName, 'admin')

    /*Logging procedure start*/
    set @logMessage = Concat('Start procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @log_userName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

    
    /*Logging parameter check*/
    set @logMessage = 'Checking parameters...'
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @log_userName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    if IsNull(@WebserviceName, '') = ''
       raiserror('The @WebserviceName parameter is compulsory.', 16, 1)

    if @WebserviceName not in(@webserviceNameDebtCase, @webserviceNameEvent)
    begin
      set @errorMessage = Concat('Unknown @WebserviceName parameter value. Accepted values: ', @webserviceNameDebtCase, ' / ', @webserviceNameEvent, '.') 
      raiserror(@errorMessage, 16, 1)
    end

    if IsNull(@correlationID, '') = ''
       raiserror('The @correlationID parameter is compulsory.', 16, 1)

    if IsNull(@json, '') = ''
       raiserror('The @json parameter is compulsory.', 16, 1)

    if IsJson(@json) = 0
       raiserror('The @json parameter contains an invalid JSON.', 16, 1)


    /*read ID from json*/
    if @WebserviceName = @webserviceNameDebtCase
    begin
      select @ContentDataID = d.dealId
      from openjson(@json) 
      with(dealId NVarChar(200) '$.dealId') d

      if @ContentDataID is null
         raiserror('dealId value is missing from @json.', 16, 1)

      if not exists(select *
                    from DCS.DebtCase dc
                    where dc.ID = @ContentDataID
                   )
      begin
        set @errorMessage = Concat('dealId ', @ContentDataID, ' does not exist.') 
        raiserror(@errorMessage, 16, 1)
      end
    end
    else if @WebserviceName = @webserviceNameEvent
    begin
      select @ContentDataID = e.eventId
      from openjson(@json) 
      with(eventId Numeric(16) '$.eventId') e

      if @ContentDataID is null
         raiserror('eventId value is missing from @json.', 16, 1)
    end

    
    /*Logging start processing*/
    set @logMessage = 'Processing...'
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @log_userName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    select @taskTypeCode = Case @WebserviceName when @webserviceNameDebtCase then 'TASK_TYPE_DATA_SYNC_DEBT_CASE_IND' /*debtcase*/
                                                when @webserviceNameEvent then 'TASK_TYPE_DATA_SYNC_EVENT_IND' /*event*/
                           end


    begin tran        

      /*1. create the IFC.IndecsInkassoSync record*/
      insert into IFC.IndecsInkassoSync(SyncDirectionCode, WebserviceName, CorrelationID, Content, ContentDataID, InterfaceStatusCode, CreationDate, CreationTime, CreationUserName)
        select 'SYNC_DIRECTION_INDECS' SyncDirectionCode, 
               @WebserviceName,   
               @correlationID,
               @json Content,
               @ContentDataID,
               'INTERFACE_STATUS_NEW' InterfaceStatusCode, GetDate() CreationDate, GetDate() CreationDate, @username CreationUserName
  
      select @indecsInkassoSyncID = SCOPE_IDENTITY()

      /*2. insert the task*/
      exec ORG.TaskInsert	@p_taskTypeCode = @taskTypeCode,
	                        @p_referencedObjectID = null,
                          @p_userName = @username,
	                        @p_detailsStatusCode = 'TASK_DETAILED_STATUS_WAITING_TO_BE_PROCESSED',
	                        @p_creationUserName = @username,
                          @p_correlationID = @correlationID,
	                        @p_newTaskID = @taskID output


      /*3. store the ID of the created task in the TaskID field of the IFC.IndecsInkassoSync record*/
      update IFC.IndecsInkassoSync
      set TaskID = @taskID, LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @username
      where ID = @indecsInkassoSyncID

      
      /*4. create a new moduleInstance*/
      exec ORG.ModuleInstanceInsert @p_moduleCode = @moduleCode, 
                                    @p_statusCode = 'MODULE_INSTANCE_STATUS_READY_TO_RUN', 
                                    @p_CorrelationID = @correlationID, 
                                    @p_UserName = @username, 
                                    @p_moduleInstanceID = @moduleInstanceID out
    commit             

    /*Logging processing end*/
    set @logMessage = Concat('End procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @log_userName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

  end try
  begin catch
   
    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @correlationID,
                            @p_UserName = @log_userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage

    ;throw
  end catch
end
go

/*Author: Gyenese Katalin
  Create date: 2023.12.01. - DV-1749
  Description: Creates a new fee if the feeRate / PeriodTypeCode / PeriodMinimumValue / PeriodMaximumValue changes

  Parameters:
    - @feeListID: the ID of the feeList
    - @code: feeCode (FEE_INTEREST / FEE_PENALTY_INTEREST / FEE_MANAGEMENT_FEE)
    - @typeCode: typeCode (only FEE_TYPE_INTEREST_PERCENT is supported)
    - @validDate: we search the fee record valid for this date
    - @feeRate: feeRate
    - @periodTypeCode: periodType (from valueSet VALUESET_PERIOD_TYPE), if the @periodMinimumValue / @periodMaximumValue is provided
    - @periodMinimumValue: periodMinimumValue
    - @periodMaximumValue: periodMaximumValue
    - @currencyCode: currency (from valueSet VALUESET_CURRENCY)
    - @correlationID: the correlationID of the caller
    - @username: the username of the caller
    - @isFeeRateInPercentFormat: 0 = we insert the @feeRate value directly
                                 1 = we insert @feeRate/100
*/
CREATE   procedure [FIN].[RefreshFee](@feeListID Numeric(16), @code NVarChar(200), @typeCode NVarChar(200), @validDate Date, 
                                   @feeRate Numeric(15, 5),  @periodTypeCode NVarChar(200), @periodMinimumValue money, @periodMaximumValue money, @currencyCode NVarChar(200),
                                   @correlationID NVarChar(200), @username NVarChar(200), @isFeeRateInPercentFormat int = 0
                                  )
as
begin
  set NOCOUNT ON
  set XACT_ABORT ON

  
  /*variables for logging*/
	declare @errormsg NVarChar(max),	@logMessage nvarchar(max), @procedureName nvarchar(100) = 'FIN.RefreshFee',
          @errorProcedure NVarChar(200), @errorNumber int, @errorSeverity int, @errorState int, @errorLine int, @errorMessage NVarChar(max) = '', @log_userName NVarChar(200) = @username

  /*variables for the procedure logic*/
  declare @actualFeeID Numeric(16), @actualFeeRate Numeric(15, 5), @actualPeriodTypeCode NVarChar(200), @actualPeriodMinimumValue money, @actualPeriodMaximumValue money,
          @pretenseID Numeric(16), @pretenseCode NVarChar(200)

  begin try 
    /*Logging procedure start*/
    set @logMessage = Concat('Start procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @log_userName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage


    /*Logging parameter check*/
    set @logMessage = 'Checking parameters...'
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @log_userName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

    
    if @feeListID is null
       raiserror('The @feeListID parameter is compulsory.', 16, 1)

    if not exists(select *
                  from FIN.FeeList fl
                  where fl.ID = @feeListID
                 )
    begin
      set @errorMessage = Concat('FeeListID ', @feeListID, ' does not exist.')
      raiserror(@errorMessage, 16, 1)
    end

    if @validDate is null
       raiserror('The @validDate parameter is compulsory.', 16, 1)

    if IsNull(@code, '') = ''
       raiserror('The @code parameter is compulsory.', 16, 1)

    /*
    if not exists(select *
                  from gen.ValueSet vs join gen.Code c on vs.ID = c.ValueSetID
                  where vs.Code = 'VALUESET_FEE'
                    and c.ID = @code
                  )
       raiserror('Fee code %s does not exist.', 16, 1, @code)
    */
    
    if @code not in('FEE_INTEREST', 'FEE_PENALTY_INTEREST', 'FEE_MANAGEMENT_FEE')
       raiserror('The procedure only supports fee code FEE_INTEREST / FEE_PENALTY_INTEREST / FEE_MANAGEMENT_FEE.', 16, 1) 
    
    if IsNull(@typeCode, '') = ''
       raiserror('The @typeCode parameter is compulsory.', 16, 1)

    /*
    if not exists(select *
                  from gen.ValueSet vs join gen.Code c on vs.ID = c.ValueSetID
                  where vs.Code = 'VALUESET_FEE_TYPE'
                    and c.ID = @code
                  )
       raiserror('Fee type code %s does not exist.', 16, 1, @typeCode)
    */

    if @typeCode <> 'FEE_TYPE_INTEREST_PERCENT'
       raiserror('The procedure only supports fee type FEE_TYPE_INTEREST_PERCENT.', 16, 1, @typeCode) 


    if      IsNull(@currencyCode, '') = '' 
       and (@periodMinimumValue is not null or @periodMaximumValue is not null)
       raiserror('If the minimum/maximum value is not null, the @currencyCode parameter is compulsory.', 16, 1)

    if @currencyCode is not null
    begin
      if not exists(select *
                    from gen.ValueSet vs join gen.Code c on vs.ID = c.ValueSetID
                    where vs.Code = 'VALUESET_CURRENCY'
                      and c.ID = @currencyCode
                    )
         raiserror('Currencycode %s does not exist.', 16, 1, @currencyCode)
    end


    if      IsNull(@periodTypeCode, '') = '' 
       and (@periodMinimumValue is not null or @periodMaximumValue is not null)
       raiserror('If the minimum/maximum value is not null, the @periodTypeCode parameter is compulsory.', 16, 1)

    if @periodTypeCode is not null
    begin
      if not exists(select *
                    from gen.ValueSet vs join gen.Code c on vs.ID = c.ValueSetID
                    where vs.Code = 'VALUESET_PERIOD_TYPE'
                      and c.ID = @periodTypeCode
                    )
         raiserror('Period type %s does not exist.', 16, 1, @periodTypeCode)


      if @periodMinimumValue is null and @periodMaximumValue is null /*we don't store it*/
         set @periodTypeCode = null
    end

    if @feeRate is not null and @isFeeRateInPercentFormat = 1
       set @feeRate = @feeRate/100
    
    /*Logging start processing*/
    set @logMessage = 'Start processing...'
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @log_userName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage    


    /*if there are more active rows, it won't work as expected...*/
    select top 1 @actualFeeID = f.ID,
                 @actualFeeRate = f.FeeRate, @actualPeriodTypeCode = f.PeriodTypeCode, @actualPeriodMinimumValue = f.PeriodMinimumValue, @actualPeriodMaximumValue = f.PeriodMaximumValue
    from FIN.Fee f
    where f.FeeListID = @feeListID
      and f.Code = @code
      and f.TypeCode = @typeCode
      and IsNull(f.ValidFrom, @validDate) <= @validDate
      and @validDate <= IsNull(f.ValidUntil, @validDate)

    begin tran 
      /*if there's an active fee with different feeRate/PeriodTypeCode/PeriodMinimumValue/PeriodMaximumValue value, we deactivate it*/ 
      if  @actualFeeID is not null 
      and (   IsNull(@actualFeeRate, -1000000) <> IsNull(@feeRate, -1000000)
           or IsNull(@actualPeriodTypeCode, '') <> IsNull(@PeriodTypeCode, '')
           or IsNull(@actualPeriodMinimumValue, -1000000) <> IsNull(@periodMinimumValue, -1000000)
           or IsNull(@actualPeriodMaximumValue, -1000000) <> IsNull(@periodMaximumValue, -1000000)
          )
      begin
        update FIN.Fee
        set ValidUntil = DateAdd(day, -1, @validDate),
            LastModifiedDate = GetDate(), LastModifiedTime = GetDate(), LastModifiedUserName = @username
        where ID = @actualFeeID

        set @actualFeeID = null
      end
    
      /*if there's no active fee record with the given feeRate + PeriodTypeCode + PeriodMinimumValue + PeriodMaximumValue values, we insert a new*/
      if @actualFeeID is null
      begin
        select @pretenseCode = Case @code when 'FEE_INTEREST' then 'PRETENSE_INT_CALC_CAPITAL_TO_INTEREST'
                                          when 'FEE_PENALTY_INTEREST' then 'PRETENSE_INT_CALC_CAPITAL_TO_PENALTY_INTEREST'
                                          when 'FEE_MANAGEMENT_FEE' then 'PRETENSE_INT_CALC_CAPITAL_TO_MANAGEMENT_FEE'
                               end

        select @pretenseID = p.ID
        from FIN.Pretense p
        where p.Code = @pretenseCode
          and p.StatusCode = 'STATUS_NORMAL'
          and IsNull(p.ValidFrom, @validDate) <= @validDate
          and @validDate <= IsNull(p.ValidUntil, @validDate)

        if @pretenseID is null
           raiserror('Pretense code %s based on fee code %s not found.', 16, 1, @pretenseCode, @code) 

        insert into FIN.Fee(FeeListID, Code, TypeCode, PretenseID, InterestSetID, FeeRate, FeeValue, CurrencyCode, AdjustmentDateID, ValidFrom, ValidUntil, PeriodTypeCode, PeriodMinimumValue, PeriodMaximumValue, CreationDate, CreationTime, CreationUserName)
          select @feeListID, @code, @typeCode, 
                 @pretenseID PretenseID, 
                 null InterestSetID, 
                 @feeRate FeeRate, null FeeValue, @currencyCode CurrencyCode, null AdjustmentDateID, @validDate ValidFrom, null ValidUntil, @periodTypeCode PeriodTypeCode, @periodMinimumValue PeriodMinimumValue, @periodMaximumValue PeriodMaximumValue, 
                 GetDate() CreationDate, GetDate() CreationTime, @username CreationUserName
      end
    commit    

    /*Logging processing end*/
    set @logMessage = Concat('End procedure ', @procedureName)
    exec LOG.InsertLogInfo @p_CorrelationID = @correlationID,
                           @p_UserName = @log_userName,
                           @p_ServiceName = @procedurename, 
                           @p_LogMessage = @logMessage

    
    
  end try
  begin catch
    if @@TRANCOUNT > 0
       rollback
   
    /*Logging error*/
    select @errorProcedure = ERROR_PROCEDURE(), @errorNumber = ERROR_NUMBER(), @errorSeverity = ERROR_SEVERITY(), @errorState = ERROR_STATE(), @errorLine = ERROR_LINE(), @errorMessage = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @correlationID,
                            @p_UserName = @log_userName,
                            @p_ServiceName = @procedurename, 
                            @p_ErrorProcedure = @errorProcedure,
                            @p_ErrorNumber = @errorNumber,
                            @p_ErrorSeverity = @errorSeverity,
                            @p_ErrorState = @errorState,
                            @p_ErrorLine = @errorLine,
                            @p_ErrorMessage = @errorMessage
    
    ;throw;
  end catch
end
go

/*Author: Gyenese Katalin
  Create date: 2023.10.10. - DV-1524
  Last modified date: 2023.10.10.
  Description: Replaces the accented characters in the given string with non-accented ones.

  Parameters:
    - @s: the input string
*/
CREATE function GEN.RemoveAccents(@s NVarChar(200))
returns NVarChar(200)
as
begin
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'á', 'a')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'Á', 'A')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'é', 'e')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'É', 'E')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'í', 'i')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'Í', 'I')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'ó', 'o')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'Ó', 'O')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'ö', 'o')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'Ö', 'O')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'ő', 'o')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'Ő', 'O')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'ú', 'u')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'Ú', 'U')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'ü', 'u')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'Ü', 'U')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'ű', 'u')
  select @s = Replace(@s collate SQL_Latin1_General_CP1_CS_AS, 'Ű', 'U')
  
  return @s
end
go

--EXEC [dbo].[SP_DATA_UPLOAD] 


CREATE    PROCEDURE [dbo].[SP_DATA_UPLOAD] 
AS
DECLARE @VehicleID int
DECLARE @PersonID int
DECLARE @I int = 1
DECLARE @J int = 1
DECLARE @RAND int = 0
DECLARE @PlateNr_gen VARCHAR(6)
DECLARE @Date_gen date
DECLARE @Amount_gen DECIMAL(18,2)
DECLARE @StartDate date = '2017.01.01'
DECLARE @EndDate date = '2018.12.31'

DECLARE @BrandsTable TABLE (number int, brand VARCHAR(50), type VARCHAR(50))

INSERT INTO @BrandsTable   SELECT 1, 'Alfa Romeo','Brera'      UNION ALL SELECT 2, 'Mercedes', 'EQC'
	UNION ALL SELECT 3, 'Ford','S Max'			  UNION ALL SELECT 4, 'Audi', 'A8'
	UNION ALL SELECT 5, 'Ford','C Max'			  UNION ALL SELECT 6, 'Honda', 'CRV'
	UNION ALL SELECT 7, 'Ferrari','Testarossa'    UNION ALL SELECT 8, 'Lancia', 'Ypsilon'
	UNION ALL SELECT 9, 'Chevrolet', 'Captiva'	  UNION ALL SELECT 10, 'Lancia', 'Delta'

BEGIN
	

    WHILE  (  @I<= 20 )
         BEGIN

		 INSERT INTO Person (LastName, FirstName) values('Lastname' + convert(nvarchar(2),@I),'Firstname' + convert(nvarchar(2),@I)) 

		SET @PersonID  = (SELECT IDENT_CURRENT ('Person') )

			 SET @RAND = (SELECT floor(rand()*9 + 1))
			 SET @PlateNr_gen = (select char((rand()*2 + 65))+char((rand()*25 + 65))) + convert(nvarchar(4),(SELECT floor(rand()*8999 + 1000)))
             INSERT INTO Vehicle (Type,Brand, PlateNr,OwnerPersonID) 
					values ((SELECT type from @BrandsTable where number = @RAND),(SELECT brand from @BrandsTable where number = @RAND),
						 @PlateNr_gen,@PersonID)        
						 
			SET @VehicleID  = (SELECT IDENT_CURRENT ('Vehicle') )

			INSERT INTO HasLicence (PersonID, VehicleID) values (@PersonID, @VehicleID)

			SET @RAND = (SELECT floor(rand()*3 + 1))
			SET @J = 1
			WHILE  (  @J<= @RAND )
				BEGIN
					SET @Date_gen = (SELECT DATEADD(DAY, RAND(CHECKSUM(NEWID()))*(1+DATEDIFF(DAY, @StartDate, @EndDate)),@StartDate))
					SET @Amount_gen = (SELECT CONVERT( DECIMAL(18, 2), 10 + (30-10)*RAND(CHECKSUM(NEWID()))))
					INSERT INTO dbo.Refueling (VehicleID, PersonID, RefuelingDate, Amount) values (@VehicleID,@PersonID,@Date_gen,@Amount_gen)

					SET @J = @J + 1
				END;

			 IF @I % 2 = 1
			 BEGIN
				INSERT INTO Person (LastName, FirstName) values('Lastname' + convert(nvarchar(2),@I + 20),'Firstname' + convert(nvarchar(2),@I+20)) 
				SET @PersonID  = (SELECT IDENT_CURRENT ('Person') )
				INSERT INTO HasLicence (PersonID, VehicleID) values (@PersonID, @VehicleID)

				 IF @I % 4 = 1
					BEGIN
						SET @Date_gen = (SELECT DATEADD(DAY, RAND(CHECKSUM(NEWID()))*(1+DATEDIFF(DAY, @StartDate, @EndDate)),@StartDate))
						SET @Amount_gen = (SELECT CONVERT( DECIMAL(18, 2), 10 + (30-10)*RAND(CHECKSUM(NEWID()))))
						INSERT INTO Refueling (VehicleID, PersonID, RefuelingDate, Amount) values (@VehicleID,@PersonID,@Date_gen,@Amount_gen)
					END;
			 END;

         SET @I = @I + 1;
                     
         END;




END

go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2022-11-14
-- Last modified date: 2023-04-12
-- Description:	Transfer data from IFC.OTP_SRM_F, IFC.OTP_SRM_M table to 
--              IFC.Contract, IFC.ContractItem, IFC.CollectionContractItem, IFC.CollectionContractSummary tables
-- =============================================
CREATE PROCEDURE [IFC].[SRMLoder] 
	-- Add the parameters for the stored procedure here
	@p_correlationID NVARCHAR(200), 
	@p_moduleInstanceID NUMERIC(16),
	@p_result nvarchar(200) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'IFC.SRMLoader'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_ipID NUMERIC(16) = NULL;
	DECLARE @l_itContractID NUMERIC(16) = NULL;
	DECLARE @l_itCollectionContractSummaryID NUMERIC(16) = NULL;
	DECLARE @l_itContractItemID NUMERIC(16) = NULL;
	DECLARE @l_itCollectionContractItemID NUMERIC(16) = NULL;
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_previousContractNr NVARCHAR(20) = NULL;
	DECLARE @l_interfaceLoaderModuleID NUMERIC(16) = NULL;
	DECLARE @l_interfaceLoaderModuleInstanceID NUMERIC(16) = NULL;
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--Az IFC.ContractPreparationItem változói
	DECLARE @l_id NUMERIC(16) = NULL;
	DECLARE @l_contractNr NVARCHAR(20) = NULL;
	DECLARE @l_itemCount NVARCHAR(4)= NULL;
	DECLARE @l_debtCapital NVARCHAR(21) = NULL;
	DECLARE @l_debtTotal NVARCHAR(21) = NULL;
	DECLARE @l_debtInterest NVARCHAR(21);
	DECLARE @l_debtPenaltyInterest NVARCHAR(21) = NULL;
	DECLARE @l_debtCost NVARCHAR(21) = NULL;
	DECLARE @l_debtCostLocalCurrency NVARCHAR(21) = NULL;
	DECLARE @l_purchasePrice NVARCHAR(21) = NULL;
	DECLARE @l_debtCurrencyText NVARCHAR(3) = NULL;
	DECLARE @l_decisionNr NVARCHAR(200) = NULL;
	DECLARE @l_registrationNr NVARCHAR(200) = NULL;
	DECLARE @l_currencyText NVARCHAR(3) = NULL;
	DECLARE @l_sequenceNr NVARCHAR(4) = NULL;
	DECLARE @l_debtorName NVARCHAR(60) = NULL;
	DECLARE @l_accountNr NVARCHAR(24) = NULL;
	DECLARE @l_contractDate NVARCHAR(50) = NULL;
	DECLARE @l_terminationDate NVARCHAR(50) = NULL;
	DECLARE @l_financialMilestoneDate NVARCHAR(50) = NULL;
	DECLARE @l_constructionCode NVARCHAR(4) = NULL;
	--DECLARE @l_itemNr NUMERIC(16) = 1; --Ideiglenesen míg nincs OTP_SRM_M.M1 mező, a szerződésen belüli tételek kezelése
	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
			
		SELECT @l_sourceInterfaceType = CAST('OTPSRM_' + FORMAT(GETDATE(), 'yyyyMMdd_HHmmss') AS NVARCHAR(50));
		
		SELECT @l_logMsg = CONCAT('The value of generated SourceInterfaceType variable: ', @l_sourceInterfaceType);
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
			
		INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
		SELECT 'OBJECT_TYPE_IFC_INTERFACEPACKAGE', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
			 'ADMIN',
			'IFC.InterfacePackage', '1.0';

		SELECT @l_objectID = @@IDENTITY;
		
		INSERT INTO [IFC].[InterfacePackage] ([ObjectID], [SourceInterfaceType], [ImportDate], [CreationDate], [CreationTime], [CreationUserName])
		SELECT @l_objectID, @l_sourceInterfaceType, CAST(GETDATE() AS Date), CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
			'ADMIN';
			
		SELECT @l_ipID = @@IDENTITY;
		
		SELECT @l_logMsg = 'Processing of OTP_SRM_F rows...';
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--OTP_SRM_F sorok feldolgozása
		DECLARE otpSRM_F_cursor CURSOR FOR
		SELECT 
			[OTP_SRM_F].[ID],                 --OTP_SRM_F sor egyedi azonosító
			[OTP_SRM_F].[F1],                 --Engedményezési szerződésszám
			[OTP_SRM_F].[F2],                 --Pénzügyi fordulónap
			[OTP_SRM_F].[F4],                 --Össz db. szám
			[OTP_SRM_F].[F5],                 --Tőke
			[OTP_SRM_F].[F6],                 --Ügyleti kamat
			[OTP_SRM_F].[F7],                 --Késedelmi kamat
			[OTP_SRM_F].[F8],                 --Költség
			[OTP_SRM_F].[F9],                 --Vételár
			[OTP_SRM_F].[F10],                --Követelés összesen
			[OTP_SRM_F].[F11],                --Tartozás devizaneme
			[OTP_SRM_F].[F12],                --Költség (helyi devizában) deviza esetén
			[OTP_SRM_F].[F13],                --Határozatszám
			[OTP_SRM_F].[F14]                 --Vételár devizaneme
		FROM [IFC].[OTP_SRM_F]
		WHERE [OTP_SRM_F].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
		ORDER BY [OTP_SRM_F].[ID];

		OPEN otpSRM_F_cursor;
		FETCH NEXT FROM otpSRM_F_cursor
		INTO 
			@l_id,
			@l_contractNr,
			@l_financialMilestoneDate,
			@l_itemCount,
			@l_debtCapital,
			@l_debtInterest, 
			@l_debtPenaltyInterest, 
			@l_debtCost, 
			@l_purchasePrice, 
			@l_debtTotal,
			@l_debtCurrencyText,   
			@l_debtCostLocalCurrency,  
			@l_registrationNr, 
			@l_currencyText;

		WHILE @@FETCH_STATUS = 0 
		BEGIN				
			IF COALESCE(@l_errorMsg, '') = ''
			BEGIN
				IF COALESCE(@l_previousContractNr, '') <> COALESCE(@l_contractNr, '')
				BEGIN
					--IFC.InterfaceTable objektum létrehozása
					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
						'ADMIN',
						'IFC.InterfaceTable object', '1.0';
					
					SELECT @l_objectID = @@IDENTITY;
				
					--IFC.InterfaceTable sor (IFC.Contract)
					INSERT INTO [IFC].[InterfaceTable] ([ObjectID], [InterfacePackageID], [InterfaceTableName], 
						[CreationDate], [CreationTime], [CreationUserName])
					SELECT @l_objectID, @l_ipID, 'IFC.Contract', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
						'ADMIN';
					
					SELECT @l_itContractID = @@IDENTITY;
				
					--IFC.Contract sor létrehozása
					INSERT INTO [IFC].[Contract] ([SellerName], [BuyerName], [ContractTypeText], [ContractPhaseText], [StatusText], 
						[RegistrationNr], [SourceID], [SourceInterfaceType], [InterfaceStatusCode], [ImportTableID], 
						[ExternalContractNr], [FinancialMilestoneDate], [CreationDate], [CreationTime], [CreationUserName])
					SELECT CAST('OTP Bank Nyrt.' AS NVARCHAR(200)), CAST('OTP Faktoring Zrt.' AS NVARCHAR(200)), 
						CAST('Engedményezés(vásárlás)' AS NVARCHAR(200)), CAST('Szerződés előkészítés fázis' AS NVARCHAR(200)), 
						CAST('16. Aláírásra átadva' AS NVARCHAR(200)),
						@l_registrationNr,	@l_contractNr, @l_sourceInterfaceType, CAST('INTERFACE_STATUS_NEW' AS NVARCHAR(200)), 
						@l_itContractID, @l_contractNr, 
						CAST(LEFT(@l_financialMilestoneDate, 4) + '-' + SUBSTRING(@l_financialMilestoneDate, 5, 2) + '-' + RIGHT(@l_financialMilestoneDate, 2) AS DATE), 
						CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
						'ADMIN';
				END;
					
				--IFC.InterfaceTable objektum létrehozása
				INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
				SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
					'ADMIN',
					'IFC.InterfaceTable object', '1.0';
					
				SELECT @l_objectID = @@IDENTITY;
				
				--IFC.InterfaceTable sor (IFC.CollectionContractSummary)
				INSERT INTO [IFC].[InterfaceTable] ([ObjectID], [InterfacePackageID], [InterfaceTableName], 
					[CreationDate], [CreationTime], [CreationUserName])
				SELECT @l_objectID, @l_ipID, 'IFC.CollectionContractSummary', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
					'ADMIN';
					
				SELECT @l_itCollectionContractSummaryID = @@IDENTITY;
				
				--IFC.Contract sor létrehozása
				INSERT INTO [IFC].[CollectionContractSummary] ([ItemCount], [DebtCapital], [DebtInterest], [DebtPenaltyInterest], [DebtCost], 
					[DebtCostLocalCurrency], [DebtTotal], [CurrencyCode], [PurchasePrice], [PurchasePriceCurrencyCode], 
					[SourceContractID], [SourceID], [SourceInterfaceType], [InterfaceStatusCode], [ImportTableID], 
					[CreationDate], [CreationTime], [CreationUserName])
				SELECT @l_itemCount, @l_debtCapital, @l_debtInterest, @l_debtPenaltyInterest, @l_debtCost, @l_debtCostLocalCurrency,
					@l_debtTotal, CAST('CURRENCY_' + @l_debtCurrencyText AS NVARCHAR(200)), @l_purchasePrice, 
					CAST('CURRENCY_' + @l_currencyText AS NVARCHAR(200)), @l_contractNr, CAST(@l_contractNr + '/SUMMARY' AS NVARCHAR(200)), 
					@l_sourceInterfaceType, CAST('INTERFACE_STATUS_NEW' AS NVARCHAR(200)), 
					@l_itCollectionContractSummaryID, CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
					'ADMIN';
			END;

			IF COALESCE(@l_errorMsg, '') = ''
				UPDATE [IFC].[OTP_SRM_F] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED',
					--[ErrorMessage] = 'OK',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] = 'ADMIN'
				WHERE [OTP_SRM_F].[ID] = @l_id
			ELSE 
				UPDATE [IFC].[OTP_SRM_F] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
					--[ErrorMessage] = @l_errorMsg,
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] = 'ADMIN'
				WHERE [OTP_SRM_F].[ID] = @l_id;

			SELECT @l_previousContractNr = @l_contractNr;

			FETCH NEXT FROM otpSRM_F_cursor
			INTO 
				@l_id, 
				@l_contractNr,
				@l_financialMilestoneDate,
				@l_itemCount,
				@l_debtCapital,
				@l_debtInterest, 
				@l_debtPenaltyInterest, 
				@l_debtCost, 
				@l_purchasePrice, 
				@l_debtTotal,
				@l_debtCurrencyText,   
				@l_debtCostLocalCurrency,  
				@l_registrationNr, 
				@l_currencyText;
		END

		CLOSE otpSRM_F_cursor;
		DEALLOCATE otpSRM_F_cursor;
		
		SELECT @l_logMsg = 'Processing of OTP_SRM_M rows...';
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		
		DECLARE otpSRM_M_cursor CURSOR FOR 
		SELECT 
			[OTP_SRM_M].[ID],                 --OTP_SRM_M sor egyedi azonosító
			[OTP_SRM_M].[M1],                 --Adott szerződésen belüli sorszám
			[OTP_SRM_M].[M2],                 --Adós neve
			[OTP_SRM_M].[M3],                 --24 jegyű giró azonosító
			[OTP_SRM_M].[M4],                 --Aktuális tőke összeg
			[OTP_SRM_M].[M5],                 --Könyvelt ügyleti kamat (Az ügyleti kamaton kívül a visszavont kamattámogatás összege is benne van)
			[OTP_SRM_M].[M6],                 --Könyvelt késedelmi kamat
			[OTP_SRM_M].[M7],                 --Könyvelt költség (A behajtási költséget is tartalmazza)
			[OTP_SRM_M].[M9],                 --Összes követelés értéke
			[OTP_SRM_M].[M10],                --Követelés pénzneme
			[OTP_SRM_M].[M11],                --HUF-ban nyilvántartott KOLTSEG (deviza esetén)
			[OTP_SRM_M].[M12],                --Vételár
			[OTP_SRM_M].[M13],                --Vételár devizaneme
			[OTP_SRM_M].[M14],                --Szerződéskötés dátuma (YYYYMMDD)
			[OTP_SRM_M].[M15],                --Felmondás dátuma (YYYYMMDD)
			[OTP_SRM_M].[M16],                --Az a dátum ameddig a bank a kamatot számolta
			[OTP_SRM_M].[M17],                --SRM-Faktoring szerződésszám (Megegyezik a [OTP_SRM_F].[F1] mező értékével)
			[OTP_SRM_M].[M19],                --WOB azonosító
			[OTP_SRM_M].[M22]                 --Hiteltípus
		FROM [IFC].[OTP_SRM_M]
		WHERE [OTP_SRM_M].[InterfaceStatusCode] = 'INTERFACE_STATUS_NEW'
		ORDER BY [OTP_SRM_M].[M17], [OTP_SRM_M].[M1]
		
		--OTP_SRM_M sorok feldolgozása
		OPEN otpSRM_M_cursor;
		FETCH NEXT FROM otpSRM_M_cursor
		INTO 
			@l_id,
			@l_sequenceNr,
			@l_debtorName,
			@l_accountNr,
			@l_debtCapital,
			@l_debtInterest, 
			@l_debtPenaltyInterest, 
			@l_debtCost,
			@l_debtTotal,
			@l_debtCurrencyText,
			@l_debtCostLocalCurrency,
			@l_purchasePrice,
			@l_currencyText,
			@l_contractDate,
			@l_terminationDate,
			@l_financialMilestoneDate,
			@l_contractNr,
			@l_decisionNr,
			@l_constructionCode;

		WHILE @@FETCH_STATUS = 0 
		BEGIN				
			IF COALESCE(@l_errorMsg, '') = ''
			BEGIN
				--IFC.InterfaceTable objektum létrehozása
				INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
				SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
					'ADMIN',
					'IFC.InterfaceTable object', '1.0';
					
				SELECT @l_objectID = @@IDENTITY;
				
				--IFC.InterfaceTable sor (IFC.ContractItem)
				INSERT INTO [IFC].[InterfaceTable] ([ObjectID], [InterfacePackageID], [InterfaceTableName], 
					[CreationDate], [CreationTime], [CreationUserName])
				SELECT @l_objectID, @l_ipID, 'IFC.ContractItem', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
					'ADMIN';
					
				SELECT @l_itContractItemID = @@IDENTITY;
				--SELECT @l_sequenceNr = CAST(@l_itemNr AS NVARCHAR(4)); --Ideiglenesen az elemek számának kezelése miatt
				
				--IFC.ContractItem sor létrehozása
				INSERT INTO [IFC].[ContractItem] ([SequenceNr], [GrossValue], [CurrencyCode], [SourceID], [SourceContractID], 
					[SourceContractNr], [SourceInterfaceType], [InterfaceStatusCode], [ImportTableID], 
					[CreationDate], [CreationTime], [CreationUserName])
				SELECT @l_sequenceNr, CAST(@l_purchasePrice AS MONEY), CAST('CURRENCY_' + @l_currencyText AS NVARCHAR(200)), CAST(@l_contractNr + '/' + @l_sequenceNr AS NVARCHAR(200)),
					@l_contractNr, @l_contractNr, @l_sourceInterfaceType, CAST('INTERFACE_STATUS_NEW' AS NVARCHAR(200)), 
					@l_itContractItemID, CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
					 'ADMIN';
					
				--IFC.InterfaceTable objektum létrehozása
				INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
				SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
					'ADMIN',
					'IFC.InterfaceTable object', '1.0';
					
				SELECT @l_objectID = @@IDENTITY;
				
				--IFC.InterfaceTable sor (IFC.CollectionContractItem)
				INSERT INTO [IFC].[InterfaceTable] ([ObjectID], [InterfacePackageID], [InterfaceTableName], 
					[CreationDate], [CreationTime], [CreationUserName])
				SELECT @l_objectID, @l_ipID, 'IFC.CollectionContractItem', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
					 'ADMIN';
					
				SELECT @l_itCollectionContractItemID = @@IDENTITY;
				
				--IFC.CollectionContractItem sor létrehozása
				INSERT INTO [IFC].[CollectionContractItem] ([CurrencyCode], [DebtCapital], [DebtInterest], [DebtPenaltyInterest], 
					[DebtCost], [DebtCostLocalCurrency], [DebtTotal], [ConstructionCode], [DebtorName], [AccountNr], [DecisionNr], 
					[ContractDate], [TerminationDate], [FinancialMilestoneDate], [SourceID], [SourceContractItemID], [SourceInterfaceType], 
					[InterfaceStatusCode], [ImportTableID], [CreationDate], [CreationTime], [CreationUserName])
				SELECT CAST('CURRENCY_' + @l_debtCurrencyText AS NVARCHAR(200)), @l_debtCapital, @l_debtInterest, @l_debtPenaltyInterest,
					@l_debtCost, @l_debtCostLocalCurrency, @l_debtTotal, @l_constructionCode, @l_debtorName, @l_accountNr, @l_decisionNr,
					CAST(LEFT(@l_contractDate, 4) + '-' + SUBSTRING(@l_contractDate, 5, 2) + '-' + RIGHT(@l_contractDate, 2) AS DATE), 
					CAST(LEFT(@l_terminationDate, 4) + '-' + SUBSTRING(@l_terminationDate, 5, 2) + '-' + RIGHT(@l_terminationDate, 2) AS DATE), 
					CAST(LEFT(@l_financialMilestoneDate, 4) + '-' + SUBSTRING(@l_financialMilestoneDate, 5, 2) + '-' + RIGHT(@l_financialMilestoneDate, 2) AS DATE), 
					CAST(@l_contractNr + '/' + @l_sequenceNr AS NVARCHAR(200)), CAST(@l_contractNr + '/' + @l_sequenceNr AS NVARCHAR(200)), 
					@l_sourceInterfaceType, CAST('INTERFACE_STATUS_NEW' AS NVARCHAR(200)), @l_itCollectionContractItemID, 
					CAST(GETDATE() AS Date), CAST(GETDATE() AS Time),
					'ADMIN';
			END;

			IF COALESCE(@l_errorMsg, '') = ''
				UPDATE [IFC].[OTP_SRM_M] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_PROCESSED',
					--[ErrorMessage] = 'OK',
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] =  'ADMIN'
				WHERE [OTP_SRM_M].[ID] = @l_id
			ELSE 
				UPDATE [IFC].[OTP_SRM_M] SET 
					[InterfaceStatusCode] = 'INTERFACE_STATUS_ERROR',
					--[ErrorMessage] = @l_errorMsg,
					[LastModifiedDate] = CAST(GETDATE() AS Date),
					[LastModifiedTime] = CAST(GETDATE() AS Time),
					[LastModifiedUserName] =  'ADMIN'
				WHERE [OTP_SRM_M].[ID] = @l_id;
				
			--SELECT @l_itemNr = @l_itemNr + 1; --Ideiglenesen az elemek számának kezelése miatt

			FETCH NEXT FROM otpSRM_M_cursor
			INTO 
				@l_id,
				@l_sequenceNr,
				@l_debtorName,
				@l_accountNr,
				@l_debtCapital,
				@l_debtInterest, 
				@l_debtPenaltyInterest, 
				@l_debtCost,
				@l_debtTotal,
				@l_debtCurrencyText,
				@l_debtCostLocalCurrency,
				@l_purchasePrice,
				@l_currencyText,
				@l_contractDate,
				@l_terminationDate,
				@l_financialMilestoneDate,
				@l_contractNr,
				@l_decisionNr,
				@l_constructionCode;
		END

		CLOSE otpSRM_M_cursor;
		DEALLOCATE otpSRM_M_cursor;

--===========================================================
--BLOCK: BEGIN
--TABLE: ORG.ModuleInstance -> MODULE_INTERFACE_LOADER
--===========================================================
		SELECT @l_interfaceLoaderModuleID = [Module].[ID] 
		FROM [ORG].[Module] 
		WHERE [Module].[ModuleCode] = 'MODULE_INTERFACE_LOADER'
		AND [Module].[StatusCode] = 'MODULE_STATUS_CAN_RUN';

		IF COALESCE(@l_interfaceLoaderModuleID, 0) = 0
		BEGIN
			SELECT @l_logMsg = 'Based on the code ''MODULE_INTERFACE_LOADER'', no executable module can be found in the system.';

			INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				@p_CorrelationID,			-- CorrelationID
				'INDECS 3.0',			    -- ApplicationName
				DB_NAME(),					-- Environment
				'BACKEND',					-- Layer
				@l_procedureName,   		-- ServiceName
				'1.0',						-- ServiceVersion
				'ERROR',					-- SeverityLevel
				NULL,						-- MessageCategory
				@l_logMsg;
		END
		ELSE
		BEGIN
			SELECT @l_objectID = 0;

			INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
			VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_INTERFACE_LOADER', ' module instance object'), '1.0');

			SELECT @l_objectID = @@IDENTITY;

			IF COALESCE(@l_objectID, 0) > 0
			BEGIN
				INSERT INTO [ORG].[ModuleInstance] ([ObjectID], [ModuleID], [StatusCode], [CorrelationID], 
					[CreationDate], [CreationTime], [CreationUserName])
				VALUES (@l_objectID, @l_interfaceLoaderModuleID, 'MODULE_INSTANCE_STATUS_PREPARATION', @p_CorrelationID, 
					CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');

				SELECT @l_interfaceLoaderModuleInstanceID = @@IDENTITY;

				IF COALESCE(@l_interfaceLoaderModuleInstanceID, 0) > 0
				BEGIN
					--MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE
					SELECT @l_objectID = 0;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE', ' module instance parameter object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN 
						INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
							[CreationDate], [CreationTime], [CreationUserName])
						VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE', 
							@l_sourceInterfaceType, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					END;

					--MODULE_PARAMETER_IFC_CONTRACT
					SELECT @l_objectID = 0;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_CONTRACT', ' module instance parameter object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN 
						INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
							[CreationDate], [CreationTime], [CreationUserName])
						VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_CONTRACT', 
							'BOOLEAN_TRUE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					END;

					UPDATE [ORG].[ModuleInstance] SET 
						[StatusCode] = 'MODULE_INSTANCE_STATUS_READY_TO_RUN'
					WHERE [ModuleInstance].[ID] = @l_interfaceLoaderModuleInstanceID;

					SELECT @l_logMsg = CONCAT('Module ''MODULE_INTERFACE_LOADER'' instantiated successfully. Module instance identifier: ', 
						@l_interfaceLoaderModuleInstanceID);

					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),				-- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						'INFO',					    -- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;
				END
			END
		END;

--===========================================================
--BLOCK: END
--TABLE: ORG.ModuleInstance -> MODULE_INTERFACE_LOADER
--===========================================================

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;

		SELECT @p_result = 0;
		IF COALESCE(@l_interfaceLoaderModuleInstanceID, 0) > 0
		BEGIN
		SELECT @p_result=@l_interfaceLoaderModuleInstanceID
		END

		SELECT @p_result;


		RETURN;
	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'otpSRM_F_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE otpSRM_F_cursor;

			DEALLOCATE otpSRM_F_cursor;
		END
		
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'otpSRM_M_cursor');

		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE otpSRM_M_cursor;

			DEALLOCATE otpSRM_M_cursor;
		END

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage

		SELECT @p_result = @l_errorMsg;
		SELECT @p_result;
		RETURN;
	END CATCH
END
go

CREATE FUNCTION [GEN].[SearchString](@p_String nvarchar(200))
returns nvarchar(200)
/***********************************
* Administrator: Bognár Dávid      *
*  Created:      2022.11.16.       *
*  Last revised: 2022.11.16.       *
***********************************/
/*
Converts a string to "search string" (similar to Soundex SQL function)

Example:
> SELECT GEN.SearchString('Winn-disch. graetz')
VINDISGREC

*/
begin
  declare @l_Result nvarchar(200);
  declare @l_Char nvarchar(3);
  declare @l_Index integer;

  set @l_Index=1;
  set @p_string=upper(@p_string);
  set @l_Result='';
  --//Converting the string to upper case
  
 while(@l_Index <= len(@p_String)) begin

       if(substring(@p_String,@l_Index,1) between 'A' and 'Z') or
         (substring(@p_String,@l_Index,1) between '0' and '9') or
          (substring(@p_String,@l_Index,1) = '%') 

		  begin
     -- //Number or alphabetical character
              if substring(@p_String,@l_Index,1)='Y' begin set  @l_Char='I'   end;
	          else if substring(@p_String,@l_Index,1)='W' begin set  @l_Char='V'  end;
		      else if substring(@p_String,@l_Index,1)='Ő' begin set  @l_Char='O' end ;
		      else if substring(@p_String,@l_Index,1)='Ű' begin set  @l_Char='U'  end;
			  else if substring(@p_String,@l_Index+1,1) = substring(@p_String,@l_Index,1) begin set @l_Char=substring(@p_String,@l_Index,1) set @l_Index=@l_Index+2 end;
			 -- if substring(@p_String,@l_Index,2) ='TH'  begin set @l_Char='T' set @l_Index=@l_Index+1 end;
			--  if substring(@p_String,@l_Index,2) ='CH'  begin set @l_Char='C' set @l_Index=@l_Index+1 end;
            --  if substring(@p_String,@l_Index,2) ='AE'  begin set @l_Char='E' set @l_Index=@l_Index+1 end;
            --  if substring(@p_String,@l_Index,2) ='PH'  begin set @l_Char='F' set @l_Index=@l_Index+1 end;
             -- if substring(@p_String,@l_Index,2) ='TZ'  begin set @l_Char='C' set @l_Index=@l_Index+1 end;
     		 -- if substring(@p_String,@l_Index,2) ='CZ'  begin set @l_Char='C' set @l_Index=@l_Index+1 end;
              --if substring(@p_String,@l_Index,2) ='LY'  begin set @l_Char='J' set @l_Index=@l_Index+1 end;
			 -- if substring(@p_String,@l_Index,3) ='SCH' begin set @l_Char='S' set @l_Index=@l_Index+4 end;
               -- set @l_Char='S'
               -- set @l_Index=@l_Index+2
              else set @l_Char=substring(@p_String,@l_Index,1);
			  end 

			  set @l_Index=@l_Index+1
    set @l_Result=@l_Result+@l_Char
     -- else if(substring(@p_String,@l_Index,1) between 'A' and 'Z') and
       --    (substring(@p_String,@l_Index+1,1) = substring(@p_String,@l_Index,1)) 
           --Duplicated characters 
		--   begin
        --  set @l_Char=substring(@p_String,@l_Index,1);
          --set @l_Index=@l_Index+1 end;
       -- else
          -- 
		 --  end
		--	if substring(@p_String,@l_Index,2) ='CH'  set @l_Char='C';
           -- set @l_Index=@l_Index+1
			--if substring(@p_String,@l_Index,2) ='AE'  set @l_Char='E';
           --set @l_Index=@l_Index+1
			--if substring(@p_String,@l_Index,2) ='PH'  set @l_Char='F';
          -- set @l_Index=@l_Index+1
			--if substring(@p_String,@l_Index,2) ='TZ'  set @l_Char='C';
           -- set @l_Index=@l_Index+1
			--if substring(@p_String,@l_Index,2) ='CZ'  set @l_Char='C';
           -- set @l_Index=@l_Index+1
			--if substring(@p_String,@l_Index,2) ='LY'  set @l_Char='J';
          --set @l_Index=@l_Index+1;

          --  else --SCH examination
             -- if(@l_Index < len(@p_String)-1) and
               -- (substring(@p_String,@l_Index,3) = 'SCH') 
               -- set @l_Char='S'
               -- set @l_Index=@l_Index+2
             -- else
                --This is the default: normal character, no translation needed
      --          set @l_Char=substring(@p_String,@l_Index,1)
            
    --        end ;
     
      -- else
         
     
    -- end;
       
	
   
  end;
 -- if @l_Result = '' 
  --  return(null)
 -- else
 --return(@l_Result)
 return(@l_Result)
end
go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2022-11-28
-- Last modified date:	2022-11-28
--						2022-12-08, IFC.TA_FF_Loader
--						2023-04-06, Kötegelt IFC loader indítása
-- Description:	DataTranfer From IFC.OTP_FC, IFC.OTP_FK, IFC.OTP_FU to INDECS 3.0 interface
-- =============================================
CREATE   PROCEDURE [IFC].[TALoader] 
	-- Add the parameters for the stored procedure here
	@p_correlationID NVARCHAR(200), 
	@p_moduleInstanceID NUMERIC(16),
	@p_result nvarchar(200) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_sourceInterfaceType NVARCHAR(200) = NULL; --A SourceInterfaceType érték kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'IFC.TALoader'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_ipID NUMERIC(16) = NULL;
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_params NVARCHAR(200) = NULL;
	DECLARE @l_sqlStatement NVARCHAR(MAX) = NULL;
	DECLARE @l_interfaceLoaderModuleID NUMERIC(16) = NULL;
	DECLARE @l_interfaceLoaderModuleInstanceID NUMERIC(16) = NULL;
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--Amennyiben alkalmazunk cursor-okat, akkor azok definiálása (opcionális)
	
	--Feldolgozás kezdete (kötelező)
    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
			
		UPDATE [ORG].[ModuleInstance] SET 
			[StatusCode] = 'MODULE_INSTANCE_STATUS_RUNNING',
			[BeginDate] = CAST(GETDATE() AS Date),
			[BeginTime] = CAST(GETDATE() AS Time),
			[Progress] = 1.00
		WHERE [ModuleInstance].[ID] = @p_moduleInstanceID;

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
			
		SELECT @l_sourceInterfaceType = CAST('OTPTA_' + FORMAT(GETDATE(), 'yyyyMMdd_HHmmss') AS NVARCHAR(50));
		
		SELECT @l_logMsg = CONCAT('The value of generated SourceInterfaceType variable: ', @l_sourceInterfaceType);
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
			
		INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
		SELECT 'OBJECT_TYPE_IFC_INTERFACEPACKAGE', CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
			'ADMIN',
			'IFC.InterfacePackage', '1.0';

		SELECT @l_objectID = @@IDENTITY;
		
		INSERT INTO [IFC].[InterfacePackage] ([ObjectID], [SourceInterfaceType], [ImportDate], [CreationDate], [CreationTime], [CreationUserName])
		SELECT @l_objectID, @l_sourceInterfaceType, CAST(GETDATE() AS Date), CAST(GETDATE() AS Date), CAST(GETDATE() AS Time), 
			 'ADMIN';
			
		SELECT @l_ipID = @@IDENTITY;
		
		UPDATE [ORG].[ModuleInstance] SET 
			[Progress] = 25.00
		WHERE [ModuleInstance].[ID] = @p_moduleInstanceID;
		
		SELECT @l_logMsg = 'Processing of OTP_TA_FK rows...';
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

---------------------------------------------------------------------------------------------------------------------------------------			

		--IFC.TA_FK_Loader
		SELECT @l_sqlStatement = '[IFC].[TA_FK_Loader] @l_correlationID, @l_sourceIntfType, @l_interfacePackageID';
		SELECT @l_params = N'@l_correlationID NVARCHAR(200), @l_sourceIntfType NVARCHAR(200), @l_interfacePackageID NUMERIC(16)';
		EXECUTE sp_executesql 
			@l_sqlStatement, 
			@l_params, 
			@l_correlationID = @p_correlationID, 
			@l_sourceIntfType = @l_sourceInterfaceType, 
			@l_interfacePackageID=@l_ipID;
			
		UPDATE [ORG].[ModuleInstance] SET 
			[Progress] = 50.00
		WHERE [ModuleInstance].[ID] = @p_moduleInstanceID;

		SELECT @l_logMsg = 'Processing of OTP_TA_FU rows...';
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
---------------------------------------------------------------------------------------------------------------------------------------			

		--IFC.TA_FU_Loader
		SELECT @l_sqlStatement = '[IFC].[TA_FU_Loader] @l_correlationID, @l_sourceIntfType, @l_interfacePackageID';
		SELECT @l_params = N'@l_correlationID NVARCHAR(200), @l_sourceIntfType NVARCHAR(200), @l_interfacePackageID NUMERIC(16)';
		EXECUTE sp_executesql 
			@l_sqlStatement, 
			@l_params, 
			@l_correlationID = @p_correlationID, 
			@l_sourceIntfType = @l_sourceInterfaceType, 
			@l_interfacePackageID=@l_ipID;
			
		UPDATE [ORG].[ModuleInstance] SET 
			[Progress] = 75.00
		WHERE [ModuleInstance].[ID] = @p_moduleInstanceID;

		SELECT @l_logMsg = 'Processing of OTP_TA_FC rows...';
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
---------------------------------------------------------------------------------------------------------------------------------------			
	
		--IFC.TA_FC_Loader
		SELECT @l_sqlStatement = '[IFC].[TA_FC_Loader] @l_correlationID, @l_sourceIntfType, @l_interfacePackageID';
		SELECT @l_params = N'@l_correlationID NVARCHAR(200), @l_sourceIntfType NVARCHAR(200), @l_interfacePackageID NUMERIC(16)';
		EXECUTE sp_executesql 
			@l_sqlStatement, 
			@l_params, 
			@l_correlationID = @p_correlationID, 
			@l_sourceIntfType = @l_sourceInterfaceType, 
			@l_interfacePackageID=@l_ipID;

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;
---------------------------------------------------------------------------------------------------------------------------------------			

		--IFC.TA_FF_Loader
		SELECT @l_sqlStatement = '[IFC].[TA_FF_Loader] @l_correlationID, @l_sourceIntfType, @l_interfacePackageID';
		SELECT @l_params = N'@l_correlationID NVARCHAR(200), @l_sourceIntfType NVARCHAR(200), @l_interfacePackageID NUMERIC(16)';
		EXECUTE sp_executesql 
			@l_sqlStatement, 
			@l_params, 
			@l_correlationID = @p_correlationID, 
			@l_sourceIntfType = @l_sourceInterfaceType, 
			@l_interfacePackageID=@l_ipID;

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;
---------------------------------------------------------------------------------------------------------------------------------------			
			
		UPDATE [ORG].[ModuleInstance] SET 
			[StatusCode] = 'MODULE_INSTANCE_STATUS_FINISHED',
			[EndDate] = CAST(GETDATE() AS Date),
			[EndTime] = CAST(GETDATE() AS Time),
			[Progress] = 100.00
		WHERE [ModuleInstance].[ID] = @p_moduleInstanceID;

--===========================================================
--BLOCK: BEGIN
--TABLE: ORG.ModuleInstance -> MODULE_INTERFACE_LOADER
--===========================================================
		SELECT @l_interfaceLoaderModuleID = [Module].[ID] 
		FROM [ORG].[Module] 
		WHERE [Module].[ModuleCode] = 'MODULE_INTERFACE_LOADER'
		AND [Module].[StatusCode] = 'MODULE_STATUS_CAN_RUN';

		IF COALESCE(@l_interfaceLoaderModuleID, 0) = 0
		BEGIN
			SELECT @l_logMsg = 'Based on the code ''MODULE_INTERFACE_LOADER'', no executable module can be found in the system.';

			INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				@p_CorrelationID,			-- CorrelationID
				'INDECS 3.0',			    -- ApplicationName
				DB_NAME(),					-- Environment
				'BACKEND',					-- Layer
				@l_procedureName,   		-- ServiceName
				'1.0',						-- ServiceVersion
				'ERROR',					-- SeverityLevel
				NULL,						-- MessageCategory
				@l_logMsg;
		END
		ELSE
		BEGIN
			SELECT @l_objectID = 0;

			INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
			VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_INTERFACE_LOADER', ' module instance object'), '1.0');

			SELECT @l_objectID = @@IDENTITY;

			IF COALESCE(@l_objectID, 0) > 0
			BEGIN
				INSERT INTO [ORG].[ModuleInstance] ([ObjectID], [ModuleID], [StatusCode], [CorrelationID], 
					[CreationDate], [CreationTime], [CreationUserName])
				VALUES (@l_objectID, @l_interfaceLoaderModuleID, 'MODULE_INSTANCE_STATUS_PREPARATION', @p_CorrelationID, 
					CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');

				SELECT @l_interfaceLoaderModuleInstanceID = @@IDENTITY;

				IF COALESCE(@l_interfaceLoaderModuleInstanceID, 0) > 0
				BEGIN
					--MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE
					SELECT @l_objectID = 0;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE', ' module instance parameter object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN 
						INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
							[CreationDate], [CreationTime], [CreationUserName])
						VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_SOURCE_INTERFACE_TYPE', 
							@l_sourceInterfaceType, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					END;

------------------------
					--MODULE_PARAMETER_IFC_COMPANY
					SELECT @l_objectID = 0;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_COMPANY', ' module instance parameter object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN 
						INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
							[CreationDate], [CreationTime], [CreationUserName])
						VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_COMPANY', 
							'BOOLEAN_TRUE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					END;
------------------------
					--MODULE_PARAMETER_IFC_PERSON
					SELECT @l_objectID = 0;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_PERSON', ' module instance parameter object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN 
						INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
							[CreationDate], [CreationTime], [CreationUserName])
						VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_PERSON', 
							'BOOLEAN_TRUE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					END;
------------------------
					--MODULE_PARAMETER_IFC_ADDRESS
					SELECT @l_objectID = 0;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_ADDRESS', ' module instance parameter object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN 
						INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
							[CreationDate], [CreationTime], [CreationUserName])
						VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_ADDRESS', 
							'BOOLEAN_TRUE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					END;
------------------------
					--MODULE_PARAMETER_IFC_CONTACT
					SELECT @l_objectID = 0;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_CONTACT', ' module instance parameter object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN 
						INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
							[CreationDate], [CreationTime], [CreationUserName])
						VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_CONTACT', 
							'BOOLEAN_TRUE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					END;
------------------------
					--MODULE_PARAMETER_IFC_DEBTOR
					SELECT @l_objectID = 0;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_DEBTOR', ' module instance parameter object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN 
						INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
							[CreationDate], [CreationTime], [CreationUserName])
						VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_DEBTOR', 
							'BOOLEAN_TRUE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					END;
------------------------
					--MODULE_PARAMETER_IFC_DEBT_CASE
					SELECT @l_objectID = 0;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_DEBT_CASE', ' module instance parameter object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN 
						INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
							[CreationDate], [CreationTime], [CreationUserName])
						VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_DEBT_CASE', 
							'BOOLEAN_TRUE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					END;
------------------------
					--MODULE_PARAMETER_IFC_INVOICE
					SELECT @l_objectID = 0;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_INVOICE', ' module instance parameter object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN 
						INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
							[CreationDate], [CreationTime], [CreationUserName])
						VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_INVOICE', 
							'BOOLEAN_TRUE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					END;
------------------------
					--MODULE_PARAMETER_IFC_IDENTIFIER
					SELECT @l_objectID = 0;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_IDENTIFIER', ' module instance parameter object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN 
						INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
							[CreationDate], [CreationTime], [CreationUserName])
						VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_IDENTIFIER', 
							'BOOLEAN_TRUE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					END;
------------------------
					----MODULE_PARAMETER_IFC_CONTRACT_CHECK
					--SELECT @l_objectID = 0;

					--INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					--VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_CONTRACT_CHECK', ' module instance parameter object'), '1.0');

					--SELECT @l_objectID = @@IDENTITY;

					--IF COALESCE(@l_objectID, 0) > 0
					--BEGIN 
					--	INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
					--		[CreationDate], [CreationTime], [CreationUserName])
					--	VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_CONTRACT_CHECK', 
					--		'BOOLEAN_TRUE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					--END;
------------------------
					--MODULE_PARAMETER_IFC_ASSETALL
					SELECT @l_objectID = 0;

					INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
					VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCEPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('MODULE_PARAMETER_IFC_ASSETALL', ' module instance parameter object'), '1.0');

					SELECT @l_objectID = @@IDENTITY;

					IF COALESCE(@l_objectID, 0) > 0
					BEGIN 
						INSERT INTO [ORG].[ModuleInstanceParameter] ([ObjectID], [ModuleInstanceID], [ParameterCode], [ParameterValue], 
							[CreationDate], [CreationTime], [CreationUserName])
						VALUES (@l_objectID, @l_interfaceLoaderModuleInstanceID, 'MODULE_PARAMETER_IFC_ASSETALL', 
							'BOOLEAN_TRUE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');
					END;

					UPDATE [ORG].[ModuleInstance] SET 
						[StatusCode] = 'MODULE_INSTANCE_STATUS_READY_TO_RUN'
					WHERE [ModuleInstance].[ID] = @l_interfaceLoaderModuleInstanceID;

					SELECT @l_logMsg = CONCAT('Module ''MODULE_INTERFACE_LOADER'' instantiated successfully. Module instance identifier: ', 
						@l_interfaceLoaderModuleInstanceID);

					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),				-- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						'INFO',					    -- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;
				END
			END
		END;

--===========================================================
--BLOCK: END
--TABLE: ORG.ModuleInstance -> MODULE_INTERFACE_LOADER
--===========================================================


		SELECT @p_result = 0;
		IF COALESCE(@l_interfaceLoaderModuleInstanceID, 0) > 0
		BEGIN 
		SELECT @p_result = @l_interfaceLoaderModuleInstanceID;
		END
		SELECT @p_result
		RETURN;
	END TRY

	BEGIN CATCH
		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
			
		UPDATE [ORG].[ModuleInstance] SET 
			[StatusCode] = 'MODULE_INSTANCE_STATUS_FAILED',
			[EndDate] = CAST(GETDATE() AS Date),
			[EndTime] = CAST(GETDATE() AS Time)
		WHERE [ModuleInstance].[ID] = @p_moduleInstanceID;

		SELECT @p_result = @l_errorMsg;
		SELECT @p_result;
		RETURN;
	END CATCH
END
go


CREATE     PROCEDURE [IFC].[TA_FC_Loader](@p_CorrelationID nVarchar(200), @p_SourceInterfaceType nVarchar(200), @p_InterfacePackageID Numeric(16))

/* 
USE [indecs_dev]
*/

-- =====================================================================================================================
/*
 Author:				Tóth Gábor
 Creation date:			2022.10.24.
 Last modified date:	2022.11.01.
						2022.11.08, InterfaceStatusCode, LOG
						2022.11.09, Átnevezés, 999 -> 99, ObjectType, AppUser, InterfaceStatusCode = NULL, Return, Errormessage
						2022.11.10, If Isnull(@ErrorMessage,'') <> ''
						2022.11.17, AddressType Hard-kódolás, CountryCode
						2022.11.20, Címtípus hossz
						2022.11.21, @p_CorrelationID nVarchar(200)
						2022-11-27: @l_ErrorExists ( Nem volt hiba: 1, Volt hiba: 99 )
						2022-12-13: @FC19
						2022-12-16: @CurrentUserName
						2023-01-07: (SourceCompanyID, SourcePersonID) + címtípus meghatározás áthelyezése az IFC.AddressLoader betöltõbe
						2023-01-17: TAFC...
						2023-02-09: CurrenUserName
						2023-04-13: OBJECT_TYPE_IFC_INTERFACETABLE
						2023-04-14: Return 99

 Description:	DataTranfer From IFT.OTP_FC to IFC.Address
*/
-- =====================================================================================================================


AS

BEGIN
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;

    DECLARE @LogMessage NVARCHAR(200);

	SET @ErrorMessage = '';
	SET @ErrorSeverity = 0;
	SET @ErrorState = 0;
	SET @ErrorLine = 0;

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	/*
	Set @CurrentUser = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));

	Set @CurrentUserName = 0;
	If exists (select 1 from PRT.AppUser where UserName = @CurrentUser)
		Set @CurrentUserName = (select Top 1 ID from PRT.AppUser where UserName = @CurrentUser order by ID);
	ELSE
		Set @ErrorMessage = 'Current user id not defined (' + @CurrentUser + ')';
	*/
	/*Set @CurrentUserName = 'Admin'; 2023-02-09*/
	Set @CurrentUserName = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));


	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FC_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

    BEGIN TRANSACTION

    BEGIN TRY
        SET @LogMessage = 'Address Loader Started';
		
		Declare @l_Company nvarchar(1); -- Company = 'T'
		Declare @l_Person nvarchar(1); -- Person = 'T'
-----------------------------------------------
		Declare @ID numeric(22, 0);
		Declare @FC01 nvarchar(30);   -- FIOKKOD
		Declare @FC02 nvarchar(24);   -- BANKSZAMLASZAM
		Declare @FC03 nvarchar(3);   -- ALSZAMLASZAM
		Declare @FC04 nvarchar(2);   -- FORRASRENDSZERID
		Declare @FC05 nvarchar(20);   -- SZERZODESDATUM
		Declare @FC06 nvarchar(8);   -- UGYFELSZAM
		Declare @FC07 nvarchar(200);   -- CIMTIPUSID
		Declare @FC08 nvarchar(35);   -- IRSZAM
		Declare @FC09 nvarchar(35);   -- VAROS
		Declare @FC10 nvarchar(35);   -- UTCA
		Declare @FC11 nvarchar(15);   -- HAZSZAM
		Declare @FC12 nvarchar(80);   -- SZABADSZOVEGESCIM
		Declare @FC13 nvarchar(50);   -- CIMERVENYESSEG
		Declare @FC14 nvarchar(22);   -- CIMID
		Declare @FC15 nvarchar(22);   -- CEGID
		Declare @FC16 nvarchar(22);   -- UGYID
		Declare @FC17 nvarchar(2);   -- MODOSITASSORSZAM
		Declare @FC18 nvarchar(200);   -- ORSZAGNEV
		Declare @FC19 nvarchar(200);   -- ORSZAGKOD
		Declare @TFileName nvarchar(500);   -- 
		Declare @TInterfaceStatusCode nvarchar(200);   -- 
		Declare @TErrorMessage nvarchar(200);   -- 
		--Declare @LErrorMessage nvarchar(200);   -- 
		Declare @Filler1 nvarchar(200);   -- 
		Declare @RankFC06 nvarchar(50);

		Declare @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		Declare @l_ObjectID numeric(18);
		Declare @l_Address_InterfaceTableID numeric(18);
		
		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);
		Declare @l_FC07 nvarchar(200);   -- CIMTIPUSID

		Declare @l_ErrorExists int; /* Nem volt hiba: 1, Volt hiba: 99 */

		

		Set @l_AllRowCounts = 0;
		Set @l_ImportedRowCounts = 0;
		Set @l_ErrorRowCounts = 0;

-- Address InterfaceTableID:
		IF not exists (select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.Address')
			BEGIN
				-- New ObjectID:
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
				SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				SET @l_ObjectID = @@Identity;

				Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUserName)
				Select 
					@l_ObjectID as l_ObjectID, 
					@p_InterfacePackageID as l_InterfacePackageID, 
					'IFC.Address' as l_InterfaceTableName, 
					NULL as l_DocumentID, 
					NULL as l_SheetNr, 
					NULL as l_FolderID, 
					CAST( GETDATE() AS Date ) as l_CreationDate, 
					CAST( GETDATE() AS Time ) as l_CreationTime, 
					@CurrentUserName as l_CreationUserName;

					SET @l_Address_InterfaceTableID = @@Identity;
			END
		ELSE
			BEGIN
				SET @l_Address_InterfaceTableID = (select ID from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.Address');
			END;


		Set @l_AllRowCounts = (Select Count(*) FROM IFC.OTP_TA_FC where InterfaceStatusCode = 'INTERFACE_STATUS_NEW');

		DECLARE db_cursor CURSOR FOR 
		SELECT 
			ID, FC01, FC02, FC03, FC04, FC05, FC06, FC07, FC08, FC09, FC10, FC11, FC12, FC13, FC14, FC15, FC16, FC17, FC18, FC19,
			FC06 + '/' + Cast(RANK() OVER(PARTITION BY FC06 ORDER BY FC06, ID) as nvarchar(10)) as RankFC06
		FROM IFC.OTP_TA_FC

		where InterfaceStatusCode = 'INTERFACE_STATUS_NEW' Order by Id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID, @FC01, @FC02, @FC03, @FC04, @FC05, @FC06, @FC07, @FC08, @FC09, @FC10, @FC11, @FC12, @FC13, @FC14, @FC15, @FC16, @FC17, @FC18, @FC19, @RankFC06;

		WHILE @@FETCH_STATUS = 0  
		BEGIN  

-- Company SourceID Search:
/* 2023-01-17
		Set @l_Company = NULL;
		Set @l_ImportID = 0;

		IF EXISTS (
			Select 1 from PRT.Entity
			join Prt.Company on Company.EntityID = Entity.ID
			where Entity.SourceInterfaceType = @p_SourceInterfaceType and Entity.SourceID = @FC06)
		--THEN 
		Set @l_Company = 'T';

		IF @l_Company is NULL 
		AND EXISTS (
			Select 1 from IFC.Company
			where SourceInterfaceType = @p_SourceInterfaceType and SourceID = @FC06)
		--THEN 
		Set @l_Company = 'T';
*/

-- Person SourceID Search:
/* 2023-01-17
		Set @l_Person = NULL;

		IF EXISTS (
			Select 1 from PRT.Entity
			join Prt.Person on Person.EntityID = Entity.ID
			where Entity.SourceInterfaceType = @p_SourceInterfaceType and Entity.SourceID = @FC06)
		--THEN 
		Set @l_Person = 'T';

		IF @l_Person is NULL 
		AND EXISTS (
			Select 1 from IFC.Person
			where SourceInterfaceType = @p_SourceInterfaceType and SourceID = @FC06)
		--THEN 
		Set @l_Person = 'T';


-- Error Section:
		Set @LErrorMessage = NULL;
		IF @l_Company is NULL and @l_Person is NULL
			Set @LErrorMessage = 'Company or Person not exists';

*/		
		Set @l_ErrorExists = 1;

/*
		IF COALESCE(@LErrorMessage, '') = ''
			SET @l_ErrorExists = 1 else SET @l_ErrorExists = 99;
*/

-- Insert Section:
		--IF @LErrorMessage is NULL
		--	BEGIN

				IF Isnull(@FC18,'') <> ''
				Begin
					if exists (Select 1 from Gen.Translation where CodeID like 'COUNTRY_%' and Text = Trim(@FC18))
						Set @FC19 = (Select Top 1 CodeID from Gen.Translation where CodeID like 'COUNTRY_%' and Text = Trim(@FC18) order by id desc);
				End;

				--IF @l_Company = 'T' 
				-- THEN
				--	BEGIN
						/*
						Set @l_FC07 = ( Case @FC07
										When '01' Then 'ADDRESS_TYPE_COMPANY_HEADQUARTERS'
										When '03' Then 'ADDRESS_TYPE_COMPANY_HEADQUARTERS'
										When '05' Then 'ADDRESS_TYPE_COMPANY_MAILING'
										When '07' Then 'ADDRESS_TYPE_COMPANY_MAILING'
									End);
						*/
						INSERT INTO IFC.ADDRESS (
						  SourceInterfaceType,
						  SourceId,
						  SourcePersonId,
						  SourceCompanyId,
						  AddressType,
						  ZipCode,
						  City,
						  Street,
						  HouseNr,
						  Country,
						  CountryCode,
						  InterfaceStatusCode,
						  InterfaceTableID,
						  CreationDate,
						  CreationUserName,
						  CreationTime
						  )
						SELECT
						  @p_SourceInterfaceType,
						  @RankFC06, -- SourceId
						  @FC06, -- SourcePersonId
						  @FC06, -- SourceCompanyId
						  --@l_FC07, -- AddressType
						  'TAFC' + @FC07, -- AddressType
						  @FC08, -- ZipCode 
						  @FC09, -- City
						  @FC10, -- Street
						  @FC11, -- HouseNr
						  @FC18, -- Country
						  @FC19, -- CountryID
						  'INTERFACE_STATUS_NEW',   -- InterfaceStatusCode
						  @l_Address_InterfaceTableID,
						  CAST( GETDATE() AS Date ),
						  @CurrentUserName,
						  CAST( GETDATE() AS Time );
						SET @l_ImportID = @@Identity;
					--END;

/*
				IF @l_Person = 'T' 
					-- THEN
					BEGIN
						Set @l_FC07 = ( Case @FC07
										When '01' Then 'ADDRESS_TYPE_PERSON_PERMANENT'
										When '03' Then 'ADDRESS_TYPE_PERSON_PERMANENT'
										When '05' Then 'ADDRESS_TYPE_PERSON_RESIDENCE'
										When '07' Then 'ADDRESS_TYPE_PERSON_RESIDENCE'
									End);
						INSERT INTO IFC.ADDRESS (
						  SourceInterfaceType,
						  SourceId,
						  SourcePersonId,
						  --SourceCompanyId,
						  AddressType,
						  ZipCode,
						  City,
						  Street,
						  HouseNr,
						  Country,
						  CountryCode,
						  InterfaceStatusCode,
						  InterfaceTableID,
						  CreationDate,
						  CreationUserName,
						  CreationTime
						  )
						SELECT
						  @p_SourceInterfaceType,
						  @RankFC06, -- SourceId
						  @FC06, -- SourcePersonId
						  --@FC06, -- SourceCompanyId
						  @l_FC07, -- AddressType
						  @FC08, -- ZipCode 
						  @FC09, -- City
						  @FC10, -- Street
						  @FC11, -- HouseNr
						  @FC18, -- Country
						  @FC19, -- CountryID
						  'INTERFACE_STATUS_NEW',   -- InterfaceStatusCode
						  @l_Address_InterfaceTableID,
						  CAST( GETDATE() AS Date ),
						  @CurrentUserName,
						  CAST( GETDATE() AS Time );
						SET @l_ImportID = @@Identity;
				END;
*/
				IF @l_ImportID <> 0
				BEGIN
						UPDATE IFC.OTP_TA_FC SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage = NULL where ID = @ID;
						Set @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
				END;
			--END /* @LErrorMessage is NULL */
			--ELSE
			--	BEGIN
			--		UPDATE IFC.OTP_TA_FC SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @LErrorMessage where ID = @ID;
			--		Set @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
			--	END;



			FETCH NEXT FROM db_cursor INTO @ID, @FC01, @FC02, @FC03, @FC04, @FC05, @FC06, @FC07, @FC08, @FC09, @FC10, @FC11, @FC12, @FC13, @FC14, @FC15, @FC16, @FC17, @FC18, @FC19, @RankFC06;

		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    COMMIT TRANSACTION;

    END TRY


    BEGIN CATCH

        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FC_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;				-- LogMessage

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        ROLLBACK TRANSACTION;

        --RETURN @ErrorMessage;
		Return 99;


    END CATCH;


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FC_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + ', ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18))  + ', ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) -- LogMessage



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FC_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage

	If Isnull(@ErrorMessage,'') <> ''
		RETURN 99;
	else
		RETURN @l_ErrorExists;


END;

/*


update IFC.OTP_TA_FC set interfacestatusCode='INTERFACE_STATUS_NEW';

select interfacestatusCode,* from IFC.OTP_TA_FC;

CLOSE db_cursor;
DEALLOCATE db_cursor;

Declare @hiba NVARCHAR(200);
exec @hiba = IFC.TA_FC_Loader 1, 'Masodik-teszt', 20059;
Select @hiba;

select interfacestatusCode,* from IFC.OTP_TA_FC;


select * from LOG.LOG order by id desc

delete 
delete IFC.Address where creationdate = '2022-11-10';
delete IFC.InterfaceTable where InterfacePackageID = 20059;


select * from IFC.ADDRESS where creationdate = '2022-11-10'
select count(*) from IFC.ADDRESS  --2174

Select * from IFC.InterfacePackage where InterfaceTableName = 'IFC.Address' 
Select * from IFC.InterfaceTable order by id desc


*/
go


CREATE   PROCEDURE [IFC].[TA_FF_Loader](@p_CorrelationID nVarchar(200), @p_SourceInterfaceType nVarchar(200), @p_InterfacePackageID Numeric(16))

-- =====================================================================================================================
/*
 Author:				Tóth Gábor
 Creation date:			2022.11.30.
 Last modified date:	2022.12.06: @FF27 validation
						2022.12.07: 'ASSET_TYPE_' + Trim(@FF12)
						2022.12.07: 'ADDRESS_TYPE_ASSET_LOCATION' as AddressType
						2022.12.08: @@Identity kommentelése
						2022.12.14: SourceDebtCaseId = @FF02
						2023-01-27: Ha FF10 (Name) = üres, akkkor FF10 (Name) := ff19 (City) + ' '  + ff13 (Hrsz)
						2023-02-07: Értékkészlet változtatás: 'ASSET_PROPERTY_TYPE_3'
						2023-02-08: (select Top 1 ID from Gen.Portfolio where TreatmentTypeCode = 'TREATMENT_TYPE_ASSIGNMENT' order by ID desc)
						2023-02-08: DebtorAsset töltés kommentelése, mert megszűnt az IFC.DebtorAsset tábla
						2023-02-09: @CurrentUserName
						2023-02-09: @l_AssetClass
						2023-02-13: Cast(@l_AssetType as Numeric(2)), Cast(@l_AssetType as Numeric(2))
						2023-03-09: 'ASSET_STATUS_OWNED_BY_DEBTOR' as Status, /* 2023-03-09 ba Karesz */
						2023-04-13: OBJECT_TYPE_IFC_INTERFACETABLE
						2023-04-14: Return 99;

						
 Description:	DataTranfer From IFT.OTP_FF to ...
 */
-- =====================================================================================================================

AS

BEGIN
	SET NOCOUNT ON;
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;

    DECLARE @LogMessage NVARCHAR(200);

	SET @ErrorMessage = '';
	SET @ErrorSeverity = 0;
	SET @ErrorState = 0;
	SET @ErrorLine = 0;

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);

	/*
	Set @CurrentUser = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));

	Set @CurrentUserName = 0;
	If exists (select 1 from PRT.AppUser where UserName = @CurrentUser)
		Set @CurrentUserName = (select Top 1 ID from PRT.AppUser where UserName = @CurrentUser order by ID);
	ELSE
		Set @ErrorMessage = 'Current user id not defined (' + @CurrentUser + ')';
	*/

	/*Set @CurrentUserName = 'Admin'; 2023-02-09*/
	Set @CurrentUserName = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));

   
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FF_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage


    BEGIN TRY
        SET @LogMessage = 'Asset Loader Started';
		
-----------------------------------------------
		Declare @ID numeric(22, 0);
		Declare @FF01  nvarchar (30);   -- FIOKKOD
		Declare @FF02  nvarchar (24);   -- BANKSZAMLASZAM
		Declare @FF03  nvarchar (3);   -- ALSZAMLASZAM
		Declare @FF04  nvarchar (2);   -- FORRASRENDSZERID			Asset.SourceInterfaceType?
		Declare @FF05  nvarchar (20);   -- SZERZODESSZAM
		Declare @FF06  nvarchar (30);   -- FEDEZETAZONOSITOID		Asset.SourceID
		Declare @FF08  nvarchar (5);   -- TULAJDONIHANYAD			DebtorAsset.ShareDividend '/' DebtorAsset.ShareDivisor
		Declare @FF07  nvarchar (30);   -- TULAJDONRESZAZONOSITO	DebtorAsset.SourceID
		Declare @FF09  nvarchar (22);   -- TULAJDONIHANYADSZAZALEK	DebtorAsset.SharePercent
		Declare @FF10  nvarchar (30);   -- MEGNEVEZES				- IFC.AssetName
		Declare @FF11  nvarchar (2);   -- TATIPUSID				Asset.AssetClass	
		Declare @FF12  nvarchar (2);   -- TAJELLEGID				Asset.AssetType
		Declare @FF13  nvarchar (24);   -- HRSZ						Asset.LandRegisterReference
		Declare @FF14  nvarchar (24);   -- (NEM KELL) JZ_OKIRATSZAM
		Declare @FF15  nvarchar (50);   -- (NEM KELL) JZ_BEJEGYZESDATUM
		Declare @FF16  nvarchar (50);   -- (NEM KELL) VHJOGHATAROZATSZAM
		Declare @FF17  nvarchar (50);   -- (NEM KELL) VHBEJEGYZESDATUM
		Declare @FF18  nvarchar (35);   -- IRSZAM					--IFC.Address, Balázs tudja
		Declare @FF19  nvarchar (35);   -- HELYSEG					--IFC.Asset.LandRegisterCity + IFC.Address.City, de Balázs tudja
		Declare @FF20  nvarchar (35);   -- UTCA						--IFC.Address, Balázs tudja
		Declare @FF21  nvarchar (15);   -- HAZSZAM					--IFC.Address, Balázs tudja
		Declare @FF22  nvarchar (80);   -- SZABADSZOVEGESCIM		--IFC.Address, Balázs tudja
		Declare @FF23  nvarchar (22);   -- FORGALMIERTEK			--IFC.AssetValuation, IFC.AssetValuationValue  0 érték nem kell!
		Declare @FF24  nvarchar (22);   -- MENEKULESIERTEK			--IFC.AssetValuation, IFC.AssetValuationValue  0 érték nem kell!
		Declare @FF25  nvarchar (22);   -- VALOSFORGALMIERTEK		--IFC.AssetValuation, IFC.AssetValuationValue  0 érték nem kell!
		Declare @FF26  nvarchar (22);   -- VALOSMENEKULESIERTEK		--IFC.AssetValuation, IFC.AssetValuationValue  0 érték nem kell!
		Declare @FF27  nvarchar (50);   -- '(yyymmdd) UTOLSO_ERTEKBECSLES_DATUMA  --IFC.AssetValuation, IFC.AssetValuationValue
		Declare @FF28  nvarchar (8);   -- TULAJDONOSUGYFELKOD		-- valahogy IFC.AssetDebtor??
		Declare @FF29  nvarchar (22);   -- (ÜRES) FEDEZETID
		Declare @FF30  nvarchar (22);   -- (ÜRES) CEGID
		Declare @FF31  nvarchar (22);   -- (ÜRES) UGYID
		Declare @FF32  nvarchar (2);   -- MODOSITASSORSZAM
		Declare @FileName nvarchar (500);   -- FileName
		Set @FileName = '';
	
		Declare @RankFF06 nvarchar (50); -- SourceID

		Declare @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		
		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);

		Declare @l_PortfolioID numeric(16);
		/*Set @l_PortfolioID = 3;*/
		Set @l_PortfolioID = (select Top 1 ID from Gen.Portfolio where TreatmentTypeCode = 'TREATMENT_TYPE_ASSIGNMENT' order by ID desc);
		
		Set @l_AllRowCounts = 0;
		Set @l_ImportedRowCounts = 0;
		Set @l_ErrorRowCounts = 0;

  		Declare @l_InterfacePackageID numeric(18);
		Declare @l_ObjectID numeric(18);
		Declare @l_InterfaceTableID numeric(18);
		Declare @l_Asset_InterfaceTableID numeric(18);
		Declare @l_AssetValuation_InterfaceTableID numeric(18);
		Declare @l_AssetValuationValue_InterfaceTableID numeric(18);
		Declare @l_Address_InterfaceTableID numeric(18);
		/*Declare @l_DebtorAsset_InterfaceTableID numeric(18); 2023-02-08*/
		Declare @l_DebtCaseAsset_InterfaceTableID numeric(18);
		Declare @l_EntityAsset_InterfaceTableID numeric(18);

		DECLARE @l_AssetType NVARCHAR(200) = NULL;
		Declare @l_AssetClass NVARCHAR(200) = NULL;
		
					
-- Asset InterfaceTableID:
		-- New ObjectID:
		INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr, PortfolioID)
		SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @l_PortfolioID;
		SET @l_ObjectID = @@Identity;

		Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUserName)
		Select 
			@l_ObjectID as l_ObjectID, 
			@p_InterfacePackageID as l_InterfacePackageID, 
			'IFC.Asset' as l_InterfaceTableName, 
			NULL as l_DocumentID, 
			NULL as l_SheetNr, 
			NULL as l_FolderID, 
			CAST( GETDATE() AS Date ) as l_CreationDate, 
			CAST( GETDATE() AS Time ) as l_CreationTime, 
			@CurrentUserName as l_CreationUserName 

		where not exists (Select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.Asset');
		--SET @l_Asset_InterfaceTableID = @@Identity;
		SET @l_Asset_InterfaceTableID = (Select Top 1 InterfaceTable.ID from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.Asset' order by InterfaceTable.ID desc);

-- AssetValuation InterfaceTableID:
		-- New ObjectID:
		INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr, PortfolioID)
		SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @l_PortfolioID;
		SET @l_ObjectID = @@Identity;

		Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUserName)
		Select 
			@l_ObjectID as l_ObjectID, 
			@p_InterfacePackageID as l_InterfacePackageID, 
			'IFC.AssetValuation' as l_InterfaceTableName, 
			NULL as l_DocumentID, 
			NULL as l_SheetNr, 
			NULL as l_FolderID, 
			CAST( GETDATE() AS Date ) as l_CreationDate, 
			CAST( GETDATE() AS Time ) as l_CreationTime, 
			@CurrentUserName as l_CreationUserName 
		where not exists (Select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.AssetValuation');
		--SET @l_AssetValuation_InterfaceTableID = @@Identity;
		SET @l_AssetValuation_InterfaceTableID = (Select Top 1 InterfaceTable.ID from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.AssetValuation' order by InterfaceTable.ID desc);


-- AssetValuationValue InterfaceTableID:
		-- New ObjectID:
		INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr, PortfolioID)
		SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @l_PortfolioID;
		SET @l_ObjectID = @@Identity;

		Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUserName)
		Select 
			@l_ObjectID as l_ObjectID, 
			@p_InterfacePackageID as l_InterfacePackageID, 
			'IFC.AssetValuationValue'  as l_InterfaceTableName, 
			NULL as l_DocumentID, 
			NULL as l_SheetNr, 
			NULL as l_FolderID, 
			CAST( GETDATE() AS Date ) as l_CreationDate, 
			CAST( GETDATE() AS Time ) as l_CreationTime, 
			@CurrentUserName as l_CreationUserName 
		where not exists (Select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.AssetValuationValue');
		--SET @l_AssetValuationValue_InterfaceTableID = @@Identity;
		SET @l_AssetValuationValue_InterfaceTableID = (Select Top 1 InterfaceTable.ID from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.AssetValuationValue' order by InterfaceTable.ID desc);


-- Address InterfaceTableID:
		-- New ObjectID:
		INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
		SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
		SET @l_ObjectID = @@Identity;

		Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUserName)
		Select 
			@l_ObjectID as l_ObjectID, 
			@p_InterfacePackageID as l_InterfacePackageID, 
			'IFC.Address' as l_InterfaceTableName, 
			NULL as l_DocumentID, 
			NULL as l_SheetNr, 
			NULL as l_FolderID, 
			CAST( GETDATE() AS Date ) as l_CreationDate, 
			CAST( GETDATE() AS Time ) as l_CreationTime, 
			@CurrentUserName as l_CreationUserName 
		where not exists (Select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.Address');
		--SET @l_Address_InterfaceTableID = @@Identity;
		SET @l_Address_InterfaceTableID = (Select Top 1 InterfaceTable.ID from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.Address' order by InterfaceTable.ID desc);

-- DebtorAsset InterfaceTableID:
		-- New ObjectID:
/* 2023-02-08
		INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
		SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
		SET @l_ObjectID = @@Identity;

		Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUserName)
		Select 
			@l_ObjectID as l_ObjectID, 
			@p_InterfacePackageID as l_InterfacePackageID, 
			'IFC.DebtorAsset' as l_InterfaceTableName, 
			NULL as l_DocumentID, 
			NULL as l_SheetNr, 
			NULL as l_FolderID, 
			CAST( GETDATE() AS Date ) as l_CreationDate, 
			CAST( GETDATE() AS Time ) as l_CreationTime, 
			@CurrentUserName as l_CreationUserName 
		where not exists (Select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.DebtorAsset');
		--SET @l_DebtorAsset_InterfaceTableID = @@Identity;
		SET @l_DebtorAsset_InterfaceTableID = (Select Top 1 InterfaceTable.ID from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.DebtorAsset' order by InterfaceTable.ID desc);
*/

-- DebtCaseAsset InterfaceTableID:
		-- New ObjectID:
		INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
		SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
		SET @l_ObjectID = @@Identity;

		Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUserName)
		Select 
			@l_ObjectID as l_ObjectID, 
			@p_InterfacePackageID as l_InterfacePackageID, 
			'IFC.DebtCaseAsset' as l_InterfaceTableName, 
			NULL as l_DocumentID, 
			NULL as l_SheetNr, 
			NULL as l_FolderID, 
			CAST( GETDATE() AS Date ) as l_CreationDate, 
			CAST( GETDATE() AS Time ) as l_CreationTime, 
			@CurrentUserName as l_CreationUserName 
		where not exists (Select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.DebtCaseAsset');
		--SET @l_DebtCaseAsset_InterfaceTableID = @@Identity;
		SET @l_DebtCaseAsset_InterfaceTableID = (Select Top 1 InterfaceTable.ID from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.DebtCaseAsset' order by InterfaceTable.ID desc);

-- EntityAsset InterfaceTableID:
		-- New ObjectID:
		INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
		SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
		SET @l_ObjectID = @@Identity;

		Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUserName)
		Select 
			@l_ObjectID as l_ObjectID, 
			@p_InterfacePackageID as l_InterfacePackageID, 
			'IFC.EntityAsset' as l_InterfaceTableName, 
			NULL as l_DocumentID, 
			NULL as l_SheetNr, 
			NULL as l_FolderID, 
			CAST( GETDATE() AS Date ) as l_CreationDate, 
			CAST( GETDATE() AS Time ) as l_CreationTime, 
			@CurrentUserName as l_CreationUserName 
		where not exists (Select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.EntityAsset');
		--SET @l_EntityAsset_InterfaceTableID = @@Identity;
		SET @l_EntityAsset_InterfaceTableID = (Select Top 1 InterfaceTable.ID from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and Isnull(InterfaceTableName,'') = 'IFC.EntityAsset' order by InterfaceTable.ID desc);

		Set @l_AllRowCounts = (Select Count(*) FROM IFC.OTP_TA_FF where InterfaceStatusCode = 'INTERFACE_STATUS_NEW');

		DECLARE db_cursor CURSOR FOR 
		SELECT ID, FF01, FF02, FF03, FF04, FF05, FF06, FF08, FF07, FF09, FF10, FF11, FF12, FF13, FF14, FF15, 
			FF16, FF17, FF18, FF19, FF20, FF21, FF22, FF23, FF24, FF25, FF26, FF27, FF28, FF29, FF30, FF31, FF32, [FileName],
			Trim(FF06) + '/' + Cast(RANK() OVER(PARTITION BY FF05, Trim(FF06) ORDER BY FF05, Trim(FF06), ID) as nVarchar(10)) as RankFF06
		FROM IFC.OTP_TA_FF
		where InterfaceStatusCode = 'INTERFACE_STATUS_NEW' Order by Id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID, @FF01, @FF02, @FF03, @FF04, @FF05, @FF06, @FF08, @FF07, @FF09, @FF10, @FF11, @FF12, @FF13, @FF14, @FF15, 
			@FF16, @FF17, @FF18, @FF19, @FF20, @FF21, @FF22, @FF23, @FF24, @FF25, @FF26, @FF27, @FF28, @FF29, @FF30, @FF31, @FF32, @FileName, @RankFF06;

		WHILE @@FETCH_STATUS = 0  
		BEGIN  

		Set @ErrorMessage = NULL;
		Set @l_ImportID = 0;

		If Isnull(@FF27,'') <> '' and len(@FF27) <> 8
			Set @ErrorMessage = 'Not valid Date: ' + Isnull(@FF27,'');

		If Isnull(@FF27,'') <> '' and len(@FF27) = 8
		BEGIN
			If Isdate(LEFT(@FF27,4) + '-' + SUBSTRING(@FF27,5,2) + '-' + RIGHT(@FF27,2)) = 1
				Set @FF27 = LEFT(@FF27,4) + '-' + SUBSTRING(@FF27,5,2) + '-' + RIGHT(@FF27,2);
			Else
				Set @ErrorMessage = 'Not valid Date: ' + Isnull(@FF27,'');
		END;

		IF  @ErrorMessage is NULL
		BEGIN
			SELECT @l_AssetType = CASE Cast(TRIM(@FF12) as numeric(2))
				WHEN '1' THEN 'ASSET_PROPERTY_TYPE_2' /*'ASSET_TYPE_2'*/ /* Lakó */
				WHEN '2' THEN 'ASSET_PROPERTY_TYPE_2' /*'ASSET_TYPE_2'*/ /* Ház */
				WHEN '3' THEN 'ASSET_PROPERTY_TYPE_2' /*'ASSET_TYPE_2'*/ /* Nyaraló */
				WHEN '5' THEN 'ASSET_PROPERTY_TYPE_1' /*'ASSET_TYPE_1'*/ /* mg-i ingatlan */
				WHEN '6' THEN 'ASSET_PROPERTY_TYPE_4' /*'ASSET_TYPE_4'*/ /* ipari ingatlan */
				WHEN '7' THEN 'ASSET_PROPERTY_TYPE_3' /*'ASSET_TYPE_3'*/ /* irodaház */
				ELSE 'ASSET_PROPERTY_TYPE_5' /*'ASSET_TYPE_5'*/ /* egyéb */
			END
			SELECT @l_AssetClass = CASE Cast(TRIM(@FF11) as numeric(2))
				WHEN '1' THEN 'ASSET_CLASS_PROPERTY' /* ingatlan */
				WHEN '2' THEN 'ASSET_CLASS_CHATTEL'  /* Ingó */
				ELSE 'ASSET_CLASS_CHATTEL' /* Ingó */
			END
---------------------------------------------------------------------------
			Insert Into IFC.Asset (AssetClass, AssetClassText, AssetType, AssetTypeText, Name, LandRegisterCity, LandRegisterReference, Status, StatusText, LandRegisterOfficeEntityID, ExternalReferenceNr, StructureSize, LotSize, LotSizeUnitCode, LotSizeUnitText, InhabitedCode, InhabitedText, RentedOutCode, RentedOutText, UndividedCommonPropertyCode, UndividedCommonPropertyText, DataOriginCode, DataOriginText, AssetID, SourceInterfaceType, SourceID, InterfaceStatusCode, ErrorMessage, InterfaceTableID, CreationDate, CreationTime, CreationUserName, PortfolioName, PortfolioID)
				Select 
				@l_AssetClass as AssetClass, 
				NULL as AssetClassText, 
				@l_AssetType as AssetType, 
				NULL as AssetTypeText, 
				Case When Isnull(@FF10,'') = '' 
					Then 
						Cast(@FF19 as Nvarchar(500)) + ' ' + Cast(@FF13 as Nvarchar(500))
					Else @FF10
					End as [Name],
				NULL as LandRegisterCity, 
				@FF13 as LandRegisterReference, 
				--'ASSET_STATUS_OWNED_BY_FACTORING' as Status, 
				'ASSET_STATUS_OWNED_BY_DEBTOR' as Status, /* 2023-03-09 ba Karesz */
				NULL as StatusText, 
				NULL as LandRegisterOfficeEntityID, 
				NULL as ExternalReferenceNr, 
				NULL as StructureSize, 
				NULL as LotSize, 
				NULL as LotSizeUnitCode, 
				NULL as LotSizeUnitText, 
				NULL as InhabitedCode, 
				NULL as InhabitedText, 
				NULL as RentedOutCode, 
				NULL as RentedOutText, 
				NULL as UndividedCommonPropertyCode, 
				NULL as UndividedCommonPropertyText, 
				NULL as DataOriginCode, 
				NULL as DataOriginText, 
				NULL as AssetID, 
				@p_SourceInterfaceType as SourceInterfaceType, 
				@FF06 as SourceID, 
				'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
				NULL as ErrorMessage, 
				@l_Asset_InterfaceTableID as InterfaceTableID, 
				CAST( GETDATE() AS Date ) as CreationDate, 
				CAST( GETDATE() AS Time ) as CreationTime, 
				@CurrentUserName as CreationUserName,
				NULL as PortfolioName, 
				@l_PortfolioID as PortfolioID;

---------------------------------------------------------------------------
			Insert Into IFC.AssetValuation (ValuerEntityID, ValuationDate, ValuationTypeCode, ValuationTypeText, ValidFrom, ValidUntil, AssetValuationID, SourceInterfaceType, SourceID, SourceAssetID, SourceCompanyID, InterfaceStatusCode, ErrorMessage, InterfaceTableID, CreationDate, CreationTime, CreationUserName)
				Select 
				NULL as ValuerEntityID, 
				@FF27 as ValuationDate, 
				NULL as ValuationTypeCode, 
				NULL as ValuationTypeText, 
				NULL as ValidFrom, 
				NULL as ValidUntil, 
				NULL as AssetValuationID, 
				@p_SourceInterfaceType as SourceInterfaceType, 
				@FF06 as SourceID, 
				@FF06 as SourceAssetID, 
				NULL as SourceCompanyID, 
				'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
				NULL as ErrorMessage, 
				@l_AssetValuation_InterfaceTableID as InterfaceTableID, 
				CAST( GETDATE() AS Date ) as CreationDate, 
				CAST( GETDATE() AS Time ) as CreationTime, 
				@CurrentUserName as CreationUserName;
				
---------------------------------------------------------------------------
-- 'NetValue', -- 'Forgalmi érték' -- 'ASSET_VALUATION_VALUE_TYPE_MARKET'
			Insert Into IFC.AssetValuationValue (ValueTypeCode, ValueTypeText, NetValue, VatRate, VatValue, GrossValue, ValueCurrencyCode, ValueCurrencyText, AssetValuationValueID, AssetValuationID, SourceInterfaceType, SourceID, SourceAssetValuationID, InterfaceStatusCode, ErrorMessage, InterfaceTableID, CreationDate, CreationTime, CreationUserName)
				Select 
				'ASSET_VALUATION_VALUE_TYPE_MARKET' as ValueTypeCode, 
				NULL as ValueTypeText, 
				Cast(@FF23 as money) as NetValue, -- Forgalmi érték
				NULL as VatRate,  -- Valós menekülési érték
				NULL as VatValue, 		-- Valós forgalmi érték
				NULL as GrossValue,	-- Menekülési érték
				NULL as ValueCurrencyCode, 
				NULL as ValueCurrencyText, 
				NULL as AssetValuationValueID, 
				NULL as AssetValuationID, 
				@p_SourceInterfaceType as SourceInterfaceType, 
				@FF06 + '/1' as SourceID, 
				@FF06 as SourceAssetValuationID, 
				'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
				NULL as ErrorMessage, 
				@l_AssetValuationValue_InterfaceTableID as InterfaceTableID, 
				CAST( GETDATE() AS Date ) as CreationDate, 
				CAST( GETDATE() AS Time ) as CreationTime, 
				@CurrentUserName as CreationUserName
				where Cast(@FF23 as money) <> 0;

-- 'VatRate',  -- 'Valós menekülési érték' -- 'ASSET_VALUATION_VALUE_TYPE_LIQUIDATION'
			Insert Into IFC.AssetValuationValue (ValueTypeCode, ValueTypeText, NetValue, VatRate, VatValue, GrossValue, ValueCurrencyCode, ValueCurrencyText, AssetValuationValueID, AssetValuationID, SourceInterfaceType, SourceID, SourceAssetValuationID, InterfaceStatusCode, ErrorMessage, InterfaceTableID, CreationDate, CreationTime, CreationUserName)
				Select 
				'ASSET_VALUATION_VALUE_TYPE_LIQUIDATION' as ValueTypeCode, 
				NULL as ValueTypeText, 
				NULL as NetValue, -- Forgalmi érték
				Cast(@FF26 as Numeric(10)) as VatRate,  -- Valós menekülési érték
				NULL as VatValue, 		-- Valós forgalmi érték
				NULL as GrossValue,	-- Menekülési érték
				NULL as ValueCurrencyCode, 
				NULL as ValueCurrencyText, 
				NULL as AssetValuationValueID, 
				NULL as AssetValuationID, 
				@p_SourceInterfaceType as SourceInterfaceType, 
				@FF06 + '/2' as SourceID, 
				@FF06 as SourceAssetValuationID, 
				'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
				NULL as ErrorMessage, 
				@l_AssetValuationValue_InterfaceTableID as InterfaceTableID, 
				CAST( GETDATE() AS Date ) as CreationDate, 
				CAST( GETDATE() AS Time ) as CreationTime, 
				@CurrentUserName as CreationUserName
				where Cast(@FF26 as Numeric(10)) <> 0;

-- 'VatValue' 	-- 'Valós forgalmi érték' -- 'ASSET_VALUATION_VALUE_TYPE_READY_TO_MOVE'
			Insert Into IFC.AssetValuationValue (ValueTypeCode, ValueTypeText, NetValue, VatRate, VatValue, GrossValue, ValueCurrencyCode, ValueCurrencyText, AssetValuationValueID, AssetValuationID, SourceInterfaceType, SourceID, SourceAssetValuationID, InterfaceStatusCode, ErrorMessage, InterfaceTableID, CreationDate, CreationTime, CreationUserName)
				Select 
				'ASSET_VALUATION_VALUE_TYPE_READY_TO_MOVE' as ValueTypeCode, 
				NULL as ValueTypeText, 
				NULL as NetValue, -- Forgalmi érték
				NULL as VatRate,  -- Valós menekülési érték
				Cast(@FF25 as money) as VatValue, 	-- Valós forgalmi érték
				NULL as GrossValue,	-- Menekülési érték
				NULL as ValueCurrencyCode, 
				NULL as ValueCurrencyText, 
				NULL as AssetValuationValueID, 
				NULL as AssetValuationID, 
				@p_SourceInterfaceType as SourceInterfaceType, 
				@FF06 + '/3' as SourceID, 
				@FF06 as SourceAssetValuationID, 
				'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
				NULL as ErrorMessage, 
				@l_AssetValuationValue_InterfaceTableID as InterfaceTableID, 
				CAST( GETDATE() AS Date ) as CreationDate, 
				CAST( GETDATE() AS Time ) as CreationTime, 
				@CurrentUserName as CreationUserName
				where Cast(@FF25 as Numeric(10)) <> 0;

-- 'GrossValue' -- 'Menekülési érték' -- 'ASSET_VALUATION_VALUE_TYPE_ESCAPE'
			Insert Into IFC.AssetValuationValue (ValueTypeCode, ValueTypeText, NetValue, VatRate, VatValue, GrossValue, ValueCurrencyCode, ValueCurrencyText, AssetValuationValueID, AssetValuationID, SourceInterfaceType, SourceID, SourceAssetValuationID, InterfaceStatusCode, ErrorMessage, InterfaceTableID, CreationDate, CreationTime, CreationUserName)
				Select 
				'ASSET_VALUATION_VALUE_TYPE_ESCAPE' as ValueTypeCode, 
				NULL as ValueTypeText, 
				NULL as NetValue, -- Forgalmi érték
				NULL as VatRate,  -- Valós menekülési érték
				NULL as VatValue, -- Valós forgalmi érték
				Cast(@FF24 as money) as GrossValue,	-- Menekülési érték
				NULL as ValueCurrencyCode, 
				NULL as ValueCurrencyText, 
				NULL as AssetValuationValueID, 
				NULL as AssetValuationID, 
				@p_SourceInterfaceType as SourceInterfaceType, 
				@FF06 + '/4' as SourceID, 
				@FF06 as SourceAssetValuationID, 
				'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
				NULL as ErrorMessage, 
				@l_AssetValuationValue_InterfaceTableID as InterfaceTableID, 
				CAST( GETDATE() AS Date ) as CreationDate, 
				CAST( GETDATE() AS Time ) as CreationTime, 
				@CurrentUserName as CreationUserName
				where Cast(@FF24 as Numeric(10)) <> 0;

---------------------------------------------------------------------------
			Insert Into IFC.Address (ObjectID, SourceInterfaceType, SourceID, SourceCompanyID, SourcePersonID, RegistrationNr, TaxNr, StatisticalNr, AddressType, Country, CountryCode, CountryID, ZipCode, City, Street, HouseNr, FullAddress, Description, ValidFrom, ValidUntil, Field1, Field2, Field3, Field4, Field5, CrefoID, InterfaceStatusCode, ErrorMessage, ActualisationDate, Operation, InterfaceTableID, MainAddress, CreationDate, CreationTime, CreationUserName, SourceAssetID)
			Select 
				NULL as ObjectID, 
				@p_SourceInterfaceType as SourceInterfaceType, 
				@RankFF06 as SourceID, 
				NULL as SourceCompanyID, 
				NULL as SourcePersonID, 
				NULL as RegistrationNr, 
				NULL as TaxNr, 
				NULL as StatisticalNr, 
				'ADDRESS_TYPE_ASSET_LOCATION' as AddressType, 
				NULL as Country, 
				NULL as CountryCode, 
				NULL as CountryID, 
				@FF18 as ZipCode, 
				@FF19 as City, 
				@FF20 as Street, 
				@FF21 as HouseNr, 
				@FF22 as FullAddress, 
				NULL as Description, 
				NULL as ValidFrom, 
				NULL as ValidUntil, 
				NULL as Field1, 
				NULL as Field2, 
				NULL as Field3, 
				NULL as Field4, 
				NULL as Field5, 
				NULL as CrefoID, 
				'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
				NULL as ErrorMessage, 
				NULL as ActualisationDate, 
				NULL as Operation, 
				@l_Address_InterfaceTableID as InterfaceTableID, 
				NULL as MainAddress, 
				CAST( GETDATE() AS Date ) as CreationDate, 
				CAST( GETDATE() AS Time ) as CreationTime, 
				@CurrentUserName as CreationUserName,
				@FF06 as SourceAssetID;

---------------------------------------------------------------------------
-- nem kell, helyett EntityAsset, de azért maradjon !
/* 2022-02-08
			Insert Into IFC.DebtorAsset(AssetDebtorRelationTypeCode, AssetDebtorRelationTypeText, OwnPercent, SharePercent, ShareDividend, ShareDivisor, ValidFrom, ValidUntil, StatusCode, Status, DebtorAssetID, AssetID, DebtorID, SourceInterfaceType, SourceID, SourceAssetID, SourceDebtorID, InterfaceStatusCode, ErrorMessage, InterfaceTableID, CreationDate, CreationTime, CreationUserName)
			Select 
				NULL as AssetDebtorRelationTypeCode,
				NULL as AssetDebtorRelationTypeText,
				NULL as OwnPercent,
				NULL, --Cast(@FF08 as Numeric(5)) AS SharePercent,  -- Tulajdoni hányad % 
				Cast(@FF09  as Numeric(5)) as ShareDividend, -- Tulajdoni hányad
				NULL as ShareDivisor,
				NULL as ValidFrom,
				NULL as ValidUntil,
				NULL as StatusCode,
				NULL as Status,
				NULL as DebtorAssetID,
				NULL as AssetID,
				NULL as DebtorID,
				@p_SourceInterfaceType as SourceInterfaceType,
				@FF06 as SourceID,
				@FF06 as SourceAssetID,
				@FF28 as SourceDebtorID, -- Tulajdonos ügyfélkód
				'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
				NULL as ErrorMessage, 
				@l_DebtorAsset_InterfaceTableID as InterfaceTableID,
				CAST( GETDATE() AS Date ) as CreationDate, 
				CAST( GETDATE() AS Time ) as CreationTime, 
				@CurrentUserName as CreationUserName;
*/
---------------------------------------------------------------------------

			Insert Into IFC.DebtCaseAsset(StatusCode, StatusText, TypeCode, TypeText, DecisionNr, ValidFrom, ValidUntil, DebtCaseAssetID, AssetID, DebtCaseID, SourceInterfaceType, SourceID, SourceAssetID, SourceDebtCaseID, InterfaceStatusCode, ErrorMessage, InterfaceTableID, CreationDate, CreationTime, CreationUserName)
			Select 
				NULL as StatusCode,
				NULL as StatusText,
				NULL as TypeCode,
				NULL as TypeText,
				NULL as DecisionNr,
				NULL as ValidFrom,
				NULL as ValidUntil,
				NULL as DebtCaseAssetID,
				NULL as AssetID,
				NULL as DebtCaseID,
				@p_SourceInterfaceType as SourceInterfaceType,
				@FF06 as SourceID,
				@FF06 as SourceAssetID,
				@FF02 as SourceDebtCaseID,
				'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
				NULL as ErrorMessage, 
				@l_DebtCaseAsset_InterfaceTableID as InterfaceTableID,
				CAST( GETDATE() AS Date ) as CreationDate, 
				CAST( GETDATE() AS Time ) as CreationTime, 
				@CurrentUserName as CreationUserName;

 				SET @l_ImportID = @@Identity;
				

		END; /* IF  @ErrorMessage is NULL */

---------------------------------------------------------------------------
-- IFC.EntityAsset:

		Insert Into IFC.EntityAsset(EntityAssetRelationTypeCode, EntityAssetRelationTypeText, SharePercent, ShareDividend, ShareDivisor, ExternalReferenceNr, DecisionNr, ValidFrom, ValidUntil, StatusCode, StatusText, EntityAssetID, AssetID, EntityID, SourceInterfaceType, SourceID, SourceAssetID, SourceEntityID, InterfaceStatusCode, ErrorMessage, InterfaceTableID, CreationDate, CreationTime, CreationUserName)
			Select 
				NULL as EntityAssetRelationTypeCode,
				NULL as EntityAssetRelationTypeText,
				NULL as SharePercent,
				Cast(@FF09  as Numeric(5)) as ShareDividend,
				NULL as ShareDivisor,
				NULL as ExternalReferenceNr,
				NULL as DecisionNr,
				NULL as ValidFrom,
				NULL as ValidUntil,
				NULL as StatusCode,
				NULL as StatusText,
				NULL as EntityAssetID,
				NULL as AssetID,
				NULL as EntityID,
				@p_SourceInterfaceType as SourceInterfaceType,
				@FF06 as SourceID,
				@FF06 as SourceAssetID,
				@FF28 as SourceEntityID,
				'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
				NULL as ErrorMessage,
				@l_EntityAsset_InterfaceTableID as InterfaceTableID,
				CAST( GETDATE() AS Date ) as CreationDate, 
				CAST( GETDATE() AS Time ) as CreationTime, 
				@CurrentUserName as CreationUserName;

---------------------------------------------------------------------------
		IF @ErrorMessage is NULL
		BEGIN
			UPDATE IFC.OTP_TA_FF SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage = NULL where ID = @ID;
			SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
		END;
		ELSE
		BEGIN
			UPDATE IFC.OTP_TA_FF SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage where ID = @ID;
			Set @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
		END;

		FETCH NEXT FROM db_cursor INTO 
		@ID, @FF01, @FF02, @FF03, @FF04, @FF05, @FF06, @FF08, @FF07, @FF09, @FF10, @FF11, @FF12, @FF13, @FF14, @FF15, 
		@FF16, @FF17, @FF18, @FF19, @FF20, @FF21, @FF22, @FF23, @FF24, @FF25, @FF26, @FF27, @FF28, @FF29, @FF30, @FF31, @FF32, @FileName, @RankFF06;

		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;

		--end;

    END TRY


    BEGIN CATCH

        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FF_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;				-- LogMessage


        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        --RETURN @ErrorMessage;
		Return 99;

    END CATCH;

------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FF_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + ', ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18))  + ', ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) -- LogMessage



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FF_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If Isnull(@ErrorMessage,'') <> ''
		Return 99;
	else
		Return 1;

END;
go

CREATE   PROCEDURE [IFC].[TA_FK_Loader](@p_CorrelationID nVarchar(200), @p_SourceInterfaceType nVarchar(200), @p_InterfacePackageID Numeric(16))

-- =====================================================================================================================
/*
 Author:				Tóth Gábor
 Creation date:			2022.10.24.
 Last modified date:	2022.11.02,
						2022.11.08, InterfacStatusCode, LOG 
						2022.11.09, Átnevezés, 999 -> 99, AppUser, InterfaceStatusCode = NULL, Return, Errormessage
						2022.11.10, If Isnull(@ErrorMessage,'') <> ''
						2022.11.18, CreditTypeCode, "Currency_", DEPARTMENT_TYPE
						2022.11.21, @p_CorrelationID nVarchar(200)
						2022.11.21, @FK07 When '01' Then 'DEPARTMENT_TYPE_1' /* Lakossági */
						2022.11.29: OwnProperty = "OwnProperty"
						2022.12.07: @p_InterfacePackageID as PackageID, @l_PartyName as PartyName,	@l_PartyID as PartyID, --@FK02 as PartyBankAccountNr, NULL as PartyBankAccountNr
						2022.12.09: PhaseCode
						2022.12.13: DebtCase.SourceId = @FK02, debtNr = dátum
						2023.01.10: CreditorEntityID
						2023.01.25: 'INVOICE_TYPE_CREDIT' as InvoiceTypeCode
						2023.01.25: Konstrukciós kód @FK57
						2023.01.31: Cast(@FK60 as money) as ArrearsCostLocalCurrency,	-- Devizaszámla HUF díjegyenlege
						2023.02.02: @FK05 -> @FK02
						2023.02.02: @FK55 Konstrukciós kód
						2023.02.03: @l_PurchaseDate
						2023.02.08: (select Top 1 ID from Gen.Portfolio where TreatmentTypeCode = 'TREATMENT_TYPE_ASSIGNMENT' order by ID desc)
						2023.02.09: CurrentUserName
						2023.02.13: PurchasePriceCurrencyCode
						2023.02.17: 'OTP Bank Nyrt.' /*'OTP Faktoring Zrt.'*/
						2023.02.22: DepartmentTypeCode
						2023.04.13: OBJECT_TYPE_IFC_INTERFACETABLE, OBJECT_TYPE_IFC_INTERFACEPACKAGE
						2023.04.14: Return 99
						2023.11.17: Concat('TAFK55/', @FK55) as CreditTypeCode
						2023.11.28: (@FK16 as money) as InterestRate, -- Felmondási kamat %
						2023.11.28: (@FK18 as money) as CostRate, -- Költség %
						2023.11.30: Case when Isnull(@FK14,'') <> '' Then 'CURRENCY_' + @FK14 Else @FK14 End  as PurchasePriceCurrencyCode
						2023.12.05: Ha FK16, FK17, FK18 = '', akkor legyen midegyik NULL értékű
						2023.12.07: @FK55 as ConstructionCode DV-1818
						2023.12.07: FIN.ConstructionCode betöltés, ha szükséges DV-1818
            2023.12.14: CreditTypeCode az FK08 mező alapján jöjjön DV-2005
            2023.12.15: FIN.ConstructionCode betöltésnél legyen rögzítési idő, user DV-1818
            2023.12.18: FIN.ConstructionCode betöltés kikerült; IFC.DebtCase-en Level1-Level7 mezők töltése DV-2013
						2023.12.20: @FK61, LoanGuaranteedCode, DV-2019
						2023.12.21: @FK04 - AccountingSystemCode, DV-2030
						2023.12.30: @FK04 - AccountingSystemCode, DV-2030
						2023.12.30: @FK25 - PurchaseDate DV-1998

 Description:	DataTranfer From IFT.OTP_FK to IFC.DebtCase, IFC.Invoice
*/
-- =====================================================================================================================

AS

BEGIN
	SET NOCOUNT ON;
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;

    DECLARE @LogMessage NVARCHAR(200);

	SET @ErrorMessage = '';
	SET @ErrorSeverity = 0;
	SET @ErrorState = 0;
	SET @ErrorLine = 0;


	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);
	/*
	Set @CurrentUser = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));

	Set @CurrentUserName = 0;
	If exists (select 1 from PRT.AppUser where UserName = @CurrentUser)
		Set @CurrentUserName = (select Top 1 ID from PRT.AppUser where UserName = @CurrentUser order by ID);
	ELSE
		Set @ErrorMessage = 'Current user id not defined (' + @CurrentUser + ')';
	*/
   	/*Set @CurrentUserName = 'Admin'; 2023-02-09*/
	Set @CurrentUserName = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));


	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FK_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

    BEGIN TRANSACTION

    BEGIN TRY
        SET @LogMessage = 'DebtCase-Invoice Loader Started';
		
		Declare @l_Company nvarchar(1); -- Company = 'T'
		Declare @l_Person nvarchar(1); -- Person = 'T'
-----------------------------------------------
		Declare @ID NUMERIC(22);
		Declare @FK01 NVARCHAR(30); -- FIOKKOD
		Declare @FK02 NVARCHAR(24); -- BANKSZAMLASZAM
		Declare @FK03 NVARCHAR(3); -- ALSZAMLASZAM
		Declare @FK04 NVARCHAR(2); -- FORRASRENDSZERID
		Declare @FK05 NVARCHAR(20); -- SZERZODESSZAM
		Declare @FK06 NVARCHAR(30); -- ANSZAMLASZAM
		Declare @FK07 NVARCHAR(3); -- UZLETAG
		Declare @FK08 NVARCHAR(3); -- OTPHITELTIPUS
		Declare @FK09 NVARCHAR(60); -- ADOSNEV
		Declare @FK10 NVARCHAR(22); -- TOKE
		Declare @FK11 NVARCHAR(22); -- UGYLETIKAMAT
		Declare @FK12 NVARCHAR(22); -- KESEDELMIKAMAT
		Declare @FK13 NVARCHAR(22); -- KOLTSEG
		Declare @FK14 NVARCHAR(3); -- DEVIZAID
		Declare @FK15 NVARCHAR(22); -- OSSZTARTOZAS
		Declare @FK16 NVARCHAR(22); -- LEJARATKORIKAMAT, Felmondáskori kamat %
		Declare @FK17 NVARCHAR(22); -- KESEDELMIKAMATLAB, PenaltyInterest Rate
		Declare @FK18 NVARCHAR(22); -- KEZELESIKOLTSEG_SZAZALEK, Költség %
		Declare @FK19 NVARCHAR(50); -- FELMONDAS_DATUM
		Declare @FK20 NVARCHAR(50); -- KIHELYEZES_DATUM
		Declare @FK21 NVARCHAR(50); -- MULASZTAS_DATUM
		Declare @FK22 NVARCHAR(2); -- FIZETESIMOD
		Declare @FK23 NVARCHAR(2); -- FIZETESIHATARIDO
		Declare @FK24 NVARCHAR(2); -- ARAZASID
		Declare @FK25 NVARCHAR(50); -- FORDULONAP
		Declare @FK26 NVARCHAR(22); -- VETELAR
		Declare @FK27 NVARCHAR(22); -- REGIOKOD
		Declare @FK28 NVARCHAR(1); -- ATADASTIPUS
		Declare @FK29 NVARCHAR(1); -- STATUSZ
		Declare @FK30 NVARCHAR(50); -- ALAIRAS_DATUM
		Declare @FK31 NVARCHAR(50); -- BASELPOOL
		Declare @FK32 NVARCHAR(50); -- BASELTERMEK
		Declare @FK33 NVARCHAR(22); -- UGYID
		Declare @FK34 NVARCHAR(30); -- OTPAZONOSITO
		Declare @FK35 NVARCHAR(2); -- MODOSITASSORSZAM
		Declare @FK36 NVARCHAR(2); -- REKORDMODOSITAS_SZORSZAM
		Declare @FK37 NVARCHAR(22); -- NETTOTERULES_SZAZALEK
		Declare @FK38 NVARCHAR(22); -- SZERZODESOSSZEG
		Declare @FK39 NVARCHAR(1); -- KHRATADHATO
		Declare @FK40 NVARCHAR(50); -- KESEDELEM_DATUM
		Declare @FK41 NVARCHAR(50); -- LEVEL_DATUM
		Declare @FK42 NVARCHAR(50); -- KHR_MULASZTAS_DATUM
		-------------------------
		Declare @FK43 NVARCHAR(21); -- KEZELESIKOLTSEGMIN	(- Deviza hitel esetén árfolyam)
		Declare @FK44 NVARCHAR(18); -- KEZELESIKOLTSEGMAX	(- Visszavont kamattámogatás)
		Declare @FK45 NVARCHAR(2);  -- BIZTOSITOKOD			(- SAP termékjellemző)
		Declare @FK46 NVARCHAR(3);  -- BIZTOSITASMOD		(- SAP termék (WWTC1))
		Declare @FK47 NVARCHAR(50); -- BIZTOSITASKEZDEZE	(- SAP termék (RBPROD))
		Declare @FK48 NVARCHAR(50); -- BIZTOSITASVEGE		(- Átadáskor státusz)
		Declare @FK49 NVARCHAR(22); -- BIZTOSITASOSSZEGE	(- )
		Declare @FK50 NVARCHAR(22); -- BIZTOSITASESEDEKESSEGIDIJ ()
		Declare @FK51 NVARCHAR(22); -- BIZTOSITASMEGFIZETETTDIJ	(- Ügykezelő régió kódja)
		Declare @FK52 NVARCHAR(2);  -- TELEPULESMINOSITES (- Kezelési költség számla devizában)
		Declare @FK53 NVARCHAR(1);  -- HVPJEL (- KEZELESIKOLTSEGMIN)
		Declare @FK54 NVARCHAR(1);  -- LAKESMENTES (- KEZELESIKOLTSEGMAX)
		Declare @FK55 NVARCHAR(22); -- TAKONSTRUKCIOID (- BIZTOSITOKOD)
		Declare @FK56 NVARCHAR(240); -- TAKONSTRUKCIONEV (- BIZTOSITASMOD)
		Declare @FK57 NVARCHAR(32); -- KONSTRUKCIOKOD (- BIZTOSITASKEZDET)
		Declare @FK58 NVARCHAR(50); -- HATRALEKBAESE_DATUMA (- BIZTOSITASVEGE)
		Declare @FK59 NVARCHAR(22); -- ELADASIARALAP (- BIZTOSITASOSSZEG)
		Declare @FK60 NVARCHAR(22); -- LC_KOLTSEGTARTOZAS (- BIZTOSITASESEDEKESDIJ) - Devizaszámla HUF díjegyenlege
		Declare @FK61 NVARCHAR(1);  -- HITELGARANCIA (- BIZTOSITASMEGFIZETETTDIJ)
		Declare @FK62 NVARCHAR(22); -- SZERZODESUGY.BANKITERULES (- HVPJEL)
		Declare @FK63 NVARCHAR(18); -- KHR_KOVETELES.KHRBANKIAZONOSITO (- LAKASMENTES)
		Declare @FileName NVARCHAR(500); -- 
		Declare @InterfaceStatusCode NVARCHAR(200); -- 
		Declare @RankFK06 nvarchar (50);					   

		Declare @FK64 NVARCHAR(230); -- D(1004-  8)L Eredeti lejárat
		Declare @FK65 NVARCHAR(230); -- N(1012- 16)R Eredeti hitelösszeg)
		Declare @FK66 NVARCHAR(230); -- D(1028-  8)L Kezesség beváltás dátuma
		Declare @FK67 NVARCHAR(230); -- N(1036- 16)R Beváltott kezesség összeg
		Declare @FK68 NVARCHAR(230); -- C(1052-240)L Szint_1_h
		Declare @FK69 NVARCHAR(230); -- C(1292-240)L Szint_2_h
		Declare @FK70 NVARCHAR(230); -- C(1532-240)L Szint_3_h
		Declare @FK71 NVARCHAR(230); -- C(1772-240)L Szint_4_h
		Declare @FK72 NVARCHAR(230); -- C(2012-240)L Szint_5_h
		Declare @FK73 NVARCHAR(230); -- C(2252-240)L Szint_6_h
		Declare @FK74 NVARCHAR(230); -- C(2492-240)L Szint_7_h
	
		Declare @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		Declare @l_ObjectID numeric(18);
		Declare @l_DebtCase_InterfaceTableID numeric(18);
		Declare @l_Invoice_InterfaceTableID numeric(18);
		
		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);

		Declare @l_PortfolioID numeric(16);
		/*Set @l_PortfolioID = 3;*/
		Set @l_PortfolioID = (select Top 1 ID from Gen.Portfolio where TreatmentTypeCode = 'TREATMENT_TYPE_ASSIGNMENT' order by ID desc);

		Declare @l_PartyName nvarchar(50);
		Declare @l_PartyID numeric(18);
		Declare @l_CreditorEntityID numeric(18);
		--Declare @l_MappingId numeric(18);
		Declare @l_PurchaseDate nvarchar(10)


		Declare @datum nvarchar(10);
		Set @datum = (select Replace(cast(CAST( GETDATE() AS Date ) as nvarchar(10)),'-','') + Cast(CAST( GETDATE() AS Time ) as nvarchar(2)));

		Set @l_PartyName = 'OTP Bank Nyrt.' /*'OTP Faktoring Zrt.'*/;
		Set @l_PartyID = (Select Top 1 Party.Id from PRT.Party
							join PRT.Company on Company.EntityID = Party.EntityID
							where Company.Name = 'OTP Bank Nyrt.' /*'OTP Faktoring Zrt.'*/ order by Party.Id desc);

		Set @l_CreditorEntityID = (Select Top 1 Company.EntityID from PRT.Company 
							where Company.Name = 'OTP Bank Nyrt.' /*'OTP Faktoring Zrt.'*/ order by Company.Id desc);


		Set @l_AllRowCounts = 0;
		Set @l_ImportedRowCounts = 0;
		Set @l_ErrorRowCounts = 0;

		--Set @l_MappingId = (Select Top 1 Id from IFC.Mapping where Mapping.Name = 'Konstrukciós kód alapján termék típus meghatározás(TA)' order by Mapping.Id desc);

		-- InterfacePackageID:
		IF not exists (select 1 from IFC.InterfacePackage where id = @p_InterfacePackageID)
		BEGIN
			-- New ObjectID:
			INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUsername, VersionNr, PortfolioID)
			SELECT 'OBJECT_TYPE_IFC_INTERFACEPACKAGE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @l_PortfolioID;
			SET @l_ObjectID = @@Identity;

			Insert into IFC.InterfacePackage(ObjectId, SourceInterfaceType, CostumerID, CreditorCode, ImportDate, Status, ImportType, CreationDAte, CreationTime, CreationUsername, PartyId, ContractId)
			Select 
				@l_ObjectID as ObjectId, 
				@p_SourceInterfaceType as SourceInterfaceType, 
				NULL as CustomerId, 
				NULL as CreditorCode, 
				CAST( GETDATE() AS Date ) as ImportDate,
				NULL as Status, 
				NULL as ImportType, 
				CAST( GETDATE() AS Date ) as CreationDate, 
				CAST( GETDATE() AS Time ) as CreationTime, 
				@CurrentUserName as CreationUsername, 
				NULL as PartId, 
				NULL as ContractId;
			SET @p_InterfacePackageID = @@Identity;
		END;

--print '3';

-- DebtCase InterfaceTableID:
		IF not exists (select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.DebtCase')
			BEGIN
				-- New ObjectID:
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUsername, VersionNr, PortfolioID)
				SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @l_PortfolioID;
				SET @l_ObjectID = @@Identity;

				Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUsername)
				Select 
					@l_ObjectID as l_ObjectID, 
					@p_InterfacePackageID as l_InterfacePackageID, 
					'IFC.DebtCase' as l_InterfaceTableName, 
					NULL as l_DocumentID, 
					NULL as l_SheetNr, 
					NULL as l_FolderID, 
					CAST( GETDATE() AS Date ) as l_CreationDate, 
					CAST( GETDATE() AS Time ) as l_CreationTime, 
					@CurrentUserName as l_CreationUsername; 

					SET @l_DebtCase_InterfaceTableID = @@Identity;
			END
		ELSE
			BEGIN
				SET @l_DebtCase_InterfaceTableID = (select Top 1 ID from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.DebtCase' order by Id Desc);
			END;

-- Invoice InterfaceTableID:
		IF not exists (select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.Invoice')
			BEGIN
				-- New ObjectID:
				INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUsername, VersionNr)
				SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
				SET @l_ObjectID = @@Identity;

				Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUsername)
				Select 
					@l_ObjectID as l_ObjectID, 
					@p_InterfacePackageID as l_InterfacePackageID, 
					'IFC.Invoice' as l_InterfaceTableName, 
					NULL as l_DocumentID, 
					NULL as l_SheetNr, 
					NULL as l_FolderID, 
					CAST( GETDATE() AS Date ) as l_CreationDate, 
					CAST( GETDATE() AS Time ) as l_CreationTime, 
					@CurrentUserName as l_CreationUsername;
					 
					SET @l_Invoice_InterfaceTableID = @@Identity;
			END
		ELSE
			BEGIN
				SET @l_Invoice_InterfaceTableID = (select Top 1 ID from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.Invoice' order by Id Desc);
			END;

		Set @l_AllRowCounts = (Select Count(*) FROM IFC.OTP_TA_FK where InterfaceStatusCode = 'INTERFACE_STATUS_NEW');

		DECLARE db_cursor CURSOR FOR 
		SELECT
			  ID, FK01, FK02, FK03, FK04, FK05, Trim(FK06) as FK06, FK07, FK08, FK09, FK10, FK11, FK12, FK13, FK14, FK15, FK16, FK17, FK18, FK19, FK20, FK21, FK22, FK23, 
			FK24, FK25, FK26, FK27, FK28, FK29, FK30, FK31, FK32, FK33, FK34, FK35, FK36, FK37, FK38, FK39, FK40, FK41, FK42, FK43, FK44, FK45, FK46, FK47,
			FK48, FK49, FK50, FK51, FK52, FK53, FK54, FK55, FK56, FK57, FK58, FK59, FK60, FK61, FK62, FK63, [FileName], InterfaceStatusCode,
			Trim(FK06) + '/' + Cast(RANK() OVER(PARTITION BY FK05, Trim(FK06) ORDER BY FK05, Trim(FK06), ID) as nVarchar(10)) as RankFK06,
			FK64, FK65, FK66, FK67, FK68, FK69, FK70, FK71, FK72, FK73, FK74

		FROM IFC.OTP_TA_FK
		where InterfaceStatusCode = 'INTERFACE_STATUS_NEW' Order by Id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO 
			  @ID, @FK01, @FK02, @FK03, @FK04, @FK05, @FK06, @FK07, @FK08, @FK09, @FK10, @FK11, @FK12, @FK13, @FK14, @FK15, @FK16, @FK17, @FK18, @FK19, @FK20, @FK21, @FK22, @FK23, 
			@FK24, @FK25, @FK26, @FK27, @FK28, @FK29, @FK30, @FK31, @FK32, @FK33, @FK34, @FK35, @FK36, @FK37, @FK38, @FK39, @FK40, @FK41, @FK42, @FK43, @FK44, @FK45, @FK46, @FK47, 
			@FK48, @FK49, @FK50, @FK51, @FK52, @FK53, @FK54, @FK55, @FK56, @FK57, @FK58, @FK59, @FK60, @FK61, @FK62, @FK63, @FileName, @InterfaceStatusCode/*, @ErrorMessage*/, @RankFK06,
			@FK64, @FK65, @FK66, @FK67, @FK68, @FK69, @FK70, @FK71, @FK72, @FK73, @FK74;



		WHILE @@FETCH_STATUS = 0  
		BEGIN  

			Set @l_ImportID = 0;

/* 2023-12-30, DV-1998
			Set @l_PurchaseDate = NULL;

			Set @l_PurchaseDate = (Select SUBSTRING(@FileName,11,8))
			Set @l_PurchaseDate = SUBSTRING(@l_PurchaseDate,1,4) + '-' + SUBSTRING(@l_PurchaseDate,5,2) + '-' + SUBSTRING(@l_PurchaseDate,7,2)
			If Isdate(@l_PurchaseDate) = 0
			begin
				Set @l_PurchaseDate = NULL;
			end;
*/			


------------------------------------------------------------------
-- FIN.ConstructionCode betöltés, ha szükséges: - átkerült az Interfész betöltőbe DV-2013
------------------------------------------------------------------
/*		If @FK55 is not null
		Begin
			Insert Into FIN.ConstructionCode(Code, Level1, Level2, Level3, Level4, Level5, Level6, Level7, CreationDate, CreationTime, CreationUsername)
  			Select @FK55 Code, @FK68 Level1, @FK69 Level2, @FK70 Level3, @FK71 Level4, @FK72 Level5, @FK73 Level6, @FK74 Level7, GetDate() CreationDate, GetDate() CreationTime, @CurrentUserName CreationUsername
	  		where not exists (Select 1 from FIN.ConstructionCode where ConstructionCode.Code = @FK55);
		End;
*/

------------------------------------------------------------------
-- DebtCase:
------------------------------------------------------------------
--select * from IFC.debtcase

			INSERT INTO IFC.DebtCase(
				SourceInterfaceType, SourceID, PackageName, PackageCode, PackageID, DebtNr, 
				PartyName, PartyID, PartyBankAccountNr, CreditorName, CreditorEntityID, 
				OwnProperty, PurchasePrice, PurchasePriceCurrency, PurchasePriceCurrencyCode, 
				Currency, CurrencyCode, /*Comments,*/ /*Field1,*/ /*Field2,*/ /*Field3,*/ /*Field4,*/ /*Field5,*/ 
				OperationCode, DebtCaseID, InterfaceStatusCode, /*ErrorMessage,*/ InterfaceTableID, 
				MainDebtorID, Section, SectionCode, Phase, PhaseCode, CloseReason, 
				CloseDate, OfficeID, Office, ClientNr, CreationDate, CreationUsername, CreationTime, CreditTypeCode, PortfolioID, BankAccountNumber, PurchaseDate, DepartmentTypeCode, 
				ConstructionCode, Level1, Level2, Level3, Level4, Level5, Level6, Level7, LoanGuaranteedCode, AccountingSystemCode
       )
			SELECT
				@p_SourceInterfaceType, 
				@FK02 as SourceID, 
				NULL as PackageName, 
				NULL as PackageCode, 
				@p_InterfacePackageID as PackageID, /*2022-12-07*/
				--@FK05 as DebtNr,
				@datum + cast(@ID as nvarchar(18)) as DebtNr,
				@l_PartyName as PartyName,		/*2022-12-07*/
				@l_PartyID as PartyID,			/*2022-12-07*/
				--@FK02 as PartyBankAccountNr,	/*2022-12-07*/
				NULL as PartyBankAccountNr,		/*2022-12-07*/
				NULL as CreditorName, 
				@l_CreditorEntityID as CreditorEntityID, /*2023-01-10*/
				'BOOLEAN_TRUE' as OwnProperty, 
				Cast(@FK26 as money) as PurchasePrice, 

				/*@FK14 as PurchasePriceCurrency,  2023-02-13*/
				/*Case when Isnull(@FK14,'') <> '' Then 'CURRENCY_' + @FK14 Else @FK14 End  as PurchasePriceCurrencyCode,*/

				NULL as PurchasePriceCurrency, 
				/*
				(select Top 1 ContractItem.CurrencyID from crm.CollectionContractItem
				join crm.ContractItem ON ContractItem.ID = CollectionContractItem.ContractItemID
				where CollectionContractItem.AccountNr = @FK02 order by CollectionContractItem.ID desc)  as PurchasePriceCurrencyCode,
				*/
				/* 2023-11-30 */
				Case when Isnull(@FK14,'') <> '' Then 'CURRENCY_' + @FK14 Else @FK14 End  as PurchasePriceCurrencyCode,


				@FK14 as Currency, 
				Case when Isnull(@FK14,'') <> '' Then 'CURRENCY_' + @FK14 Else @FK14 End  as CurrencyCode, 
				/*Comments,*/ 
				/*Field1,*/ 
				/*Field2,*/ 
				/*Field3,*/ 
				/*Field4,*/ 
				/*Field5,*/
				NULL as OperationCode, 
				NULL as DebtCaseID, 
				'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
				/*ErrorMessage,*/ 
				@l_DebtCase_InterfaceTableID as InterfaceTableID, 
				NULL as MainDebtorID, NULL as Section, 
				NULL as SectionCode, 
				NULL as Phase, 
				/* 2022-11-21*/
				/* 2023-02-22
				Case @FK07 
					When '01' Then 'DEPARTMENT_TYPE_RETAIL' /* Lakossági */
					When '02' Then 'DEPARTMENT_TYPE_BUSINESS' /* Vállalkozói */
					When '03' Then 'DEPARTMENT_TYPE_GOVERNMENT' /* Önkormányzati */
				End as PhaseCode, 
				*/
				NULL as PhaseCode, 
				/*
				Case @FK07 
					When '01' Then 'DEPARTMENT_TYPE_1' /* Lakossági */
					When '02' Then 'DEPARTMENT_TYPE_2' /* Vállalkozói */
					When '03' Then 'DEPARTMENT_TYPE_3' /* Önkormányzati */
				End as PhaseCode, 
				*/
				NULL as CloseReason, 
				NULL as CloseDate, 
				@FK01 as OfficeID, 
				NULL as Office, 
				NULL as ClientNr, 
				CAST( GETDATE() AS Date ) as CreationDate, @CurrentUserName, CAST( GETDATE() AS Time ) as CreationTime,
				/* 2023-01-25
				Case Cast(@FK08 as numeric(5))
					When '5'  Then 'CREDIT_TYPE_1051' /* Jelzáloghitel (Lakáshitel) */
					When '6'  Then 'CREDIT_TYPE_1014' /* Forráshitel */
					When '12' Then 'CREDIT_TYPE_1055' /* Egyéb vállalati követelés */
					When '13' Then 'CREDIT_TYPE_1034' /*Egyéb lakossági hitel */
					When '17' Then 'CREDIT_TYPE_1025' /* Egyéb folyószámlahitel */
					When '25' Then 'CREDIT_TYPE_1057' /* Egyéb vállalati bankgarancia */
				END as CrediTypeCode,
				*/
				/* 2023-11-17
				(select top 1 Code from IFC.MappingCode where MappingCode.ExternalCode = @FK55 and Isnull(ValidFrom,CAST( GETDATE() AS Date )) >= CAST( GETDATE() AS Date ) and Isnull(ValidUntil, CAST( GETDATE() AS Date )) <= CAST( GETDATE() AS Date )
							and MappingCode.MappingId = @l_MappingId order by MappingCode.Id desc)
				as CreditTypeCode,
				*/
				/* 2023-12-07
				Concat('TAFK55/', @FK55) as CreditTypeCode,
				*/
				Case when IsNull(@FK08, '') <> '' then 'CREDIT_TYPE_' + @FK08 else @FK08 end as CreditTypeCode,
				@l_PortfolioID,
				@FK02,
				--@l_PurchaseDate,
				Case when Isdate(@FK25) = 0
				Then
					NULL
				Else
					@FK25
				End as PurchaseDate,
				Case @FK07 
					When '01' Then 'DEPARTMENT_TYPE_RETAIL' /* Lakossági */
					When '02' Then 'DEPARTMENT_TYPE_BUSINESS' /* Vállalkozói */
					When '03' Then 'DEPARTMENT_TYPE_GOVERNMENT' /* Önkormányzati */
				End as DepartmentTypeCode,
				@FK55 as ConstructionCode,
				@FK68 Level1, @FK69 Level2, @FK70 Level3, @FK71 Level4, @FK72 Level5, @FK73 Level6, @FK74 Level7,
				@FK61, 
				Concat('ACCOUNTING_SYSTEM_', @FK04) as AccountingSystemCode;


			SET @l_ImportID = @@Identity;
			--UPDATE IFC.OTP_TA_FK SET IFCDebtCaseID = @l_ImportID where ID = @ID;

------------------------------------------------------------------
-- Invoice:
------------------------------------------------------------------

			INSERT INTO IFC.INVOICE(
				ObjectID, 
				InvoiceTypeText, 
				InvoiceTypeCode, 
				SellerPartyID, 
				BuyerPartyID, 
				InvoiceNr, 
				RegistrationNr, 
				CreditTypeCode, 
				CreditTypeText, 
				ProductCode, 
				ProductText, 
				ContractDate, 
				FulfillmentDate, 
				IssueDate, 
				DueDate, 
				TerminationDate, 
				PaymentMethodCode, 
				PaymentMethodText, 
				CurrencyCode, 
				CurrencyText, 
				TotalNetAmount, 
				TotalVATAmount, 
				TotalGrossAmount, 
				TotalCredit, 
				TotalInstalment, 
				ArrearsCapital, 
				ArrearsInterest, 
				ArrearsPenaltyInterest, 
				ArrearsCost, 
				ArrearsCostLocalCurrency, 
				InterestRate, 
				PenaltyInterestRate, 
				CostRate,
				InvoiceID, 
				SourceID, 
				SourceDebtCaseID, 
				SourceContractID, 
				SourceInterfaceType, 
				InterfaceStatusCode, 
				--ErrorMessage, 
				OperationCode, 
				ImportTableID, 
				CreationDate, 
				CreationUsername,
				CreationTime) 

					
			SELECT
				NULL as ObjectID, 
				NULL as InvoiceTypeText, 
				'INVOICE_TYPE_CREDIT' as InvoiceTypeCode, 
				NULL as SellerPartyID, 
				NULL as BuyerPartyID, 
				--@FK05 as InvoiceNr, 				-- SZERZODESSZAM
				@FK02 as InvoiceNr, 				-- SZERZODESSZAM
				NULL as RegistrationNr, 
				NULL /*@FK08 as */CreditTypeCode, 			-- OTPHITELTIPUS <-- nem kell, átkerült a DCS.DebtCase-be
				-- kódosztályból kell majd tölteni
				--'VALUESET_CREDIT_TYPE'
				--'CREDIT_TYPE'
				NULL as CreditTypeText, 			-- OTPHITELTIPUS <-- nem kell, átkerült a DCS.DebtCase-be
				NULL as ProductCode, 
				NULL as ProductText, 
				@FK30 as ContractDate, 				-- ALAIRAS_DATUM
				@FK21 as FulfillmentDate, 			-- MULASZTAS_DATUM
				@FK20 as IssueDate, 				-- KIHELYEZES_DATUM
				@FK23 as DueDate,					-- FIZETESIHATARIDO
				@FK19 as TerminationDate, 			-- FELMONDAS_DATUM
				NULL /*@FK22*/ as PaymentMethodCode, 			-- FIZETESIMOD <-- nem kell betölteni
				-- kódosztályból kell majd tölteni
				-- Értékkészlet kódja: 'VALUESET_PAYMENT'
				-- Előtag: 'PAYMENT'
				NULL as PaymentMethodText, 		-- FIZETESIMOD <-- nem kell betölteni
				Case when Isnull(@FK14,'') <> '' Then 'CURRENCY_' + @FK14 Else NULL End as CurrencyCode, 	-- DEVIZACode
				@FK14 as CurrencyText, 			
				Cast(NULL as money) as TotalNetAmount, 
				Cast(NULL as money) as TotalVATAmount, 
				Cast(NULL as money) as TotalGrossAmount, 
				Cast(NULL as money) as TotalCredit, 
				Cast(NULL as money) as TotalInstalment, 
				Cast(@FK10 as money) as ArrearsCapital, 			-- TOKE
				Cast(@FK11 as money) as ArrearsInterest, 			-- UGYLETIKAMAT
				Cast(@FK12 as money) as ArrearsPenaltyInterest, 	-- KESEDELMIKAMAT
				Cast(@FK13 as money) as ArrearsCost, 				-- KOLTSEG
				Cast(@FK60 as money) as ArrearsCostLocalCurrency,	-- Devizaszámla HUF díjegyenlege
				Case when Trim(@FK16) = ''
					then NULL
					else Cast(@FK16 as money)
					end as InterestRate,				-- Felmondáskori kamat %
				Case when Trim(@FK17) = ''
					then NULL
					else Cast(@FK17 as money)
					end as PenaltyInterestRate, 		-- KESEDELMIKAMATLAB
				Case when Trim(@FK18) = ''
					then NULL
					else Cast(@FK18 as money)
					end as CostRate,					-- Költség %
				NULL as InvoiceID, 
				@RankFK06 as SourceID, 
				@FK02 as SourceDebtCaseID, 			-- SZERZODESSZAM
				(Select Top 1 ID from CRM.Contract where Contract.ContractNr = @FK05 order by id desc) as SourceContractID, -- @FK05 as SourceContractID, /*!! DE ID kell ide !*/
				@p_SourceInterfaceType as SourceInterfaceType, 
				'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
				--ErrorMessage, 
				NULL as OperationCode, 
				@l_Invoice_InterfaceTableID as ImportTableID,
				CAST( GETDATE() AS Date ) as CreationDate, 
				@CurrentUserName as CreationUsername,
				CAST( GETDATE() AS Time ) as CreationTime;
				

			SET @l_ImportID = @@Identity;
			--UPDATE IFC.OTP_TA_FK SET IFCInvoiceID = @l_ImportID where ID = @ID;


			IF @l_ImportID <> 0
				BEGIN
					UPDATE IFC.OTP_TA_FK SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', Errormessage = NULL where ID = @ID;
					SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
				END;
			ELSE
				BEGIN
					UPDATE IFC.OTP_TA_FK SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR' where ID = @ID;
					INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
						SELECT 
							CAST( GETDATE() AS Date ),	-- LogDate,	
							CAST( GETDATE() AS Time ),	-- LogTime,
							SUSER_SNAME(),				-- UserName
							@p_CorrelationID,			-- CorrelationID
							'INDECS 3.0',				-- ApplicationName
							DB_NAME(),					-- Environment
							'BACKEND',					-- Layer
							'IFC.TA_FK_Loader',			-- ServiceName
							'1.0',						-- ServiceVersion
							'WARNING',					-- SeverityLevel
							NULL,						-- MessageCategory
							'Not Insert OTP_TA_FK.ID = '+ Cast(@ID as nVarchar(18));					-- LogMessage
					Set @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
				END;
			FETCH NEXT FROM db_cursor INTO 			  
			  @ID, @FK01, @FK02, @FK03, @FK04, @FK05, @FK06, @FK07, @FK08, @FK09, @FK10, @FK11, @FK12, @FK13, @FK14, @FK15, @FK16, @FK17, @FK18, @FK19, @FK20, @FK21, @FK22, @FK23, 
			@FK24, @FK25, @FK26, @FK27, @FK28, @FK29, @FK30, @FK31, @FK32, @FK33, @FK34, @FK35, @FK36, @FK37, @FK38, @FK39, @FK40, @FK41, @FK42, @FK43, @FK44, @FK45, @FK46, @FK47, 
			@FK48, @FK49, @FK50, @FK51, @FK52, @FK53, @FK54, @FK55, @FK56, @FK57, @FK58, @FK59, @FK60, @FK61, @FK62, @FK63, @FileName, @InterfaceStatusCode/*, @ErrorMessage*/, @RankFK06,
			@FK64, @FK65, @FK66, @FK67, @FK68, @FK69, @FK70, @FK71, @FK72, @FK73, @FK74;

		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    COMMIT TRANSACTION;

    END TRY


    BEGIN CATCH
        
        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FK_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;				-- LogMessage

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        ROLLBACK TRANSACTION;

		Return 99;

    END CATCH;

------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FK_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + ', ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18))  + ', ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) -- LogMessage



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FK_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage

	Return 1;

END;
go

CREATE   PROCEDURE [IFC].[TA_FU_Loader](@p_CorrelationID nVarchar(200), @p_SourceInterfaceType nVarchar(200), @p_InterfacePackageID Numeric(16))

-- =====================================================================================================================
/*
 Author:				Tóth Gábor
 Creation date:			2022.10.24.
 Last modified date:	2022.11.08: InterfaceStatusCode, LOG, 
						2022.11.09: Átnevezés, 999 -> 99, AppUser, InterfaceStatusCode = NULL, Return, Errormessage
						2022.11.10: If Isnull(@ErrorMessage,'') <> ''
						2022.11.17: kód előtagok, cég / magánszemély, debtortype hardkódolás, BirstDate validation
						2022.11.19: FirstName <-> LastName, MaidenFirstName, MaidenLastName
						2022.11.20: @l_FU21 bevezetése
						2022.11.21: @p_CorrelationID nVarchar(200)
						2022.11.21: IF @FU16 is not NULL
						2022.11.23: @l_MothersFirstName, @l_MothersLastName, Operation, Comments, CrefoId, Sex, Deceased, Country, DeathCountryId
						2022.11.27: Belső hibakezelés kivétele (Errormessage), majd a Person-, és CompanyLoader fogja megcsinálni
						2022.11.28: @l_PortfolioID
						2022.12.08: InterfaceTable.Id <-> @@Identity
						2022.12.13: SourceDebtCaseID = @FU02, @FU42, @FU43
						2023-01-13: Magánszemély <-> Cég szészedés a "Ügybetöltő" 2023.01.13 Laki Tamás levele szerint
						2023-02-06: ContactType <-> ContactTypeCodeCode
						2023-02-08: (select Top 1 ID from Gen.Portfolio where TreatmentTypeCode = 'TREATMENT_TYPE_ASSIGNMENT' order by ID desc)
						2023-02-09: CurrentUserName
						2023-04-13: OBJECT_TYPE_IFC_INTERFACETABLE
						2023-04-14: Return 99	
						2023-10-03: Set @l_FU21 = 'LEGAL_FORM_9999';
						2023-11-17: NationalityCode
						2023-12-30: FU24, FU25, FU26, FU27 ha nem üres, csak akkor jöjjön létre IFC.Contact record, DV-1963
						
 */
-- =====================================================================================================================

AS

BEGIN
	SET NOCOUNT ON;
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;

    DECLARE @LogMessage NVARCHAR(200);

	SET @ErrorMessage = '';
	SET @ErrorSeverity = 0;
	SET @ErrorState = 0;
	SET @ErrorLine = 0;

	Declare @CurrentUserName nvarchar(200);
	Declare @CurrentUser nvarchar(50);
	/*
	Set @CurrentUser = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));

	Set @CurrentUserName = 0;
	If exists (select 1 from PRT.AppUser where UserName = @CurrentUser)
		Set @CurrentUserName = (select Top 1 ID from PRT.AppUser where UserName = @CurrentUser order by ID);
	ELSE
		Set @ErrorMessage = 'Current user id not defined (' + @CurrentUser + ')';
	*/
	/*Set @CurrentUserName = 'Admin'; 2023-02-09*/
	Set @CurrentUserName = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));

   
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FU_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

    BEGIN TRANSACTION

    BEGIN TRY
        SET @LogMessage = 'Person-Company Loader Started';
		
		Declare @l_Company nvarchar(1); -- Company = 'T'
		Declare @l_Person nvarchar(1); -- Person = 'T'
-----------------------------------------------
		Declare @ID numeric(22, 0);
		Declare @FU01 nvarchar (30);   -- FIOKKOD
		Declare @FU02 nvarchar (24);   -- BANKSZAMLASZAM
		Declare @FU03 nvarchar (3);   -- ALSZAMLASZAM
		Declare @FU04 nvarchar (2);   -- FORRASRENDSZERID
		Declare @FU05 nvarchar (20);   -- SZERZODESSZAM (SourceDebtCaseID)
		Declare @FU06 nvarchar (8);   -- UGYFELSZAM (SoureCompany/SourcePersonID)
		Declare @FU07 nvarchar (2);   -- KEZESTIPUSID ( adóstípus )
		Declare @FU08 nvarchar (30);   -- ANSZAMLASZAM
		Declare @FU09 nvarchar (60);   -- NEV
		Declare @FU10 nvarchar (30);   -- VEZETEKNEV
		Declare @FU11 nvarchar (30);   -- KERESZTNEV
		Declare @FU12 nvarchar (30);   -- ELOZONEV
		Declare @FU13 nvarchar (35);   -- LEANYKORINEV
		Declare @FU14 nvarchar (35);   -- ANYJANEVE
		Declare @FU15 nvarchar (30);   -- SZULHELY
		Declare @FU16 nvarchar (50);   -- SZULIDO
		Declare @FU17 nvarchar (11);   -- SZEMELYISZAM
		Declare @FU18 nvarchar (10);   -- ADOAZONOSITO
		Declare @FU19 nvarchar (50);   -- HOSSZUNEV
		Declare @FU20 nvarchar (30);   -- ROVIDNEV
		Declare @FU21 nvarchar (30);   -- CEGFORMA
		Declare @FU22 nvarchar (15);   -- ADOSZAM
		Declare @FU23 nvarchar (15);   -- CEGJEGYZEKSZAM
		Declare @FU24 nvarchar (24);   -- TELEFON1
		Declare @FU25 nvarchar (24);   -- TELEFON2
		Declare @FU26 nvarchar (24);   -- MOBIL
		Declare @FU27 nvarchar (24);   -- EMAIL
		Declare @FU28 nvarchar (15);   -- SZIGSZAM
		Declare @FU29 nvarchar (15);   -- UTLEVELSZAM
		Declare @FU30 nvarchar (15);   -- JOGOSITVANYSZAM
		Declare @FU31 nvarchar (1);   -- ATADASHOZHOZZAJARULT
		Declare @FU32 nvarchar (22);   -- CEGID
		Declare @FU33 nvarchar (22);   -- UGYID
		Declare @FU34 nvarchar (2);   -- MODOSITAS_SORSZAM
		Declare @FU35 nvarchar (4);   -- ALLAMPOLGARSAG
		Declare @FU36 nvarchar (30);   -- KHRBANKIAZON
		Declare @FU37 nvarchar (1);   -- KHRSTATUSZ
		Declare @FU38 nvarchar (22);   -- KHRMULASZTASAZON
		Declare @FU39 nvarchar (50);   -- KHRAKTUALISDATUM
		Declare @FU40 nvarchar (4);   -- MNBSZEKTORKOD
		Declare @FU41 nvarchar (30);   -- KEPVISELO1
		Declare @FU42 nvarchar (24);   -- KK_TELEFON1
		Declare @FU43 nvarchar (24);   -- KK_TELEFON2
		Declare @FU44 nvarchar (1);   -- ELHUNYT
		Declare @FileName nvarchar (500);   -- 
		Declare @InterfaceStatusCode nvarchar (200);   -- 
		Declare @RankFU06 nvarchar (50);					   
	
		Declare @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		
		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);

		Declare @l_FU35 nvarchar (200);   -- ALLAMPOLGARSAG
		Declare @l_FU21 nvarchar (200);   -- CEGFORMA
		Declare @l_FU07 nvarchar (200);   -- KEZESTIPUSID ( adóstípus )

		Declare @l_PortfolioID numeric(16);
		/*Set @l_PortfolioID = 3;*/
		Set @l_PortfolioID = (select Top 1 ID from Gen.Portfolio where TreatmentTypeCode = 'TREATMENT_TYPE_ASSIGNMENT' order by ID desc);
		
		

		Set @l_AllRowCounts = 0;
		Set @l_ImportedRowCounts = 0;
		Set @l_ErrorRowCounts = 0;

  		Declare @l_InterfacePackageID numeric(18);
		Declare @l_ObjectID numeric(18);
		Declare @l_InterfaceTableID numeric(18);
		Declare @l_Company_InterfaceTableID numeric(18);
		Declare @l_Person_InterfaceTableID numeric(18);
		Declare @l_Contact_InterfaceTableID numeric(18);
		Declare @l_Debtor_InterfaceTableID numeric(18);
		
		Declare @l_MFirstName  nvarchar (200);
		Declare @l_MLastName  nvarchar (200);
		Declare @l_MothersFirstName  nvarchar (200);
		Declare @l_MothersLastName  nvarchar (200);
		Declare @l_Pos numeric(3);


					
-- Company InterfaceTableID:
		-- New ObjectID:
		INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr, PortfolioID)
		SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @l_PortfolioID;
		SET @l_ObjectID = @@Identity;

		Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUserName)
		Select 
			@l_ObjectID as l_ObjectID, 
			@p_InterfacePackageID as l_InterfacePackageID, 
			'IFC.Company' as l_InterfaceTableName, 
			NULL as l_DocumentID, 
			NULL as l_SheetNr, 
			NULL as l_FolderID, 
			CAST( GETDATE() AS Date ) as l_CreationDate, 
			CAST( GETDATE() AS Time ) as l_CreationTime, 
			@CurrentUserName as l_CreationUserName 
		where not exists (Select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.Company');

		SET @l_Company_InterfaceTableID = (Select Top 1 InterfaceTable.ID from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.Company' order by InterfaceTable.ID Desc);

-- Person InterfaceTableID:
	-- New ObjectID:
		INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr, PortfolioID)
		SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0', @l_PortfolioID;
		SET @l_ObjectID = @@Identity;

		Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUserName)
		Select 
			@l_ObjectID as l_ObjectID, 
			@p_InterfacePackageID as l_InterfacePackageID, 
			'IFC.Person' as l_InterfaceTableName, 
			NULL as l_DocumentID, 
			NULL as l_SheetNr, 
			NULL as l_FolderID, 
			CAST( GETDATE() AS Date ) as l_CreationDate, 
			CAST( GETDATE() AS Time ) as l_CreationTime, 
			@CurrentUserName as l_CreationUserName 
		where not exists (Select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.Person');

		SET @l_Person_InterfaceTableID = (Select Top 1 InterfaceTable.Id from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.Person' order by InterfaceTable.Id desc);


-- Contact InterfaceTableID:
		-- New ObjectID:
		INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
		SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
		SET @l_ObjectID = @@Identity;

		Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUserName)
		Select 
			@l_ObjectID as l_ObjectID, 
			@p_InterfacePackageID as l_InterfacePackageID, 
			'IFC.Contact' as l_InterfaceTableName, 
			NULL as l_DocumentID, 
			NULL as l_SheetNr, 
			NULL as l_FolderID, 
			CAST( GETDATE() AS Date ) as l_CreationDate, 
			CAST( GETDATE() AS Time ) as l_CreationTime, 
			@CurrentUserName as l_CreationUserName 
		where not exists (Select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.Contact');

		SET @l_Contact_InterfaceTableID = (Select Top 1 InterfaceTable.Id from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.Contact' order by InterfaceTable.Id desc);

-- Debtor InterfaceTableID:
		-- New ObjectID:
		INSERT INTO Gen.Object (ObjectType, CreationDate, CreationTime, CreationUserName, VersionNr)
		SELECT 'OBJECT_TYPE_IFC_INTERFACETABLE' as ObjectType, CAST( GETDATE() AS Date ), CAST( GETDATE() AS Time ), @CurrentUserName, '1.0.0';
		SET @l_ObjectID = @@Identity;

		Insert into IFC.InterfaceTable(ObjectID, InterfacePackageID, InterfaceTableName, DocumentID, SheetNr, FolderID, CreationDate, CreationTime, CreationUserName)
		Select 
			@l_ObjectID as l_ObjectID, 
			@p_InterfacePackageID as l_InterfacePackageID, 
			'IFC.Debtor' as l_InterfaceTableName, 
			NULL as l_DocumentID, 
			NULL as l_SheetNr, 
			NULL as l_FolderID, 
			CAST( GETDATE() AS Date ) as l_CreationDate, 
			CAST( GETDATE() AS Time ) as l_CreationTime, 
			@CurrentUserName as l_CreationUserName 
		where not exists (Select 1 from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.Debtor');

		SET @l_Debtor_InterfaceTableID = (Select Top 1 InterfaceTable.Id from IFC.InterfaceTable where InterfacePackageID = @p_InterfacePackageID and InterfaceTableName = 'IFC.Debtor' order by InterfaceTable.Id desc);

		Set @l_AllRowCounts = (Select Count(*) FROM IFC.OTP_TA_FU where InterfaceStatusCode = 'INTERFACE_STATUS_NEW');

		DECLARE db_cursor CURSOR FOR 
		SELECT ID,
			FU01, FU02, FU03, FU04, FU05, FU06, FU07, FU08, FU09, FU10, FU11, FU12, FU13, FU14, FU15, FU16, FU17, FU18, FU19, FU20, FU21, FU22, FU23, 
			FU24, FU25, FU26, FU27, FU28, FU29, FU30, FU31, FU32, FU33, FU34, FU35, FU36, FU37, FU38, FU39, FU40, FU41, FU42, FU43, FU44, [FileName], InterfaceStatusCode,
			FU06 + '/' + Cast(RANK() OVER(PARTITION BY FU06 ORDER BY FU06, ID) as nVarchar(10)) as RankFU06
		FROM IFC.OTP_TA_FU
		where InterfaceStatusCode = 'INTERFACE_STATUS_NEW' Order by Id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO @ID, @FU01, @FU02, @FU03, @FU04, @FU05, @FU06, @FU07, @FU08, @FU09, @FU10, @FU11, @FU12, @FU13, @FU14, @FU15, @FU16, @FU17, @FU18, @FU19, @FU20, @FU21, @FU22, @FU23, 
		@FU24, @FU25, @FU26, @FU27, @FU28, @FU29, @FU30, @FU31, @FU32, @FU33, @FU34, @FU35, @FU36, @FU37, @FU38, @FU39, @FU40, @FU41, @FU42, @FU43, @FU44, @FileName, @InterfaceStatusCode, @RankFU06;

		WHILE @@FETCH_STATUS = 0  
		BEGIN  

		Set @FU09 = Trim(@FU09);
		Set @FU18 = Trim(@FU18);
		Set @FU19 = Trim(@FU19);
		Set @FU20 = Trim(@FU20);
		Set @FU21 = Trim(@FU21);
		Set @FU22 = Trim(@FU22);
		Set @FU23 = Trim(@FU23);

		Set @ErrorMessage = NULL;
		Set @l_ImportID = 0;

		IF  @ErrorMessage is NULL
		BEGIN
-- Magánszemély vagy Cég:
			Set @l_Company = 'F';
			Set @l_Person = 'T';

			If Isnull(@FU22,'') <> '' OR Isnull(@FU23,'') <> ''
			Begin
					Set @l_Company = 'T';
					Set @l_Person = 'F';
			End;

/* Ha magánszemély és nincs kitöltve a vezeték- és keresztneve, DE ki van töltve a TELJES név, akkor szét kell bontatni a TELJES nevet */
			If @l_Person = 'T'
				and Trim(Isnull(@FU09,'')) <> '' and Trim(Isnull(@FU10,'')) = '' and Trim(Isnull(@FU11,'')) = ''
			Begin
				Set @l_Pos = 0;
				Set @l_pos = charindex(' ', Trim(Isnull(@FU09,'')));
				if @l_pos > 0
				begin
					Set @FU10 = left(Trim(Isnull(@FU09,'')),@l_pos);
					Set @FU11 = Right(Trim(Isnull(@FU09,'')),len(Trim(Isnull(@FU09,'')))-@l_pos);
				end
				else
				begin
					Set @FU10 = @FU09;
					Set @FU11 = '';
					Set @FU09 = '';
				end;
			End;


-- állampolgárság:
			If Isnull(@FU35,'') <> ''
			Begin
				If @FU35 = 'HU'
					Set @FU35 = 'HUN';
				Set @l_FU35 = 'NATIONALITY_' + @FU35;
			End;

-- adóazonosító (FU18) vs. adószám (FU22):
			If Isnull(@FU18,'') <> '' and Isnull(@FU22,'') = ''  
			Begin
				Set @FU22 = @FU18
			End;
------------------------------------------------------------------
-- Company:
------------------------------------------------------------------

			If @l_Company = 'T'
			--THEN
				BEGIN

					If Isnull(@FU21,'') <> ''
					Begin
						Set @l_FU21 = 'LEGAL_FORM_' + @FU21;
						If not exists (Select 1 from Gen.Code where id like 'LEGAL_FORM_%' and Id = @l_FU21) 
						Begin 
							Set @l_FU21 = 'LEGAL_FORM_9999';
							/* Set @ErrorMessage = Isnull(@ErrorMessage,'') + ' Not valid legalform: ' + @l_FU21; */
						END;
					End;

					INSERT INTO IFC.COMPANY(
						ObjectID,									SourceInterfaceType,							SourceID,
						RegistrationNr,								RegistrationDate,								TaxNr,
						StatisticalNr,								LegalForm,										LegalFormID,
						Name,										ZipCode,										City,
						Street,										MainActivityCode,								LegalStatus,
						LegalStatusID,								Field1,											Field2,
						Field3,										Field4,											Field5,
						CrefoID,									InterfaceStatusCode,							ErrorMessage,
						ParentStatisticalNr,						ValidFrom,										UpdateDate,
						ValidUntil,									ActualisationDate,								InternationalTaxNr,
						IndustryCode,								EntrepreneurNr,									TaxResidence,
						Operation,									InterfaceTableID,								CountryID,
						Country,									OrganizationUnitCode,							OrganizationUnitID,
						CreationDate,								CreationTime,									CreationUserName,
						PortfolioID)
					SELECT
						NULL as ObjectID,							@p_SourceInterfaceType as SourceInterfaceType,	@FU06 as SourceID,
						@FU23 as RegistrationNr,					NULL as RegistrationDate,						@FU22 as TaxNr,
						NULL as StatisticalNr,						NULL as LegalForm,								@l_FU21 as LegalFormID,
						/*@FU19*/ @FU09 as Name,					NULL as ZipCode,								NULL as City,
						NULL as Street,								NULL as MainActivityCode,						NULL as LegalStatus,
						NULL as LegalStatusID,						NULL as Field1,									NULL as Field2,
						NULL as Field3,								NULL as Field4,									NULL as Field5,
						NULL as CrefoID,							'INTERFACE_STATUS_NEW' as InterfaceStatusCode,	NULL as ErrorMessage,
						NULL as ParentStatisticalNr,				NULL as ValidFrom,								NULL as UpdateDate,
						NULL as ValidUntil,							NULL as ActualisationDate,						NULL as InternationalTaxNr,
						NULL as IndustryCode			,			NULL as EntrepreneurNr,							NULL as TaxResidence,
						NULL as Operation,							@l_Company_InterfaceTableID,					@l_FU35  as CountryID,
						NULL as Country,							NULL as OrganizationUnitCode,					NULL as OrganizationUnitID,
						CAST( GETDATE() AS Date ) as CreationDate,	CAST( GETDATE() AS Time ) as CreationTime,		@CurrentUserName,
						@l_PortfolioID;

					SET @l_ImportID = @@Identity;
					--UPDATE IFC.OTP_TA_FU SET IFCCompanyID = @l_ImportID where ID = @ID;

				END;
			-- END IF
------------------------------------------------------------------
-- Person:
------------------------------------------------------------------

			If @l_Person = 'T'
			--THEN
				BEGIN

					If isnull(@FU28,'') = ''
					Begin
						Set @FU28 = @FU29; /* Ha a személyi igazolványszám nincs kitöltve, akkor az útlevélszámot töltjük be */
					End;

-- Születéskori név szétbontása:

					Set @l_MFirstName = '';
					Set @l_MLastName = '';
					Set @l_Pos = 0;
					Set @FU13 = Trim(@FU13);
					Set @l_Pos = Charindex(' ', @FU13);
					Set @l_MLastName = Trim(left(@FU13, @l_Pos));
					Set @l_MFirstName = Trim(right(@FU13, len(@FU13)-@l_Pos));

-- Anyja neve szétbontása:

					Set @l_MothersFirstName = '';
					Set @l_MothersLastName = '';
					Set @l_Pos = 0;
					Set @FU14 = Trim(@FU14);
					Set @l_Pos = Charindex(' ', @FU14);
					Set @l_MothersLastName = Trim(left(@FU14, @l_Pos));
					Set @l_MothersFirstName = Trim(right(@FU14, len(@FU14)-@l_Pos));

					INSERT INTO IFC.PERSON(
						SourceInterfaceType,						SourceID,										RegistrationNr, 
						TaxNr,										StatisticalNr,									Title,
						LastName,									MiddleName,										FirstName,
						FullName,									BirthPlace,										BirthDate,
						MaidenLastName,								MaidenFirstName,								MothersLastName,
						MothersFirstName,							FaxNr,											EMail,
						PhoneNr,									IdentityCardNr,									PensionerNr,
						Web,										Field1,											Field2,
						Field3,										Field4,											Field5,
						PersonID,									InterfaceStatusCode,							ErrorMessage,
						ActualisationDate,							Operation,										InterfaceTableID,
						GenderCode,									DeceasedCode,									CountryCode,
						OrganizationUnitCode,						OrganizationUnitID,								FathersName,
						DeathDate,									DeathCountryCode,								DeathZipCode,
						DeathCity,									CreationDate,									CreationTime,
						CreationUserName,							PortfolioID,									NationalityCode)

					SELECT
						@p_SourceInterfaceType as SourceInterfaceType, @FU06 as SourceID,							NULL as RegistrationNr, 
						@FU22 as TaxNr,								NULL as StatisticalNr,							NULL as Title,
						@FU10 as LastName,							NULL as MiddleName,								@FU11 as FirstName,
						@FU09 as FullName,							@FU15 as BirthPlace,							@FU16 as BirthDate,
						@l_MLastName as MaidenLastName,				@l_MFirstName as MaidenFirstName,				@l_MothersLastName,
						@l_MothersFirstName,						NULL as FaxNr,									NULL as EMail,
						NULL as PhoneNr,							@FU28 as IdentityCardNr,						NULL as PensionerNr,
						NULL as Web,								NULL as Field1,									NULL as Field2,
						NULL as Field3,								NULL as Field4,									NULL as Field5,
						NULL as CrefoID,							'INTERFACE_STATUS_NEW' as InterfaceStatusCode,	NULL as ErrorMessage,
						NULL as ActualisationDate,					NULL as Operation,								@l_Person_InterfaceTableID,
						NULL as Sex,								@FU44 as Deceased,								NULL as CountryID,
						NULL as OrganizationUnitCode,				NULL as OrganizationUnitID,						NULL as FathersName,
						NULL as DeathDate,							NULL as DeathCountryID,							NULL as DeathZipCode,
						NULL as DeathCity,							CAST( GETDATE() AS Date ) as CreationDate,		CAST( GETDATE() AS Time ) as CreationTime,
						@CurrentUserName,							@l_PortfolioID,									@l_FU35 as NationalityCode;


					SET @l_ImportID = @@Identity;
					--UPDATE IFC.OTP_TA_FU SET IFCPersonID = @l_ImportID where ID = @ID;

				END;
			-- END IF
			
------------------------------------------------------------------
-- Contact:
------------------------------------------------------------------
			IF @l_ImportID <> 0
			-- THEN
				BEGIN
					IF ISNULL(@FU24,'') <> ''
					BEGIN
						-- TELEFON1:
						INSERT INTO IFC.Contact(
							ObjectID,									SourceInterfaceType,							SourceID, 
							TaxNr,										RegistrationNr,									SourcePersonID,
							StatisticalNr		,						ContactTypeCode,									SourceCompanyID,
							ContactType,								Contact,										MainContact, 
							Description,								CrefoID,										InterfaceStatusCode, 
							ActualisationDate,							ContactID,										Operation, 
							InterfaceTableID,							ValidFrom, 										ValidUntil, 
							CreationDate,								CreationTime, 									CreationUserName)
						SELECT
							NULL as ObjectId,							@p_SourceInterfaceType as SourceInterfaceType,	@RankFU06 + '/T1' as SourceID,
							NULL as TaxNr,								NULL as RegistrationNr,							CASE WHEN @l_Person = 'T' THEN @FU06 ELSE NULL END as SourcePersonID,
							NULL as StatisticalNr,						'CONTACT_TYPE_PHONE' as ContactTypeCode,			CASE WHEN @l_Company = 'T' THEN @FU06 ELSE NULL END as SourceCompanyID,
							NULL as ContactType,						@FU24 as Contact,								NULL as MainContact, 
							NULL as Description,						NULL as CrefoID,								'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
							NULL as ActualisationDate,					NULL as ContactID,								NULL as Operation, 
							@l_Contact_InterfaceTableID,				NULL as ValidFrom,								NULL as ValidUntil, 
							CAST( GETDATE() AS Date ) as CreationDate,	CAST( GETDATE() AS Time ) as CreationTime,		@CurrentUserName;
					END;

					--SET @l_ImportID = @@Identity;
					--UPDATE IFC.OTP_TA_FU SET IFCContactID = Cast(@l_ImportID as nvarchar(18)) where ID = @ID;


					-- TELEFON2:
					IF ISNULL(@FU25,'') <> ''
					BEGIN
						INSERT INTO IFC.Contact(
							ObjectID,									SourceInterfaceType,							SourceID, 
							TaxNr,										RegistrationNr,									SourcePersonID,
							StatisticalNr		,						ContactTypeCode,									SourceCompanyID,
							ContactType,								Contact,										MainContact, 
							Description,								CrefoID,										InterfaceStatusCode, 
							ActualisationDate,							ContactID,										Operation, 
							InterfaceTableID,							ValidFrom, 										ValidUntil, 
							CreationDate,								CreationTime, 									CreationUserName)
						SELECT
							NULL as ObjectId,							@p_SourceInterfaceType as SourceInterfaceType,	@RankFU06 + '/T2' as SourceID,
							NULL as TaxNr,								NULL as RegistrationNr,							CASE WHEN @l_Person = 'T' THEN @FU06 ELSE NULL END as SourcePersonID,
							NULL as StatisticalNr,						'CONTACT_TYPE_PHONE' as ContactTypeCode,			CASE WHEN @l_Company = 'T' THEN @FU06 ELSE NULL END as SourceCompanyID,
							NULL as ContactType,						@FU25 as Contact,								NULL as MainContact, 
							NULL as Description,						NULL as CrefoID,								'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
							NULL as ActualisationDate,					NULL as ContactID,								NULL as Operation, 
							@l_Contact_InterfaceTableID,				NULL as ValidFrom,								NULL as ValidUntil, 
							CAST( GETDATE() AS Date ) as CreationDate,	CAST( GETDATE() AS Time ) as CreationTime,		@CurrentUserName;
					END;

					-- TELEFON-42:
					INSERT INTO IFC.Contact(
						ObjectID,									SourceInterfaceType,							SourceID, 
						TaxNr,										RegistrationNr,									SourcePersonID,
						StatisticalNr		,						ContactTypeCode,									SourceCompanyID,
						ContactType,								Contact,										MainContact, 
						Description,								CrefoID,										InterfaceStatusCode, 
						ActualisationDate,							ContactID,										Operation, 
						InterfaceTableID,							ValidFrom, 										ValidUntil, 
						CreationDate,								CreationTime, 									CreationUserName)
					SELECT
						NULL as ObjectId,							@p_SourceInterfaceType as SourceInterfaceType,	@RankFU06 + '/T3' as SourceID,
						NULL as TaxNr,								NULL as RegistrationNr,							CASE WHEN @l_Person = 'T' THEN @FU06 ELSE NULL END as SourcePersonID,
						NULL as StatisticalNr,						'CONTACT_TYPE_PHONE' as ContactTypeCode,			CASE WHEN @l_Company = 'T' THEN @FU06 ELSE NULL END as SourceCompanyID,
						NULL as ContactType,						@FU42 as Contact,								NULL as MainContact, 
						NULL as Description,						NULL as CrefoID,								'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
						NULL as ActualisationDate,					NULL as ContactID,								NULL as Operation, 
						@l_Contact_InterfaceTableID,				NULL as ValidFrom,								NULL as ValidUntil, 
						CAST( GETDATE() AS Date ) as CreationDate,	CAST( GETDATE() AS Time ) as CreationTime,		@CurrentUserName;

					-- TELEFON-43:
					INSERT INTO IFC.Contact(
						ObjectID,									SourceInterfaceType,							SourceID, 
						TaxNr,										RegistrationNr,									SourcePersonID,
						StatisticalNr		,						ContactTypeCode,									SourceCompanyID,
						ContactType,								Contact,										MainContact, 
						Description,								CrefoID,										InterfaceStatusCode, 
						ActualisationDate,							ContactID,										Operation, 
						InterfaceTableID,							ValidFrom, 										ValidUntil, 
						CreationDate,								CreationTime, 									CreationUserName)
					SELECT
						NULL as ObjectId,							@p_SourceInterfaceType as SourceInterfaceType,	@RankFU06 + '/T4' as SourceID,
						NULL as TaxNr,								NULL as RegistrationNr,							CASE WHEN @l_Person = 'T' THEN @FU06 ELSE NULL END as SourcePersonID,
						NULL as StatisticalNr,						'CONTACT_TYPE_PHONE' as ContactTypeCode,			CASE WHEN @l_Company = 'T' THEN @FU06 ELSE NULL END as SourceCompanyID,
						NULL as ContactType,						@FU43 as Contact,								NULL as MainContact, 
						NULL as Description,						NULL as CrefoID,								'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
						NULL as ActualisationDate,					NULL as ContactID,								NULL as Operation, 
						@l_Contact_InterfaceTableID,				NULL as ValidFrom,								NULL as ValidUntil, 
						CAST( GETDATE() AS Date ) as CreationDate,	CAST( GETDATE() AS Time ) as CreationTime,		@CurrentUserName;

					--SET @l_ImportID = @@Identity;
					--UPDATE IFC.OTP_TA_FU SET IFCContactID = Cast(@l_ImportID as nvarchar(18)) where ID = @ID;

					-- MOBIL:
					IF ISNULL(@FU26,'') <> ''
					BEGIN
						INSERT INTO IFC.Contact(
							ObjectID,									SourceInterfaceType,							SourceID, 
							TaxNr,										RegistrationNr,									SourcePersonID,
							StatisticalNr		,						ContactTypeCode,									SourceCompanyID,
							ContactType,								Contact,										MainContact, 
							Description,								CrefoID,										InterfaceStatusCode, 
							ActualisationDate,							ContactID,										Operation, 
							InterfaceTableID,							ValidFrom, 										ValidUntil, 
							CreationDate,								CreationTime, 									CreationUserName)
						SELECT
							NULL as ObjectId,							@p_SourceInterfaceType as SourceInterfaceType,	@RankFU06 + '/M1' as SourceID,
							NULL as TaxNr,								NULL as RegistrationNr,							CASE WHEN @l_Person = 'T' THEN @FU06 ELSE NULL END as SourcePersonID,
							NULL as StatisticalNr,						'CONTACT_TYPE_MOBILE' as ContactTypeCode,			CASE WHEN @l_Company = 'T' THEN @FU06 ELSE NULL END as SourceCompanyID,
							NULL as ContactType,						@FU26 as Contact,								NULL as MainContact, 
							NULL as Description,						NULL as CrefoID,								'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
							NULL as ActualisationDate,					NULL as ContactID,								NULL as Operation, 
							@l_Contact_InterfaceTableID,				NULL as ValidFrom,								NULL as ValidUntil, 
							CAST( GETDATE() AS Date ) as CreationDate,	CAST( GETDATE() AS Time ) as CreationTime,		@CurrentUserName;
					END;

					--SET @l_ImportID = @@Identity;
					--UPDATE IFC.OTP_TA_FU SET IFCContactID = Cast(@l_ImportID as nvarchar(18)) where ID = @ID;
		
					-- eMAIL:
					IF ISNULL(@FU27,'') <> ''
					BEGIN
						INSERT INTO IFC.Contact(
							ObjectID,									SourceInterfaceType,							SourceID, 
							TaxNr,										RegistrationNr,									SourcePersonID,
							StatisticalNr		,						ContactTypeCode,									SourceCompanyID,
							ContactType,								Contact,										MainContact, 
							Description,								CrefoID,										InterfaceStatusCode, 
							ActualisationDate,							ContactID,										Operation, 
							InterfaceTableID,							ValidFrom, 										ValidUntil, 
							CreationDate,								CreationTime, 									CreationUserName)
						SELECT
							NULL as ObjectId,							@p_SourceInterfaceType as SourceInterfaceType,	@RankFU06 + '/e1' as SourceID,
							NULL as TaxNr,								NULL as RegistrationNr,							CASE WHEN @l_Person = 'T' THEN @FU06 ELSE NULL END as SourcePersonID,
							NULL as StatisticalNr,						'CONTACT_TYPE_EMAIL' as ContactTypeCode,			CASE WHEN @l_Company = 'T' THEN @FU06 ELSE NULL END as SourceCompanyID,
							NULL as ContactType,						@FU27 as Contact,								NULL as MainContact, 
							NULL as Description,						NULL as CrefoID,								'INTERFACE_STATUS_NEW' as InterfaceStatusCode, 
							NULL as ActualisationDate,					NULL as ContactID,								NULL as Operation, 
							@l_Contact_InterfaceTableID,				NULL as ValidFrom,								NULL as ValidUntil, 
							CAST( GETDATE() AS Date ) as CreationDate,	CAST( GETDATE() AS Time ) as CreationTime,		@CurrentUserName;
					END;
				END;

------------------------------------------------------------------
-- Debtor:
------------------------------------------------------------------

			IF @l_ImportID <> 0
			-- THEN
				BEGIN

				Set @l_FU07 =	
					Case Cast(@FU07 as numeric)
						When 1 Then 'DEBTOR_ROLE_1' /* Adós */
						When 2 Then 'DEBTOR_ROLE_2' /* Adóstárs */
						When 3 Then 'DEBTOR_ROLE_4' /* Dologi adós */
						When 4 Then 'DEBTOR_ROLE_3' /* Kezes */
						When 5 Then 'DEBTOR_ROLE_15' /* cég (tulajdonos) */
						When 6 Then 'DEBTOR_ROLE_16' /* cég (ügyvezető) */
						When 7 Then 'DEBTOR_ROLE_17' /* cég (ügyintéző)  ---- Inaktív-Cég (ügyintéző) */
						When 8 Then 'DEBTOR_ROLE_20'  /* Egyéb */
					End;

					INSERT INTO IFC.DEBTOR(
						SourceInterfaceType,						
						SourceID,										
						RoleCode,
						RoleText,
						InterfaceStatusCode,
						SourceDebtCaseID,							
						SourcePersonID,									
						SourceCompanyID,
						CreationDate,								
						CreationTime,
						CreationUserName,
						InterfaceTableID)
					SELECT
						@p_SourceInterfaceType as SourceInterfaceType,
						@RankFU06 as SourceID,
						@l_FU07 as RoleCode,
						NULL as RoleText,
						'INTERFACE_STATUS_NEW' as Status,
						--@FU05 as SourceDebtCaseID,
						@FU02 as SourceDebtCaseID,
						CASE WHEN @l_Person = 'T' THEN @FU06 ELSE NULL END as SourcePersonID,
						CASE WHEN @l_Company = 'T' THEN @FU06 ELSE NULL END as SourceCompanyID,
						CAST( GETDATE() AS Date ) as CreationDate,	CAST( GETDATE() AS Time ) as CreationTime,
						@CurrentUserName,
						@l_Debtor_InterfaceTableID;
						
					SET @l_ImportID = @@Identity;
					--UPDATE IFC.OTP_TA_FU SET IFCDebtorID = @l_ImportID where ID = @ID;

				END;
			END; /* ErrorMessage is NULL */
			IF @l_ImportID <> 0
				BEGIN
					UPDATE IFC.OTP_TA_FU SET InterfaceStatusCode = 'INTERFACE_STATUS_PROCESSED', ErrorMessage = NULL where ID = @ID;
					SET @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
				END;
			ELSE
				BEGIN
					UPDATE IFC.OTP_TA_FU SET InterfaceStatusCode = 'INTERFACE_STATUS_ERROR', ErrorMessage = @ErrorMessage where ID = @ID;
					Set @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
				END;
			FETCH NEXT FROM db_cursor INTO @ID, @FU01, @FU02, @FU03, @FU04, @FU05, @FU06, @FU07, @FU08, @FU09, @FU10, @FU11, @FU12, @FU13, @FU14, @FU15, @FU16, @FU17, @FU18, @FU19, @FU20, @FU21, @FU22, @FU23, 
			@FU24, @FU25, @FU26, @FU27, @FU28, @FU29, @FU30, @FU31, @FU32, @FU33, @FU34, @FU35, @FU36, @FU37, @FU38, @FU39, @FU40, @FU41, @FU42, @FU43, @FU44, @FileName, @InterfaceStatusCode, @RankFU06;
		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    COMMIT TRANSACTION;

    END TRY


    BEGIN CATCH

        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FU_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;				-- LogMessage


        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        ROLLBACK TRANSACTION;

        --RETURN @ErrorMessage;
		Return 99;


    END CATCH;

------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FU_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + ', ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18))  + ', ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) -- LogMessage



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_FU_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If Isnull(@ErrorMessage,'') <> ''
		Return 99;
	else
		Return 1;

END;
go


CREATE PROCEDURE [IFC].[TA_IFCSRM_M_Loader]
	(@p_CorrelationID Numeric(16), @pp_RequestId Numeric(16), @p_SourceInterfaceType nVarchar(200), @p_ImportPackageID Numeric(16), @p_InterfacePackageID Numeric(16))

/* 

USE [indecs_dev]
GO
*/

-- =============================================
-- Author:		Tóth Gábor
-- Creation date: 2022.10.20.
-- Last modified date: 2022.10.20. Ha egyéni vállalkozó, akkor be van töltve a Person-ba is meg a Company-ba is ugyanolyan SourceID-val.
--  KI KELL majd CSERÉLNI: TMP.SRM <-> IFC.SRM
-- Description:	DataTranfer From IFT.OTP_FC to IFC.SRM
-- =============================================

AS

BEGIN
	SET NOCOUNT ON;

    DECLARE @ErrorMSG NVARCHAR(200);
    DECLARE @LogMessage NVARCHAR(200);

	INSERT INTO TMP.TGLOGLOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'TA Loader',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.SRM_M_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		0,							-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage

    SET @ErrorMSG = NULL;

    BEGIN TRANSACTION

    BEGIN TRY
        SET @LogMessage = 'SRM_M Loader Started';
		
		Declare @ID NUMERIC(16);
		Declare @SORSZAM NVARCHAR(4);
		Declare @ADOS_NEVE NVARCHAR(60);
		Declare @HITELSZAMLASZAM NVARCHAR(24);
		Declare @AKTUALIS_TOKE Numeric(21);
		Declare @KONYV_UGYLETI_KAM Numeric(21);
		Declare @KONYV_KES_KAM Numeric(21);
		Declare @KONYV_KOLTS Numeric(21);
		Declare @EGYEB_KOLTS Numeric(21);
		Declare @OSSZES_KOV_ERTEKE Numeric(21);
		Declare @KOV_PENZNEME NVARCHAR(3);
		Declare @DEVSZLA_HUF_DIJ Numeric(21);
		Declare @VETELAR Numeric(21);
		Declare @VETELAR_DEVIZANEME NVARCHAR(3);
		Declare @SZERZ_DATUMA Date;
		Declare @FELM_DATUMA Date;
		Declare @FORDULONAP Date;
		Declare @SZERZODESSZAM  NVARCHAR(20);
		Declare @HITELEZO_ENGEDMENYEZO NVARCHAR(3);
		Declare @WOB_SZAM NVARCHAR(30);
		Declare @ENG_SZERZ_DATUM Date;
		Declare @OSSZ_DB_SZAM Numeric(4);
		Declare @HITELTIPUS NVARCHAR(2);


		Declare @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		
		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);


		Set @l_AllRowCounts = 0;
		Set @l_ImportedRowCounts = 0;
		Set @l_ErrorRowCounts = 0;


		Set @l_AllRowCounts = (Select Count(*) FROM TMP.TGIFCOTP_SRM_M where InterfaceStatusCode = 'InterfaceStatus_NEW');

		DECLARE db_cursor CURSOR FOR 
		SELECT 
			ID, M1, M2, M3, M4, M5, M6, M7, M8, M9, M10, M11, 
			M12, M13, M14, M15, M16, M17, M18, M19, M20, M21, M22 
		FROM TMP.TGIFCOTP_SRM_M
		where InterfaceStatusCode = 'InterfaceStatus_NEW' order by Id;

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO 
			@ID, @SORSZAM, @ADOS_NEVE, @HITELSZAMLASZAM, @AKTUALIS_TOKE, @KONYV_UGYLETI_KAM, @KONYV_KES_KAM, @KONYV_KOLTS, @EGYEB_KOLTS,
			@OSSZES_KOV_ERTEKE, @KOV_PENZNEME, @DEVSZLA_HUF_DIJ, @VETELAR, @VETELAR_DEVIZANEME, @SZERZ_DATUMA, @FELM_DATUMA, @FORDULONAP,
			@SZERZODESSZAM , @HITELEZO_ENGEDMENYEZO, @WOB_SZAM, @ENG_SZERZ_DATUM, @OSSZ_DB_SZAM, @HITELTIPUS

		WHILE @@FETCH_STATUS = 0  
		BEGIN  

-- Insert Section:
select * from TMP.TGIFC_SRM_F

				  INSERT INTO TMP.TGIFC_SRM_M (
					SORSZAM,
					ADOS_NEVE,
					HITELSZAMLASZAM,
					AKTUALIS_TOKE,
					KONYV_UGYLETI_KAM,
					KONYV_KES_KAM,
					KONYV_KOLTS,
					EGYEB_KOLTS,
					OSSZES_KOV_ERTEKE,
					KOV_PENZNEME,
					DEVSZLA_HUF_DIJ,
					VETELAR,
					VETELAR_DEVIZANEME,
					SZERZ_DATUMA,
					FELM_DATUMA,
					FORDULONAP,
					SZERZODESSZAM ,
					HITELEZO_ENGEDMENYEZO,
					WOB_SZAM,
					ENG_SZERZ_DATUM,
					OSSZ_DB_SZAM,
					HITELTIPUS,
					InterfacePackageID,
					InterfaceStatusCode,
					--SourceInterfaceType,
					CreationDate,
					CreationTime,
					CreationUserName
					  )
				  SELECT
					@SORSZAM,
					@ADOS_NEVE,
					@HITELSZAMLASZAM,
					@AKTUALIS_TOKE,
					@KONYV_UGYLETI_KAM,
					@KONYV_KES_KAM,
					@KONYV_KOLTS,
					@EGYEB_KOLTS,
					@OSSZES_KOV_ERTEKE,
					@KOV_PENZNEME,
					@DEVSZLA_HUF_DIJ,
					@VETELAR,
					@VETELAR_DEVIZANEME,
					@SZERZ_DATUMA,
					@FELM_DATUMA,
					@FORDULONAP,
					@SZERZODESSZAM ,
					@HITELEZO_ENGEDMENYEZO,
					@WOB_SZAM,
					@ENG_SZERZ_DATUM,
					@OSSZ_DB_SZAM,
					@HITELTIPUS,
					@p_InterfacePackageID,	-- InterfacePackageID,
					'InterfaceStatus_NEW',	-- InterfaceStatusCode,
					--@p_SourceInterfaceType,
					CAST( GETDATE() AS Date ),
					CAST( GETDATE() AS Time ),
					SUSER_SNAME();
				  SET @l_ImportID = @@Identity;
				  UPDATE TMP.TGIFCOTP_SRM_F SET IFCSRM_F_ID = @l_ImportID where ID = @ID;
				END;

				IF @l_ImportID <> 0
					BEGIN
						UPDATE TMP.TGIFCOTP_SRM_F SET InterfaceStatusCode = 'InterfaceStatus_PROCESSED' where ID = @ID;
						Set @l_ImportedRowCounts = @l_ImportedRowCounts + 1;
					END;
				ELSE
					BEGIN
						UPDATE TMP.TGIFCOTP_SRM_F SET InterfaceStatusCode = 'InterfaceStatus_ERROR' /*, ErrorMessage = ''*/ where ID = @ID;
						Set @l_ErrorRowCounts = @l_ErrorRowCounts + 1;
					END;


			  FETCH NEXT FROM db_cursor INTO @ID, @SORSZAM, @ADOS_NEVE, @HITELSZAMLASZAM, @AKTUALIS_TOKE, @KONYV_UGYLETI_KAM, @KONYV_KES_KAM, @KONYV_KOLTS, @EGYEB_KOLTS,
			@OSSZES_KOV_ERTEKE, @KOV_PENZNEME, @DEVSZLA_HUF_DIJ, @VETELAR, @VETELAR_DEVIZANEME, @SZERZ_DATUMA, @FELM_DATUMA, @FORDULONAP,
			@SZERZODESSZAM , @HITELEZO_ENGEDMENYEZO, @WOB_SZAM, @ENG_SZERZ_DATUM, @OSSZ_DB_SZAM, @HITELTIPUS


		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    COMMIT TRANSACTION;

    END TRY


    BEGIN CATCH
        DECLARE @ErrorMessage NVARCHAR(200);
        DECLARE @ErrorSeverity INT;
        DECLARE @ErrorState INT;
        DECLARE @ErrorLine INT;

        SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        ROLLBACK TRANSACTION;

        SELECT @ErrorMSG;

    END CATCH;


------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------

	INSERT INTO TMP.TGLOGLOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'TA Loader',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.SRM_M_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		0,							-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + ', ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18))  + ', ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) -- LogMessage



	INSERT INTO TMP.TGLOGLOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'TA Loader',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.SRM_M_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		0,							-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage

END

go


CREATE   PROCEDURE [IFC].[TA_SRM_F_Loader]
	(@p_CorrelationID Numeric(16), @p_SourceInterfaceType nVarchar(200), @p_InterfacePackageID Numeric(16))

/* 

USE [indecs_dev]
GO
*/

-- =============================================
-- Author:		Tóth Gábor
-- Creation date: 2022.11.10.
-- Last modified date: 
--  KI KELL majd 
-- Description:	DataTranfer From IFT.OTP_FC to IFC.SRM
-- =============================================

AS

BEGIN
	SET NOCOUNT ON;
	DECLARE @ErrorMessage NVARCHAR(200);
	DECLARE @ErrorSeverity INT;
	DECLARE @ErrorState INT;
	DECLARE @ErrorLine INT;
	Declare @l_ObjectID numeric(18);

    DECLARE @LogMessage NVARCHAR(200);

	SET @ErrorMessage = '';
	SET @ErrorSeverity = 0;
	SET @ErrorState = 0;
	SET @ErrorLine = 0;

	Declare @CurrentUserID numeric(18);
	Declare @CurrentUser nvarchar(50);

	Set @CurrentUser = (select Right(SUSER_SNAME(), len(SUSER_SNAME())-Charindex('\',SUSER_SNAME())));

	Set @CurrentUserID = 'Admin';
	If exists (select 1 from PRT.AppUser where UserName = @CurrentUser)
		Set @CurrentUserID = (select Top 1 ID from PRT.AppUser where UserName = @CurrentUser order by ID);
	ELSE
		Set @ErrorMessage = 'Current user id not defined (' + @CurrentUser + ')';



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'TA Loader',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_SRM_F_Loader',		-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'START';					-- LogMessage


    BEGIN TRANSACTION

    BEGIN TRY
        SET @LogMessage = 'SRM_F Loader Started';
		
		Declare @ID NUMERIC(16);
		Declare @SZERZODESSZAM  NVARCHAR(20);
		Declare @PENZUGYI_FORDULONAP Date;
		Declare @ENG_SZERZ_ALAIRAS_DATUMA Date;
		Declare @OSSZ_DB_SZAM Numeric(4);
		Declare @TOKE Numeric(21);
		Declare @KAMAT_UGYLETI Numeric(21);
		Declare @KAMAT_KESEDELMI Numeric(21);
		Declare @KOLTSEG Numeric(21);
		Declare @VETELAR Numeric(21);
		Declare @KOVETELES_OSSZESEN Numeric(21);
		Declare @KOV_PENZNEME NVARCHAR(3);
		Declare @DEVSZLA_HUF_DIJ Numeric(21);
		Declare @HATAROZATSZAM NVARCHAR(30);
		Declare @VETELAR_DEVIZANEME NVARCHAR(3);


		Declare @l_ImportID numeric(18); -- Az újonnan beszúrt IFC rekordok ID-ja
		
		Declare @l_AllRowCounts numeric(18);
		Declare @l_ImportedRowCounts numeric(18);
		Declare @l_ErrorRowCounts numeric(18);


		Set @l_AllRowCounts = 0;
		Set @l_ImportedRowCounts = 0;
		Set @l_ErrorRowCounts = 0;


		Set @l_AllRowCounts = (Select Count(*) FROM IFC.OTP_SRM_F where InterfaceStatusCode = 'InterfaceStatus_NEW');

		DECLARE db_cursor CURSOR FOR 
		SELECT 
			ID, F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14 
		FROM IFC.OTP_SRM_F
		where InterfaceStatusCode = 'InterfaceStatus_NEW';

		OPEN db_cursor;
		FETCH NEXT FROM db_cursor INTO 
			@ID, @SZERZODESSZAM, @PENZUGYI_FORDULONAP, @ENG_SZERZ_ALAIRAS_DATUMA, @OSSZ_DB_SZAM, @TOKE, @KAMAT_UGYLETI,
			@KAMAT_KESEDELMI, @KOLTSEG, @VETELAR, @KOVETELES_OSSZESEN, @KOV_PENZNEME, @DEVSZLA_HUF_DIJ, @HATAROZATSZAM, @VETELAR_DEVIZANEME
		WHILE @@FETCH_STATUS = 0  
		BEGIN  

-- Insert Section:
		  INSERT INTO IFC.Contract(
				ObjectID, 
				SellerName, 
				SellerPartyID, 
				BuyerName, 
				BuyerPartyID, 
				ReferencedContractNr, 
				ReferencedContractID, 
				ContractTypeCode, 
				ContractTypeText, 
				ContractPhaseCode, 
				ContractPhaseText, 
				StatusCode, 
				StatusText, 
				ContractNr, 
				RegistrationNr, 
				ExternalContractNr, 
				DecisionNr, 
				ValidFrom, 
				ValidUntil, 
				ContractDate, 
				SourceID, 
				SourceInterfaceType, 
				InterfaceStatusCode, 
				ErrorMessage, 
				Operation, 
				ImportTableID, 
				CreationDate, 
				CreationTime, 
				CreationUserName)
		  SELECT
		  		@l_ObjectID as ObjectID, 
				NULL as SellerName, 
				NULL as SellerPartyID, 
				NULL as BuyerName, 
				NULL as BuyerPartyID, 
				NULL as ReferencedContractNr, 
				NULL as ReferencedContractID, 
				NULL as ContractTypeCode, 
				NULL as ContractTypeText, 
				NULL as ContractPhaseCode, 
				NULL as ContractPhaseText, 
				NULL as StatusCode, 
				NULL as StatusText, 
				NULL as ContractNr, 
				@HATAROZATSZAM as RegistrationNr, 
				@SZERZODESSZAM as ExternalContractNr, 
				NULL as DecisionNr, 
				NULL as ValidFrom, 
				NULL as ValidUntil, 
				NULL as ContractDate, 
				@SZERZODESSZAM as SourceID, 
				@p_SourceInterfaceType as SourceInterfaceType, 
				'InterfaceStatus_NEW' as InterfaceStatusCode, 
				NULL as ErrorMessage, 
				NULL as Operation, 
				@p_InterfacePackageID as ImportTableID, 
				CAST( GETDATE() AS Date ),
				CAST( GETDATE() AS Time ),
				@CurrentUserID;

-- Insert Section:
			INSERT INTO IFC.CollectionContractSummary(
				ObjectID, 
				CurrencyCode, 
				ItemCount, 
				DebtCapital, 
				DebtInterest, 
				DebtPenaltyInterest, 
				DebtCost, 
				DebtCostLocalCurrency, 
				DebtTotal, 
				PurchasePrice, 
				PurchasePriceCurrencyCode, 
				CollectionContractSummaryID, 
				SourceID, 
				SourceContractID, 
				SourceInterfaceType, 
				InterfaceStatusCode, 
				ErrorMessage, 
				OperationCode, 
				ImportTableID, 
				CreationDate, 
				CreationTime, 
				CreationUserName)
			SELECT
				NULL as ObjectID, 
				@KOV_PENZNEME as CurrencyCode,
				@OSSZ_DB_SZAM as ItemCount,
				@TOKE as DebtCapital,
				@KAMAT_UGYLETI as DebtInterest,
				@KAMAT_KESEDELMI as DebtPenaltyInterest, 
				@KOLTSEG as DebtCost,
				@DEVSZLA_HUF_DIJ as DebtCostLocalCurrency,
				@KOVETELES_OSSZESEN as DebtTotal,
				@VETELAR as PurchasePrice, 
				@VETELAR_DEVIZANEME as PurchasePriceCurrencyCode,
				NULL as CollectionContractSummaryID, 
				@SZERZODESSZAM as SourceID, 
				@SZERZODESSZAM as SourceContractID, 
				@p_SourceInterfaceType as SourceInterfaceType, 
				'InterfaceStatus_NEW' as InterfaceStatusCode, 
				NULL as ErrorMessage, 
				NULL as Operation, 
				@p_InterfacePackageID as ImportTableID, 
				CAST( GETDATE() AS Date ),
				CAST( GETDATE() AS Time ),
				@CurrentUserID;


			  FETCH NEXT FROM db_cursor INTO @ID, @SZERZODESSZAM, @PENZUGYI_FORDULONAP, @ENG_SZERZ_ALAIRAS_DATUMA, @OSSZ_DB_SZAM, @TOKE, @KAMAT_UGYLETI,
			@KAMAT_KESEDELMI, @KOLTSEG, @VETELAR, @KOVETELES_OSSZESEN, @KOV_PENZNEME, @DEVSZLA_HUF_DIJ, @HATAROZATSZAM, @VETELAR_DEVIZANEME

		END;

		CLOSE db_cursor;
		DEALLOCATE db_cursor;


    COMMIT TRANSACTION;

    END TRY


    BEGIN CATCH

	SELECT   
        @ErrorMessage = ERROR_MESSAGE(),  
        @ErrorSeverity = ERROR_SEVERITY(),  
        @ErrorState = ERROR_STATE(),
        @ErrorLine = ERROR_LINE();

        SET @ErrorMessage = CONCAT('Error occured in line: ', @ErrorLine, ', in query: ', @LogMessage, Char(10), 'ERROR MESSAGE: ', @ErrorMessage);

	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'TA Loader',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_SRM_F_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'FATAL',					-- SeverityLevel
		NULL,						-- MessageCategory
		@ErrorMessage;				-- LogMessage


        RAISERROR ( @ErrorMessage, @ErrorSeverity, @ErrorState, @ErrorLine );

        ROLLBACK TRANSACTION;

        RETURN @ErrorMessage;

    END CATCH;

------------------------------------------------------------------
-- LOG-olás:
------------------------------------------------------------------
	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'TA Loader',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_SRM_F_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'AllRowCounts: ' + CAST(@l_AllRowCounts as NVARCHAR(18)) + ', ImportedRowsCount: ' + CAST(@l_ImportedRowCounts as NVARCHAR(18))  + ', ErrorRowsCount: ' + CAST(@l_ErrorRowCounts as NVARCHAR(18)) -- LogMessage



	INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	SELECT 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'TA Loader',				-- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		'IFC.TA_SRM_F_Loader',			-- ServiceName
		'1.0',						-- ServiceVersion
		'INFO',						-- SeverityLevel
		NULL,						-- MessageCategory
		'END';						-- LogMessage


	If Isnull(@ErrorMessage,'') <> ''
		Return 99;
	else
		Return 1;

END;

go


-- =============================================
-- Author:        Kiss János
-- Create date: 2023-03-14
-- Last modified date:
-- Description:
-- =============================================
CREATE PROCEDURE [ORG].[TaskCalling]
    @TaskTypeCode NVARCHAR(200),
	@ObjectID NUMERIC(16),
	@ProcessID NUMERIC(16) = NULL,
	@UserName NVARCHAR(200) = NULL,
	@Subject NVARCHAR(200) = NULL,
	@Comment NVARCHAR(MAX) = NULL,
	@Priority NVARCHAR(50) = NULL,
	@DeadLineDate DATE,
	@DeadLineTime Time,
	@ExternalTaskID NVARCHAR(200),
	@DetailsStatusCode NVARCHAR(200),
	@CreationUserName NVARCHAR(200)

AS



BEGIN



   DECLARE @ErrorMSG NVARCHAR(200)
   DECLARE @LogMessage NVARCHAR(200)
   DECLARE @InsertedObjectID NUMERIC(16)
   DECLARE @DateDiff numeric

   select @DateDiff=DeadlineDay from org.TaskType where ID=@TaskTypeCode

   set @DeadLineDate=coalesce(@DeadLineDate,CAST( GETDATE()+@DateDiff AS Date))
   set @DeadLineTime=coalesce(@DeadLineTime,CONVERT(VARCHAR(8), GETDATE(),108))

   SET @ErrorMSG = NULL



   BEGIN TRANSACTION
        BEGIN TRY

			SET @LogMessage = 'Task creation start...'
            PRINT (@LogMessage)

			IF @UserName is null
				SET @UserName = 'Admin'

			INSERT INTO gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
				VALUES((SELECT GEN.ObjectType.Code
							FROM GEN.ObjectType
							WHERE GEN.ObjectType.TableName = 'ORG.Task'), CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @CreationUserName, 'Process task', '1.0.0')

			SELECT @InsertedObjectID = @@IDENTITY;

			INSERT INTO ORG.Task(ObjectID, TaskTypeID, ReferencedObjectTypeCode, ReferencedObjectID, UserID, StatusCode, Subject, PriorityCode, ProcessID, CreationDate, CreationTime, CreationUserName, Comments, DeadlineDate, DeadlineTime, ExternalTaskID, DetailsStatusCode,BeginDate,BeginTime)
				VALUES(@InsertedObjectID, @TaskTypeCode, (SELECT GEN.ObjectType.Code
															FROM GEN.Object
																join GEN.ObjectType on GEN.ObjectType.TableName = GEN.Object.ObjectType
															WHERE ID = @ObjectID), @ObjectID, @UserName, 'TASK_MAIN_STATUS_NEW', @Subject, @Priority, @ProcessID, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @CreationUserName, @Comment, @DeadLineDate, @DeadLineTime, @ExternalTaskID, @DetailsStatusCode,CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108))


			SET @LogMessage = 'Task creation end.'
            PRINT (@LogMessage) 

   COMMIT TRANSACTION


	SELECT * 
		FROM ORG.Task
		WHERE ORG.Task.ObjectID = @InsertedObjectID

            
        END TRY
        BEGIN CATCH
            SELECT  
                ERROR_NUMBER() AS ErrorNumber  
                ,ERROR_SEVERITY() AS ErrorSeverity  
                ,ERROR_STATE() AS ErrorState  
                ,ERROR_PROCEDURE() AS ErrorProcedure  
                ,ERROR_LINE() AS ErrorLine  
                ,ERROR_MESSAGE() AS ErrorMessage;



           SET @LogMessage = 'ERROR'
            PRINT (@LogMessage)



           ROLLBACK TRANSACTION



       END CATCH



END
go


-- =============================================
-- Author:        Kiss János
-- Create date: 2023-03-14
-- Last modified date:
-- Description:
-- =============================================
CREATE PROCEDURE [ORG].[TaskCalling_2]
    @TaskTypeCode NVARCHAR(200),
	@ObjectID NUMERIC(16),
	@ProcessID NUMERIC(16) = NULL,
	@UserName NVARCHAR(200) = NULL,
	@Subject NVARCHAR(200) = NULL,
	@Comment NVARCHAR(MAX) = NULL,
	@Priority NVARCHAR(50) = NULL,
	@DeadLineDate DATE,
	@DeadLineTime Time,
	@ExternalTaskID NVARCHAR(200),
	@DetailsStatusCode NVARCHAR(200),
	@CreationUserName NVARCHAR(200),
	@TaskID NUMERIC(16) OUTPUT

AS



BEGIN
	SET NOCOUNT ON


   DECLARE @ErrorMSG NVARCHAR(200)
   DECLARE @LogMessage NVARCHAR(200)
   DECLARE @InsertedObjectID NUMERIC(16)
   DECLARE @DateDiff numeric

   select @DateDiff=DeadlineDay from org.TaskType where ID=@TaskTypeCode

   set @DeadLineDate=coalesce(@DeadLineDate,CAST( GETDATE()+@DateDiff AS Date))
   set @DeadLineTime=coalesce(@DeadLineTime,CONVERT(VARCHAR(8), GETDATE(),108))

   SET @ErrorMSG = NULL



   BEGIN TRANSACTION
        BEGIN TRY

			SET @LogMessage = 'Task creation start...'
            PRINT (@LogMessage)

			IF @UserName is null
				SET @UserName = 'Admin'

			INSERT INTO gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
				VALUES((SELECT GEN.ObjectType.Code
							FROM GEN.ObjectType
							WHERE GEN.ObjectType.TableName = 'ORG.Task'), CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @CreationUserName, 'Process task', '1.0.0')

			SELECT @InsertedObjectID = @@IDENTITY;

			INSERT INTO ORG.Task(ObjectID, TaskTypeID, ReferencedObjectTypeCode, ReferencedObjectID, UserID, StatusCode, Subject, PriorityCode, ProcessID, CreationDate, CreationTime, CreationUserName, Comments, DeadlineDate, DeadlineTime, ExternalTaskID, DetailsStatusCode,BeginDate,BeginTime)
				VALUES(@InsertedObjectID, @TaskTypeCode, (SELECT GEN.ObjectType.Code
															FROM GEN.Object
																join GEN.ObjectType on GEN.ObjectType.TableName = GEN.Object.ObjectType
															WHERE ID = @ObjectID), @ObjectID, @UserName, 'TASK_MAIN_STATUS_NEW', @Subject, @Priority, @ProcessID, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @CreationUserName, @Comment, @DeadLineDate, @DeadLineTime, @ExternalTaskID, @DetailsStatusCode,CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108))


			SET @LogMessage = 'Task creation end.'
            PRINT (@LogMessage) 

   COMMIT TRANSACTION


		SELECT @TaskID = Task.ID 
		FROM ORG.Task
		WHERE ORG.Task.ObjectID = @InsertedObjectID

		SET @LogMessage = CONCAT('Object id.:', @InsertedObjectID, ', Task id.: ', @TaskID)
        PRINT (@LogMessage)

		RETURN;            
        END TRY
        BEGIN CATCH
			ROLLBACK TRANSACTION

			/*SELECT
				NULL AS ID,
				NULL AS ObjectID, 
				NULL AS TaskTypeID, 
				NULL AS UserID, 
				NULL AS StatusCode,
				NULL AS DetailedStatusCode,
				NULL AS BeginDate, 
				NULL AS BeginTime,
				NULL AS EndDate, 
				NULL AS EndTime, 
				NULL AS DeadlineDate, 
				NULL AS DeadlineTime, 
				NULL AS Subject,
				NULL AS ParentTaskID,
				NULL AS Priority,
				NULL AS ProcessID,
				NULL AS CreationDate, 
				NULL AS CreationTime, 
				NULL AS CreationUserName,
				NULL AS LastModifiedDate,
				NULL AS LastModifiedTime,
				NULL AS LastModifiedUserName,
				NULL AS Comments,
				NULL AS ReferencedObjectID,
				NULL AS TaskListID,
				NULL AS ReferencedObjectTypeCode,
				NULL AS PriorityCode,
				NULL AS ResultObjectTypeCode,
				NULL AS ResultObjectID,
				NULL AS WaitingForTaskID,
				NULL AS ScheduleDate,
				NULL AS ScheduleTime, 
				NULL AS ExternalTaskID,
				NULL AS TaskGroupOperationID;*/
			
			/*SELECT  
                ERROR_NUMBER() AS ErrorNumber  
                ,ERROR_SEVERITY() AS ErrorSeverity  
                ,ERROR_STATE() AS ErrorState  
                ,ERROR_PROCEDURE() AS ErrorProcedure  
                ,ERROR_LINE() AS ErrorLine  
                ,ERROR_MESSAGE() AS ErrorMessage;*/



           SET @LogMessage = 'ERROR'
            PRINT (@LogMessage)



			SELECT @TaskID = 0;
			RETURN;

       END CATCH



END
go

-- =============================================
-- Author:		Balázs ARANYI
-- Create date: 2023-03-30
-- Last modified date: 2023-10-13
-- Description:	Inserts a new Task record
--              2023.10.13. DV-1524: the referencedObjectID can be null, if the ReferencedObjectTypeCode of the TaskType is null (we need this for the Indecs-Inkasso synchronization)
-- =============================================
CREATE   PROCEDURE [ORG].[TaskCalling_NewVersion]
	@p_taskTypeCode NVARCHAR(200),
	@p_referencedObjectID NUMERIC(16),
	@p_processID NUMERIC(16) = NULL,
	@p_userName NVARCHAR(200) = NULL,
	@p_subject NVARCHAR(200) = NULL,
	@p_comment NVARCHAR(MAX) = NULL,
	@p_priority NVARCHAR(50) = NULL,
	@p_deadLineDate DATE,
	@p_deadLineTime Time,
	@p_externalTaskID NVARCHAR(200),
	@p_detailsStatusCode NVARCHAR(200),
	@p_creationUserName NVARCHAR(200),
	@p_newTaskID NUMERIC(16) OUTPUT,
	@p_errorMsg NVARCHAR(MAX) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'ORG.[TaskCalling_NewVersion]'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók definiálása (opcionális)
	DECLARE @l_referencedObjectTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_orgTaskListObjectTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_orgTaskObjectTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_deadlineDayTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_dateDiff NUMERIC(5) = NULL;
	DECLARE @l_taskListTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_taskListID NUMERIC(16) = NULL;
	--ORG.TaskListType változói
	DECLARE @l_dataSourceSQLStatement NVARCHAR(MAX) = NULL;
	DECLARE @l_subject NVARCHAR(250) = NULL;
	--ORG.TaskType változói
	DECLARE @l_taskTypeReferencedObjectTypeCode NVARCHAR(200) = NULL;
	--ORG.Task változói
	DECLARE @l_taskID NUMERIC(16) = NULL;

	BEGIN TRY
--===========================================================
--BLOCK      : START
--DESCRIPTION: Start procedure
--===========================================================
	--	BEGIN TRANSACTION MAIN_TRANSACTION;

		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		--Kimenő paraméterek inicializálása
		SELECT @p_newTaskID = NULL;
		SELECT @p_errorMsg = NULL;

--===========================================================
--BLOCK      : CHECK SYSTEM COMPONENTS
--DESCRIPTION: Checking system components
--===========================================================
		SELECT @l_logMsg = 'Checking system components... ';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		SELECT @l_errorMsg = NULL;

		SELECT @l_orgTaskObjectTypeCode = [ObjectType].[Code]
		FROM [GEN].[ObjectType] 
		WHERE [ObjectType].[TableName] = 'ORG.Task';

		IF COALESCE(@l_orgTaskObjectTypeCode, '') = ''
			SELECT @l_errorMsg = @l_errorMsg + 
				'Object type is not defined: ORG.Task. ';

		SELECT @l_orgTaskListObjectTypeCode = [ObjectType].[Code]
		FROM [GEN].[ObjectType] 
		WHERE [ObjectType].[TableName] = 'ORG.TaskList';

		IF COALESCE(@l_orgTaskListObjectTypeCode, '') = ''
			SELECT @l_errorMsg = @l_errorMsg + 
				'Object type is not defined: ORG.TaskList. ';

		IF COALESCE(@l_errorMsg, '') <> '' 
			RAISERROR(@l_errorMsg, 16, 1);

--===========================================================
--BLOCK      : CHECK PARAMS
--DESCRIPTION: Checking parameters
--===========================================================
		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		IF COALESCE(@p_taskTypeCode, '') = ''
			RAISERROR('The p_taskTypeCode parameter can''t empty.', 16, 1);

--===========================================================
--BLOCK      : PROCESS START
--DESCRIPTION: 
--===========================================================
		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

--===========================================================
--BLOCK      : PROCESS IN PROGRESS
--DESCRIPTION: Retrieving the data required for processing
--===========================================================

    if IsNull(@p_creationUserName, '') = ''
       set @p_creationUserName = IsNull(@p_creationUserName, 'admin')
    
		SELECT 
			@l_deadlineDayTypeCode = COALESCE([TaskType].[DeadlineDayTypeCode], 'DAY_TYPE_DAY'),
			@l_DateDiff = COALESCE([TaskType].[DeadlineDay], 0), 
			@l_taskListTypeCode = [TaskType].[TaskListTypeID],
			@l_taskTypeReferencedObjectTypeCode = [TaskType].[ReferencedObjectTypeCode]
		FROM [ORG].[TaskType] 
		WHERE [TaskType].[ID] = @p_taskTypeCode;


    IF COALESCE(@l_taskTypeReferencedObjectTypeCode, '') <> '' 
    begin
      if COALESCE(@p_referencedObjectID, 0) = 0
			   RAISERROR('The p_referencedObjectID parameter can''t empty.', 16, 1)

		  SELECT 
			  @l_referencedObjectTypeCode = [Object].[ObjectType]
		  FROM [GEN].[Object] 
		  WHERE [Object].[ID] = @p_referencedObjectID;

		  IF COALESCE(@l_referencedObjectTypeCode, '') = '' 
		  BEGIN 
			  SELECT @l_errorMsg = CONCAT('The type of referenced object isn''t defined. Referenced object id.:', @p_referencedObjectID, '.');
			  RAISERROR(@l_errorMsg, 16, 1);
		  END;

		  IF @l_referencedObjectTypeCode <> @l_taskTypeReferencedObjectTypeCode
		  BEGIN 
			  SELECT @l_errorMsg = 
				  CONCAT('The type of referenced object is not same with the referenced object type of task type. ', 
					  'Referenced object type:', @l_referencedObjectTypeCode, 
					  ', Task type: ', @p_taskTypeCode,
					  ', Referenced object type of task type: ', @l_taskTypeReferencedObjectTypeCode, 
					  '.');
			  RAISERROR(@l_errorMsg, 16, 1);
		  END;
    end
--===========================================================
--BLOCK      : PROCESS IN PROGRESS
--DESCRIPTION: Calculationg task list type
--===========================================================

		IF COALESCE(@l_taskListTypeCode, '') = ''
		BEGIN
			SELECT @l_errorMsg = CONCAT('The task list type isn''t defined to task type: ', @p_taskTypeCode, '.');
			RAISERROR(@l_errorMsg, 16, 1);
		END

		SELECT @l_dataSourceSQLStatement = [DataSource].[SQLExpression]
		FROM [GEN].[DataSource]
		JOIN [ORG].[TaskListType] ON ([TaskListType].[SelectionRuleDataSourceID] = [DataSource].[ID])
		WHERE [TaskListType].[ID] = @l_taskListTypeCode;

		IF COALESCE(@l_dataSourceSQLStatement, '') = ''
		BEGIN
			SELECT @l_taskListID = [TaskList].[ID] 
			FROM [ORG].[TaskList] 
			WHERE [TaskList].[TaskListTypeID] = @l_taskListTypeCode
			AND [TaskList].[StatusCode] IN ('TASK_LIST_MAIN_STATUS_NEW', 'TASK_LIST_MAIN_STATUS_PROCESSING')
			AND [TaskList].[CreationDate] = CAST( GETDATE() AS Date );
		END;

		SELECT @l_objectID = NULL;

		IF COALESCE(@l_taskListID, 0) = 0
		BEGIN
			INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr]) 
			SELECT @l_orgTaskListObjectTypeCode, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @p_creationUserName, CONCAT(@l_taskListTypeCode, ' task list object'), '1.0';

			SELECT @l_objectID = @@IDENTITY;

			IF COALESCE(@l_objectID, 0) > 0
			BEGIN
				INSERT INTO [ORG].[TaskList] ([ObjectID], [TaskListTypeID], [StatusCode], [Subject], [CreationDate], [CreationTime], [CreationUserName])
				SELECT @l_objectID, @l_taskListTypeCode, 'TASK_LIST_MAIN_STATUS_NEW', NULL, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @p_creationUserName;
			
				SELECT @l_taskListID = @@IDENTITY;			
			END
		END;

		IF COALESCE(@l_taskListID, 0) = 0 
		BEGIN
			SELECT @l_errorMsg = CONCAT('The task list identifier isn''t empty. Task list type: ', @l_taskListTypeCode, '.');
			RAISERROR(@l_errorMsg, 16, 1);
		END;

		SELECT @l_dataSourceSQLStatement = NULL;

		SELECT @l_dataSourceSQLStatement = [DataSource].[SQLExpression]
		FROM [GEN].[DataSource]
		JOIN [ORG].[TaskListType] ON ([TaskListType].[SubjectDataSourceID] = [DataSource].[ID])
		WHERE [TaskListType].[ID] = @l_taskListTypeCode;

		IF COALESCE(@l_dataSourceSQLStatement, '') = ''
			SELECT @l_subject = CONCAT([GEN].[TranslateCode](@l_taskListTypeCode, 'HU'), ' ', CAST( GETDATE() AS DATE));

		UPDATE [ORG].[TaskList] SET 
			[Subject] = @l_subject 
		WHERE [TaskList].[ID] = @l_taskListID;

--===========================================================
--BLOCK      : PROCESS IN PROGRESS
--DESCRIPTION: Calculating deadline
--===========================================================
		
		SELECT @p_deadLineDate = COALESCE(@p_deadLineDate, CAST(GETDATE() + @l_DateDiff AS DATE));
		SELECT @p_deadLineTime = COALESCE(@p_deadLineTime, CONVERT(VARCHAR(8), GETDATE(),108));

--===========================================================
--BLOCK      : PROCESS IN PROGRESS
--DESCRIPTION: Inserting new task
--===========================================================

		SELECT @l_objectID = NULL;

		INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr]) 
		SELECT @l_orgTaskObjectTypeCode, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), @p_creationUserName, CONCAT(@l_taskListTypeCode, ' task list object'), '1.0';

		SELECT @l_objectID = @@IDENTITY;

		IF COALESCE(@l_objectID, 0) > 0
		BEGIN
			INSERT INTO [ORG].[Task] (
				[ObjectID], 
				[ReferencedObjectTypeCode],
				[ReferencedObjectID],
				[TaskTypeID], 
				[UserID], 
				[StatusCode], 
				[DetailsStatusCode],
				[DeadlineDate],
				[DeadlineTime],
				[Subject], 
				[PriorityCode],
				[ProcessID],
				[TaskListID],
				[ExternalTaskID],
				[CreationDate], 
				[CreationTime], 
				[CreationUserName])
			SELECT 
				@l_objectID, 
				@l_referencedObjectTypeCode,
				@p_referencedObjectID,
				@p_taskTypeCode,
				@p_userName,
				'TASK_MAIN_STATUS_NEW',
				@p_detailsStatusCode,
				@p_deadLineDate,
				@p_deadLineTime,
				@p_subject,
				@p_priority,
				@p_processID,
				@l_taskListID,
				@p_externalTaskID,
				CAST( GETDATE() AS Date), 
				CONVERT(VARCHAR(8), GETDATE(),108), 
				@p_creationUserName;
			
			SELECT @l_taskID = @@IDENTITY;	
			
			SELECT @l_logMsg = CONCAT('Identifier of the created task: ', @l_taskID);

			BEGIN TRANSACTION LOG_TRANSACTION;
			INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				NULL,			-- CorrelationID
				'INDECS 3.0',			    -- ApplicationName
				DB_NAME(),					-- Environment
				'BACKEND',					-- Layer
				@l_procedureName,   		-- ServiceName
				'1.0',						-- ServiceVersion
				'INFO',					        -- SeverityLevel
				NULL,						-- MessageCategory
				@l_logMsg;				    -- LogMessage
			COMMIT TRANSACTION LOG_TRANSACTION;
			
			PRINT @l_logMsg;
		END
		
		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		--COMMIT TRANSACTION MAIN_TRANSACTION;

		SELECT 
			@p_newTaskID = [Task].[ID],
			@p_errorMsg  = ''
		FROM [ORG].[Task] 
		WHERE [Task].[ID] = @l_taskID;
	END TRY

	BEGIN CATCH
		--ROLLBACK TRANSACTION MAIN_TRANSACTION;

		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			NULL,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_errorMsg;

		SELECT 
			@p_newTaskID = NULL,
			@p_errorMsg = @l_errorMsg;
	END CATCH
END
go

-- =============================================
-- Author:		Aranyi Balázs
-- Create date: 2023.04.13.
-- Last modified date: 2023.04.20.
-- Description:	Processes the group operation specified in the parameter. 
--
-- 2023.04.20. Added MessageQueueTopic on ModuleINstanceInsert to 'FROM_DB' (Csaba Meszaros)
-- =============================================
CREATE PROCEDURE [ORG].[TaskGroupOperationModule] 
	-- Add the parameters for the stored procedure here
	@p_correlationID NVARCHAR(200), 
	@p_moduleInstanceID NUMERIC(16),
	@p_result nvarchar(200) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	DECLARE @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	DECLARE @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	DECLARE @l_cursorStatus SMALLINT = NULL; --Amennyiben alkalmazunk cursor-t, akkor a cursor állapotának kezelése miatt
	DECLARE @l_procedureName NVARCHAR(100) = 'ORG.TaskGroupOperationModule'; --Naplózás miatt a tárolt eljárás neve
	--Specifikus változók
	DECLARE @l_taskGroupOperationSetID NUMERIC(16) = NULL;
	DECLARE @l_taskID NUMERIC(16) = NULL;
	DECLARE @l_taskTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_referencedObjectID NUMERIC(16) = NULL;
	DECLARE @l_processID NUMERIC(16) = NULL;
	DECLARE @l_userName NVARCHAR(200) = NULL;
	DECLARE @l_subject NVARCHAR(200) = NULL;
	DECLARE @l_comment NVARCHAR(MAX) = NULL;
	DECLARE @l_priority NVARCHAR(50) = NULL;
	DECLARE @l_deadLineDate DATE = NULL;
	DECLARE @l_deadLineTime TIME = NULL;
	DECLARE @l_externalTaskID NVARCHAR(200) = NULL;
	DECLARE @l_detailsStatusCode NVARCHAR(200) = NULL;
	DECLARE @l_deadlineDayTypeCode NVARCHAR(200) = NULL;
	DECLARE @l_deadlineDay NUMERIC(5) = NULL;
	DECLARE @l_objectID NUMERIC(16) = NULL;
	DECLARE @l_moduleInstanceID NUMERIC(16) = NULL;
	--Amennyiben alkalmazunk cursor-t, akkor a cursor-ban lekért adatok változóinak definiálása (opcionális)
	--taskGroupOperation_cursor változói
	DECLARE @l_taskGroupOperationID NUMERIC(16) = NULL;
	DECLARE @l_taskGroupOperationDefinitionTaskTypeID NVARCHAR(200) = NULL; 
	DECLARE @l_taskGroupOperationWaitingForTaskGroupOperationID NUMERIC(16) = NULL;
	DECLARE @l_taskGroupOperationScheduleDate DATE = NULL; 
	DECLARE @l_taskGroupOperationScheduleTime TIME = NULL;
	--taskGroupOperationParameter_cursor változói 
	DECLARE @l_taskGroupOperationParameterID NUMERIC(16) = NULL; 
	DECLARE @l_taskGroupOperationParameterParameterCode NVARCHAR(200) = NULL;
	DECLARE @l_taskGroupOperationParameterParameterValue NVARCHAR(MAX) = NULL;
	--taskGroupOperationResult_cursor
	DECLARE @l_taskGroupOperationResultID NUMERIC(16) = NULL;
	DECLARE @l_taskGroupOperationResultRelatedObjectID NUMERIC(16) = NULL;
	--taskGroupOperationSetObject_cursor
	--DECLARE @l_taskGroupOperationSetObjectRelatedObjectID NUMERIC(16) = NULL;
	--moduleList_cursor
	DECLARE @l_moduleID NUMERIC(16) = NULL;
	DECLARE @l_moduleCode NVARCHAR(200) = NULL;
	--ORG.TaskCalling eredmény változó
	DECLARE @l_taskCallingResult INT = NULL;
	--Tábla, mint változó definiálása a létrehozott feladat adatainak tárolására
	DECLARE @tempTable_Task AS TABLE
		(ID NUMERIC(16),
		 ObjectID NUMERIC(16), 
		 TaskTypeID NVARCHAR(200), 
		 UserID NVARCHAR(200), 
		 StatusCode NVARCHAR(200),
		 DetailedStatusCode NVARCHAR(200),
		 BeginDate DATE, 
		 BeginTime TIME,
		 EndDate DATE, 
		 EndTime TIME, 
		 DeadlineDate DATE, 
		 DeadlineTime TIME, 
		 Subject NVARCHAR(200),
		 ParentTaskID NUMERIC(16),
		 Priority NVARCHAR(50),
		 ProcessID NUMERIC(16),
		 CreationDate DATE, 
		 CreationTime TIME, 
		 CreationUserName NVARCHAR(200),
		 LastModifiedDate DATE,
		 LastModifiedTime TIME,
		 LastModifiedUserName NVARCHAR(200),
		 Comments NVARCHAR(MAX),
		 ReferencedObjectID NUMERIC(16),
		 TaskListID NUMERIC(16),
		 ReferencedObjectTypeCode NVARCHAR(200),
		 PriorityCode NVARCHAR(200),
		 ResultObjectTypeCode NVARCHAR(200),
		 ResultObjectID NUMERIC(16),
		 WaitingForTaskID NUMERIC(16),
		 ScheduleDate DATE,
		 ScheduleTime TIME, 
		 ExternalTaskID NVARCHAR(200),
		 TaskGroupOperationID NUMERIC(16)
	);
	--Tábla, mint változó definiálása a példányosítandó modulok tárolására
	DECLARE @tempTable_Module AS TABLE 
		(ModuleID NUMERIC(16)
	);

    BEGIN TRY
--===========================================================
--BLOCK      : START
--DESCRIPTION: Start procedure
--===========================================================
		BEGIN TRANSACTION MAIN_TRANSACTION;

		--Naplóbejegyzés a kezdésről (kötelező)
		SELECT @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_correlationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

--===========================================================
--BLOCK      : CHECK PARAMS
--DESCRIPTION: Checking parameters
--===========================================================
		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		SELECT @l_logMsg = 'Checing parameters... ';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_correlationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		IF COALESCE(@p_moduleInstanceID, 0) = 0 
			RAISERROR('The p_moduleInstanceID parameter isn''t empty.', 16, 1);
		
		SELECT @l_taskGroupOperationSetID = [ModuleInstanceParameter].[ParameterID]
		FROM [ORG].[ModuleInstanceParameter]
		WHERE [ModuleInstanceParameter].[ModuleInstanceID] = @p_moduleInstanceID
		AND [ModuleInstanceParameter].[ParameterCode] = 'MODULE_PARAMETER_TASK_GROUP_OPERATION_SET_ID'
			
		IF COALESCE(@l_taskGroupOperationSetID, 0) = 0 
			RAISERROR('Not defined the "MODULE_PARAMETER_TASK_GROUP_OPERATION_SET_ID" parameter.', 16, 1);

		SELECT @l_logMsg = CONCAT('Task group operation set identifier: ', @l_taskGroupOperationSetID);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_correlationID,	        -- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

--===========================================================
--BLOCK      : PROCESS START
--DESCRIPTION: 
--===========================================================
		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		SELECT @l_logMsg = 'Processing...';

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_correlationID,	        -- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;

		--Ideiglenes táblák ürítése
		PRINT 'Emptying the @tempTable_Task, @tempTable_Module tables.';
		DELETE FROM @tempTable_Task;
		DELETE FROM @tempTable_Module;

		--Csoportos művelet állapotának módosítása
		PRINT CONCAT('Modify status of ', @l_taskGroupOperationSetID, '  task group operation.');

		UPDATE [ORG].[TaskGroupOperationSet] SET 
			[StatusCode] = 'TASK_GROUP_OPERATION_SET_STATUS_PROCESSING',
			[LastModifiedDate] = CAST(GETDATE() AS Date),
			[LastModifiedTime] = CAST( GETDATE() AS Time ),
			[LastModifiedUserName] = 'admin' 
		WHERE [TaskGroupOperationSet].[ID] = @l_taskGroupOperationSetID;
		
		DECLARE taskGroupOperation_cursor CURSOR FOR 
		SELECT 
			[TaskGroupOperation].[ID],
			[TaskGroupOperationDefinition].[TaskTypeID], 
			[TaskGroupOperation].[WaitingForTaskGroupOperationID],
			[TaskGroupOperation].[ScheduleDate], 
			[TaskGroupOperation].[ScheduleTime]
		FROM [ORG].[TaskGroupOperation] 
		JOIN [ORG].[TaskGroupOperationDefinition] ON 
			([TaskGroupOperationDefinition].[ID] = [TaskGroupOperation].[TaskGroupOperationDefinitionID])
		WHERE [TaskGroupOperation].[TaskGroupOperationSetID] = @l_taskGroupOperationSetID
		ORDER BY [TaskGroupOperation].[SequenceNr];
		
		OPEN taskGroupOperation_cursor;
		FETCH NEXT FROM taskGroupOperation_cursor 
		INTO 
			@l_taskGroupOperationID,
			@l_taskGroupOperationDefinitionTaskTypeID, 
			@l_taskGroupOperationWaitingForTaskGroupOperationID,
			@l_taskGroupOperationScheduleDate, 
			@l_taskGroupOperationScheduleTime;

		WHILE @@FETCH_STATUS = 0
		BEGIN 
			SELECT @l_taskTypeCode = @l_taskGroupOperationDefinitionTaskTypeID;
			SELECT @l_referencedObjectID = NULL;
			SELECT @l_processID = NULL;
			SELECT @l_userName = NULL;
			SELECT @l_subject = NULL;
			SELECT @l_comment = NULL;
			SELECT @l_priority = NULL;
			SELECT @l_deadLineDate = NULL;
			SELECT @l_deadLineTime = NULL;
			SELECT @l_externalTaskID = NULL;
			SELECT @l_detailsStatusCode = 'TASK_DETAILED_STATUS_WAITING_TO_BE_PROCESSED';
			SELECT @l_deadlineDayTypeCode = NULL;
			SELECT @l_deadlineDay = NULL;

			SELECT @l_logMsg = CONCAT('Opertion: ', GEN.TranslateCode(@l_taskTypeCode, 'HU'), ' (', @l_taskTypeCode, ')');

			UPDATE [ORG].[TaskGroupOperation] SET 
				[StatusCode] = 'TASK_GROUP_OPERATION_STATUS_OPERATION_IN_PROGRESS', 
				[LastModifiedDate] = CAST( GETDATE() AS Date ),
				[LastModifiedTime] = CAST( GETDATE() AS Time ),
				[LastModifiedUserName] = 'admin' 
			WHERE [TaskGroupOperation].[ID] = @l_taskGroupOperationID;

			BEGIN TRANSACTION LOG_TRANSACTION;
			INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
			SELECT 
				CAST( GETDATE() AS Date ),	-- LogDate,	
				CAST( GETDATE() AS Time ),	-- LogTime,
				SUSER_SNAME(),				-- UserName
				@p_correlationID,	        -- CorrelationID
				'INDECS 3.0',			    -- ApplicationName
				DB_NAME(),					-- Environment
				'BACKEND',					-- Layer
				@l_procedureName,   		-- ServiceName
				'1.0',						-- ServiceVersion
				'INFO',					        -- SeverityLevel
				NULL,						-- MessageCategory
				@l_logMsg;				    -- LogMessage
			COMMIT TRANSACTION LOG_TRANSACTION;
			
			PRINT @l_logMsg;
			
			SELECT 
				@l_priority = [TaskType].[PriorityCode],
				@l_deadlineDayTypeCode = [TaskType].[DeadlineDayTypeCode],
				@l_deadlineDay = [TaskType].[DeadlineDay],
				@l_userName = [Module].[TechnicalUserName],
				@l_subject = GEN.TranslateCode([TaskType].[ID], 'HU'),
				@l_comment = GEN.TranslateCode([TaskType].[ID], 'HU')
			FROM [ORG].[TaskType] 
			JOIN [ORG].[TaskTypeModule] ON ([TaskTypeModule].[TaskTypeID] = [TaskType].[ID])
			JOIN [ORG].[Module] ON ([Module].[ID] = [TaskTypeModule].[ModuleID])
			WHERE [TaskType].[ID] = @l_taskTypeCode;
			
			IF COALESCE(@l_priority, '') = '' 
				SELECT @l_priority = 'PRIORITY_1';
			
			IF COALESCE(@l_deadlineDayTypeCode, '') = ''
			BEGIN
				SELECT @l_deadLineDate = DATEADD(day, 1,CAST( GETDATE() AS Date));
				SELECT @l_deadLineTime = CONVERT(VARCHAR(8), GETDATE(),108);
			END;
			
			IF COALESCE(@l_userName, '') = '' 
				SELECT @l_userName = 'admin';
				
			--A csoportos művelet objektumai csak azokra a műveletekre értendőek, amelyek nem várnak másik műveletre
			IF COALESCE(@l_taskGroupOperationWaitingForTaskGroupOperationID, 0) = 0 
			BEGIN 
				PRINT CONCAT('@l_taskGroupOperationWaitingForTaskGroupOperationID: ', 
					COALESCE(@l_taskGroupOperationWaitingForTaskGroupOperationID, 0));

				DECLARE taskGroupOperationResult_cursor CURSOR FOR 
				SELECT 
					[TaskGroupOperationResult].[ID],
					[TaskGroupOperationResult].[RelatedObjectID]
				FROM [ORG].[TaskGroupOperationResult]
				WHERE [TaskGroupOperationResult].[TaskGroupOperationID] = @l_taskGroupOperationID
				AND [TaskGroupOperationResult].[ResultCode] = 'TASK_GROUP_OPERATION_RESULT_CAN_BE_PERFORMED'
				ORDER BY [TaskGroupOperationResult].[ID]
				
				OPEN taskGroupOperationResult_cursor;
				FETCH NEXT FROM taskGroupOperationResult_cursor
				INTO 
					@l_taskGroupOperationResultID,
					@l_taskGroupOperationResultRelatedObjectID;
				
				WHILE @@FETCH_STATUS = 0
				BEGIN
					SELECT @l_taskID = NULL;
					DELETE FROM @tempTable_Task;
					
					IF COALESCE(@l_taskGroupOperationResultRelatedObjectID, 0) > 0 
					BEGIN
						/*PRINT CONCAT('EXECUTE @l_taskCallingResult = [ORG].[TaskCalling] ', 
							@l_taskTypeCode, ','
							,@l_taskGroupOperationResultRelatedObjectID, ','
							,@l_processID, ','
							,@l_userName, ','
							,@l_subject, ','
							,@l_comment, ','
							,@l_priority, ','
							,@l_deadLineDate, ','
							,@l_deadLineTime, ','
							,@l_externalTaskID, ','
							,@l_detailsStatusCode, ','
							,'admin');

						INSERT INTO @tempTable_Task 
						EXECUTE @l_taskCallingResult = [ORG].[TaskCalling_2] 
							@l_taskTypeCode
							,@l_taskGroupOperationResultRelatedObjectID
							,@l_processID
							,@l_userName
							,@l_subject
							,@l_comment
							,@l_priority
							,@l_deadLineDate
							,@l_deadLineTime
							,@l_externalTaskID
							,@l_detailsStatusCode
							,'admin';
							
						SELECT @l_taskID = TaskTable.ID 
						FROM 
							(SELECT * FROM @tempTable_Task) AS TaskTable;*/

						PRINT CONCAT('EXECUTE @l_taskCallingResult = [ORG].[TaskCalling] ', 
							@l_taskTypeCode, ','
							,@l_taskGroupOperationResultRelatedObjectID, ','
							,@l_processID, ','
							,@l_userName, ','
							,@l_subject, ','
							,@l_comment, ','
							,@l_priority, ','
							,@l_deadLineDate, ','
							,@l_deadLineTime, ','
							,@l_externalTaskID, ','
							,@l_detailsStatusCode, ','
							,'admin', ','
							,@l_taskID, ' OUTPUT');

						EXECUTE @l_taskCallingResult = [ORG].[TaskCalling_2] 
							@l_taskTypeCode
							,@l_taskGroupOperationResultRelatedObjectID
							,@l_processID
							,@l_userName
							,@l_subject
							,@l_comment
							,@l_priority
							,@l_deadLineDate
							,@l_deadLineTime
							,@l_externalTaskID
							,@l_detailsStatusCode
							,'admin'
							,@l_taskID OUTPUT;

						PRINT CONCAT('Created task id.: ', @l_taskID);

						IF COALESCE(@l_taskID, 0) > 0
						BEGIN
							SELECT @l_logMsg = CONCAT('Task created. Task id.: ', [Task].[ID], ' Task type: ', 
								GEN.TranslateCode([Task].[TaskTypeID], 'HU'))
							FROM [ORG].[Task] 
							WHERE [Task].[ID] = @l_taskID;

							BEGIN TRANSACTION LOG_TRANSACTION;
							INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
							SELECT 
								CAST( GETDATE() AS Date ),	-- LogDate,	
								CAST( GETDATE() AS Time ),	-- LogTime,
								SUSER_SNAME(),				-- UserName
								@p_correlationID,	        -- CorrelationID
								'INDECS 3.0',			    -- ApplicationName
								DB_NAME(),					-- Environment
								'BACKEND',					-- Layer
								@l_procedureName,   		-- ServiceName
								'1.0',						-- ServiceVersion
								'INFO',					        -- SeverityLevel
								NULL,						-- MessageCategory
								@l_logMsg;				    -- LogMessage
							COMMIT TRANSACTION LOG_TRANSACTION;

							UPDATE [ORG].[Task] SET 
								[TaskGroupOperationID] = @l_taskGroupOperationID
							WHERE [Task].[ID] = @l_taskID;

							--Példányosítandó modul bejegyzése
							INSERT INTO @tempTable_Module (ModuleID)
							SELECT [Module].[ID] 
							FROM [ORG].[Module] 
							JOIN [ORG].[TaskTypeModule] ON ([TaskTypeModule].[ModuleID] = [Module].[ID])
							JOIN [ORG].[Task] ON ([Task].[TaskTypeID] = [TaskTypeModule].[TaskTypeID])
							WHERE [Task].[ID] = @l_taskID
							AND NOT EXISTS 
								(SELECT 1 FROM @tempTable_Module WHERE ModuleID = [Module].[ID]);
						END;
					END;
					
					DECLARE taskGroupOperationParameter_cursor CURSOR FOR 
					SELECT 
						[TaskGroupOperationParameter].[ID], 
						[TaskGroupOperationParameter].[ParameterCode],
						[TaskGroupOperationParameter].[ParameterValue]
					FROM [ORG].[TaskGroupOperationParameter]
					WHERE [TaskGroupOperationParameter].[TaskGroupOperationID] = @l_taskGroupOperationID
					ORDER BY [TaskGroupOperationParameter].[ParameterCode];
				
					OPEN taskGroupOperationParameter_cursor;
					FETCH NEXT FROM taskGroupOperationParameter_cursor 
					INTO 
						@l_taskGroupOperationParameterID, 
						@l_taskGroupOperationParameterParameterCode,
						@l_taskGroupOperationParameterParameterValue;

					WHILE @@FETCH_STATUS = 0
					BEGIN 
						SELECT @l_objectID = NULL;
						
						IF COALESCE(@l_taskID, 0) > 0 
						BEGIN
							INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr]) 
							SELECT 'OBJECT_TYPE_ORG_TASKPARAMETER', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT('Task parameter object of ', @l_taskID, ' task'), '1.0';
						
							SELECT @l_objectID = @@IDENTITY;
							
							IF COALESCE(@l_objectID, 0) > 0 
								INSERT INTO [ORG].[TaskParameter] ([ObjectID], [TaskID], [ParameterCode], [ParameterValue], [CreationDate], [CreationTime], [CreationUserName])
								SELECT @l_objectID, @l_taskID, @l_taskGroupOperationParameterParameterCode, @l_taskGroupOperationParameterParameterValue, 
									CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin';
						END;
						
						FETCH NEXT FROM taskGroupOperationParameter_cursor 
						INTO 
							@l_taskGroupOperationParameterID, 
							@l_taskGroupOperationParameterParameterCode,
							@l_taskGroupOperationParameterParameterValue;
					END;

					CLOSE taskGroupOperationParameter_cursor;
					DEALLOCATE taskGroupOperationParameter_cursor;
					
					IF COALESCE(@l_taskID, 0) > 0
						UPDATE [ORG].[TaskGroupOperationResult] SET
							[TaskID] = @l_taskID,
							[ResultCode] = 'TASK_GROUP_OPERATION_RESULT_COMPLETED', 
							[LastModifiedDate] = CAST( GETDATE() AS Date ),
							[LastModifiedTime] = CAST( GETDATE() AS Time ),
							[LastModifiedUserName] = 'admin'
						WHERE [TaskGroupOperationResult].[ID] = @l_taskGroupOperationResultID
					ELSE 
						UPDATE [ORG].[TaskGroupOperationResult] SET
							[ResultCode] = 'TASK_GROUP_OPERATION_RESULT_CANNOT_BE_PERFORMED', 
							[LastModifiedDate] = CAST( GETDATE() AS Date ),
							[LastModifiedTime] = CAST( GETDATE() AS Time ),
							[LastModifiedUserName] = 'admin'
						WHERE [TaskGroupOperationResult].[ID] = @l_taskGroupOperationResultID;
					
					FETCH NEXT FROM taskGroupOperationResult_cursor
					INTO 
						@l_taskGroupOperationResultID,
						@l_taskGroupOperationResultRelatedObjectID;
				END;
				
				CLOSE taskGroupOperationResult_cursor;
				DEALLOCATE taskGroupOperationResult_cursor;
			END;

			UPDATE [ORG].[TaskGroupOperation] SET 
				[StatusCode] = 'TASK_GROUP_OPERATION_STATUS_OPERATION_DONE', 
				[LastModifiedDate] = CAST( GETDATE() AS Date ),
				[LastModifiedTime] = CAST( GETDATE() AS Time ),
				[LastModifiedUserName] = 'admin' 
			WHERE [TaskGroupOperation].[ID] = @l_taskGroupOperationID;
			
			FETCH NEXT FROM taskGroupOperation_cursor 
			INTO 
				@l_taskGroupOperationID,
				@l_taskGroupOperationDefinitionTaskTypeID, 
				@l_taskGroupOperationWaitingForTaskGroupOperationID,
				@l_taskGroupOperationScheduleDate, 
				@l_taskGroupOperationScheduleTime;
		END;
		
		CLOSE taskGroupOperation_cursor;
		DEALLOCATE taskGroupOperation_cursor;

		UPDATE [ORG].[TaskGroupOperationSet] SET 
			[StatusCode] = 'TASK_GROUP_OPERATION_SET_STATUS_CLOSED', 
			[LastModifiedDate] = CAST( GETDATE() AS Date ),
			[LastModifiedTime] = CAST( GETDATE() AS Time ),
			[LastModifiedUserName] = 'admin'
		WHERE [TaskGroupOperationSet].[ID] = @l_taskGroupOperationSetID;

		--Példonyosítandó modulok létrehozása
		DECLARE moduleList_cursor CURSOR FOR
		SELECT DISTINCT ModuleID, 
			(SELECT [Module].[ModuleCode]
			 FROM [ORG].[Module] 
			 WHERE [Module].[ID] = ModuleID) AS ModuleCode 
		FROM @tempTable_Module
		ORDER BY ModuleID;

		OPEN moduleList_cursor;
		FETCH NEXT FROM moduleList_cursor 
		INTO 
			@l_moduleID, 
			@l_moduleCode;

		WHILE @@FETCH_STATUS = 0
		BEGIN
			SELECT @l_objectID = NULL;

			INSERT INTO [GEN].[Object] ([ObjectType], [CreationDate], [CreationTime], [CreationUserName], [Comments], [VersionNr])
			VALUES ('OBJECT_TYPE_ORG_MODULEINSTANCE', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin', CONCAT(@l_moduleCode, ' module instance object'), '1.0');

			SELECT @l_objectID = @@IDENTITY;

			IF COALESCE(@l_objectID, 0) > 0
			BEGIN
				INSERT INTO [ORG].[ModuleInstance] ([ObjectID], [ModuleID], [StatusCode], [CorrelationID], 
					[MessageQueueTopic], [CreationDate], [CreationTime], [CreationUserName])
				VALUES (@l_objectID, @l_moduleID, 'MODULE_INSTANCE_STATUS_PREPARATION', @p_CorrelationID, 
					@l_moduleCode, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'admin');

				SELECT @l_moduleInstanceID = @@IDENTITY;

				IF COALESCE(@l_moduleInstanceID, 0) > 0
				BEGIN 
					SELECT @l_logMsg = CONCAT(GEN.TranslateCode(@l_moduleCode, 'HU') , ' module instantiated successfully.');

					INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
					SELECT 
						CAST( GETDATE() AS Date ),	-- LogDate,	
						CAST( GETDATE() AS Time ),	-- LogTime,
						SUSER_SNAME(),		        -- UserName
						@p_CorrelationID,			-- CorrelationID
						'INDECS 3.0',			    -- ApplicationName
						DB_NAME(),					-- Environment
						'BACKEND',					-- Layer
						@l_procedureName,   		-- ServiceName
						'1.0',						-- ServiceVersion
						'INFO',					        -- SeverityLevel
						NULL,						-- MessageCategory
						@l_logMsg;

					UPDATE [ORG].[ModuleInstance] SET 
						[StatusCode] = 'MODULE_INSTANCE_STATUS_READY_TO_RUN', 
						[LastModifiedDate] = CAST( GETDATE() AS Date),
						[LastModifiedTime] = CONVERT(VARCHAR(8), GETDATE(),108),
						[LastModifiedUserName] = 'admin',
						[MessageQueueTopic] = 'FROM_DB'
					WHERE [ModuleInstance].[ID] = @l_moduleInstanceID;
				END
			END;

			FETCH NEXT FROM moduleList_cursor 
			INTO 
				@l_moduleID, 
				@l_moduleCode;
		END

		CLOSE moduleList_cursor;
		DEALLOCATE moduleList_cursor;

		SELECT @l_logMsg = CONCAT('End procedure ', @l_procedureName);

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_correlationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			'INFO',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_logMsg;
		
		COMMIT TRANSACTION MAIN_TRANSACTION;
		
		SELECT @p_result = 0;
		IF COALESCE(@l_ModuleInstanceID, 0) > 0
		BEGIN
		SELECT @p_result=@l_ModuleInstanceID
		END

		SELECT @p_result;


		RETURN;
	END TRY

	BEGIN CATCH
		ROLLBACK TRANSACTION MAIN_TRANSACTION;

		--Hiba kezelés
		--Amennyiben alkalmazunk cursor-okat, akkor azokat meg kell szüntetni.
		--Értékek értelmezése:
		--   -3 ha egyáltalán nem létezik a cursor
		--   -1 ha létezik, de nincs nyitva
		--    1 ha létezik és nyitva is van
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'moduleList_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE moduleList_cursor;

			DEALLOCATE moduleList_cursor;
		END

		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'taskGroupOperationResult_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE taskGroupOperationResult_cursor;

			DEALLOCATE taskGroupOperationResult_cursor;
		END
		
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'taskGroupOperationParameter_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE taskGroupOperationParameter_cursor;

			DEALLOCATE taskGroupOperationParameter_cursor;
		END
		
		SELECT @l_cursorStatus = CURSOR_STATUS('global', 'taskGroupOperation_cursor');
		
		IF @l_cursorStatus <> -3
		BEGIN
			IF @l_cursorStatus = 1
				CLOSE taskGroupOperation_cursor;

			DEALLOCATE taskGroupOperation_cursor;
		END
		
		SELECT @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		BEGIN TRANSACTION LOG_TRANSACTION;
		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		SELECT 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_correlationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			'ERROR',					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
		COMMIT TRANSACTION LOG_TRANSACTION;
			
		PRINT @l_errorMsg;
		
		SELECT @p_result = @l_errorMsg;
		SELECT @p_result;
		RETURN;
	END CATCH
END
go

/*Author: Gyenese Katalin
  Create date: 2023.11.02. - DV-1524
  Description: Inserts a new Task record

  Parameters:
    - @p_taskTypeCode: Task.TaskTypeID
	  - @p_referencedObjectID: the referencedObjectID. 
                             It can be null, if the ReferencedObjectTypeCode of the TaskType is null (we need this for the Indecs-Inkasso synchronization); 
                             otherwise it's compulsory and the objectType of the referencedObject has to be equal to the ReferencedObjectTypeCode of the TaskType
	  - @p_processID: Task.ProcessID
	  - @p_userName: username for Task.UserID
	  - @p_subject: Task.Subject
	  - @p_comment: Task.Comments
	  - @p_priority: Task.PriorityCode
	  - @p_deadLineDate: Task.DeadlineDate
	  - @p_deadLineTime: Task.DeadlineTime
	  - @p_externalTaskID: Task.ExternalTaskID
	  - @p_detailsStatusCode: Task.DetailsStatusCode
	  - @p_creationUserName: creationUserName + userName logging
    - @p_correlationID: correlationID of the caller
	  - @p_newTaskID: ID of the created Task

  Modifications:
    2023.12.28.: objecttype check modification: OBJECT_TYPE_PRT_PERSON, OBJECT_TYPE_PRT_COMPANY is accepted for OBJECT_TYPE_PRT_ENTITY DV-1744
*/
CREATE procedure [ORG].[TaskInsert]
	@p_taskTypeCode NVarChar(200),
	@p_referencedObjectID Numeric(16),
	@p_processID Numeric(16) = null,
	@p_userName NVarChar(200) = null,
	@p_subject NVarChar(200) = null,
	@p_comment NVarChar(max) = null,
	@p_priority NVarChar(50) = null,
	@p_deadLineDate Date = null,
	@p_deadLineTime Time = null,
	@p_externalTaskID NVarChar(200) = null,
	@p_detailsStatusCode NVarChar(200),
	@p_creationUserName NVarChar(200),
  @p_correlationID NVarChar(200) = null,
	@p_newTaskID Numeric(16) OUTPUT
AS
BEGIN
	SET NOCOUNT ON;

	--Általános változók definiálása (kötelező)
	declare @l_errorMsg NVARCHAR(MAX) = '' --Hiba üzenetek tárolása, kezelése miatt
	declare @l_logMsg NVARCHAR(MAX) = NULL --Működéssel kapcsolatos üzenetek tárolása miatt
	declare @l_procedureName NVARCHAR(100) = 'ORG.TaskInsert'; --Naplózás miatt a tárolt eljárás neve
  declare @l_errorProcedure NVarChar(200), @l_errorNumber int, @l_errorSeverity int, @l_errorState int, @l_errorLine int,
          @l_log_userName NVarChar(200) = @p_creationUserName
	
  --Specifikus változók definiálása (opcionális)
	DECLARE @l_referencedObjectTypeCode NVarChar(200)
	DECLARE @l_orgTaskListObjectTypeCode NVarChar(200)
	DECLARE @l_orgTaskObjectTypeCode NVarChar(200)
	DECLARE @l_objectID Numeric(16)
	DECLARE @l_deadlineDayTypeCode NVarChar(200)
	DECLARE @l_dateDiff Numeric(5)
	DECLARE @l_taskListTypeCode NVarChar(200)
	DECLARE @l_taskListID Numeric(16)
	
  --ORG.TaskListType változói
	declare @l_dataSourceSQLStatement NVarChar(MAX)
	declare @l_subject NVarChar(250)
	
  --ORG.TaskType változói
	declare @l_taskTypeReferencedObjectTypeCode NVarChar(200)

	begin try
--===========================================================
--BLOCK      : START
--DESCRIPTION: Start procedure
--===========================================================
		--Naplóbejegyzés a kezdésről (kötelező)
    select @l_logMsg = CONCAT('Start procedure ', @l_procedureName);
    exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @l_log_userName,
                           @p_ServiceName = @l_procedureName, 
                           @p_LogMessage = @l_logMsg
			
		--Kimenő paraméterek inicializálása
		SELECT @p_newTaskID = NULL

--===========================================================
--BLOCK      : CHECK SYSTEM COMPONENTS
--DESCRIPTION: Checking system components
--===========================================================
		select @l_logMsg = 'Checking system components... ';
	  exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @l_log_userName,
                           @p_ServiceName = @l_procedureName, 
                           @p_LogMessage = @l_logMsg

		select @l_orgTaskObjectTypeCode = ObjectType.Code
		from GEN.ObjectType
		where ObjectType.TableName = 'ORG.Task';

		if IsNull(@l_orgTaskObjectTypeCode, '') = ''
			select @l_errorMsg = @l_errorMsg + 'Object type is not defined: ORG.Task. ';

		SELECT @l_orgTaskListObjectTypeCode = ObjectType.Code
		FROM GEN.ObjectType 
		WHERE ObjectType.TableName = 'ORG.TaskList';

		if IsNull(@l_orgTaskListObjectTypeCode, '') = ''
			select @l_errorMsg = @l_errorMsg + 'Object type is not defined: ORG.TaskList. ';

		if IsNull(@l_errorMsg, '') <> '' 
			 raiserror(@l_errorMsg, 16, 1);

--===========================================================
--BLOCK      : CHECK PARAMS
--DESCRIPTION: Checking parameters
--===========================================================
		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		select @l_logMsg = 'Checking parameters... ';
	  exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @l_log_userName,
                           @p_ServiceName = @l_procedureName, 
                           @p_LogMessage = @l_logMsg
			
		if IsNull(@p_taskTypeCode, '') = ''
			 raiserror('The @p_taskTypeCode parameter can''t empty.', 16, 1)

--===========================================================
--BLOCK      : PROCESS START
--DESCRIPTION: 
--===========================================================
		--Feldolgozás kezdetéről naplóbejegyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
    select @l_logMsg = 'Processing... ';
	  exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @l_log_userName,
                           @p_ServiceName = @l_procedureName, 
                           @p_LogMessage = @l_logMsg

--===========================================================
--BLOCK      : PROCESS IN PROGRESS
--DESCRIPTION: Retrieving the data required for processing
--===========================================================

    if IsNull(@p_creationUserName, '') = ''
       set @p_creationUserName = IsNull(@p_creationUserName, 'admin')
    
		select @l_deadlineDayTypeCode = IsNull(TaskType.DeadlineDayTypeCode, 'DAY_TYPE_DAY'),
			     @l_DateDiff = IsNull(TaskType.DeadlineDay, 0), 
			     @l_taskListTypeCode = TaskType.TaskListTypeID,
			     @l_taskTypeReferencedObjectTypeCode = TaskType.ReferencedObjectTypeCode
		from ORG.TaskType 
		where TaskType.ID = @p_taskTypeCode


    if IsNull(@l_taskTypeReferencedObjectTypeCode, '') <> '' 
    begin
      if @p_referencedObjectID is null
			   raiserror('The @p_referencedObjectID parameter can''t empty.', 16, 1)

		  SELECT @l_referencedObjectTypeCode = Object.ObjectType
		  FROM GEN.Object 
		  WHERE Object.ID = @p_referencedObjectID

		  if IsNull(@l_referencedObjectTypeCode, '') = '' 
		  begin 
			  select @l_errorMsg = CONCAT('The type of referenced object isn''t defined. Referenced object id.:', @p_referencedObjectID, '.');
			  raiserror(@l_errormsg, 16, 1)
		  end

		  if       @l_referencedObjectTypeCode <> @l_taskTypeReferencedObjectTypeCode
      and not (@l_referencedObjectTypeCode in('OBJECT_TYPE_PRT_PERSON', 'OBJECT_TYPE_PRT_COMPANY') and @l_taskTypeReferencedObjectTypeCode = 'OBJECT_TYPE_PRT_ENTITY')
		  begin 
			  select @l_errorMsg = CONCAT('The type of referenced object is not equal to the referenced object type of task type. ', 
					                          'Referenced object type:', @l_referencedObjectTypeCode, 
					                          ', Task type: ', @p_taskTypeCode,
					                          ', Referenced object type of task type: ', @l_taskTypeReferencedObjectTypeCode, 
					                          '.'
                                   )
			  raiserror(@l_errorMsg, 16, 1)
		  end
    end
--===========================================================
--BLOCK      : PROCESS IN PROGRESS
--DESCRIPTION: Calculationg task list type
--===========================================================

		if IsNull(@l_taskListTypeCode, '') = ''
		begin
			select @l_errorMsg = CONCAT('The task list type isn''t defined to task type: ', @p_taskTypeCode, '.')
			raiserror(@l_errorMsg, 16, 1)
		end

		select @l_dataSourceSQLStatement = DataSource.SQLExpression
		from GEN.DataSource join ORG.TaskListType on TaskListType.SelectionRuleDataSourceID = DataSource.ID
		where TaskListType.ID = @l_taskListTypeCode

		if IsNull(@l_dataSourceSQLStatement, '') = ''
		begin
			select @l_taskListID = TaskList.ID 
			from ORG.TaskList 
			where TaskList.TaskListTypeID = @l_taskListTypeCode
 			  and TaskList.StatusCode IN ('TASK_LIST_MAIN_STATUS_NEW', 'TASK_LIST_MAIN_STATUS_PROCESSING')
			  and TaskList.CreationDate = CAST( GETDATE() AS Date )
		END;

    begin tran 

		  if @l_taskListID is null
		  begin
        insert into GEN.Object (ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr) 
		  	                 select @l_orgTaskListObjectTypeCode ObjectType, GetDate() CreationDate, GetDate() CreationTime, @p_creationUserName CreationUserName, CONCAT(@l_taskListTypeCode, ' task list object') Comments, '1.0.0' VersionNr

			  select @l_objectID = SCOPE_IDENTITY()

			  if @l_objectID is not null
			  begin
				  insert into ORG.TaskList (ObjectID, TaskListTypeID, StatusCode, Subject, CreationDate, CreationTime, CreationUserName)
				                     select @l_objectID ObjectID, @l_taskListTypeCode TaskListTypeID, 'TASK_LIST_MAIN_STATUS_NEW' StatusCode, NULL Subject, 
                                    GetDate() CreationDate, GetDate() CreationTime, @p_creationUserName CreationUserName
			
				  select @l_taskListID = SCOPE_IDENTITY()			
			  end
		  end

		  if @l_taskListID is null
		  begin
			  select @l_errorMsg = CONCAT('The task list identifier is empty. Task list type: ', @l_taskListTypeCode, '.');
			  raiserror(@l_errormsg, 16, 1)
		  end

		  select @l_dataSourceSQLStatement = null

		  select @l_dataSourceSQLStatement = DataSource.SQLExpression
		  from GEN.DataSource join ORG.TaskListType on TaskListType.SubjectDataSourceID = DataSource.ID
		  where TaskListType.ID = @l_taskListTypeCode

		  if IsNull(@l_dataSourceSQLStatement, '') = ''
			  select @l_subject = CONCAT(GEN.TranslateCode(@l_taskListTypeCode, 'HU'), ' ', CAST( GETDATE() AS DATE))

		  update ORG.TaskList
      set Subject = @l_subject 
		  where TaskList.ID = @l_taskListID;

  --===========================================================
  --BLOCK      : PROCESS IN PROGRESS
  --DESCRIPTION: Calculating deadline
  --===========================================================
		
		  select @p_deadLineDate = IsNull(@p_deadLineDate, Cast(GetDate() + @l_DateDiff as Date))
		  select @p_deadLineTime = IsNull(@p_deadLineTime, CONVERT(VarChar(8), GetDate(),108))

  --===========================================================
  --BLOCK      : PROCESS IN PROGRESS
  --DESCRIPTION: Inserting new task
  --===========================================================

		  select @l_objectID = null

		  insert into GEN.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr) 
	  	                select @l_orgTaskObjectTypeCode ObjectType, GetDate() CreationDate, GetDate() CreationTime, @p_creationUserName CreationUserName, CONCAT(@l_taskListTypeCode, ' task list object') Comments, '1.0.0' VersionNr

		  select @l_objectID = SCOPE_IDENTITY()

		  if @l_objectID is not null
		  begin
        insert into ORG.Task(ObjectID, ReferencedObjectTypeCode, ReferencedObjectID, TaskTypeID, UserID, StatusCode, DetailsStatusCode, DeadlineDate, DeadlineTime, Subject, Comments, PriorityCode, ProcessID, TaskListID, ExternalTaskID, 
                             CreationDate, CreationTime, CreationUserName
                            )
			    select @l_objectID ObjectID, @l_referencedObjectTypeCode ReferencedObjectTypeCode, @p_referencedObjectID ReferencedObjectID, @p_taskTypeCode TaskTypeID, @p_userName UserID, 'TASK_MAIN_STATUS_NEW' StatusCode, 
                 @p_detailsStatusCode DetailsStatusCode, @p_deadLineDate DeadlineDate, @p_deadLineTime DeadlineTime, @p_subject Subject, @p_comment Comments, @p_priority PriorityCode, @p_processID ProcessID, @l_taskListID TaskListID, 
                 @p_externalTaskID ExternalTaskID, GetDate() CreationDate, GetDate() CreationTime, @p_creationUserName CreationUserName
			
			  select @p_newTaskID = SCOPE_IDENTITY()	
			
			  select @l_logMsg = CONCAT('Identifier of the created task: ', @p_newTaskID)
			  exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                               @p_UserName = @l_log_userName,
                               @p_ServiceName = @l_procedureName, 
                               @p_LogMessage = @l_logMsg
		  end
		
    commit

		select @l_logMsg = CONCAT('End procedure ', @l_procedureName);
		exec LOG.InsertLogInfo @p_CorrelationID = @p_CorrelationID,
                           @p_UserName = @l_log_userName,
                           @p_ServiceName = @l_procedureName, 
                           @p_LogMessage = @l_logMsg

	end try
	begin catch
    if @@trancount > 0
       rollback

    select @l_errorProcedure = ERROR_PROCEDURE(), @l_errorNumber = ERROR_NUMBER(), @l_errorSeverity = ERROR_SEVERITY(), @l_errorState = ERROR_STATE(), @l_errorLine = ERROR_LINE(), @l_logMsg = ERROR_MESSAGE()
    
    exec LOG.InsertLogError @p_CorrelationID = @p_CorrelationID,
                            @p_UserName = @p_UserName,
                            @p_ServiceName = @l_procedureName, 
                            @p_ErrorProcedure = @l_errorProcedure,
                            @p_ErrorNumber = @l_errorNumber,
                            @p_ErrorSeverity = @l_errorSeverity,
                            @p_ErrorState = @l_errorState,
                            @p_ErrorLine = @l_errorLine,
                            @p_ErrorMessage = @l_logMsg

    ;throw
	end catch
end
go

CREATE FUNCTION [PRT].[Translate](@p_Word nvarchar(200),@p_LanguageIDFrom nvarchar(2),@p_LanguageIDTo nvarchar(2))
returns nvarchar(200)
/***********************************
* Administrator: Dávid Bognár      *
*  Created:      2022.11.16        *
*  Last revised: 2022.11.16        *
***********************************/
/****************************************************************
Translates a word from the "From" language to the "To" language.
If the translation is not possible, then returns the Word itself

example:
- Translate('Dog', 1, 9)
returns
- 'Kutya'
****************************************************************/
begin
  declare @m_Result nvarchar(200);

  set @m_Result=@p_Word;

  select @m_Result = COALESCE(C2.Text,@p_Word) 
    from GEN.Translation as C1,GEN.Translation as C2 where
    C1.Language = @p_LanguageIDFrom and C2.Language = @p_LanguageIDTo and
    C1.CodeID = C2.CodeID and
    C1.Text = @p_Word;

  return @m_Result;
end
go


/*
 =============================================
 Author:		Bognár Dávid
 Create date: 2022-11-22
 Description:	Update Account data
 ModificationDate	2023.12.06. PRETENSE_CODE_... --> PRETENSE_ rename DV-1867
					2023.12.15. Begin...End T.G. DV-2012

-- =============================================
*/
CREATE   PROCEDURE [FIN].[UpdateAccount]
	-- Tárolt eljárás bemenő paraméterei
  @p_correlationID NVARCHAR(200), --Kötelező paraméter a Session kezelés miatt 
	--További szükséges bemenő paraméterek
  @p_InvoiceID numeric(16), 
  @p_AccountType NVARCHAR(200),
  @p_Amount money, 
  @p_CurrencyCode nvarchar(16)
AS
BEGIN
	SET NOCOUNT ON;
	--Általános változók definiálása (kötelező)
	Declare @l_errorMsg NVARCHAR(MAX) = NULL; --Hiba üzenetek tárolása, kezelése miatt
	Declare @l_logMsg NVARCHAR(MAX) = NULL; --Működéssel kapcsolatos üzenetek tárolása miatt
	Declare @l_procedureName NVARCHAR(100) = 'FIN.UpdateAccount'; --Naplózás miatt a tárolt eljárás neve

	Declare @l_AccountTypeCode numeric(8) ;
	Select @l_AccountTypeCode = (Select ID from FIN.AccountType where Code=@p_AccountType);

	Declare @Object_ID numeric(16);
	Declare @InvoiceArrearsID numeric(16);
	Declare @Account_ID numeric(16);
	Declare @CalculationID numeric(16);

	Declare @l_InvoiceArrearsID numeric(16);
	Declare @l_Amount_Diff money;
	Declare @l_Amount_Old money;
	Declare @l_Account_ID_Diff money;

    BEGIN TRY
		--Naplóbejegyzés a kezdésről (kötelező)
		Select @l_logMsg = CONCAT('Start procedure ', @l_procedureName);

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		Select 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,           -- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--Naplóbejegyzés a paraméterek ellenőrzéséről (opcionális)
		--Amennyiben szükséges, akkor a tárolt eljárást működtető paraméterek ellenőrzése. Hibás kitöltöttség esetén hiba kezelés. 
		Select @l_logMsg = 'Checing parameters... ';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		Select 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage

		--TODO: Paraméterek ellenőrzése

		--Feldolgozás kezdetéről naplóbejgyzés (kötelező)
		--Innen következnek a feldolgozó utasítások, azok naplózása
		Select @l_logMsg = 'Processing...';

		INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		Select 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			@l_procedureName,   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_logMsg;				    -- LogMessage



   if @l_AccountTypeCode not in (Select AccountTypeID from fin.InvoiceArrears where InvoiceID=@p_InvoiceID and AccountTypeID is not null)
   begin

		INSERT INTO FIN.InvoiceArrears
		(InvoiceID, AccountTypeID, Amount, CurrencyCode, CreationDate, CreationTime, CreationUserName, LastModifiedDate, LastModifiedTime)
		VALUES(@p_InvoiceID, @l_AccountTypeCode, @p_Amount, @p_CurrencyCode, CAST( GETDATE() AS Date),  CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', NULL, NULL);
		Select @InvoiceArrearsID = SCOPE_IDENTITY();

		insert into gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
		values('OBJECT_TYPE_FIN_ACCOUNT', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', 'Teszt', '1.0.0');
		Select @Object_ID = SCOPE_IDENTITY();

		Select @CalculationID=FIN.CalculationInvoice.CalculationID 
		from FIN.InvoiceArrears 
			left join FIN.Invoice              on FIN.InvoiceArrears.InvoiceID=FIN.Invoice.ID
			left join FIN.CalculationInvoice   on FIN.CalculationInvoice.InvoiceID=FIN.Invoice.ID
		where FIN.InvoiceArrears.ID=@InvoiceArrearsID;

		INSERT INTO fin.Account
		(ObjectID, CalculationID, AccountTypeID, Balance, InvoiceLineID, CreationDate, CreationTime, CreationUserName, LastModifiedDate, LastModifiedTime, LastModifiedUserName, CurrencyCode, InvoiceArrearsID)
		VALUES( @Object_ID, @CalculationID, @l_AccountTypeCode, @p_Amount, NULL, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', NULL, NULL, NULL, @p_CurrencyCode, @InvoiceArrearsID);
		Select @Account_ID = SCOPE_IDENTITY();

		insert into gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
		values('OBJECT_TYPE_FIN_TRANSACTION', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', 'Tesztügyfél', '1.0.0')
		Select @Object_ID = SCOPE_IDENTITY();

		INSERT INTO fin.[Transaction]
		( ObjectID, AccountID, PeriodID, BankJournalDate, BankValueDate, ValueDate, AccountingDate, ExchangeDate, Amount, CreationDate, CreationTime, CreationUserName, LastModifiedDate, LastModifiedTime, LastModifiedUserName, PretenseCode)
		VALUES( @Object_ID, @Account_ID, NULL, CAST( GETDATE() AS Date), CAST( GETDATE() AS Date), CAST( GETDATE() AS Date), CAST( GETDATE() AS Date), CAST( GETDATE() AS Date), @p_Amount, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', NULL, NULL, NULL, N'PRETENSE_INITIAL_ARREARS');
	end -- if @l_AccountTypeCode not in (Select AccountTypeID from fin.InvoiceArrears where InvoiceID=@p_InvoiceID and AccountTypeID is not null)
	ELSE
	--if @l_AccountTypeCode in (Select AccountTypeID from fin.InvoiceArrears where InvoiceID=@p_InvoiceID)
	begin

		Select @l_InvoiceArrearsID = i.ID
		from fin.InvoiceArrears i
		where i.InvoiceID=@p_InvoiceID and AccountTypeID=@l_AccountTypeCode;

		Select @l_Amount_Old = a.Balance
		from FIN.Account a
		WHERE InvoiceArrearsID=@l_InvoiceArrearsID;

		Select @l_Account_ID_Diff = a.ID
		from FIN.Account a
		WHERE InvoiceArrearsID=@l_InvoiceArrearsID;

		Select @l_Amount_Diff=@p_Amount-@l_Amount_Old;
	
		IF @l_Amount_Diff <>0
		begin
			UPDATE fin.InvoiceArrears
			SET Amount=@p_Amount
			WHERE InvoiceID=@p_InvoiceID and AccountTypeID=@l_AccountTypeCode;

			UPDATE FIN.Account
			SET Balance=@p_Amount
			WHERE InvoiceArrearsID=@l_InvoiceArrearsID;

			Insert into gen.Object(ObjectType, CreationDate, CreationTime, CreationUserName, Comments, VersionNr)
				values('OBJECT_TYPE_FIN_TRANSACTION', CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', 'Tesztügyfél', '1.0.0');
			Select @Object_ID = SCOPE_IDENTITY();

			INSERT INTO fin.[Transaction]
			( ObjectID, AccountID, PeriodID, BankJournalDate, BankValueDate, ValueDate, AccountingDate, ExchangeDate, Amount, CreationDate, CreationTime, CreationUserName, LastModifiedDate, LastModifiedTime, LastModifiedUserName, PretenseCode)
			VALUES( @Object_ID, @l_Account_ID_Diff, NULL, CAST( GETDATE() AS Date), CAST( GETDATE() AS Date), CAST( GETDATE() AS Date), CAST( GETDATE() AS Date), CAST( GETDATE() AS Date), @l_Amount_Diff, CAST( GETDATE() AS Date), CONVERT(VARCHAR(8), GETDATE(),108), 'Admin', NULL, NULL, NULL, N'PRETENSE_INITIAL_ARREARS');
		end; -- IF @l_Amount_Diff <>0
	end; if @l_AccountTypeCode in (Select AccountTypeID from fin.InvoiceArrears where InvoiceID=@p_InvoiceID)
		
	--Naplóbejegyzés a befejezésről (kötelező)
	Select @l_logMsg = CONCAT('End procedure ', @l_procedureName);

	INSERT INTO LOG.LOG (LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
	Select 
		CAST( GETDATE() AS Date ),	-- LogDate,	
		CAST( GETDATE() AS Time ),	-- LogTime,
		SUSER_SNAME(),				-- UserName
		@p_CorrelationID,			-- CorrelationID
		'INDECS 3.0',			    -- ApplicationName
		DB_NAME(),					-- Environment
		'BACKEND',					-- Layer
		@l_procedureName,   		-- ServiceName
		'1.0',						-- ServiceVersion
		0,					        -- SeverityLevel
		NULL,						-- MessageCategory
		@l_logMsg;                  --LogMessage
			
	--COMMIT TRAN

	RETURN 1;

	END TRY

	BEGIN CATCH

		Select @l_errorMsg = CONCAT('## ERROR (', ERROR_PROCEDURE(), '): ERROR_NUMBER: ', ERROR_NUMBER(), ' ERROR_SEVERITY: ', ERROR_SEVERITY(), 
			' ERROR_STATE: ', ERROR_STATE(), ' ERROR_LINE: ', ERROR_LINE(), ' ERROR_MESSAGE: ', ERROR_MESSAGE());

		INSERT INTO LOG.LOG(LogDate, LogTime, UserName, CorrelationID, ApplicationName, Environment, Layer, ServiceName, ServiceVersion, SeverityLevel, MessageCategory, LogMessage)
		Select 
			CAST( GETDATE() AS Date ),	-- LogDate,	
			CAST( GETDATE() AS Time ),	-- LogTime,
			SUSER_SNAME(),				-- UserName
			@p_CorrelationID,			-- CorrelationID
			'INDECS 3.0',			    -- ApplicationName
			DB_NAME(),					-- Environment
			'BACKEND',					-- Layer
			ERROR_PROCEDURE(),   		-- ServiceName
			'1.0',						-- ServiceVersion
			0,					        -- SeverityLevel
			NULL,						-- MessageCategory
			@l_errorMsg;				-- LogMessage
			
		--ROLLBACK TRAN

		Select 99;

	END CATCH
END
go

CREATE   procedure [GEN].[VIRSQLTester](@p_formCodeID NVarChar(200) = null, @p_filterCode NVarChar(200) = null)
as
begin
  /*A VIR keresők alap SQL-jének illetve a hozzájuk beállított szűrőknek a tesztelését végzi ez a tárolt úgy, hogy:
      - összeállítja a megfelelő SQL szöveget
      - a benne szereplő a backend által kezelt kulcsszavakat kireplace-eli
      - az így kapott SQL szöveget felhasználva lefuttat egy kicsit módosított SQL szerkezetű SQL-t (a részleteket ld. a GEN.VIRSQLTesterSQLPrepare fv-ben)
        azért nem közvetlenül az eredetit, mert el akarjuk kerülni, hogy a selectet eredményei megjelenjenek, ezért egy temp táblába nyomjuk ki az eredményt
        (sajnos a SET FMTONLY ON, set noexec on nem akad le, ha nem létező táblára hivatkozunk mondjuk, úgyhogy az nem elég jó)
        a fenti SQL kihasználja, hogy minden futtatandó SQL végén szerel egy ORDER BY
      - a hibás SQL-eket összegyűjti és a futás végén kiírja egyben az összes hibát  

      - az alapSQL lefuttatásakor ellenőrzi azt is, hogy az SQL-ben szereplő mezők mindegyike fel van-e véve a FormColumn-ba és fordítva
    
    Paraméterek:
      - @formCodeID: csak a megadott kódú form szűréseit teszteli
      - @filterCode: csak a megadott kódú szűrést teszteli
  */

  declare @formid int, @formCodeID NVarChar(200), @formFilterID int, @filterID int, @filterCode NVarChar(200), @filterType VarChar(200), @valueSetID int, @listingModeCode NVarChar(100),
          @sqlTextBase NVarChar(max), @sqlTextBaseWithSampleData NVarChar(max),
          @sqlTextFilter NVarChar(max), @intervalLowerSQLText NVarChar(max), @intervalUpperSQLText NVarChar(max),
          @sqlTextFilterWithSampleData NVarChar(max), @intervalLowerSQLTextWithSampleData NVarChar(max), @intervalUpperSQLTextWithSampleData NVarChar(max),
          @sqlWithTempTableInsert NVarChar(max),
          @disableFilterMode NVarChar(max), @valueReplacerGlobal NVarChar(100) = '123456', @valueReplacerDate NVarChar(100) = '2000-01-01', @valueSetOperator NVarChar(100) = 'AND',
          @pattern NVarChar(100), @replacer NVarChar(100),
          @missingColumnsFromFormColumn NVarChar(max), @missingColumnsFromSQL NVarChar(max)
  declare @stringsToReplace table(pattern NVarChar(100))
  declare @errors table (FormID int, FormCodeID NVarChar(200), FilterType NVarChar(200), ListingModeCode NVarChar(200), FilterCode NVarChar(200), SQLType NVarChar(200), 
                         FullSQL NVarChar(max), FilterSQL NVarChar(max), intervalLowerSQLText NVarChar(max), intervalUpperSQLText NVarChar(max), TestedSQL NVarChar(max),
                         ErrorMessage NVarChar(max)
                        )
  

  insert into @stringsToReplace(pattern) values('%VALUE%'), ('%VALUE1%'), ('%VALUE2%'), ('%VALUE3%'), ('%VALUE4%'), ('%FROM%'), ('%TO%')

  declare cur cursor local fast_forward for
    select f.ID FormID, f.CodeID, flm.ListingModeCode, IsNull(flm.SQLText, f.SQLText) sqlTextBase
    from MIS.Form f left join MIS.FormListingMode flm on f.ID = flm.FormID
    where f.CodeID = IsNull(@p_formCodeID, f.CodeID)

  open cur

  while 1 = 1
  begin
    fetch next from cur into @formid, @formCodeID, @listingModeCode, @sqlTextBase

    if @@FETCH_STATUS <> 0
       break

    select @sqlTextBaseWithSampleData = REPLACE(@sqlTextBase, '%FILTER%', '')

    begin try

      select  @sqlWithTempTableInsert = GEN.VIRSQLTesterSQLPrepare(@sqlTextBaseWithSampleData, 1 /*@withmissingColumnCheck*/)
     
      exec sp_executesql @sqlWithTempTableInsert, N'@formID int, @missingColumnsFromFormColumn NVarChar(max) output, @missingColumnsFromSQL NVarChar(max) output', @formid, @missingColumnsFromFormColumn output, @missingColumnsFromSQL output
    end try
    begin catch
      insert into @errors(FormID, FormCodeID, ListingModeCode, SQLType, FullSQL, TestedSQL, ErrorMessage)
           select @formid, @formCodeID, @listingModeCode, 'Base SQL', @sqlTextBaseWithSampleData, @sqlWithTempTableInsert, ERROR_MESSAGE()

      /*ha eleve hibás az alap SQL, akkor a filtereket nem nézzük már meg hozzá*/ 
      continue 
    end catch

    /*ha a FormColumnból vagy az SQL-ből hiányoznak mezők, akkor azt is ellogoljuk hibának, de a filterek ellenőrzésével megyünk attól még tovább*/
    if @missingColumnsFromFormColumn is not null
    begin
      insert into @errors(FormID, FormCodeID, ListingModeCode, SQLType, FullSQL, ErrorMessage)
        select @formid, @formCodeID, @listingModeCode, 'Base SQL - missing FormColumn columns', @sqlTextBaseWithSampleData, @missingColumnsFromFormColumn
    end
    if @missingColumnsFromSQL is not null
    begin
      insert into @errors(FormID, FormCodeID, ListingModeCode, SQLType, FullSQL, ErrorMessage)
        select @formid, @formCodeID, @listingModeCode, 'Base SQL - missing SQL columns', @sqlTextBaseWithSampleData, @missingColumnsFromSQL
    end
  
    declare cur_filter cursor local fast_forward for
      select ffi.Code, flm.ListingModeCode, fi.FilterType, ffi.DisableFilterMode,
             IsNull(flm.SQLText, ffi.SQLText) SQLText,
             IsNULL(flm.IntervalLowerSQLText, ffi.IntervalLowerSQLText) IntervalLowerSQLText,
             IsNULL(flm.IntervalUpperSQLText, ffi.IntervalUpperSQLText) IntervalUpperSQLText
      from MIS.FormFilter ffi join MIS.Filter fi on ffi.FilterID = fi.ID
                              left join MIS.FormFilterListingMode flm on ffi.ID = flm.FormFilterID and flm.ListingModeCode = @listingModeCode 
      where ffi.FormID = @formid
        and ffi.Code = IsNull(@p_filterCode, ffi.Code)


    open cur_filter

    while 1 = 1
    begin
      fetch next from cur_filter into @filterCode, @listingModeCode, @filterType, @disableFilterMode, @sqlTextFilter, @intervalLowerSQLText, @intervalUpperSQLText

      if @@FETCH_STATUS <> 0
         break

      select @sqlTextFilterWithSampleData = @sqlTextFilter,
             @intervalLowerSQLTextWithSampleData = @intervalLowerSQLText,
             @intervalUpperSQLTextWithSampleData = @intervalUpperSQLText

      declare cur_replacer cursor local fast_forward for
        select t.pattern, Case when @filterType = 'SET' and t.pattern = '%VALUE2%' then @valueSetOperator
                               when @filterType = 'SET' and t.pattern <> '%VALUE2%' then Concat('''', @valueReplacerGlobal, '''')
                               when @filterType in('DATEINTERVAL') then @valueReplacerDate 
                               else @valueReplacerGlobal 
                          end replacer
        from @stringsToReplace t

      open cur_replacer

      while 1 = 1
      begin
        fetch next from cur_replacer into @pattern, @replacer
        if @@FETCH_STATUS <> 0
           break

        select @sqlTextFilterWithSampleData = Replace(@sqlTextFilterWithSampleData, @pattern, @replacer),
               @intervalLowerSQLTextWithSampleData = Replace(@intervalLowerSQLTextWithSampleData, @pattern, @replacer),
               @intervalUpperSQLTextWithSampleData = Replace(@intervalUpperSQLTextWithSampleData, @pattern, @replacer)
      end

      close cur_replacer
      deallocate cur_replacer


      if Replace(@sqlTextFilterWithSampleData, ' ', '') = '1=1'
      begin
        set @sqlTextFilterWithSampleData = ' and ' + @sqlTextFilterWithSampleData
      end

      if @sqlTextFilterWithSampleData like '%|%'
      begin
         set @sqlTextFilterWithSampleData = Replace(@sqlTextFilterWithSampleData, '| AND', 'AND')
      end

      /*alap szűrés*/
      select @sqlTextFilterWithSampleData = Replace(@sqlTextBase, '%FILTER%', @sqlTextFilterWithSampleData) 

      begin try
        select  @sqlWithTempTableInsert = GEN.VIRSQLTesterSQLPrepare(@sqlTextFilterWithSampleData, 0 /*@withmissingColumnCheck*/)
        exec sp_executesql @sqlWithTempTableInsert
      end try
      begin catch
         insert into @errors(FormID, FormCodeID, FilterCode, FilterType, ListingModeCode, SQLType, FullSQL, FilterSQL, intervalLowerSQLText, intervalUpperSQLText, TestedSQL, ErrorMessage)
           select @formid, @formCodeID, @filterCode, @filterType, @listingModeCode, 'Base filter', @sqlTextFilterWithSampleData, @sqlTextFilter, @intervalLowerSQLText, @intervalUpperSQLText, @sqlWithTempTableInsert, ERROR_MESSAGE()
      end catch
      
      /*intervallumos szűrés*/
      if @disableFilterMode = 'BOOLEAN_TRUE'
      begin
        select @sqlTextFilterWithSampleData = Replace(@sqlTextBase, '%FILTER%', IsNull(@intervalLowerSQLTextWithSampleData, '') + ' ' + IsNull(@intervalUpperSQLTextWithSampleData, ''))

        begin try
          select  @sqlWithTempTableInsert = GEN.VIRSQLTesterSQLPrepare(@sqlTextFilterWithSampleData, 0 /*@withmissingColumnCheck*/)
          exec sp_executesql @sqlWithTempTableInsert
        end try
        begin catch
           insert into @errors(FormID, FormCodeID, FilterCode, FilterType, ListingModeCode, SQLType, FullSQL, FilterSQL, intervalLowerSQLText, intervalUpperSQLText, TestedSQL, ErrorMessage)
             select @formid, @formCodeID, @filterCode, @filterType, @listingModeCode, 'Interval filter', @sqlTextFilterWithSampleData, @sqlTextFilter, @intervalLowerSQLText, @intervalUpperSQLText, @sqlWithTempTableInsert, ERROR_MESSAGE()
        end catch
      end
    end

    close cur_filter
    deallocate cur_filter
  end

  close cur
  deallocate cur


  ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  select GEN.TranslateCode(FormCodeID, 'HU') FormName, GEN.TranslateCode(FilterCode, 'HU') FilterName, *
  from @errors
  order by FormID, FilterCode, ListingModeCode
end
go

CREATE   function [GEN].[VIRSQLTesterSQLPrepare](@sqlText NVarChar(max), @withmissingColumnCheck int = 0)
returns NVarChar(max)
as
begin
  /*a paraméterben kapott SQL textből az alábbi módosított szerkezetű SQL szöveget állítja elő (a tSQLt.VIRSQLTester tárolt majd ezt fogja tesztként lefuttatni):
    select *
    into #tmp
    from (<@sqlText>
          OFFSET 0 ROWS FETCH FIRST 1 ROW ONLY
         ) x 

    ha @withmissingColumnCheck = 1, akkor azt is ellenőrzi, hogy a legenerált #tmp táblában szerepel-e olyan mező, ami hiányzik a megfelelő FormColumn rekordok közül és fordítva
                                    ilyenkor át kell adni majd a visszaadott SQL futtatásakor paraméterként a @formID-t; valamint a hibák kiolvasására 2 output paramétert: missingColumnsFromFormColumn illetve missingColumnsFromSQL

  */
  
  declare @res NVarChar(max)

  select @res = Concat('select * 
                 into #tmp
                 from (', @sqlText, '
                       OFFSET 0 ROWS FETCH FIRST 1 ROW ONLY
                      ) x'
                      )
                
  if @withmissingColumnCheck = 1
  begin
    select @res = Concat('/*Missing column check*/',
                         char(13), char(10),  
                         @res,
                         char(13), char(10),  
                         'select @missingColumnsFromFormColumn = ''Missing columns from FormColumn: '' + String_Agg(sqlCols.name, '', '' ),
                                 @missingColumnsFromSQL = ''Missing columns from SQL: '' + String_Agg(formCols.ColumnName, '', '' )
                          from (select sqlCols.name
                                from tempdb.sys.columns sqlCols
                                where sqlCols.object_id = OBJECT_ID(N''tempdb..#tmp'')
                               ) sqlCols full outer join
                               (select formCols.ColumnName
                                from MIS.FormColumn formCols
                                where formCols.FormID = @formID
                               ) formCols on sqlCols.name = formCols.ColumnName
                          where sqlCols.name is null
                             or formCols.ColumnName is null'  
                       )
  end

  return @res
end
go

-- ===================================================
-- Author:		GURBAN
-- Create date:		2022.07.26
-- Main version:	Ver 0.6
-- Description:	Importing JSON data to the MIS 
--    sysytem. 
-- Arguments:
--    @pRunFlag	     -- controlling run. 
--	 0 - Complete run, Interprets the JSON data
--	    (default)
--	 1 - Using the interpreted JSON data earlier
--    @pJSONInput    -- the JSON input AS string
--    @TraceMode     -- the intended trace mode, 
--	 0     - starting in production environment, 
--		  logging the most important events and all
--		  runtime problems (errors)
--	 1     - starting in test/debug environment, logging 
--		  all relevant information
--
--    @pTraceMode    -- the flag cotrolling tracing
--	 0     -  production tracing, logging the most relevant 
--		  information goes into the log only (defaul)
--	 > 0   -  debug tracing, all information goes into the log.
-- Warning: the code does not use @pJSONInput 
-- when @pRunGlag = 0 !! In this case there is a 
-- flag indicating which partition was the last that
-- could be done properly earlier.
-- ===================================================

-- FIXME is the name of the USER who exeutes the procedure required?

--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- TODO The user handling of the MkObjectIDForTable is not ok
-- TODO Update data when loading the same MIS Form
-- TODO Handle object versioning, with Status flag (stable)
--!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

-- TODO print for traceing execution

CREATE   PROCEDURE [MIS].[VirMainJSON]
(
   @pJSONInput	  NVARCHAR(MAX) ,
   @pRunFlag	  INT = 0 ,
   @pTraceMode	  INT = 0  
)

AS
BEGIN

   DECLARE @lRes INT ; -- Result code of the procedure
   DECLARE @lTableSize	   INT 
   DECLARE @lProcPhase	   INT
   DECLARE @lMainBlock	   INT 
   DECLARE @lInsertMode	   INT ;
   DECLARE @lSize	   NUMERIC(16,0) 
   -- Common comment for the GEN.Object table
   DECLARE @lObjectComment NVARCHAR(50) 
   DECLARE @lObjectVersion NVARCHAR(50) 

   -- Variables to handle data

   DECLARE @lFormSQLText	 NVARCHAR(MAX)
   DECLARE @lFilterJSON		 NVARCHAR(MAX)
   DECLARE @lFilterFoldJSON	 NVARCHAR(MAX)
   DECLARE @lFolderTreeJSON	 NVARCHAR(MAX)
   DECLARE @lsubElementJSON	 NVARCHAR(MAX)
   DECLARE @lTranslationsJSON	 NVARCHAR(MAX)
   DECLARE @lFilterSqlstatement	 NVARCHAR(MAX)
   DECLARE @lSubTreeJSON	 NVARCHAR(MAX)   

   DECLARE @lErrorLevel		 NUMERIC(2,0) ;      
   DECLARE @lDebugLevel		 NUMERIC(2,0) ;

-- Local variables for processing the data

   DECLARE @lsubTreeDepth	 INT
   DECLARE @ltranslationIndex	 INT 
   DECLARE @lFilterIndex	 INT
   DECLARE @lCursorStatus	 INT
   DECLARE @lFormId		 NUMERIC(16,0)
   DECLARE @lValueSetId		 NUMERIC(16,0)  
   DECLARE @lFolderId		 NUMERIC(16,0)
   DECLARE @luniversalID	 NUMERIC(16,0)
   DECLARE @lRootFolderId	 NUMERIC(16,0)
   DECLARE @lFilterRootId	 NUMERIC(16,0)
   DECLARE @lFilterId		 NUMERIC(16,0)
   DECLARE @lFormFilterID	 NUMERIC(16,0)
   DECLARE @lordNr		 NUMERIC(16,0)
   DECLARE @lCodeId		 NUMERIC(16,0)

   DECLARE @lRootTableName	 NVARCHAR(50)
   DECLARE @lFormCode		 NVARCHAR(50)
   DECLARE @lFormIcon		 NVARCHAR(50)
   DECLARE @lFormVersion	 NVARCHAR(50)
   DECLARE @lFCode		 NVARCHAR(50)
   DECLARE @lActionCode		 NVARCHAR(50)
   DECLARE @lDefaultAction	 NVARCHAR(50)
   DECLARE @lFilterJSONValueSet	 NVARCHAR(50)
   DECLARE @lTransCountry	 NVARCHAR(5) 
   DECLARE @lTransText		 NVARCHAR(200)
   DECLARE @lFilterDefType	 NVARCHAR(50)
   DECLARE @lFilterDefValue	 NVARCHAR(100)
   DECLARE @lFilterIconName	 NVARCHAR(50)
   DECLARE @lFilterType		 NVARCHAR(50)
   DECLARE @lModuleName		 NVARCHAR(50) ;
   DECLARE @lModuleVersion	 NVARCHAR(50) ;
   DECLARE @lFolderCode		 NVARCHAR(50) ;
   DECLARE @lFolderIconName	 NVARCHAR(50) ;
   DECLARE @lMisUserID		 NVARCHAR(50) ;
   DECLARE @ltmpStr		 NVARCHAR(50) ;
      
   DECLARE @lFormValueSet  	 NVARCHAR(200)
   DECLARE @lFolderValueSet	 NVARCHAR(200)
   DECLARE @lFilterValueSet	 NVARCHAR(200)
   DECLARE @lColumnValueSet	 NVARCHAR(200)
   DECLARE @lActionValueSet	 NVARCHAR(200)

-- Cursors

   SELECT @lCursorStatus = CURSOR_STATUS('global','FilterValSetCursor')
   IF @lCursorStatus =-3
      DECLARE FilterValSetCursor CURSOR FOR
	 SELECT FilterValueSet 
	 FROM TMP.FilterVector 

   SELECT @lCursorStatus = CURSOR_STATUS('global','FilterCursor')
   IF @lCursorStatus =-3
      DECLARE FilterCursor CURSOR FOR
	 SELECT UPPER(FilterCode), UPPER(FilterValueSet), defType, defValue, 
	    CAST(ordNr AS NUMERIC(16,0)) AS ordNr, FilterIconName, 
	    FilterType, FilterSqlstatement, FilterTrans, 
	    FilterFolderVector
	 FROM TMP.FilterVector 

   SET @lRes = 0 ; 
   SET @lSize = 0
   SET @lFilterIndex = 0
   SET @lProcPhase = 0 ;
   SET @lsubTreeDepth = 0 ;
   SET @lValueSetId = 0 
   SET @lInsertMode = 0 ; -- New MIS.Form will be inserted.
   SET @lObjectComment = 'MIS JSON data loader'

   -- For logging
   SET @lModuleName = 'MIS.VirMainJSON' ;
   SET @lModuleVersion = 'Ver 0.0.6d' ;
   SET @lObjectVersion = '1.0'

   SET @lErrorLevel = 7 ;   
   SET @lDebugLevel = 3 ;
   SET @lMainBlock = 1

   SET @lRootTableName = 'MIS.Folder' ;

-- For testing ONLY!!!!! on local DEV

-- XXX GUR

   SET @lFormValueSet = 'MISFORM'
   SET @lFolderValueSet = 'FOLDERNAME'
   SET @lFilterValueSet = 'MISFORM_FILTER'
   SET @lColumnValueSet = 'MISFORM_COLUMN'
   SET @lActionValueSet = 'MISFORM_ACTION'


-- TODO check indention

-- For production

-- TODO username honnan

	INSERT INTO [LOG].[SysLog]
		(UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	VALUES	
		(USER_NAME(), @lModuleName, @lDebugLevel, CONCAT('Procedure start, ',@lModuleVersion), 
			CAST(getdate() AS DATE), CAST(getdate() AS TIME))

   PRINT CONCAT('Start, version ', @lModuleVersion, ' main block')

   BEGIN TRY

      -- 1. Check input parameters and consistency
  
      IF  @pRunFlag = 0
	 BEGIN
	    IF LEN(@pJSONInput) = 0
	       RAISERROR('No input string given!', 16, 1)
	 END
      ELSE -- @pRunFlag <> 0
	 BEGIN
	    SELECT @lSize = COUNT(*)
	    FROM MIS.VirImport 

	    IF @lSize = 0
	       BEGIN
		  -- No parsed data when rerun
		  RAISERROR('No parsed data when rerun!', 16, 1)
	       END  
	 END

      -- ===================================================
      -- Populating the work table from JSON data string
      -- Table may remain persitent to enable re-run of the 
      -- procedure in case of faulty or broken execution.
      -- ===================================================

      IF @pRunFlag = 0 AND LEN(@pJSONInput) <> 0
	 BEGIN 
	    
	    TRUNCATE TABLE MIS.VirImport

	    INSERT INTO MIS.VirImport
	       (System, Version, Tipe, UserId, UserEmail, LastMod, Encoding, 
		  Code, FolderTree, IconName, QueryVersion, SQLText, QueryTranslations, 
		  FilterVector, ColumnVector, ActionVector)
	    SELECT  System, Version, Tipe, UserId, UserEmail, LastMod, Encoding, 
	       Code, FolderTree, IconName, QueryVersion, SQLText, QueryTranslations, 
	       FilterVector, ColumnVector, ActionVector
	    FROM OPENJSON(@pJSONInput)
	       WITH
		  (
		     System	    NVARCHAR(50)   '$.header.system', 
		     Version	    INT		   '$.header.version', 
		     Tipe	    NVARCHAR(50)   '$.header.type', 
		     UserId	    NVARCHAR(50)   '$.header.userID', 
		     UserEmail	    NVARCHAR(50)   '$.header.userEmail', 
		     LastMod	    DATE	   '$.header.lastModDate', 
		     Encoding	    NVARCHAR(50)   '$.header.encoding', 
		     qData	    NVARCHAR(MAX)  '$.queryData'	as JSON
		  ) 
	    OUTER APPLY OPENJSON(qData)
	       WITH
		  (
		     Code		  NVARCHAR(50)   '$.code', 
		     QueryTranslations	  NVARCHAR(MAX)  '$.translations'	as JSON, 
		     FolderTree		  NVARCHAR(MAX)  '$.folders'		as JSON, 
		     IconName		  NVARCHAR(50)   '$.iconName', 
		     QueryVersion	  NVARCHAR(50)   '$.version',     
		     SQLText		  NVARCHAR(MAX)  '$.SQLText',
		     FilterVector	  NVARCHAR(MAX)  '$.filters'		as JSON, 
		     ColumnVector	  NVARCHAR(MAX)  '$.columnData'	as JSON, 
		     ActionVector	  NVARCHAR(MAX)  '$.actionData'	as JSON 
		  )

	    IF @pTraceMode <> 0 

	       INSERT INTO [LOG].[SysLog]
		  (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	       VALUES	
		  (USER_NAME(), @lModuleName, @lDebugLevel, 'JSON parsing completed.', 
		     CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	    -- ===================================================
	    -- Check the package just parsed and loaded
	    -- ===================================================

	    -- Only 1 record in the table

	    SELECT @lSize = CASE WHEN Version = 3 AND Tipe = 'MIS_QUERY' THEN 1 
			   ELSE 0 END 
	    FROM MIS.VirImport

	    IF @lSize <> 1 
	       -- Loaded package not conforms specification
	       RAISERROR('Loaded package not conforms specification!', 16, 1)


	    -- Checking user

	       INSERT INTO [LOG].[SysLog]
		  (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	       VALUES	
		  (USER_NAME(), @lModuleName, @lDebugLevel, 
		     'User autentication switched off for TESTING.', 
		     CAST(getdate() AS DATE), CAST(getdate() AS TIME))

/*  FOR productions!!

	    SET @lSize = 0 

	    SELECT @lMisUserID = MAX(MIS.VirImport.UserID)
	    FROM MIS.VirImport

	    SELECT @lSize = COUNT(*) 
	    FROM PRT.AppUser 
	    WHERE PRT.AppUser.UserName = @lMisUserID
	    
	    IF @lSize = 0 
	       -- User authorization missing
	       RAISERROR('User authorization missing!', 16, 1)
*/

	 END  -- @pRunFlag = 0 AND LEN(@pJSONInput) <> 0

      -- ===================================================
      -- Start processing the data just loaded
      -- ===================================================

-- TODO the log should be according to the other debug logs
	 -- Preliminary check of ValueSets
	 -- MIS_FORM

	 SET @lSize = 0

	 -- For testing only on local DEV

	 IF @pTraceMOde <> 0
	    INSERT INTO [LOG].[SysLog]
	       (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	    VALUES	
	       (USER_NAME(), @lModuleName, @lDebugLevel, 
		  CONCAT('Form ValueSet is ',@lFormValueSet,'> for check.'), 
		  CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	 SELECT @lSize = COUNT(*)
	 FROM GEN.ValueSet 
	 WHERE GEN.ValueSet.CodePrefix = @lFormValueSet

	 IF @lSize = 0
	    RAISERROR('No Form valueSet in DB!', 16, 1)

	 -- FOLDER_MIS
	 
	 SET @lSize = 0

	 IF @pTraceMode <> 0 
	    INSERT INTO [LOG].[SysLog]
	       (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	    VALUES	
	       (USER_NAME(), @lModuleName, @lDebugLevel, 
		  CONCAT('Folder ValueSet is <',@lFolderValueSet,'> for check.'), 
		  CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	 SELECT @lSize = COUNT(*)
	 FROM GEN.ValueSet 
	 WHERE GEN.ValueSet.CodePrefix = @lFolderValueSet

	 IF @lSize = 0
	    RAISERROR('No Folder valueSet in DB!', 16, 1)

	 -------------------------
	 -- TMP.FilterVector
	 -------------------------

	 SELECT @lFilterJSON = MIS.VirImport.FilterVector 
	 FROM MIS.VirImport ;

	 TRUNCATE TABLE TMP.FilterVector

	 INSERT INTO TMP.FilterVector
	    (FilterCode, FilterValueSet, defType, defValue, ordNr, FilterIconName, 
	       FilterType, FilterSqlstatement, FilterTrans, FilterFolderVector)
	 SELECT FilterCode, FilterValueSet, defType, defValue, ordNr, FilterIconName, 
	    FilterType, FilterSqlstatement, FilterTrans, FilterFolderVector
	 FROM OPENJSON(@lFilterJSON)
	 WITH
	    (
	       FilterCode	    NVARCHAR(50)	 '$.code', 
	       FilterTrans	    NVARCHAR(MAX)	 '$.translations'     as JSON,
	       FilterValueSet       NVARCHAR(50)	 '$.valueSetCodeID', 
	       defType		    NVARCHAR(50)	 '$.defaultType', 
	       defValue		    NVARCHAR(100)	 '$.defaultValue', 
	       ordNr		    INT			 '$.ordNr', 
	       FilterIconName	    NVARCHAR(50)	 '$.iconName', 
	       FilterType	    NVARCHAR(50)	 '$.filterType',
	       FilterSqlstatement   NVARCHAR(MAX)	 '$.SQLStatement', 
	       FilterFolderVector   NVARCHAR(MAX)	 '$.folders'	     as JSON
	    )

	 SET @lTableSize = 0 

	 SELECT @lTableSize = COUNT(*)
	 FROM TMP.FilterVector 

	 OPEN FilterValSetCursor 
	 FETCH NEXT FROM FilterValSetCursor INTO @lFilterJSONValueSet

	 WHILE @@FETCH_STATUS = 0
	    BEGIN

	       SET @lSize = 0

	       SET @ltmpStr = CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet)
	       
	       IF @pTraceMode <> 0
		  INSERT INTO [LOG].[SysLog]
		     (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		  VALUES	
		     (USER_NAME(), @lModuleName, @lDebugLevel, 
		     CONCAT('Filter ValueSet is <',@ltmpStr,'> for check.'), 
		     CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	       SELECT @lSize = COUNT(*) 
	       FROM GEN.ValueSet 
	       WHERE GEN.ValueSet.CodePrefix = @ltmpStr

--	       WHERE GEN.ValueSet.CodePrefix = CONCAT('MIS_FORM_FILTER_', @lFilterValueSet) // Original Urban

	       IF @lSize > 0 
		  SET @lRes = @lRes + 1
	       ELSE 

		  INSERT INTO [LOG].[SysLog]
		     (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		  VALUES	
		     (USER_NAME(), @lModuleName, @lErrorLevel, CONCAT('No FilterValueSet for ', @ltmpStr), 
			CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	       FETCH NEXT FROM FilterValSetCursor INTO @lFilterJSONValueSet 
 
	    END -- @@FETCH_STATUS = 0

	 CLOSE FilterValSetCursor 
	 DEALLOCATE FilterValSetCursor 

	 IF @pTraceMode > 0
	    
	    INSERT INTO [LOG].[SysLog]
	       (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	    VALUES	
	       (USER_NAME(), @lModuleName, @lDebugLevel, 
		  CONCAT('TableSize = ', CAST(@lTableSize AS NVARCHAR(10)), ' Found = ', 
		     CAST(@lRes AS NVARCHAR(10))), CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	 IF @lRes <> @lTableSize
	    RAISERROR('Not enough Filter valueSets in DB!', 16, 1)
	 ELSE -- for testing
	    PRINT 'OK'
  
	 -- Column and Action valueSets

	 SET @lSize = 0

	 -- For testing only on local DEV

	 IF @pTraceMode <> 0
	    INSERT INTO [LOG].[SysLog]
	       (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	    VALUES	
	       (USER_NAME(), @lModuleName, @lDebugLevel, 
	       CONCAT('Column ValueSet is <',@lColumnValueSet,'> for check.'), 
	       CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	 SELECT @lSize = COUNT(*)
	 FROM GEN.ValueSet 
	 WHERE GEN.ValueSet.CodePrefix = @lColumnValueSet

	 IF @lSize = 0
	    RAISERROR('No Column valueSet in DB!', 16, 1)

	 SET @lSize = 0

	 -- For testing only on local DEV

	 IF @pTraceMOde <> 0
	    INSERT INTO [LOG].[SysLog]
	       (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	    VALUES	
	       (USER_NAME(), @lModuleName, @lDebugLevel, 
	       CONCAT('Form ValueSet is <',@lActionValueSet, '> for check.'), 
	       CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	 SELECT @lSize = COUNT(*)
	 FROM GEN.ValueSet 
	 WHERE GEN.ValueSet.CodePrefix = @lActionValueSet

	 IF @lSize = 0
	    RAISERROR('No Action valueSet in DB!', 16, 1)


	 -- Check passed

-- TODO Handle existing record !!

      -- FIXME Other fields to set?? 

      -------------------------
      -- Topmost entry in hierarchy is MIS.FORM
      -------------------------

	 SET @lProcPhase = 1

	 PRINT CONCAT('Phase = ', CAST(@lProcPhase AS NVARCHAR(10)))

	 IF @pTraceMode > 0
	    
	    INSERT INTO [LOG].[SysLog]
	       (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	    VALUES	
	       (USER_NAME(), @lModuleName, @lDebugLevel, 
		  'Start actual processing.', CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	 BEGIN TRANSACTION 

	 SELECT @lFormSqlText = MIS.VirImport.SQLText FROM MIS.VirImport ;
	 SELECT @lFormIcon    = MIS.VirImport.IconName FROM MIS.VirImport ;
	 SELECT @lFormCode    = MIS.VirImport.Code FROM MIS.VirImport ;
	 SELECT @lFormVersion = MIS.VirImport.QueryVersion FROM MIS.VirImport ;
	    
	 -- FIXME: decide of there is such a Form already -- ok?
	 -- FIXME: RootFolder issue postponed till DB update

	 IF @pTraceMode > 0
	    
	    INSERT INTO [LOG].[SysLog]
	       (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	    VALUES	
	       (USER_NAME(), @lModuleName, @lDebugLevel, 
		  'Base data extracted.', CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	 SET @lFormId = 0 ;

	 PRINT CONCAT('=========>', @lFormValueSet, '_' , @lFormCode)

	 SELECT @lFormId = [MIS].[Form].ID FROM [MIS].[Form]
	 WHERE [MIS].[Form].CodeID = CONCAT(@lFormValueSet, '_' , @lFormCode)
	 AND [MIS].[Form].IconName = @lFormIcon ;

	 IF @lFormId = 0

	    BEGIN

 	       SET @lRootFolderId = 0 ;

	       IF @pTraceMode > 0
	    
		  INSERT INTO [LOG].[SysLog]
		     (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		  VALUES	
		     (USER_NAME(), @lModuleName, @lDebugLevel, 
		     'New MIS.Form to be inserted.', CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	       PRINT 'Not found'
	    
	       SELECT @lRootFolderId = GEN.RootFolder.ID 
		   FROM GEN.RootFolder
	       WHERE GEN.RootFolder.TableName = @lRootTableName

	       IF @lRootFolderId = 0
		  RAISERROR('Root folder for MIS not found!', 16, 1)

	       -- Create Object for the MIS.Form

	       SET @luniversalID = 0 ;

	       INSERT INTO [GEN].[Object]
	          (ObjectType, CreationDate, CreationTime,  Comments, VersionNr)
	       VALUES
		  ('MIS.Form', CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), @lObjectComment,@lFormVersion)

	       SET @luniversalID = @@IDENTITY

	       IF @pTraceMode > 0
	    
		  INSERT INTO [LOG].[SysLog]
		     (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		  VALUES	
		     (USER_NAME(), @lModuleName, @lDebugLevel, 
			'Object for MIS.Form called for.', CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	       IF @luniversalID = 0
		  BEGIN

		  INSERT INTO [LOG].[SysLog]
		     (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		  VALUES	
			(USER_NAME(), @lModuleName, @lErrorLevel, 'Object for MIS.Form set to NULL.', 
			CAST(getdate() AS DATE), CAST(getdate() AS TIME))

		     SET @luniversalID = NULL ;
		  END

	       SET @lCodeId = 0 

	       SELECT @lCodeId = GEN.Code.OrderID 
	       FROM GEN.Code 
	       WHERE GEN.Code.ID = CONCAT(@lFormValueSet, '_', @lFormCode)

	       PRINT CONCAT('Form COde ID ====== ', CAST(@lCodeId AS NVARCHAR(10)))

	       IF @lCodeId = 0 
		  BEGIN 
		     IF @pTraceMode > 0
			INSERT INTO [LOG].[SysLog]
			   (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
			VALUES	
			   (USER_NAME(), @lModuleName, @lDebugLevel, 
			      CONCAT('Code inserted for ', @lFormValueSet, '_', @lFormCode), 
			      CAST(getdate() AS DATE), CAST(getdate() AS TIME))

		     SET @lValueSetId = 0

		     SELECT @lValueSetId = [GEN].[ValueSet].ID
		     FROM [GEN].[ValueSet]
		     WHERE [GEN].[ValueSet].CodePrefix = @lFormValueSet

		     PRINT 'Code inseerted from MIS.FORM'

		     INSERT INTO [GEN].[Code]
			(ID, ValueSetID, CreationDate, CreationTime, ValidFrom)
		     VALUES 
			(CONCAT(@lFormValueSet, '_', @lFormCode), @lValueSetId, CAST(GETDATE() AS DATE), 
			   CAST(GETDATE() AS TIME), CAST(GETDATE() AS DATE))
	    
		  END -- @lCodeId = 0		     

	       -- Create MIS.Form entry

	       INSERT INTO [MIS].[Form]
		  (SQLText, CreationDate, CreationTime, IconName, CodeID, RootFilterFolderID, ObjectID)
	       VALUES 
		  (@lFormSqlText, CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), @lFormIcon, 
		     CONCAT(@lFormValueSet, '_' , @lFormCode), @lRootFolderId, @lUniversalID) ;

	       SET @lFormId = @@IDENTITY

	       PRINT 'Form ok --'

	       -- Inserting the translations for MIS.FORM

	       SELECT @lTranslationsJSON = MIS.VirImport.QueryTranslations
	       FROM MIS.VirImport

	       TRUNCATE TABLE TMP.Translations

	       INSERT INTO TMP.Translations
		  (TransCountry, TransText)
	       SELECT UPPER(TransCountry), TransText
	       FROM OPENJSON(@lTranslationsJSON)
	       WITH
		  (
		     TransCountry   NVARCHAR(5)    '$.country',
		     TransText      NVARCHAR(200)  '$.text'
		  )

	       PRINT 'Form translation started'

   	       SELECT @ltranslationIndex = (MIN(TransID) - 1)
	       FROM TMP.Translations 

	       PRINT CONCAT('Starting id = ',CAST(@ltranslationIndex AS NVARCHAR(10)))

	       WHILE 1 = 1 
		  BEGIN

		     SELECT @lTransCountry = TransCountry, @lTransText = TransText
		     FROM  TMP.Translations
		     WHERE TransID = @ltranslationIndex + 1

		     IF @@ROWCOUNT = 0
			BREAK ;

		     SET @lSize = 0

		     PRINT CONCAT('Form translation READ code = ',@lFormValueSet, '_', @lFormCode, ' ', @lTransText)

		     SELECT @lSize = COUNT(*)
		     FROM [GEN].[Translation]
		     WHERE GEN.Translation.CodeID = CONCAT(@lFormValueSet, '_', @lFormCode) 
			AND GEN.Translation.Language = @lTransCountry 

-- TODO Logging

		     IF @lSize = 0
			INSERT INTO [GEN].[Translation]
			   (CodeID, Language, Text, CreationDate, CreationTime)
			VALUES
			   (CONCAT(@lFormValueSet, '_', @lFormCode), @lTransCountry, @lTransText, 
			      CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME))
		     ELSE
			UPDATE [GEN].[Translation]
			   SET GEN.Translation.Text = @lTransText, GEN.Translation.LastModifiedDate = CAST(GETDATE() AS DATE), 
			   GEN.Translation.LastModifiedTime = CAST(GETDATE() AS TIME)
			WHERE GEN.Translation.CodeID = CONCAT(@lFormValueSet, '_', @lFormCode) 
			   AND GEN.Translation.Language = @lTransCountry 

		     SET @ltranslationIndex = @ltranslationIndex + 1  
		  END -- WHILE 1 = 1 

		  PRINT CONCAT('Form translation processed indxe = ',CAST(@ltranslationIndex AS NVARCHAR(4)))

	    END -- @lFormId = 0
/*
	 ELSE -- @lFormId > 0
	    BEGIN
	    END -- @lFormId > 0
*/


      ------------------------------------
      -- Processing vector JSON structure:
      ------------------------------------

      -- MIS.FilterVector

	 SET @lSize = 0

	 PRINT 'Start filters'

	 SELECT @lSize = COUNT(*) 
	 FROM TMP.FilterVector 

	 IF @lRes = 0
	    RAISERROR('Filter vector data lost during processing!', 16,1)
	 
	 OPEN FilterCursor

	 FETCH NEXT FROM FilterCursor
	 INTO @lFCode, @lFilterJSONValueSet, @lFilterDefType, @lFilterDefValue, @lordNr, 
	    @lFilterIconName, @lFilterType, @lFilterSqlstatement, @lTranslationsJSON, 
	    @lFilterFoldJSON

	 WHILE @@FETCH_STATUS = 0
	    BEGIN

	       SET @lfilterIndex = @lfilterIndex + 1

	       PRINT '******************************************************************'
	       PRINT CONCAT('Filter index = ', CAST(@lfilterIndex AS  NVARCHAR(10)))
	       PRINT '******************************************************************'

	       SET @lValueSetId = 0

	       PRINT  CONCAT('Filter cursor read ',@lFilterValueSet, '_', @lFilterJSONValueSet)

	       SELECT @lValueSetId = GEN.ValueSet.ID 
	       FROM GEN.ValueSet 
	       WHERE GEN.ValueSet.CodePrefix = CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet)

	       SET @lFilterId = 0

	       SELECT @lFilterId = MIS.Filter.ID 
	       FROM MIS.Filter 
	       WHERE MIS.Filter.Code = CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet,'_',@lFcode)

	       PRINT CONCAT('ValSetID = ', CAST(@lValueSetId AS NVARCHAR(10)), ' FilterID = ', CAST(@lFilterId AS NVARCHAR(10)))

	       IF @lFilterId = 0
		  BEGIN

		     PRINT 'NEW filter is to be inserted'

		     -- Create Object for the MIS.Filter
		     SET @luniversalID = 0 ;

		     INSERT INTO [GEN].[Object]
			(ObjectType, CreationDate, CreationTime,  Comments, VersionNr)
		     VALUES
			('MIS.Filter', CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), @lObjectComment, @lObjectVersion)

		     SET @luniversalID = @@IDENTITY

		     IF @luniversalID = 0
			BEGIN

			   INSERT INTO [LOG].[SysLog]
			      (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
			   VALUES	
			      (USER_NAME(), @lModuleName, @lErrorLevel, 'Object for MIS.Filter set to NULL.', 
				 CAST(getdate() AS DATE), CAST(getdate() AS TIME))
			   SET @luniversalID = NULL ;
			END

		     SET @lCodeId = 0 

		     SELECT @lCodeId = GEN.Code.OrderID 
		     FROM GEN.Code 
		     WHERE GEN.Code.ID = CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet,'_',@lFcode)

		     PRINT CONCAT('Test Code for:', @lFilterValueSet, '_', @lFilterJSONValueSet,'_',@lFcode)

		     IF @lCodeId = 0

			BEGIN 

			   IF @pTraceMode > 0
			      INSERT INTO [LOG].[SysLog]
				 (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
			      VALUES	
				 (USER_NAME(), @lModuleName, @lDebugLevel, 
				    CONCAT('Code inserted for ', @lFormValueSet, '_', @lFilterJSONValueSet,'_',@lFcode), 
				    CAST(getdate() AS DATE), CAST(getdate() AS TIME))

			   SET @lValueSetId = 0

			   SELECT @lValueSetId = [GEN].[ValueSet].ID
			   FROM [GEN].[ValueSet]
			   WHERE [GEN].[ValueSet].CodePrefix = @lFormValueSet

			   INSERT INTO [GEN].[Code]
			      (ID, ValueSetID, CreationDate, CreationTime, ValidFrom)
			   VALUES 
			      (CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet,'_',@lFcode), @lValueSetId, 
				 CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), CAST(GETDATE() AS DATE))

			   PRINT 'GEN.Code entry inserted'

			END -- @lCodeId = 0

		     -- Create MIS.Filter entry

		     INSERT INTO [MIS].[Filter]
			(SQLText, CreationDate, CreationTime, Code, valueSetID, 
			      ObjectID)
		     VALUES
			(@lFilterSqlstatement, CAST(GETDATE() AS DATE), 
			   CAST(GETDATE() AS TIME), CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet,'_',@lFcode), 
			   @lValueSetId, @luniversalID) ;

		     SET @lFilterId = @@IDENTITY 

		  END -- @lFilterId = 0 
-- /*		  
-- 	       ELSE
--		  BEGIN 
--		  END -- FIXME update!!
-- */
	       PRINT 'MIS.Filter   ok'
	      
	       -- Create Object for the MIS.FormFilter

	       SET @luniversalID = 0 

	       INSERT INTO [GEN].[Object]
	          (ObjectType, CreationDate, CreationTime,  Comments, VersionNr)
	       VALUES
		  ('MIS.FormFilter', CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), @lObjectComment, @lObjectVersion)

	       PRINT 'FormFilter object OK'

	       SET @luniversalID = @@IDENTITY

	       IF @luniversalID = 0
		  BEGIN

		     INSERT INTO [LOG].[SysLog]
			(UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		     VALUES	
			(USER_NAME(), @lModuleName, @lErrorLevel, 'Object for MIS.FormFilter set to NULL.', 
			CAST(getdate() AS DATE), CAST(getdate() AS TIME))

		     SET @luniversalID = NULL ;
		  END		  

	       -- Check Code 

		  SET @lCodeId = 0 

		  SELECT @lCodeId = GEN.Code.OrderID 
		  FROM GEN.Code 
		  WHERE GEN.Code.ID = CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet,'_',@lFcode)


		  PRINT CONCAT('Recheck Code for:', @lFilterValueSet, '_', @lFilterJSONValueSet,'_',@lFcode)

		  IF @lCodeId = 0

		     BEGIN 

			PRINT 'Insert new'

			IF @pTraceMode > 0
			   INSERT INTO [LOG].[SysLog]
			   (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
			   VALUES	
			      (USER_NAME(), @lModuleName, @lDebugLevel, 
				 CONCAT('Code inserted for ', @lFormValueSet, '_', @lFormCode), 
				 CAST(getdate() AS DATE), CAST(getdate() AS TIME))

			SET @lValueSetId = 0

			SELECT @lValueSetId = [GEN].[ValueSet].ID
			FROM [GEN].[ValueSet]
			WHERE [GEN].[ValueSet].CodePrefix = CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet)

			INSERT INTO [GEN].[Code]
			   (ID, ValueSetID, CreationDate, CreationTime, ValidFrom)
			VALUES 
			   (CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet,'_',@lFcode), @lValueSetId, 
			      CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), CAST(GETDATE() AS DATE))

		     END -- @lCodeId = 0
		  
	       -- Create the MIS.FormFilter entry

	       INSERT INTO [MIS].[FormFilter]
		  (FormID, FilterID, CreationDate, CreationTime, IconName, SQLText, 
		     DefaultType, OrdNr, DefaultValue, ObjectID, Code)
	       VALUES 
		  (@lFormId, @lFilterId, CAST(GETDATE() AS DATE), 
		     CAST(GETDATE() AS TIME), @lFilterIconName, @lFilterSqlstatement, 
		     @lFilterDefType, @lordNr, @lFilterDefValue, @luniversalID, 
		     CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet,'_',@lFcode))

	       SET @lFormFilterID = @@IDENTITY

	       PRINT 'MIS.FormFilter created'	       

	       TRUNCATE TABLE TMP.Translations
	    
	       INSERT INTO TMP.Translations
		  (TransCountry, TransText)
	       SELECT UPPER(TransCountry), TransText
	       FROM OPENJSON(@lTranslationsJSON)
	       WITH
		  (
		     TransCountry   NVARCHAR(5)    '$.country',
		     TransText      NVARCHAR(200)  '$.text'
		  )

	       PRINT 'FormFilter translations vector created'

	       PRINT @lTranslationsJSON

   	       SELECT @ltranslationIndex = (MIN(TransID) - 1)
	       FROM TMP.Translations  

	       PRINT CONCAT('Starting id = ',CAST(@ltranslationIndex AS NVARCHAR(10)))

	       SELECT  @lCursorStatus = COUNT(*)
	       FROM  TMP.Translations

	       PRINT CONCAT('Tabs table size = ', CAST(@lCursorStatus AS NVARCHAR(6)))

	       WHILE 1 = 1 
		  BEGIN

		     SELECT @lTransCountry = TransCountry, @lTransText = TransText
		     FROM  TMP.Translations
		     WHERE TransID = @ltranslationIndex + 1

		     IF @@ROWCOUNT = 0
			BREAK ;

		     SET @lSize = 0 

		     SELECT @lSize = COUNT(*)
		     FROM [GEN].[Translation]
		     WHERE GEN.Translation.CodeID = CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet, '_', @lFCode) 
			AND GEN.Translation.Language = @lTransCountry

		     IF @lSize = 0
			INSERT [GEN].[Translation]
			   (CodeID, Language, Text, CreationDate, CreationTime)
			VALUES
			   (CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet, '_', @lFCode), @lTransCountry, @lTransText, 
			      CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME))
		     ELSE 
			UPDATE [GEN].[Translation]
			   SET GEN.Translation.Text = @lTransText, GEN.Translation.LastModifiedDate = CAST(GETDATE() AS DATE), 
			      GEN.Translation.LastModifiedTime = CAST(GETDATE() AS TIME) 
			WHERE GEN.Translation.CodeID = CONCAT(@lFilterValueSet, '_', @lFilterJSONValueSet, '_', @lFCode) 
			   AND GEN.Translation.Language = @lTransCountry

		     SET @ltranslationIndex = @ltranslationIndex + 1 

		  END -- WHILE 1 = 1 

	       PRINT 'FomrFilter translations inserted'

-- Foldertree -- @lFilterRootId

	       TRUNCATE TABLE TMP.FolderTree 

	       INSERT INTO TMP.FolderTree
		  (FolderCode, IconName, Translations, SubFolderTree)
	       SELECT FolderCode, IconName, Translations, SubFolderTree
	       FROM OPENJSON(@lFilterFoldJSON)
		  WITH
		     (
			FolderCode     NVARCHAR(50)   '$.folder.code', 
			IconName       NVARCHAR(50)   '$.folder.iconName', 
			Translations   NVARCHAR(MAX)  '$.folder.translations'    AS JSON, 
			SubFolderTree  NVARCHAR(MAX)  '$.folder.folder'		 AS JSON
		     )             	    
-- There is only one record??

	       SET @lsubTreeDepth = 1

	       SELECT @lFolderCode = TMP.FolderTree.FolderCode 
	       FROM TMP.FolderTree 
	    
	       SELECT @lFolderIconName = TMP.FolderTree.IconName 
	       FROM TMP.FolderTree 

	       SELECT @lTranslationsJSON = TMP.FolderTree.Translations
	       FROM TMP.FolderTree	    

	       SELECT @lSubTreeJSON = TMP.FolderTree.SubFolderTree
	       FROM TMP.FolderTree	    

	       PRINT 'FoldertTree data extracted'

	       PRINT CONCAT('Tree depth = ', CAST(@lsubTreeDepth AS NVARCHAR(10)))

	       PRINT CONCAT('Code = ', @lFolderCode, ', Icon = ',@lFolderIconName )

	       PRINT '*****************************************************************'

	       IF @lSubTreeJSON IS NULL 
		  PRINT('No subtree')
	       ELSE
		  PRINT('SubTree defined')
	       PRINT '*****************************************************************'	       

	       -- Create Object for the MIS.Filter

	       SET @luniversalID = 0 ;

	       INSERT INTO [GEN].[Object]
		  (ObjectType, CreationDate, CreationTime,  Comments, VersionNr)
	       VALUES
		  ('MIS.Folder', CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), @lObjectComment, @lObjectVersion)

	       SET @luniversalID = @@IDENTITY ;

	       IF @luniversalID = 0
		  BEGIN

		     INSERT INTO [LOG].[SysLog]
			(UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		     VALUES	
			(USER_NAME(), @lModuleName, @lErrorLevel, 'Object for GEN.Folder set to NULL.', 
			CAST(getdate() AS DATE), CAST(getdate() AS TIME))

		     SET @luniversalID = NULL ;
		  END

	       -- Create Folder entry Topmost folder ha snot RootID nor ParentID

	       SELECT @lFilterRootId = GEN.RootFolder.ID 
		   FROM GEN.RootFolder
	       WHERE GEN.RootFolder.TableName = 'MIS.FormFilter' ;

	       -- Check Code

	       SET @lCodeId = 0 

	       PRINT CONCAT('Check folder code = ',@lFolderValueSet,'_',@lFolderCode)

	       SELECT @lCodeId = GEN.Code.OrderID 
	       FROM GEN.Code 
	       WHERE GEN.Code.ID = CONCAT(@lFolderValueSet,'_',@lFolderCode)

	       IF @lCodeId = 0
		  
		  BEGIN 

		     PRINT 'Insert Folder Code'

		     IF @pTraceMode > 0
			INSERT INTO [LOG].[SysLog]
			   (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
			VALUES	
			   (USER_NAME(), @lModuleName, @lDebugLevel, 
			      CONCAT('Code inserted for ', @lFolderValueSet,'_',@lFolderCode), 
			      CAST(getdate() AS DATE), CAST(getdate() AS TIME))

		     SET @lValueSetId = 0

		     SELECT @lValueSetId = [GEN].[ValueSet].ID
		     FROM [GEN].[ValueSet]
		     WHERE [GEN].[ValueSet].CodePrefix = @lFormValueSet

		     INSERT INTO [GEN].[Code]
			(ID, ValueSetID, CreationDate, CreationTime, ValidFrom)
		     VALUES 
			(CONCAT(@lFolderValueSet,'_',@lFolderCode), @lValueSetId, 
			   CAST(GETDATE() AS DATE), 
			   CAST(GETDATE() AS TIME), CAST(GETDATE() AS DATE))

		  END

	       INSERT INTO [GEN].[Folder]
		  (Code, CreationDate, CreationTime, ObjectID, IconName)
	       VALUES 
		  (CONCAT(@lFolderValueSet,'_',@lFolderCode), CAST(GETDATE() AS DATE), 
		  CAST(GETDATE() AS TIME), @luniversalID, @lFolderIconName) ;

	       SET @lFolderId = @@IDENTITY
   
	       PRINT 'Folder entry created'

	       TRUNCATE TABLE TMP.Translations

	       INSERT INTO TMP.Translations
		  (TransCountry, TransText)
	       SELECT UPPER(TransCountry), TransText
	       FROM OPENJSON(@lTranslationsJSON)
		  WITH
		     (
			TransCountry   NVARCHAR(5)    '$.country',
			TransText      NVARCHAR(200)  '$.text'
		     )

	       PRINT 'Folder translation data set created'

   	       SELECT @ltranslationIndex = (MIN(TransID) - 1)
	       FROM TMP.Translations  

	       PRINT CONCAT('Starting id = ',CAST(@ltranslationIndex AS NVARCHAR(10))) 

	       WHILE 1 = 1 
		  BEGIN

		     SELECT @lTransCountry = TransCountry, @lTransText = TransText
		     FROM  TMP.Translations
		     WHERE TransID = @ltranslationIndex + 1

		     IF @@ROWCOUNT = 0
			BREAK ;

		     SET @lSize = 0

	             SELECT @lSize = COUNT(*)
		     FROM [GEN].[Translation]
		     WHERE GEN.Translation.CodeID = CONCAT(@lFolderValueSet,'_',@lFolderCode) 
			AND GEN.Translation.Language = @lTransCountry 
		     
		     IF @lSize = 0
			INSERT INTO [GEN].[Translation]
			   (CodeID, Language, Text, CreationDate, CreationTime)
			VALUES
			   (CONCAT(@lFolderValueSet,'_',@lFolderCode), @lTransCountry, @lTransText, 
			      CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME))
		     ELSE 
			UPDATE [GEN].[Translation]
			   SET GEN.Translation.Text = @lTransText, GEN.Translation.LastModifiedDate = CAST(GETDATE() AS DATE), 
			      GEN.Translation.LastModifiedTime = CAST(GETDATE() AS TIME)
			WHERE GEN.Translation.CodeID = CONCAT(@lFolderValueSet,'_',@lFolderCode) 
			   AND GEN.Translation.Language = @lTransCountry 

		     SET @ltranslationIndex = @ltranslationIndex + 1

		  END -- WHILE 1 = 1
	       
	       PRINT 'Folder translation data set created'

	       WHILE @lSubTreeJSON IS NOT NULL
		  BEGIN

		     SET @lsubTreeDepth = @lsubTreeDepth + 1 ;

		     TRUNCATE TABLE TMP.SubTree

		     INSERT INTO TMP.SubTree
			(FolderCode, IconName, Translations, SubFolderTree)
		     SELECT FolderCode, IconName, Translations, SubFolderTree
		     FROM OPENJSON(@lSubTreeJSON)
			WITH
			   (
			      FolderCode     NVARCHAR(50)   '$.code', 
			      IconName	     NVARCHAR(50)   '$.iconName', 
			      Translations   NVARCHAR(MAX)  '$.translations'  as JSON, 
			      SubFolderTree  NVARCHAR(MAX)  '$.folder'	      as JSON
			   )

		     SELECT @lFolderCode = MIS.FolderTree.FolderCode 
		     FROM MIS.SubTree 
	    
		     SELECT @lFolderIconName = MIS.FolderTree.IconName 
		     FROM MIS.SubTree 

		     SELECT @lTranslationsJSON = MIS.FolderTree.Translations
		     FROM MIS.SubTree	    

		     SELECT @lSubTreeJSON = MIS.FolderTree.SubFolderTree
		     FROM MIS.SubTree	    			

		     SET @luniversalID = 0 ;

		     INSERT INTO [GEN].[Object]
			(ObjectType, CreationDate, CreationTime,  Comments, VersionNr)
		     VALUES
			('MIS.Folder', CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), @lObjectComment, @lObjectVersion)

		     SET @luniversalID = @@IDENTITY

		     IF @luniversalID = 0
			BEGIN

			   INSERT INTO [LOG].[SysLog]
			      (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
			   VALUES	
			      (USER_NAME(), @lModuleName, @lErrorLevel, 'Object for GEN.Folder set to NULL.', 
				 CAST(getdate() AS DATE), CAST(getdate() AS TIME))

			   SET @luniversalID = NULL ;
			END

		     -- Check Code

		     SET @lCodeId = 0 

		     SELECT @lCodeId = GEN.Code.OrderID 
		     FROM GEN.Code 
		     WHERE GEN.Code.ID = CONCAT(@lFolderValueSet,'_',@lFolderCode)

		     IF @lCodeId = 0
			BEGIN

			   IF @pTraceMode > 0

			      INSERT INTO [LOG].[SysLog]
				 (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
			      VALUES	
				 (USER_NAME(), @lModuleName, @lDebugLevel, 
				    CONCAT('Code inserted for ', @lFolderValueSet,'_',@lFolderCode), 
				    CAST(getdate() AS DATE), CAST(getdate() AS TIME))

			   SET @lValueSetId = 0

			   SELECT @lValueSetId = [GEN].[ValueSet].ID
			   FROM [GEN].[ValueSet]
			   WHERE [GEN].[ValueSet].CodePrefix = @lFormValueSet

			   INSERT INTO [GEN].[Code]
			      (ID, ValueSetID, CreationDate, CreationTime, ValidFrom)
			   VALUES 
			      (CONCAT(@lFolderValueSet,'_',@lFolderCode), @lValueSetId, CAST(GETDATE() AS DATE), 
				 CAST(GETDATE() AS TIME), CAST(GETDATE() AS DATE))

			END -- @lCodeId = 0
		  

		     -- Create Folder entry

		     INSERT INTO [GEN].[Folder]
			(Code, CreationDate, CreationTime, ObjectID, IconName, ParentFolderID)
		     VALUES 
			(CONCAT(@lFolderValueSet,'_',@lFolderCode), CAST(GETDATE() AS DATE), 
			   CAST(GETDATE() AS TIME), @luniversalID, @lFolderIconName, @lFolderId) ;

		     SET @lFolderId = @@IDENTITY

		     TRUNCATE TABLE TMP.Translations

		     INSERT INTO TMP.Translations
			(TransCountry, TransText)
		     SELECT UPPER(TransCountry), TransText
		     FROM OPENJSON(@lTranslationsJSON)
			WITH
			   (
			      TransCountry   NVARCHAR(5)    '$.country',
			      TransText      NVARCHAR(200)  '$.text'
			   )

		     SELECT @ltranslationIndex = (MIN(TransID) - 1)
		     FROM TMP.Translations  

		     PRINT CONCAT('Starting id = ',CAST(@ltranslationIndex AS NVARCHAR(10))) 

		     WHILE 1 = 1 
			BEGIN

			   SELECT @lTransCountry = TransCountry, @lTransText = TransText
			   FROM  TMP.Translations
			   WHERE TransID = @ltranslationIndex + 1

			   IF @@ROWCOUNT = 0
			      BREAK ;

			   SET @lSize = 0

			   SELECT @lSize = COUNT(*)
			   FROM [GEN].[Translation]
			   WHERE GEN.Translation.CodeID = CONCAT(@lFolderValueSet,'_',@lFolderCode) 
			      AND GEN.Translation.Language = @lTransCountry 
		     
			   IF @lSize = 0
			      INSERT INTO [GEN].[Translation]
				 (CodeID, Language, Text, CreationDate, CreationTime)
			      VALUES
				 (CONCAT(@lFolderValueSet,'_',@lFolderCode), @lTransCountry, @lTransText, 
				    CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME))
			   ELSE 
			      UPDATE [GEN].[Translation]
				 SET GEN.Translation.Text = @lTransText, 
				    GEN.Translation.LastModifiedDate = CAST(GETDATE() AS DATE), 
				    GEN.Translation.LastModifiedTime = CAST(GETDATE() AS TIME)
			      WHERE GEN.Translation.CodeID = CONCAT(@lFolderValueSet,'_',@lFolderCode) 
				 AND GEN.Translation.Language = @lTransCountry 

			   SET @ltranslationIndex =@ltranslationIndex + 1				 

			END -- WHILE 1 = 1

		  END -- @lSubTreeJSON IS NOT NULL

		  UPDATE MIS.FormFilter 
		  SET MIS.FormFilter.FolderID = @lFolderId
		  WHERE MIS.FormFilter.ID = @lFormFilterID

	       FETCH NEXT FROM FilterCursor
	       INTO @lFCode, @lFilterJSONValueSet, @lFilterDefType, @lFilterDefValue, @lordNr, 
		  @lFilterIconName, @lFilterType, @lFilterSqlstatement, @lTranslationsJSON, 
		  @lFilterFoldJSON

	    END -- @@FETCH_STATUS = 0
	 
	 CLOSE FilterCursor
	 DEALLOCATE FilterCursor


      SET @lMainBlock = 0

      EXEC MIS.VirSubJSON @lFormId, @lRootFolderId, @lFormVersion, @pTraceMode, 
 	 @pErrCode = @lRes OUTPUT
	 
      COMMIT 

   END TRY

   BEGIN CATCH
      DECLARE @l_errorMessage NVARCHAR(200) 
      DECLARE @l_errorSeverity INT 
      DECLARE @l_errorState INT
      DECLARE @l_errorLine INT 
  
      SELECT @l_errorMessage = ERROR_MESSAGE(),  
	    @l_errorSeverity = ERROR_SEVERITY(),  
	    @l_errorState = ERROR_STATE(), 
	    @l_errorLine = ERROR_LINE() 

      IF @lProcPhase = 1 AND @lMainBlock = 1
	 ROLLBACK

      INSERT INTO [LOG].[SysLog]
		(UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	VALUES	
		(USER_NAME(), CONCAT(@lModuleName, ' line = ', CAST(@l_errorLine AS VARCHAR(10))),
		  @l_errorSeverity, @l_errorMessage,
			CAST(getdate() AS DATE), CAST(getdate() AS TIME))

      RAISERROR (@l_errorMessage, @l_errorSeverity, @l_errorState )
   END CATCH
   
END
go



-- TODO comments
-- ==================================================
-- Author:		GURBAN
-- Create date: 2022.08.08
-- Description:	Importing JSON data to the MIS 
--    sysytem in tables MIS.FormColumn, MIS.FormAction
--    and GEN.Folder.
-- Arguments:--    @pMISFormID	-- the ID of the created MIS.Form 
--			      entry in the main procedure
--    @pMISRootFolderID -- the ID of the GEN.RootFolder 
--			      entry to be used.
--    @pMISVersion	-- the version of MIS extracted 
--			      from JSON input
--    @pTraceMode    -- the flag cotrolling tracing
--	 0     -  production tracing, logging the most relevant 
--		  information goes into the log only (defaul)
--	 > 0   -  debug tracing, all information goes into the log.
-- ===================================================

CREATE   PROCEDURE [MIS].[VirSubJSON]
(
   @pMISFormID	     NUMERIC(16,0), 
   @pMISRootFolderID NUMERIC(16,0), 
   @pMISVersion	     NVARCHAR(50), 
   @pTraceMode	     INT = 0 ,
   @pErrCode	     INT    OUTPUT
)

AS 
BEGIN

   DECLARE @lRes		 INT ; -- Result code of the procedure
   DECLARE @lsubTreeDepth	 INT ;      
   DECLARE @ltranslationIndex	 INT 
   DECLARE @lFilterIndex	 INT
   DECLARE @lCursorStatus	 INT
   
   DECLARE @lSize		 NUMERIC(16,0) ;
   DECLARE @luniversalID	 NUMERIC(16,0) ;
   DECLARE @lDisplayWidth	 NUMERIC(16,0) ;      
   DECLARE @lordNr		 NUMERIC(16,0) ;
   DECLARE @lFolderID		 NUMERIC(16,0) ;
   DECLARE @lErrorLevel		 NUMERIC(2,0) ;
   DECLARE @lDebugLevel		 NUMERIC(2,0) ;
   DECLARE @lCodeId		 NUMERIC(16,0)
   DECLARE @lValueSetId		 NUMERIC(16,0)

   -- Common comment for the GEN.Object table
   DECLARE @lObjectComment	 NVARCHAR(50) ;    
   DECLARE @lObjectVersion	 NVARCHAR(50) 

   DECLARE @lColumnJSON		 NVARCHAR(MAX) ;
   DECLARE @lActionJSON		 NVARCHAR(MAX) ;
   DECLARE @lColTransJSON	 NVARCHAR(MAX) ;
   DECLARE @lActionTransJSON	 NVARCHAR(MAX) ;
   DECLARE @lFolderTreeJSON	 NVARCHAR(MAX) ;
   DECLARE @lTranslationsJSON	 NVARCHAR(MAX)
   DECLARE @lSubTreeJSON	 NVARCHAR(MAX)

   DECLARE @lFCode		 NVARCHAR(50) ;
   DECLARE @lAlignment		 NVARCHAR(50) ;
   DECLARE @lFormatMask		 NVARCHAR(50) ;
   DECLARE @lArea		 NVARCHAR(50) ;
   DECLARE @lAllowedArea	 NVARCHAR(50) ;
   DECLARE @lColumnVisible	 NVARCHAR(50) ;
   DECLARE @lDefaultAction	 NVARCHAR(50) ;
   DECLARE @lActionComnName	 NVARCHAR(50) ;
   DECLARE @lFunctionName	 NVARCHAR(50) ;
   DECLARE @lFolderCode		 NVARCHAR(50) ;
   DECLARE @lFolderIconName	 NVARCHAR(50) ;

   DECLARE @lTransCountry	 NVARCHAR(5) ;
   DECLARE @lTransText		 NVARCHAR(200) ;

   DECLARE @lModuleName		 NVARCHAR(50) ;
   DECLARE @lModuleVersion	 NVARCHAR(50) ;

   DECLARE @lColumnValueSet	 NVARCHAR(200)
   DECLARE @lActionValueSet	 NVARCHAR(200)
   DECLARE @lFolderValueSet	 NVARCHAR(200)

   DECLARE @lTransactCount	 BIT

-- Cursors

   SELECT @lCursorStatus = CURSOR_STATUS('global','columnCursor')
   IF @lCursorStatus = -3
      DECLARE columnCursor CURSOR FOR
	 SELECT FCode, CAST(DisplayWidth AS NUMERIC(16,0)), Alignment, 
	 FormatMask, CAST(ordNr AS NUMERIC(16,0)), Area, AllowedArea, ColumnVisible, 
	 CTranslations
	 FROM TMP.ColumnVector ;

   SELECT @lCursorStatus = CURSOR_STATUS('global','ActionCursor')
   IF @lCursorStatus = -3
      DECLARE ActionCursor CURSOR FOR
	 SELECT ACode, DefaultAction, ColumnName, ATranslations
	 FROM TMP.ActionVector ;

-- Only if more SubTree is coded in the JSON input
   SELECT @lCursorStatus = CURSOR_STATUS('global','SubTreeCursor')
   IF @lCursorStatus = -3
      DECLARE SubTreeCursor CURSOR FOR
	 SELECT UPPER(FolderCode), IconName, Translations, SubFolderTree
	 FROM TMP.SubTree ;

   SET @lRes = 0 ; 
   SET @lObjectComment = 'MIS JSON data loader' ;
   SET @lTransactCount = 0 -- Setting up the transaction handling

   -- For logging   
   SET @lModuleName = 'MIS.VirSubJSON' ;
   SET @lModuleVersion = 'Ver 0.3.1a' ;   
   SET @lObjectVersion = '1.0'   
   SET @lErrorLevel = 7 ;
   SET @lDebugLevel = 3 ;
   SET @lObjectComment = 'MIS JSON data loader'

-- For TEST!!

   SET @lColumnValueSet = 'MISFORM_COLUMN'
   SET @lActionValueSet = 'MISFORM_ACTION'
   SET @lFolderValueSet = 'FOLDERNAME'


   INSERT INTO [LOG].[SysLog]
      (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
   VALUES	
      (USER_NAME(), @lModuleName, @lDebugLevel, CONCAT('Procedure start, ',@lModuleVersion), 
	 CAST(getdate() AS DATE), CAST(getdate() AS TIME))

   BEGIN TRY

------------------------------------
      -- MIS.FormColumn
------------------------------------
-- FIXME existing rekords

      IF @lTransactCount = 0
	 BEGIN
	    PRINT 'TRansaction crated'
	    BEGIN TRANSACTION
	    SET @lTransactCount = 1
	 END
      ELSE 
	 SAVE TRANSACTION LoopTrans	 

      PRINT 'Subprocess started'

      SELECT @lColumnJSON = MIS.VirImport.ColumnVector 
      FROM MIS.VirImport ;

      TRUNCATE TABLE TMP.ColumnVector

      INSERT INTO TMP.ColumnVector
	 (FCode, DisplayWidth, Alignment, FormatMask, ordNr, Area, AllowedArea, 
	 ColumnVisible, CTranslations)
      SELECT FCode, DisplayWidth, Alignment, FormatMask, ordNr, Area, AllowedArea, 
	 ColumnVisible, CTranslations
      FROM OPENJSON(@lColumnJSON)
	 WITH
	    (
	       FCode	      NVARCHAR(50)	'$.code', 
	       DisplayWidth   INT		'$.displayWidth', 
	       Alignment      NVARCHAR(50)	'$.alignment', 
	       FormatMask     NVARCHAR(50)	'$.formatMask', 
	       ordNr	      INT		'$.ordNr', 
	       Area	      NVARCHAR(50)	'$.area', 
	       AllowedArea    NVARCHAR(50)	'$.allowedArea', 
	       ColumnVisible  NVARCHAR(50)	'$.columnVisible', 
	       CTranslations  NVARCHAR(MAX)	'$.translations'     AS JSON
	    )

      PRINT 'ColumnVector generated'

      OPEN ColumnCursor

      FETCH NEXT FROM ColumnCursor 
      INTO @lFCode, @lDisplayWidth, @lAlignment, @lFormatMask, @lordNr, 
	 @lArea, @lAllowedArea, @lColumnVisible, @lColTransJSON

      WHILE @@FETCH_STATUS = 0 
	 BEGIN

	    -- Create Object for the MIS.FormColumn

	    SET @luniversalID = 0 ;

	    INSERT INTO [GEN].[Object]
	       (ObjectType, CreationDate, CreationTime,  Comments, VersionNr)
	    VALUES
	       ('MIS.FormColumn', CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), @lObjectComment, @lObjectVersion)

	    SET @luniversalID = @@IDENTITY

	    IF @luniversalID = 0
	       BEGIN

		  INSERT INTO [LOG].[SysLog]
		     (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		  VALUES	
		     (USER_NAME(), @lModuleName, @lErrorLevel, 'Object for MIS.FormColumn set to NULL.', 
			CAST(getdate() AS DATE), CAST(getdate() AS TIME))

		  SET @luniversalID = NULL ;
	       END

	    -- Check Code

	    SET @lCodeId = 0 

	    SELECT @lCodeId = GEN.Code.OrderID 
	    FROM GEN.Code 
	    WHERE GEN.Code.ID = CONCAT(@lColumnValueSet,'_',@lFCode)

	    IF @lCodeId = 0
		  
	       BEGIN

		  IF @pTraceMode > 0
		     INSERT INTO [LOG].[SysLog]
			(UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		     VALUES	
			(USER_NAME(), @lModuleName, @lDebugLevel, 
			   CONCAT('Code inserted for ', @lColumnValueSet,'_',@lFCode), 
			   CAST(getdate() AS DATE), CAST(getdate() AS TIME))

		  SET @lValueSetId = 0

		  SELECT @lValueSetId = [GEN].[ValueSet].ID
		  FROM [GEN].[ValueSet]
		  WHERE [GEN].[ValueSet].CodePrefix = @lColumnValueSet

		  INSERT INTO [GEN].[Code]
		     (ID, ValueSetID, CreationDate, CreationTime, ValidFrom)
		  VALUES 
		     (CONCAT(@lColumnValueSet,'_',@lFCode), @lValueSetId, CAST(GETDATE() AS DATE), 
			CAST(GETDATE() AS TIME), CAST(GETDATE() AS DATE))

	       END -- @lCodeId = 0

	    -- Create the MIS.FormColumn entry

	    INSERT INTO [MIS].[FormColumn]
	       (FormID, ColumnName, DisplayWidth, Alignment, FormatMask, OrdNr, Area, 
		  AllowedArea, ColumnVisible,CreationDate,CreationTime, ObjectID)
	    VALUES
	       (@pMISFormID, CONCAT(@lColumnValueSet,'_',@lFCode), @lDisplayWidth, @lAlignment, 
		  @lFormatMask, CAST(@lordNr AS NUMERIC(16,0)), @lArea, @lAllowedArea, 
		  @lColumnVisible, CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), 
		  @luniversalID) ;
	      
	    TRUNCATE TABLE TMP.Translations

	    INSERT INTO TMP.Translations
	       (TransCountry, TransText)
	    SELECT UPPER(TransCountry), TransText
	    FROM OPENJSON(@lColTransJSON)
	       WITH
		  (
		     TransCountry   NVARCHAR(5)    '$.country',
		     TransText      NVARCHAR(200)  '$.text'
		  )

	    PRINT 'FormColumn translation vector stated'
	    
   	    SELECT @ltranslationIndex = (MAX(TransID) - 1)
	    FROM TMP.Translations 

	    PRINT CONCAT('Starting id = ',CAST(@ltranslationIndex AS NVARCHAR(10))) 

	    WHILE 1 = 1 
	       BEGIN
		  
		  SELECT @lTransCountry = TransCountry, @lTransText = TransText
		  FROM  TMP.Translations
		  WHERE TransID = @ltranslationIndex + 1

		  IF @@ROWCOUNT = 0
		     BREAK ;

		  SET @lSize = 0

		  SELECT @lSize = COUNT(*)
		  FROM [GEN].[Translation]
		  WHERE GEN.Translation.CodeID = CONCAT(@lColumnValueSet,'_',@lFCode) 
		     AND GEN.Translation.Language = @lTransCountry

		  IF @lSize = 0

		     INSERT [GEN].[Translation]
			(CodeID, Language, Text, CreationDate, CreationTime)
		     VALUES
			(CONCAT(@lColumnValueSet,'_',@lFCode), @lTransCountry, @lTransText, 
			CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME))			
		  ELSE
		     UPDATE [GEN].[Translation]
			SET GEN.Translation.Text = @lTransText, GEN.Translation.LastModifiedDate = CAST(GETDATE() AS DATE), 
			   GEN.Translation.LastModifiedTime = CAST(GETDATE() AS TIME)			
		     WHERE GEN.Translation.CodeID = CONCAT(@lColumnValueSet,'_',@lFCode) 
			AND GEN.Translation.Language = @lTransCountry

		  SET @ltranslationIndex = @ltranslationIndex + 1

	       END -- WHILE 1 = 1

	    PRINT 'FormColumn translation vector done'

	    FETCH NEXT FROM ColumnCursor 
	    INTO @lFCode, @lDisplayWidth, @lAlignment, @lFormatMask, @lordNr, @lArea, 
	       @lAllowedArea, @lColumnVisible, @lColTransJSON
	 END

      CLOSE ColumnCursor 
      DEALLOCATE ColumnCursor
      
      PRINT 'Column vector processed'

------------------------------------
-- MIS.ActionVector
------------------------------------

      SELECT @lActionJSON = MIS.VirImport.ActionVector 
      FROM MIS.VirImport ;

      TRUNCATE TABLE TMP.ActionVector

      INSERT INTO TMP.ActionVector
	 ( ACode, DefaultAction, ColumnName, ATranslations)
      SELECT ACode, DefaultAction, ColumnName, ATranslations
      FROM OPENJSON(@lActionJSON)
      WITH
	 (
	    ACode	   NVARCHAR(50)	     '$.code',
	    DefaultAction  NVARCHAR(50)	     '$.defaultAction',
	    ColumnName	   NVARCHAR(50)	     '$.columnName',
	    ATranslations  NVARCHAR(MAX)     '$.translations'	  AS     JSON
	 )

      PRINT 'Action data set opened'

      OPEN ActionCursor 

      FETCH NEXT FROM ActionCursor
      INTO @lFunctionName, @lDefaultAction, @lActionComnName, @lActionTransJSON

      WHILE @@FETCH_STATUS = 0 
	 BEGIN
	    -- ActionColumn

	    -- Create Object for the MIS.FormAction

	    SET @luniversalID = 0 ;

	    INSERT INTO [GEN].[Object]
	       (ObjectType, CreationDate, CreationTime,  Comments, VersionNr)
	    VALUES
	       ('MIS.FormAction', CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), @lObjectComment, @lObjectVersion)

	    SET @luniversalID = @@IDENTITY

	    IF @luniversalID = 0
	       BEGIN

		  INSERT INTO [LOG].[SysLog]
		     (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		  VALUES	
		     (USER_NAME(), @lModuleName, @lErrorLevel, 'Object for MIS.FormAction set to NULL.', 
			CAST(getdate() AS DATE), CAST(getdate() AS TIME))

		  SET @luniversalID = NULL ;
	       END	       

	    -- Check Code

	    SET @lCodeId = 0 

	    SELECT @lCodeId = GEN.Code.OrderID 
	    FROM GEN.Code 
	    WHERE GEN.Code.ID = CONCAT(@lActionValueSet, '_', @lFunctionName)

	    IF @lCodeId = 0
		 
	       BEGIN

		  IF @pTraceMode > 0
		     INSERT INTO [LOG].[SysLog]
			(UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		     VALUES	
			(USER_NAME(), @lModuleName, @lDebugLevel, 
			   CONCAT('Code inserted for ', @lActionValueSet, '_', @lFunctionName), 
			   CAST(getdate() AS DATE), CAST(getdate() AS TIME))

		     SET @lValueSetId = 0

		     SELECT @lValueSetId = [GEN].[ValueSet].ID
		     FROM [GEN].[ValueSet]
		     WHERE [GEN].[ValueSet].CodePrefix = @lColumnValueSet

		     INSERT INTO [GEN].[Code]
			(ID, ValueSetID, CreationDate, CreationTime, ValidFrom)
		     VALUES 
			(CONCAT(@lActionValueSet, '_', @lFunctionName), @lValueSetId, CAST(GETDATE() AS DATE), 
			CAST(GETDATE() AS TIME), CAST(GETDATE() AS DATE))

	       END -- @lCodeId = 0

	    -- Create the MIS.FormAction entry

	    INSERT INTO [MIS].[FormAction]
	       (FormID, FunctionName,DefaultAction,ColumnName,CreationDate, CreationTime, 
		  ObjectID)
	       VALUES
		  (@pMISFormID, CONCAT(@lActionValueSet, '_', @lFunctionName),
		     @lDefaultAction,@lActionComnName, CAST(GETDATE() AS DATE), 
		     CAST(GETDATE() AS TIME), @luniversalID) ;

	    TRUNCATE TABLE TMP.Translations

	    INSERT INTO TMP.Translations
	       (TransCountry, TransText)
	    SELECT UPPER(TransCountry), TransText
	    FROM OPENJSON(@lActionTransJSON)
	       WITH
		  (
		     TransCountry   NVARCHAR(5)    '$.country',
		     TransText      NVARCHAR(200)  '$.text'
		  )	 

	    PRINT 'FormAction translation vector generated and started'

	    SELECT @ltranslationIndex = (MAX(TransID) - 1)
	    FROM TMP.Translations 

	    PRINT CONCAT('Starting id = ',CAST(@ltranslationIndex AS NVARCHAR(10)))

	    WHILE 1 = 1 
	       BEGIN

		  SELECT @lTransCountry = TransCountry, @lTransText = TransText
		  FROM  TMP.Translations
		  WHERE TransID = @ltranslationIndex + 1

		  IF @@ROWCOUNT = 0
		     BREAK ;
		  SET @lSize = 0

		  SELECT @lSize = COUNT(*)
		  FROM [GEN].[Translation]
		  WHERE GEN.Translation.CodeID = CONCAT(@lActionValueSet, '_', @lFunctionName)
		     AND GEN.Translation.Language = @lTransCountry		  

		  IF @lSize = 0
		     INSERT [GEN].[Translation]
			(CodeID, Language, Text, CreationDate, CreationTime)
		     VALUES
			(CONCAT(@lActionValueSet, '_', @lFunctionName), @lTransCountry, @lTransText, 
			   CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME))
		  ELSE 
		     UPDATE [GEN].[Translation]
			SET GEN.Translation.Text = @lTransText, GEN.Translation.LastModifiedDate = CAST(GETDATE() AS DATE), 
			GEN.Translation.LastModifiedTime = CAST(GETDATE() AS TIME)				   
		     WHERE GEN.Translation.CodeID = CONCAT(@lActionValueSet, '_', @lFunctionName)
			AND GEN.Translation.Language = @lTransCountry		  

		  SET @ltranslationIndex = @ltranslationIndex + 1
		  
	    END -- WHILE 1 = 1 

	    FETCH NEXT FROM ActionCursor
	    INTO @lFunctionName, @lDefaultAction, @lActionComnName, @lActionTransJSON
	 END

      CLOSE ActionCursor
      DEALLOCATE ActionCursor

      -- FolderTree

      -- Processing the topmost folder connected to the MIS.Form entry.
      SET @lsubTreeDepth = 1 ;

      SET @lFolderID = 0 

      SELECT @lFolderID = MIS.Form.FolderID
      FROM MIS.Form
      WHERE MIS.Form.ID = @pMISFormID
	    
      IF @lFolderID = 0
	 RAISERROR('MIS.Form entry lost during load!', 16, 1)

      SET @lFolderTreeJSON = N' '

      SELECT @lFolderTreeJSON = MIS.VirImport.FolderTree
      FROM MIS.VirImport ;

      IF @lFolderTreeJSON = N' '
	 RAISERROR('MIS.Viromport FolderTree lost during load!', 16, 1)

      TRUNCATE TABLE TMP.FolderTree

      INSERT INTO TMP.FolderTree
	 (FolderCode, IconName, Translations, SubFolderTree)
      SELECT FolderCode, IconName, Translations, SubFolderTree
      FROM OPENJSON(@lFolderTreeJSON)
      WITH
	 (
	    FolderCode     NVARCHAR(50)   '$.folder.code', 
	    IconName	   NVARCHAR(50)   '$.folder.iconName', 
	    Translations   NVARCHAR(MAX)  '$.folder.translations'    AS JSON, 
	    SubFolderTree  NVARCHAR(MAX)  '$.folder.folder'	     AS JSON
	 )             	    
-- There is only one record??

      SELECT @lFolderCode = TMP.FolderTree.FolderCode 
      FROM TMP.FolderTree 
	    
      SELECT @lFolderIconName = TMP.FolderTree.IconName 
      FROM TMP.FolderTree 

      SELECT @lTranslationsJSON = TMP.FolderTree.Translations
      FROM TMP.FolderTree	    

      SELECT @lSubTreeJSON = TMP.FolderTree.SubFolderTree
      FROM TMP.FolderTree

      PRINT 'FoldertTree data extracted'

      PRINT CONCAT('Tree depth = ', CAST(@lsubTreeDepth AS NVARCHAR(10)))

      PRINT CONCAT('Code = ', @lFolderCode, ', Icon = ',@lFolderIconName )      

      PRINT '*****************************************************************'

      IF @lSubTreeJSON IS NULL 
	 PRINT('No subtree')
      ELSE
	 PRINT('SubTree defined')
      PRINT '*****************************************************************'	       

      -- Create Object for the Folder



      SET @luniversalID = 0 ;

      INSERT INTO [GEN].[Object]
	 (ObjectType, CreationDate, CreationTime,  Comments, VersionNr)
      VALUES
	 ('MIS.Folder', CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), @lObjectComment, @lObjectVersion)

      SET @luniversalID = @@IDENTITY

      IF @luniversalID = 0
	 BEGIN

	    INSERT INTO [LOG].[SysLog]
	       (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	    VALUES	
	       (USER_NAME(), @lModuleName, @lErrorLevel, 'Object for GEN.Folder set to NULL.', 
		  CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	    SET @luniversalID = NULL ;

	    PRINT 'No object for Mis Folder'
	 END

      -- Create Folder entry

      SET @lCodeId = 0 

      SELECT @lCodeId = GEN.Code.OrderID 
      FROM GEN.Code 
      WHERE GEN.Code.ID = CONCAT(@lFolderValueSet, '_', @lFolderCode)

      IF @lCodeId = 0 
	 BEGIN

	    IF @pTraceMode > 0
	       INSERT INTO [LOG].[SysLog]
		  (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
	       VALUES	
		  (USER_NAME(), @lModuleName, @lDebugLevel, 
		     CONCAT('Code inserted for ', @lFolderValueSet, '_', @lFolderCode), 
		     CAST(getdate() AS DATE), CAST(getdate() AS TIME))

	       SET @lValueSetId = 0

	       SELECT @lValueSetId = [GEN].[ValueSet].ID
	       FROM [GEN].[ValueSet]
	       WHERE [GEN].[ValueSet].CodePrefix = @lFolderValueSet

	       PRINT 'Code inseerted from MIS.Folder'

	       INSERT INTO [GEN].[Code]
		  (ID, ValueSetID, CreationDate, CreationTime, ValidFrom)
	       VALUES 
		  (CONCAT(@lFolderValueSet, '_', @lFolderCode), @lValueSetId, CAST(GETDATE() AS DATE), 
		     CAST(GETDATE() AS TIME), CAST(GETDATE() AS DATE))

	 END -- @lCodeId = 0 

      INSERT INTO [GEN].[Folder]
	 (RootFolderID, Code, CreationDate, CreationTime, ObjectID)
      VALUES 
	 (@pMISRootFolderID, CONCAT(@lFolderValueSet, '_', @lFolderCode), CAST(GETDATE() AS DATE), 
	    CAST(GETDATE() AS TIME), @luniversalID) ;

	 SET @lFolderId = @@IDENTITY

      TRUNCATE  TABLE TMP.Translations

      INSERT INTO TMP.Translations
	 (TransCountry, TransText)
      SELECT UPPER(TransCountry), TransText
      FROM OPENJSON(@lTranslationsJSON)
      WITH
	 (
	    TransCountry   NVARCHAR(5)    '$.country',
	    TransText      NVARCHAR(200)  '$.text'
	 )

      PRINT 'Folder trans;ation started again'

      SELECT @ltranslationIndex = (MAX(TransID) - 1)
      FROM TMP.Translations 

      PRINT CONCAT('Starting id = ',CAST(@ltranslationIndex AS NVARCHAR(10)))

      WHILE 1 = 1 
	 BEGIN

	    SELECT @lTransCountry = TransCountry, @lTransText = TransText
	    FROM  TMP.Translations
	    WHERE TransID = @ltranslationIndex + 1

	    PRINT CONCAT('RowCount = ', CAST(@@ROWCOUNT AS NVARCHAR(10)))

	    IF @@ROWCOUNT = 0
	       BREAK ;

	    SET @lSize = 0

	    SELECT @lSize = COUNT(*)
	    FROM [GEN].[Translation]
	    WHERE GEN.Translation.CodeID = CONCAT(@lFolderValueSet, '_', @lFolderCode) 
	       AND GEN.Translation.Language = @lTransCountry 
		     
	    IF @lSize = 0
	       INSERT INTO [GEN].[Translation]
		  (CodeID, Language, Text, CreationDate, CreationTime)
	       VALUES
		  (CONCAT(@lFolderValueSet, '_', @lFolderCode), @lTransCountry, @lTransText, 
		     CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME))
	    ELSE 
	       UPDATE [GEN].[Translation]
		  SET GEN.Translation.Text = @lTransText, GEN.Translation.LastModifiedDate = CAST(GETDATE() AS DATE), 
		     GEN.Translation.LastModifiedTime = CAST(GETDATE() AS TIME)
		  WHERE GEN.Translation.CodeID = CONCAT(@lFolderValueSet, '_', @lFolderCode) 
		     AND GEN.Translation.Language = @lTransCountry

	    SET @ltranslationIndex = @ltranslationIndex + 1

	 END -- WHILE 1 = 1 

	 PRINT 'Done '

      WHILE @lSubTreeJSON IS NOT NULL
	 BEGIN

	    SET @lsubTreeDepth = @lsubTreeDepth + 1 ;

	    TRUNCATE TABLE TMP.SubTree

	    INSERT INTO TMP.SubTree
	       (FolderCode, IconName, Translations, SubFolderTree)
	    SELECT FolderCode, IconName, Translations, SubFolderTree
	    FROM OPENJSON(@lSubTreeJSON)
	       WITH
		  (
		     FolderCode     NVARCHAR(50)   '$.code', 
		     IconName	    NVARCHAR(50)   '$.iconName', 
		     Translations   NVARCHAR(MAX)  '$.translations'	as JSON, 
		     SubFolderTree  NVARCHAR(MAX)  '$.folder'		as JSON
		  )

	    SELECT @lFolderCode = TMP.SubTree.FolderCode 
	    FROM TMP.SubTree 
	    
	    SELECT @lFolderIconName = TMP.SubTree.IconName 
	    FROM TMP.SubTree 

	    SELECT @lTranslationsJSON = TMP.SubTree.Translations
	    FROM TMP.SubTree	    

	    SELECT @lSubTreeJSON = TMP.SubTree.SubFolderTree
	    FROM TMP.SubTree	    			

	    PRINT CONCAT(@lSubTreeJSON, '------')

	    SET @luniversalID = 0 ;

	    INSERT INTO [GEN].[Object]
	       (ObjectType, CreationDate, CreationTime,  Comments, VersionNr)
	    VALUES
	       ('MIS.Folder', CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME), @lObjectComment, @lObjectVersion)

	    SET @luniversalID = @@IDENTITY

	    IF @luniversalID = 0
	       BEGIN

		  INSERT INTO [LOG].[SysLog]
		     (UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		  VALUES	
		     (USER_NAME(), @lModuleName, @lErrorLevel, 'Object for GEN.Folder set to NULL.', 
			CAST(getdate() AS DATE), CAST(getdate() AS TIME))

		  SET @luniversalID = NULL ;
	       END

	    SET @lCodeId = 0 

	    SELECT @lCodeId = GEN.Code.OrderID 
	    FROM GEN.Code 
	    WHERE GEN.Code.ID = CONCAT(@lFolderValueSet, '_', @lFolderCode)

	    IF @lCodeId = 0 
	       BEGIN

		  IF @pTraceMode > 0
		     INSERT INTO [LOG].[SysLog]
			(UserName,ModuleName,SeverityLevel,ReasonofEvent, CreationDate, CreationTime)
		     VALUES	
			(USER_NAME(), @lModuleName, @lDebugLevel, 
			   CONCAT('Code inserted for ', @lFolderValueSet, '_', @lFolderCode), 
			   CAST(getdate() AS DATE), CAST(getdate() AS TIME))

		  SET @lValueSetId = 0

		  SELECT @lValueSetId = [GEN].[ValueSet].ID
		  FROM [GEN].[ValueSet]
		  WHERE [GEN].[ValueSet].CodePrefix = @lFolderValueSet

		  PRINT 'Code inseerted from MIS.Folder'

		  INSERT INTO [GEN].[Code]
		     (ID, ValueSetID, CreationDate, CreationTime, ValidFrom)
		  VALUES 
		     (CONCAT(@lFolderValueSet, '_', @lFolderCode), @lValueSetId, CAST(GETDATE() AS DATE), 
			CAST(GETDATE() AS TIME), CAST(GETDATE() AS DATE))

	    END -- @lCodeId = 0 

	    -- Create Folder entry

	    INSERT INTO [GEN].[Folder]
		  (RootFolderID, Code, CreationDate, CreationTime, ObjectID, IconName, ParentFolderID)
	    VALUES 
	       (@pMISRootFolderID, CONCAT(@lFolderValueSet, '_', @lFolderCode), CAST(GETDATE() AS DATE), 
		  CAST(GETDATE() AS TIME), @luniversalID, @lFolderIconName, @lFolderId) ;

	    SET @lFolderId = @@IDENTITY

	    TRUNCATE TABLE TMP.Translations

	    INSERT INTO TMP.Translations
	       (TransCountry, TransText)
	    SELECT UPPER(TransCountry), TransText	   
	    FROM OPENJSON(@lTranslationsJSON)
	    WITH
	       (
		  TransCountry   NVARCHAR(5)    '$.country',
		  TransText      NVARCHAR(200)  '$.text'
	       )

	    PRINT 'Subfolder translation'

   	    SELECT @ltranslationIndex = (MAX(TransID) - 1)
	    FROM TMP.Translations 

	    PRINT CONCAT('Starting id = ',CAST(@ltranslationIndex AS NVARCHAR(10))) 

	    WHILE 1 = 1 
	       BEGIN
		  
		  SELECT @lTransCountry = TransCountry, @lTransText = TransText
		  FROM  TMP.Translations
		  WHERE TransID = @ltranslationIndex + 1

		  PRINT CONCAT('RowCount = ', CAST(@@ROWCOUNT AS NVARCHAR(10)))

		  IF @@ROWCOUNT = 0
		     BREAK ;

		  SET @lSize = 0

		  SELECT @lSize = COUNT(*)
		  FROM [GEN].[Translation]
		  WHERE GEN.Translation.CodeID = CONCAT(@lFolderValueSet, '_', @lFolderCode) 
		     AND GEN.Translation.Language = @lTransCountry 
		     
		  IF @lSize = 0
		     INSERT INTO [GEN].[Translation]
			(CodeID, Language, Text, CreationDate, CreationTime)
		     VALUES
			(CONCAT(@lFolderValueSet, '_', @lFolderCode), @lTransCountry, @lTransText, 
			   CAST(GETDATE() AS DATE), CAST(GETDATE() AS TIME))
		  ELSE 
		     UPDATE [GEN].[Translation]
			SET GEN.Translation.Text = @lTransText, GEN.Translation.LastModifiedDate = CAST(GETDATE() AS DATE), 
			GEN.Translation.LastModifiedTime = CAST(GETDATE() AS TIME)
		     WHERE GEN.Translation.CodeID = CONCAT(@lFolderValueSet, '_', @lFolderCode) 
			AND GEN.Translation.Language = @lTransCountry 

		  SET @ltranslationIndex = @ltranslationIndex + 1 

	       END -- WHILE 1 = 1 

	    PRINT 'OK loop'

	 END -- @lSubTreeJSON IS NOT NULL
	 
	 UPDATE MIS.Form 
	    SET MIS.Form.FolderID = @lFolderId
	 WHERE  MIS.Form.ID = @pMISFormID

	 SET @pErrCode = @lRes

	 IF @lTransactCount = 1
	    COMMIT 

   END TRY

   BEGIN CATCH
      DECLARE @l_errorMessage NVARCHAR(200) 
      DECLARE @l_errorSeverity INT 
      DECLARE @l_errorState INT
      DECLARE @l_errorLine INT 	 
  
      SELECT   @l_errorMessage = ERROR_MESSAGE(),  
	       @l_errorSeverity = ERROR_SEVERITY(),  
	       @l_errorState = ERROR_STATE(), 
	       @l_errorLine = ERROR_LINE()

      IF @lTransactCount = 1	       
	 ROLLBACK
      ELSE
	 ROLLBACK TRANSACTION LoopTrans	 

      INSERT INTO [LOG].[SysLog]
	 (UserName,ModuleName,SeverityLevel,ReasonofEvent, EventStatus, 
	    CreationDate, CreationTime)
      VALUES	
	 (USER_NAME(), CONCAT(@lModuleName, ' line = ', CAST(@l_errorLine AS VARCHAR(10))), 
	    @l_errorSeverity, @l_errorMessage, @l_errorState, 
	    CAST(getdate() AS DATE), CAST(getdate() AS TIME))

      SET @pErrCode = -1

      RAISERROR (@l_errorMessage, @l_errorSeverity, @l_errorState )
   END CATCH

   RETURN ;

END
go


	CREATE FUNCTION dbo.fn_diagramobjects() 
	RETURNS int
	WITH EXECUTE AS N'dbo'
	AS
	BEGIN
		declare @id_upgraddiagrams		int
		declare @id_sysdiagrams			int
		declare @id_helpdiagrams		int
		declare @id_helpdiagramdefinition	int
		declare @id_creatediagram	int
		declare @id_renamediagram	int
		declare @id_alterdiagram 	int 
		declare @id_dropdiagram		int
		declare @InstalledObjects	int

		select @InstalledObjects = 0

		select 	@id_upgraddiagrams = object_id(N'dbo.sp_upgraddiagrams'),
			@id_sysdiagrams = object_id(N'dbo.sysdiagrams'),
			@id_helpdiagrams = object_id(N'dbo.sp_helpdiagrams'),
			@id_helpdiagramdefinition = object_id(N'dbo.sp_helpdiagramdefinition'),
			@id_creatediagram = object_id(N'dbo.sp_creatediagram'),
			@id_renamediagram = object_id(N'dbo.sp_renamediagram'),
			@id_alterdiagram = object_id(N'dbo.sp_alterdiagram'), 
			@id_dropdiagram = object_id(N'dbo.sp_dropdiagram')

		if @id_upgraddiagrams is not null
			select @InstalledObjects = @InstalledObjects + 1
		if @id_sysdiagrams is not null
			select @InstalledObjects = @InstalledObjects + 2
		if @id_helpdiagrams is not null
			select @InstalledObjects = @InstalledObjects + 4
		if @id_helpdiagramdefinition is not null
			select @InstalledObjects = @InstalledObjects + 8
		if @id_creatediagram is not null
			select @InstalledObjects = @InstalledObjects + 16
		if @id_renamediagram is not null
			select @InstalledObjects = @InstalledObjects + 32
		if @id_alterdiagram  is not null
			select @InstalledObjects = @InstalledObjects + 64
		if @id_dropdiagram is not null
			select @InstalledObjects = @InstalledObjects + 128
		
		return @InstalledObjects 
	END
go

exec sp_addextendedproperty 'microsoft_database_tools_support', 1, 'SCHEMA', 'dbo', 'FUNCTION', 'fn_diagramobjects'
go

deny execute on dbo.fn_diagramobjects to guest
go

grant execute on dbo.fn_diagramobjects to [public]
go


CREATE PROCEDURE [GEN].[getAddressSplitted](
	@p_Address nvarchar(500), 

	@o_PublicPlaceName nvarchar(200) output,
	@o_PublicPlaceType nvarchar(200) output,
	@o_HouseNr nvarchar(200) output,
	@o_Building nvarchar(200) output,
	@o_Staircase nvarchar(200) output,
	@o_Floor nvarchar(200) output,
	@o_Door nvarchar(200) output)

/*
==========================================================================================
Splits a Hungarian address into 7 separate fields                               
 
 Author:				Tóth Gábor  based on Matyas Kesmarki from Indecs2                                       
 Creation date:			2023.03.11.
 Last modified date:	
                                                                                 
 Parameters:                                                                     
 @p_Address: the address string (without the postal code and the city)            
                                                                                 
 Example:                                                                        

Set @p_Address = 'Ablak zsiráf utca 2 B ép. A lph. 3 em. /4';	-- jó
Set @p_Address = 'Ablak zsiráf utca 2 B 1/4';					-- nem jó
Set @p_Address = 'Ablak zsiráf utca 2 emelet 1/4';				-- jó
Set @p_Address = 'Ablak zsiráf utca 2 emelet 4';				-- nem jó
 execute GEN.getAddressSplitted @p_Address, 
	@o_PublicPlaceName output,
	@o_PublicPlaceType output,
	@o_HouseNr output,
	@o_Building output,
	@o_Staircase output,
	@o_Floor output,
	@o_Door output;
 select  @o_PublicPlaceName as 'közterület neve',
	@o_PublicPlaceType as 'Közterület típus',
	@o_HouseNr as 'Ház',
	@o_Building as 'épület',
	@o_Staircase as 'Lépcsőház',
	@o_Floor as 'emelet',
	@o_Door as 'ajtó';
 
==========================================================================================
*/

AS
BEGIN

SET NOCOUNT ON;

	declare @l_Address nvarchar(200);
	declare @l_HouseNr nvarchar(200);
	declare @l_Building nvarchar(200);
	declare @l_Staircase nvarchar(200);   
	declare @l_Floor nvarchar(200);
	declare @l_Door nvarchar(200);
	declare @l_Index numeric(5);
	declare @l_Length numeric(5);
--------------------------------------------------------------------------------------------------------------------

	If exists (Select 1
		FROM ifc.Address CROSS APPLY STRING_SPLIT (@p_Address, ' ')
	Join GEN.Translation On Translation.Language = 'hu' and Translation.CodeID like 'PUBLIC_PLACE_TYPE_%' and ' ' + Translation.Text + ' ' = ' ' + [value] + ' '
		where [value] <> '')
	Begin
		Set @o_PublicPlaceType = (Select DisTinct [value]
		FROM ifc.Address CROSS APPLY STRING_SPLIT (@p_Address, ' ')
			Join GEN.Translation On (Translation.Language = 'hu')
							and (Translation.CodeID like 'PUBLIC_PLACE_TYPE_%')
							and (' ' + Translation.Text + ' ') = (' ' + [value] + ' ')
		where [value] <> '');
		Set @o_PublicPlaceName = Left(@p_Address, Charindex(@o_PublicPlaceType, @p_Address)-2);

		Set @p_Address = Right(@p_Address,Len(@p_Address) - Charindex(@o_PublicPlaceType, @p_Address) - Len(@o_PublicPlaceType));
		Set @l_Address = @p_Address;

		set @l_Index = patindex('%[0-9]%', @l_Address);
		if @l_Address <> '' 
		begin 
			while substring(@l_Address,@l_Index,1) not in ('.',' ','/') and @l_Index < len(@l_Address) 
			begin
				set @l_Index = @l_Index + 1;
			end;
		end;
	End;	

	if @l_Index <> 0 
	begin 

		set @l_HouseNr = trim(replace(Left(@l_Address, @l_Index - 1),':',''));
		set @l_Address = substring(@l_Address, @l_Index, len(@l_Address));
		if patindex('%ÉP%',@l_Address) <> 0 and patindex('%LÉPCS%',@l_Address) = 0 
		begin  
			set @l_Building = trim(replace(left(@l_Address,patindex('%ÉP%',@l_Address)-1),'.',''));
			set @l_Address = substring(@l_Address,patindex('%ÉP%',@l_Address)+2,len(@l_Address));
		end;  
		else  
		begin  
		/*
			Set @l_Address = Trim(@l_Address);
			set @l_Building = trim(left(@l_Address,patindex('%[ ][A-Z][ ]%',@l_Address)+1));
			set @l_Address = substring(@l_Address,patindex('%[A-Z]%',@l_Address)+2,len(@l_Address));
		*/
		set @l_Building = ''; /*ide..*/

		end;

		set @l_Index = patindex('%/%', @l_Address);
		if @l_Index = 1 
		begin 
			If Isnull(@l_Building,'') = '' /* 2023-03-11 */
				set @l_Building = trim(substring(@l_Address,2,1));
			set @l_Address = trim(substring(@l_Address,3,len(@l_Address)));
		end;  
		else  
		begin 
			if @l_Index <> 0 
			begin
				set @l_Length = 0;
				while substring(@l_Address,@l_Index,1) <> ' ' and @l_Index > 0 
				begin
					set @l_Index = @l_Index - 1;
					set @l_Length = @l_Length + 1;
				end;
				set @l_Floor = trim(substring(@l_Address, @l_Index,@l_Length));
				set @l_Floor = trim(replace(@l_Floor,'.',''));
				set @l_Address = replace(@l_Address, 'lph', ' lépcsőház ');
				set @l_Address = replace(@l_Address, 'lp', ' lépcsőház ');
				set @l_Address = replace(@l_Address, 'lház', ' lépcsőház ');
				set @l_Address = replace(@l_Address, 'lh', ' lépcsőház '); 
				if patindex('%lépcsőház%',@l_Address) = 0 
				begin  
					set @l_Address = substring(@l_Address, @l_Index + 1, len(@l_Address));
				end;
			end;  
			else  
			begin 
				if substring(@l_Address,1,1) = '.' 
				begin  
					set @l_Address = substring(@l_Address,2,len(@l_Address));
				end;
			end;
		end;  
		end;  
		else  
		begin 
			set @l_Index = patindex('% %', @l_Address);
			if @l_Index = 0 
			begin 
				set @l_HouseNr = @l_Address;
				set @l_Address = '';
			end;  
			else  
			begin 
				set @l_HouseNr = trim(left(@l_Address, @l_Index - 1));
				set @l_Address = substring(@l_Address, @l_Index + 1, len(@l_Address));
			end;
			set @l_Building = '';
		end;
	-- message 'Address5: '||@l_address to CLIENT;
	-- Getting @Staircase 
		set @l_Index = 0;
		set @l_Address = replace(@l_Address, 'lph', ' lépcsőház ');
		set @l_Address = replace(@l_Address, 'lp', ' lépcsőház ');
		set @l_Address = replace(@l_Address, 'lház', ' lépcsőház ');
		set @l_Address = replace(@l_Address, 'lh', ' lépcsőház ');   
		set @l_Index = patindex('%lépcsőház%', @l_Address); set @l_Length = len('lépcsőház');
		if @l_Index <> 0 
		begin  
			set @l_Staircase = trim(left(@l_Address,@l_Index + @l_Length));
			set @l_Address = substring(@l_Address,@l_Index + @l_Length,len(@l_Address));
			set @l_Staircase = trim(replace(@l_Staircase,'.',''));
			set @l_Staircase = trim(replace(@l_Staircase,'/',''));
		end;  
		else  
		begin   
			set @l_Staircase = '';
		end;
	-- message 'Address6: '||@l_address to CLIENT;
	-- Searching for @Floor type
		if trim(replace(@l_Address,'.','')) <> '' 
		begin 
			set @l_Index = 0;
			set @l_Length = 0;
			if patindex('%/%',@l_Address) = 0 begin 
			set @l_Address = replace(@l_Address, 'FSZ', ' földszint ');
			set @l_Address = replace(@l_Address, 'FS', ' földszint ');
			set @l_Address = replace(@l_Address, 'em.', ' emelet ');
		end;
		set @l_Index = patindex('%emelet%', @l_Address); set @l_Length = len('emelet');
		if @l_Index = 0 begin  set @l_Index = patindex('%földszint%', @l_Address); set @l_Length = len('földszint'); end;
		if @l_Index = 0 begin  set @l_Index = patindex('%magasföldszint%', @l_Address); set @l_Length = len('magasföldszint'); end;
		if @l_Index = 0 begin  set @l_Index = patindex('%alagsor%', @l_Address); set @l_Length = len('alagsor'); end;
		if @l_Index = 0 begin  set @l_Index = patindex('%tetőtér%', @l_Address); set @l_Length = len('tetőtér'); end;
		if @l_Index = 0 begin  set @l_Index = patindex('%félemelet%', @l_Address); set @l_Length = len('félemelet'); end;
		if @l_Index = 0 begin  set @l_Index = patindex('%/%',@l_Address); set @l_Length = len('/') - 1; end;
	-- Getting @Floor and @Door    
		if @l_Index = 0 
		begin 
			if coalesce(@l_Floor,'') = '' 
			begin  
				set @l_Index = patindex('%[0-9]%',@l_Address);
				while substring(@l_Address,@l_Index,1) <> ' ' and @l_Index < len(@l_Address)
				begin
					set @l_Index = @l_Index + 1;
				end;
				if patindex('%[0-9]%',substring(@l_Address,@l_Index,len(@l_Address))) <> 0 
				begin 
					set @l_Floor = trim(left(@l_Address,@l_Index-1));
					set @l_Address = trim(substring(@l_Address,@l_Index,len(@l_Address)));
			--message 'Address7: '||@l_address to CLIENT;
				end;  
				else 
				begin 
					set @l_Floor = '';
				end; 
			end;
			set @l_Door = trim(@l_Address);
		end;  
		else  
		begin 
			set @l_Floor = trim(left(@l_Address, @l_Index + @l_Length - 1));
			set @l_Door = trim(substring(@l_Address,@l_Index + @l_Length + 1, len(@l_Address)));
			set @l_Floor = trim(replace(@l_Floor,'.',''));
		end;
	end;  
	else  
	begin 
		set @l_Floor = '';
		set @l_Door = '';
	end;

	if len(@l_Floor) <= 3 
	begin 
		set @l_Floor = replace(@l_Floor, 'FSZ', 'földszint ');
		set @l_Floor = replace(@l_Floor, 'FS', 'földszint ');
		set @l_Floor = replace(@l_Floor, 'AS', 'alagsor ');
		set @l_Floor = replace(@l_Floor, 'EM', 'emelet ');
		set @l_Floor = replace(@l_Floor, 'TT', 'tetőtér ');
		set @l_Floor = replace(@l_Floor, 'FE', 'félemelet ');
		set @l_Floor = replace(@l_Floor, 'MF', 'magasföldszint ');
	end;

	Set @o_HouseNr = @l_HouseNr;
	Set @o_Building = @l_Building;
	Set @o_Staircase = @l_Staircase;
	Set @o_Floor = @l_Floor;
	Set @o_Door = @l_Door;

	/*
print '@o_PublicPlaceName';
print @o_PublicPlaceName;
print '------------------';

print '@o_PublicPlaceType';
print @o_PublicPlaceType;
print '------------------';

print '@o_HouseNr';
print @o_HouseNr;
print '------------------';

print '@o_Building';
print @o_Building;
print '------------------';

print '@o_Staircase';
print @o_Staircase;
print '------------------';

print '@o_Floor';
print @o_Floor;
print '------------------';

print '@o_Door';
print @o_Door;
print '------------------';

*/
	

	
END;
go

CREATE FUNCTION [GEN].[getCodesText](
  @p_language nvarchar(16),
  @p_code nvarchar(50)
  )
returns nvarchar(250)
/***********************************
* Administrator: Bognár Dávid      *
*  Created:      2022.11.16        *
*  Last revised: 2022.11.16        *
************************************
*/
begin
  declare @m_result nvarchar(250);
  

  
  if @p_language is not null and @p_code is not null 
   SELECT @m_result = text FROM GEN.Translation WHERE  Language = @p_language AND CodeID = @p_code;
  return @m_result
end
go


Create   PROCEDURE [IFC].[getIFCErrorMessage](
		@l_moduleInstanceID numeric(16),
		@l_IfcTableName nvarchar(500), /*	pl:'IFC.DebtCase'*/
		@l_CodeValueSetID numeric(16),
		@l_IfcID numeric(16),
		@l_FieldName nvarchar(200),
		@l_FieldNameValue nvarchar(200),
		@l_FieldCode nvarchar(200),
		@l_FieldCodeValue nvarchar(200),
		@l_EmptyAllowed nvarchar(200), /* ha megengedett az üres Code és Name érték, akkor ez az érték nem NULL értékű */
		@l_CurrentUserName nvarchar(200),

		@l_ErrorMessage nvarchar(200) output,
		@l_FieldCodeOut nvarchar(200) output)

AS
BEGIN

SET NOCOUNT ON;

	Declare @CammelFieldName nvarchar(200);
	Declare @CammelFieldCode nvarchar(200);
	Set @l_ErrorMessage = NULL;

-- @l_FieldName,@l_FieldCode:
			-- 0 - NULL:
			If Trim(Isnull(@l_FieldNameValue,'')) = ''
				Set @l_FieldNameValue = NULL;
			If Trim(Isnull(@l_FieldCodeValue,'')) = ''
				Set @l_FieldCodeValue = NULL;
			If Trim(Isnull(@l_EmptyAllowed,'')) = ''
				Set @l_EmptyAllowed = NULL;
			Set @l_FieldNameValue = Trim(@l_FieldNameValue);
			Set @l_FieldCodeValue = Trim(@l_FieldCodeValue);
			Set @l_EmptyAllowed = Trim(@l_EmptyAllowed);
			
			-- 1 - Üres:
			If @l_FieldNameValue is NULL and @l_FieldCodeValue is NULL and @l_EmptyAllowed is NULL
			BEGIN
				Set @l_ErrorMessage = Trim(Isnull(@l_ErrorMessage,'') + ' ' + @l_FieldName + '/' + @l_FieldCode + ' are empty,');
/* name is empty */				
				Set @CammelFieldName = LOWER(Left(@l_FieldName,1)) + SubString(@l_FieldName,2,Len(@l_FieldName)-1)
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select @l_IfcTableName, @l_IfcID, @CammelFieldName, 'ERR_CODE_AND_NAME_ARE_EMPTY', @l_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @l_CurrentUserName;
/* code is empty */
				Set @CammelFieldCode = LOWER(Left(@l_FieldCode,1)) + SubString(@l_FieldCode,2,Len(@l_FieldCode)-1)
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select @l_IfcTableName, @l_IfcID, @CammelFieldCode, 'ERR_CODE_AND_NAME_ARE_EMPTY', @l_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @l_CurrentUserName;
			END;
			-- 2 - Text-NotValid:
			If @l_FieldNameValue is NOT NULL and @l_FieldCodeValue is NULL
			BEGIN
				If Not exists (
						select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where Code.ValueSetID = @l_CodeValueSetID
						and Translation.Text = @l_FieldNameValue)
				Begin
/* name is not valid */				
					Set @l_ErrorMessage = Trim(Isnull(@l_ErrorMessage,'') + ' ' + @l_FieldName + ' is not Valid,');
					Set @CammelFieldName = LOWER(Left(@l_FieldName,1)) + SubString(@l_FieldName,2,Len(@l_FieldName)-1)
					Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
					Select @l_IfcTableName, @l_IfcID, @CammelFieldName, 'ERR_CODE_NAME_NOT_VALID', @l_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @l_CurrentUserName;
				End;

				Else
					Set @l_FieldCodeOut = (select Top 1 Code.Id 
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where Code.ValueSetID = @l_CodeValueSetID
						and Translation.Text = @l_FieldNameValue order by Code.Id desc);
			END;
			-- 3 - Code-NotValid:
			If @l_FieldNameValue is NULL and @l_FieldCodeValue is not NULL
			and Not exists (select 1
						from Gen.ValueSet
						left Join Gen.Code on Code.ValueSetID = ValueSet.Id
						left join Gen.Translation on Translation.CodeID = Code.Id
						where Code.ValueSetID = @l_CodeValueSetID
						and Code.Id = @l_FieldCodeValue)
			BEGIN
/* code is not valid */
				Set @l_ErrorMessage = Trim(Isnull(@l_ErrorMessage,'') + ' ' + @l_FieldCode + ' is not Valid,');
				Set @CammelFieldCode = LOWER(Left(@l_FieldCode,1)) + SubString(@l_FieldCode,2,Len(@l_FieldCode)-1)
				Insert IFC.InterfaceError(TableName, RecordId, FieldName, ErrorCode, ModuleinstanceID, CreationDate, CreationTime, CreationUserName)
				Select @l_IfcTableName, @l_IfcID, @CammelFieldCode, 'ERR_CODE_CODE_NOT_VALID', @l_moduleInstanceID, Cast( GetDate() AS Date ), Cast( GetDate() AS Time ), @l_CurrentUserName;

			END;
	
END;

go

-- =============================================
-- Author:		IFJ Kesmarki Matyas
-- Create date: 2022-12-01
-- Last modified date: 2022-12-01
-- =============================================
CREATE   PROCEDURE [GEN].[getRelationVisualJson] (
	@p_new nvarchar(200),
	@p_ID numeric(16),
	@p_level numeric(16), 
	@o_Json nvarchar(max) output)
AS
begin
	declare @l_ID numeric(16);
	DECLARE @out nvarchar(max);
	DECLARE @Counter numeric(16); 
	--declare @m_ID numeirc(16);
	set @o_Json = '';
	set @out = '';
	if @p_new = 'TRUE' 
	begin
		print 'new-------------------';
		drop table if exists #TempRelationVisualTable;
		CREATE TABLE #TempRelationVisualTable
	      (IDFrom numeric(16),IDTo numeric(16),Direction nvarchar(200),StatusOpen numeric(5),RelType nvarchar(200));
	    set @o_Json = '{ "ID":'+ CAST(@p_ID AS VARCHAR)+',' + CHAR(13)+CHAR(10);
	    if (select prt.entity.EntityType from prt.Entity where id = @p_ID) = 'P'
		    BEGIN 
		    	set @o_Json = @o_Json+ '"text_1":"' + coalesce((select coalesce(Title,'') + ' ' + coalesce(FirstName,'') + ' ' + coalesce(MiddleName,'') + ' ' + coalesce(LastName,'') from prt.Person where entityid = @p_ID),'EMPTY') + '",' + CHAR(13)+CHAR(10) ;
		    END
		    else
		    BEGIN 
		    	set @o_Json = @o_Json+ '"text_1":"' + coalesce((select Name from prt.Company where entityid = @p_ID),'EMPTY') + '",' + CHAR(13)+CHAR(10) ; 
		    END 
	    set @o_Json = @o_Json+ '"text_2":"Kezdő",' + CHAR(13)+CHAR(10) ; 
	    set @o_Json = @o_Json+ '"type":"' + coalesce((select prt.entity.EntityType from prt.Entity where id = @p_ID),'c') + '",' + CHAR(13)+CHAR(10) ;
	   	set @o_Json = @o_Json+ '"children":[';
	end
	--print 'init' + CAST(@p_ID AS VARCHAR);
	INSERT into #TempRelationVisualTable(IDFrom,IDTo,Direction,StatusOpen,RelType) select FromEntityID,ToEntityID,'Lefelé',0,'Tulajdoni kapcsolat' from prt.EntityRelation where FromEntityID = @p_ID and ToEntityID <> @p_ID and ToEntityID  not in(select IDTo from #TempRelationVisualTable) and ToEntityID  not in(select IDFrom from #TempRelationVisualTable);
	INSERT into #TempRelationVisualTable(IDFrom,IDTo,Direction,StatusOpen,RelType) select ToEntityID,FromEntityID,'Felfelé',0,'Tulajdoni kapcsolat' from prt.EntityRelation where ToEntityID = @p_ID and FromEntityID <> @p_ID and FromEntityID  not in(select IDTo from #TempRelationVisualTable) and FromEntityID  not in(select IDFrom from #TempRelationVisualTable);
	--INSERT INTO #TempRelationVisualTable(IDFrom,IDTo,Direction,StatusOpen,RelType) select @p_ID,EntityID,coalesce((select max(DebtCaseID) from dcs.Debtor where entityid = @p_ID),'ERROR'),0,'Ugykapcsolat' from dcs.Debtor where DebtCaseID in (select DebtCaseID from dcs.Debtor where entityid = @p_ID) and EntityID <> @p_ID and EntityID not in(select IDTo from #TempRelationVisualTable) and EntityID not in(select IDFrom from #TempRelationVisualTable);
	set @p_level = @p_level +1;
	WHILE ( SELECT max(IDFrom) from #TempRelationVisualTable where StatusOpen = 0 and IDFrom = @p_ID) is not null  
		BEGIN  
		   	set @l_ID = (SELECT max(IDTo) from #TempRelationVisualTable where StatusOpen = 0 and IDFrom = @p_ID);
		   	print 'CURRENT: '+CAST(@l_ID AS VARCHAR);
		    update #TempRelationVisualTable set StatusOpen = 1 where IDTo = @l_ID;
		   	set @Counter = 1;
		   	WHILE ( @Counter <= @p_level)
				BEGIN
				    set @o_Json = @o_Json + char(9);
				    SET @Counter  = @Counter  + 1
				END
		    set @o_Json = @o_Json+ '{ "ID":' + CAST(@l_ID as VARCHAR)+ ',' + CHAR(13)+CHAR(10) ; 
		    if (select prt.entity.EntityType from prt.Entity where id = @l_ID) = 'P'
		    BEGIN 
		    	set @o_Json = @o_Json+ '"text_1":"' + coalesce((select coalesce(Title,'') + ' ' + coalesce(FirstName,'') + ' ' + coalesce(MiddleName,'') + ' ' + coalesce(LastName,'') from prt.Person where entityid =  @l_ID),'EMPTY') + '",' + CHAR(13)+CHAR(10) ;
		    END
		    else
		    BEGIN 
		    	set @o_Json = @o_Json+ '"text_1":"' + coalesce((select Name from prt.Company where entityid = @l_ID),'EMPTY') + '",' + CHAR(13)+CHAR(10) ; 
		    END 
		   	set @o_Json = @o_Json+ '"text_2":"' + (select max(RelType) from #TempRelationVisualTable where IDTo = @l_ID)+ ' ' + (select max(Direction) from #TempRelationVisualTable where IDTo = @l_ID) + '",' + CHAR(13)+CHAR(10) ; 
		    set @o_Json = @o_Json+ '"type":"' + (select prt.entity.EntityType from prt.Entity where id = @l_ID) + '",' + CHAR(13)+CHAR(10) ; 
		    set @o_Json = @o_Json+'"children":[' ;

			EXEC gen.getRelationVisualJson 'false',@l_ID,@p_level , @out output;
		   	--set @o_Json = SUBSTRING ( @o_Json ,1, len(@o_Json));
	        set @o_Json = @o_Json + @out + ']},';

		END
		if @o_Json <> '' 
		begin
			IF(EXISTS(SELECT 1 FROM #TempRelationVisualTable))
			BEGIN
			  set @o_Json = SUBSTRING ( @o_Json ,1, len(@o_Json)-1);
			END;
			
		end
		
		
		if @p_new = 'TRUE' 
		begin
			
			set @o_Json = @o_Json + ']}';
			set @o_Json = REPLACE ( @o_Json , 'á' , 'a' )  ;
			set @o_Json = REPLACE ( @o_Json , 'é' , 'e' )  ;
			set @o_Json = REPLACE ( @o_Json , 'í' , 'i' )  ;
			set @o_Json = REPLACE ( @o_Json , 'ó' , 'o' )  ;
			set @o_Json = REPLACE ( @o_Json , 'ö' , 'o' )  ;
			set @o_Json = REPLACE ( @o_Json , 'ő' , 'o' )  ;
			set @o_Json = REPLACE ( @o_Json , 'ű' , 'u' )  ;
			set @o_Json = REPLACE ( @o_Json , 'Á' , 'A' )  ;
			set @o_Json = REPLACE ( @o_Json , 'É' , 'E' )  ;
			set @o_Json = REPLACE ( @o_Json , 'Í' , 'I' )  ;
			set @o_Json = REPLACE ( @o_Json , 'Ó' , 'O' )  ;
			set @o_Json = REPLACE ( @o_Json , 'Ö' , 'O' )  ;
			set @o_Json = REPLACE ( @o_Json , 'Ő' , 'O' )  ;
			set @o_Json = REPLACE ( @o_Json , 'Ű' , 'U' )  ;
			--select * from #TempRelationVisualTable;
		end
	--select * from #TempRelationVisualTable;
end
go


	CREATE PROCEDURE dbo.sp_alterdiagram
	(
		@diagramname 	sysname,
		@owner_id	int	= null,
		@version 	int,
		@definition 	varbinary(max)
	)
	WITH EXECUTE AS 'dbo'
	AS
	BEGIN
		set nocount on
	
		declare @theId 			int
		declare @retval 		int
		declare @IsDbo 			int
		
		declare @UIDFound 		int
		declare @DiagId			int
		declare @ShouldChangeUID	int
	
		if(@diagramname is null)
		begin
			RAISERROR ('Invalid ARG', 16, 1)
			return -1
		end
	
		execute as caller;
		select @theId = DATABASE_PRINCIPAL_ID();	 
		select @IsDbo = IS_MEMBER(N'db_owner'); 
		if(@owner_id is null)
			select @owner_id = @theId;
		revert;
	
		select @ShouldChangeUID = 0
		select @DiagId = diagram_id, @UIDFound = principal_id from dbo.sysdiagrams where principal_id = @owner_id and name = @diagramname 
		
		if(@DiagId IS NULL or (@IsDbo = 0 and @theId <> @UIDFound))
		begin
			RAISERROR ('Diagram does not exist or you do not have permission.', 16, 1);
			return -3
		end
	
		if(@IsDbo <> 0)
		begin
			if(@UIDFound is null or USER_NAME(@UIDFound) is null) -- invalid principal_id
			begin
				select @ShouldChangeUID = 1 ;
			end
		end

		-- update dds data			
		update dbo.sysdiagrams set definition = @definition where diagram_id = @DiagId ;

		-- change owner
		if(@ShouldChangeUID = 1)
			update dbo.sysdiagrams set principal_id = @theId where diagram_id = @DiagId ;

		-- update dds version
		if(@version is not null)
			update dbo.sysdiagrams set version = @version where diagram_id = @DiagId ;

		return 0
	END
go

exec sp_addextendedproperty 'microsoft_database_tools_support', 1, 'SCHEMA', 'dbo', 'PROCEDURE', 'sp_alterdiagram'
go

deny execute on dbo.sp_alterdiagram to guest
go

grant execute on dbo.sp_alterdiagram to [public]
go


	CREATE PROCEDURE dbo.sp_creatediagram
	(
		@diagramname 	sysname,
		@owner_id		int	= null, 	
		@version 		int,
		@definition 	varbinary(max)
	)
	WITH EXECUTE AS 'dbo'
	AS
	BEGIN
		set nocount on
	
		declare @theId int
		declare @retval int
		declare @IsDbo	int
		declare @userName sysname
		if(@version is null or @diagramname is null)
		begin
			RAISERROR (N'E_INVALIDARG', 16, 1);
			return -1
		end
	
		execute as caller;
		select @theId = DATABASE_PRINCIPAL_ID(); 
		select @IsDbo = IS_MEMBER(N'db_owner');
		revert; 
		
		if @owner_id is null
		begin
			select @owner_id = @theId;
		end
		else
		begin
			if @theId <> @owner_id
			begin
				if @IsDbo = 0
				begin
					RAISERROR (N'E_INVALIDARG', 16, 1);
					return -1
				end
				select @theId = @owner_id
			end
		end
		-- next 2 line only for test, will be removed after define name unique
		if EXISTS(select diagram_id from dbo.sysdiagrams where principal_id = @theId and name = @diagramname)
		begin
			RAISERROR ('The name is already used.', 16, 1);
			return -2
		end
	
		insert into dbo.sysdiagrams(name, principal_id , version, definition)
				VALUES(@diagramname, @theId, @version, @definition) ;
		
		select @retval = @@IDENTITY 
		return @retval
	END
go

exec sp_addextendedproperty 'microsoft_database_tools_support', 1, 'SCHEMA', 'dbo', 'PROCEDURE', 'sp_creatediagram'
go

deny execute on dbo.sp_creatediagram to guest
go

grant execute on dbo.sp_creatediagram to [public]
go


	CREATE PROCEDURE dbo.sp_dropdiagram
	(
		@diagramname 	sysname,
		@owner_id	int	= null
	)
	WITH EXECUTE AS 'dbo'
	AS
	BEGIN
		set nocount on
		declare @theId 			int
		declare @IsDbo 			int
		
		declare @UIDFound 		int
		declare @DiagId			int
	
		if(@diagramname is null)
		begin
			RAISERROR ('Invalid value', 16, 1);
			return -1
		end
	
		EXECUTE AS CALLER;
		select @theId = DATABASE_PRINCIPAL_ID();
		select @IsDbo = IS_MEMBER(N'db_owner'); 
		if(@owner_id is null)
			select @owner_id = @theId;
		REVERT; 
		
		select @DiagId = diagram_id, @UIDFound = principal_id from dbo.sysdiagrams where principal_id = @owner_id and name = @diagramname 
		if(@DiagId IS NULL or (@IsDbo = 0 and @UIDFound <> @theId))
		begin
			RAISERROR ('Diagram does not exist or you do not have permission.', 16, 1)
			return -3
		end
	
		delete from dbo.sysdiagrams where diagram_id = @DiagId;
	
		return 0;
	END
go

exec sp_addextendedproperty 'microsoft_database_tools_support', 1, 'SCHEMA', 'dbo', 'PROCEDURE', 'sp_dropdiagram'
go

deny execute on dbo.sp_dropdiagram to guest
go

grant execute on dbo.sp_dropdiagram to [public]
go


	CREATE PROCEDURE dbo.sp_helpdiagramdefinition
	(
		@diagramname 	sysname,
		@owner_id	int	= null 		
	)
	WITH EXECUTE AS N'dbo'
	AS
	BEGIN
		set nocount on

		declare @theId 		int
		declare @IsDbo 		int
		declare @DiagId		int
		declare @UIDFound	int
	
		if(@diagramname is null)
		begin
			RAISERROR (N'E_INVALIDARG', 16, 1);
			return -1
		end
	
		execute as caller;
		select @theId = DATABASE_PRINCIPAL_ID();
		select @IsDbo = IS_MEMBER(N'db_owner');
		if(@owner_id is null)
			select @owner_id = @theId;
		revert; 
	
		select @DiagId = diagram_id, @UIDFound = principal_id from dbo.sysdiagrams where principal_id = @owner_id and name = @diagramname;
		if(@DiagId IS NULL or (@IsDbo = 0 and @UIDFound <> @theId ))
		begin
			RAISERROR ('Diagram does not exist or you do not have permission.', 16, 1);
			return -3
		end

		select version, definition FROM dbo.sysdiagrams where diagram_id = @DiagId ; 
		return 0
	END
go

exec sp_addextendedproperty 'microsoft_database_tools_support', 1, 'SCHEMA', 'dbo', 'PROCEDURE',
     'sp_helpdiagramdefinition'
go

deny execute on dbo.sp_helpdiagramdefinition to guest
go

grant execute on dbo.sp_helpdiagramdefinition to [public]
go


	CREATE PROCEDURE dbo.sp_helpdiagrams
	(
		@diagramname sysname = NULL,
		@owner_id int = NULL
	)
	WITH EXECUTE AS N'dbo'
	AS
	BEGIN
		DECLARE @user sysname
		DECLARE @dboLogin bit
		EXECUTE AS CALLER;
			SET @user = USER_NAME();
			SET @dboLogin = CONVERT(bit,IS_MEMBER('db_owner'));
		REVERT;
		SELECT
			[Database] = DB_NAME(),
			[Name] = name,
			[ID] = diagram_id,
			[Owner] = USER_NAME(principal_id),
			[OwnerID] = principal_id
		FROM
			sysdiagrams
		WHERE
			(@dboLogin = 1 OR USER_NAME(principal_id) = @user) AND
			(@diagramname IS NULL OR name = @diagramname) AND
			(@owner_id IS NULL OR principal_id = @owner_id)
		ORDER BY
			4, 5, 1
	END
go

exec sp_addextendedproperty 'microsoft_database_tools_support', 1, 'SCHEMA', 'dbo', 'PROCEDURE', 'sp_helpdiagrams'
go

deny execute on dbo.sp_helpdiagrams to guest
go

grant execute on dbo.sp_helpdiagrams to [public]
go


	CREATE PROCEDURE dbo.sp_renamediagram
	(
		@diagramname 		sysname,
		@owner_id		int	= null,
		@new_diagramname	sysname
	
	)
	WITH EXECUTE AS 'dbo'
	AS
	BEGIN
		set nocount on
		declare @theId 			int
		declare @IsDbo 			int
		
		declare @UIDFound 		int
		declare @DiagId			int
		declare @DiagIdTarg		int
		declare @u_name			sysname
		if((@diagramname is null) or (@new_diagramname is null))
		begin
			RAISERROR ('Invalid value', 16, 1);
			return -1
		end
	
		EXECUTE AS CALLER;
		select @theId = DATABASE_PRINCIPAL_ID();
		select @IsDbo = IS_MEMBER(N'db_owner'); 
		if(@owner_id is null)
			select @owner_id = @theId;
		REVERT;
	
		select @u_name = USER_NAME(@owner_id)
	
		select @DiagId = diagram_id, @UIDFound = principal_id from dbo.sysdiagrams where principal_id = @owner_id and name = @diagramname 
		if(@DiagId IS NULL or (@IsDbo = 0 and @UIDFound <> @theId))
		begin
			RAISERROR ('Diagram does not exist or you do not have permission.', 16, 1)
			return -3
		end
	
		-- if((@u_name is not null) and (@new_diagramname = @diagramname))	-- nothing will change
		--	return 0;
	
		if(@u_name is null)
			select @DiagIdTarg = diagram_id from dbo.sysdiagrams where principal_id = @theId and name = @new_diagramname
		else
			select @DiagIdTarg = diagram_id from dbo.sysdiagrams where principal_id = @owner_id and name = @new_diagramname
	
		if((@DiagIdTarg is not null) and  @DiagId <> @DiagIdTarg)
		begin
			RAISERROR ('The name is already used.', 16, 1);
			return -2
		end		
	
		if(@u_name is null)
			update dbo.sysdiagrams set [name] = @new_diagramname, principal_id = @theId where diagram_id = @DiagId
		else
			update dbo.sysdiagrams set [name] = @new_diagramname where diagram_id = @DiagId
		return 0
	END
go

exec sp_addextendedproperty 'microsoft_database_tools_support', 1, 'SCHEMA', 'dbo', 'PROCEDURE', 'sp_renamediagram'
go

deny execute on dbo.sp_renamediagram to guest
go

grant execute on dbo.sp_renamediagram to [public]
go


	CREATE PROCEDURE dbo.sp_upgraddiagrams
	AS
	BEGIN
		IF OBJECT_ID(N'dbo.sysdiagrams') IS NOT NULL
			return 0;
	
		CREATE TABLE dbo.sysdiagrams
		(
			name sysname NOT NULL,
			principal_id int NOT NULL,	-- we may change it to varbinary(85)
			diagram_id int PRIMARY KEY IDENTITY,
			version int,
	
			definition varbinary(max)
			CONSTRAINT UK_principal_name UNIQUE
			(
				principal_id,
				name
			)
		);


		/* Add this if we need to have some form of extended properties for diagrams */
		/*
		IF OBJECT_ID(N'dbo.sysdiagram_properties') IS NULL
		BEGIN
			CREATE TABLE dbo.sysdiagram_properties
			(
				diagram_id int,
				name sysname,
				value varbinary(max) NOT NULL
			)
		END
		*/

		IF OBJECT_ID(N'dbo.dtproperties') IS NOT NULL
		begin
			insert into dbo.sysdiagrams
			(
				[name],
				[principal_id],
				[version],
				[definition]
			)
			select	 
				convert(sysname, dgnm.[uvalue]),
				DATABASE_PRINCIPAL_ID(N'dbo'),			-- will change to the sid of sa
				0,							-- zero for old format, dgdef.[version],
				dgdef.[lvalue]
			from dbo.[dtproperties] dgnm
				inner join dbo.[dtproperties] dggd on dggd.[property] = 'DtgSchemaGUID' and dggd.[objectid] = dgnm.[objectid]	
				inner join dbo.[dtproperties] dgdef on dgdef.[property] = 'DtgSchemaDATA' and dgdef.[objectid] = dgnm.[objectid]
				
			where dgnm.[property] = 'DtgSchemaNAME' and dggd.[uvalue] like N'_EA3E6268-D998-11CE-9454-00AA00A3F36E_' 
			return 2;
		end
		return 1;
	END
go

exec sp_addextendedproperty 'microsoft_database_tools_support', 1, 'SCHEMA', 'dbo', 'PROCEDURE', 'sp_upgraddiagrams'
go

CREATE   PROCEDURE usp_InsertTables(
 @LastName NVARCHAR(100) 
,@FirstName NVARCHAR(100) 
,@Type NVARCHAR(60)
,@Brand NVARCHAR(60)
,@PlateNr NVARCHAR(20)
,@RefuelingDate DATETIME
,@Amount DECIMAL(18,2)
)
AS
BEGIN

SET NOCOUNT ON;

INSERT INTO Person (LastName, FirstName)
VALUES (@LastName, @FirstName)
DECLARE @PersonID INT = SCOPE_IDENTITY()

INSERT INTO Vehicle (Type, Brand, PlateNr, OwnerPersonID)
VALUES(@Type, @Brand, @PlateNr, @PersonID)
DECLARE @VehicleID INT = SCOPE_IDENTITY()

INSERT INTO HasLicence (PersonID, VehicleID)
VALUES(@PersonID, @VehicleID)

INSERT INTO Refueling (VehicleID, PersonID, RefuelingDate, Amount)
VALUES(@VehicleID, @PersonID, @RefuelingDate, @Amount )

END
go


